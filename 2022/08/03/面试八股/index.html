<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>面试八股|C++篇 | Blog of Icecorn</title>
  <meta name="description" content="面试八股C++篇define和const区别 define是在预处理阶段，const是在编译，运行阶段 define只是简单的字节流替换，而const是有类型的 define就只是宏展开，它定义的宏常量在内存中有多个（哪里使用哪里就有一块内存），而const定义的常量在内存中只有一个 const常量是可以调试的，而define是不可以调试的，因为在预处理阶段就被替换掉了  const优点：  因为">
<meta property="og:type" content="article">
<meta property="og:title" content="面试八股|C++篇">
<meta property="og:url" content="http://icecorn.github.io/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Blog of Icecorn">
<meta property="og:description" content="面试八股C++篇define和const区别 define是在预处理阶段，const是在编译，运行阶段 define只是简单的字节流替换，而const是有类型的 define就只是宏展开，它定义的宏常量在内存中有多个（哪里使用哪里就有一块内存），而const定义的常量在内存中只有一个 const常量是可以调试的，而define是不可以调试的，因为在预处理阶段就被替换掉了  const优点：  因为">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220807114227794.png">
<meta property="article:published_time" content="2022-08-03T09:25:10.000Z">
<meta property="article:modified_time" content="2022-08-10T13:51:10.789Z">
<meta property="article:author" content="Icecorn">
<meta property="article:tag" content="面试八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220807114227794.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://icecorn.github.io/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Blog of Icecorn" type="application/atom+xml">
  
  
    <link rel="icon" href="images/logo.jpg" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.2"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Icecorn" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">Icecorn</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Life is Fantastic ~</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> DaLian, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>QAQ~</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/GPU%E6%9E%B6%E6%9E%84/">GPU架构</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReadingNotes/">ReadingNotes</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ReadingNotes/C/">C++</a><span class="category-list-count">17</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ReadingNotes/Linux/">Linux</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/ReadingNotes/Linux/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">系统编程</a><span class="category-list-count">1</span></li></ul></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a><span class="category-list-count">11</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/">渲染</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%B7%A5%E5%85%B7/">工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%B8%B2%E6%9F%93/">渲染</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-Primer/" rel="tag">C++ Primer</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" rel="tag">C++内存管理机制</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPU%E6%9E%B6%E6%9E%84/" rel="tag">GPU架构</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" rel="tag">GPU渲染管线</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Games-101/" rel="tag">Games-101</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Games-104/" rel="tag">Games-104</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">Linux高性能服务器</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Markdown/" rel="tag">Markdown</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBR%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" rel="tag">PBR渲染管线</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Rasterizer/" rel="tag">Rasterizer</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/divide-conquer/" rel="tag">divide&conquer</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/openGL/" rel="tag">openGL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/shader/" rel="tag">shader</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/socket%E7%BC%96%E7%A8%8B/" rel="tag">socket编程</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E6%B1%A0/" rel="tag">内存池</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" rel="tag">动态规划</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" rel="tag">单例模式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" rel="tag">图形学</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" rel="tag">多进程</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" rel="tag">思维导图</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%8E%92%E5%BA%8F/" rel="tag">排序</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" rel="tag">游戏引擎</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" rel="tag">面试八股</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/C/" style="font-size: 13px;">C++</a> <a href="/tags/C-Primer/" style="font-size: 14px;">C++ Primer</a> <a href="/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/" style="font-size: 13.33px;">C++内存管理机制</a> <a href="/tags/GPU%E6%9E%B6%E6%9E%84/" style="font-size: 13.17px;">GPU架构</a> <a href="/tags/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" style="font-size: 13px;">GPU渲染管线</a> <a href="/tags/Games-101/" style="font-size: 13.17px;">Games-101</a> <a href="/tags/Games-104/" style="font-size: 13.67px;">Games-104</a> <a href="/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/" style="font-size: 13.83px;">Linux高性能服务器</a> <a href="/tags/Markdown/" style="font-size: 13px;">Markdown</a> <a href="/tags/PBR%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/" style="font-size: 13px;">PBR渲染管线</a> <a href="/tags/Rasterizer/" style="font-size: 13.17px;">Rasterizer</a> <a href="/tags/divide-conquer/" style="font-size: 13px;">divide&conquer</a> <a href="/tags/openGL/" style="font-size: 13px;">openGL</a> <a href="/tags/shader/" style="font-size: 13px;">shader</a> <a href="/tags/socket%E7%BC%96%E7%A8%8B/" style="font-size: 13.33px;">socket编程</a> <a href="/tags/%E5%86%85%E5%AD%98%E6%B1%A0/" style="font-size: 13px;">内存池</a> <a href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/" style="font-size: 13.17px;">动态规划</a> <a href="/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" style="font-size: 13px;">单例模式</a> <a href="/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/" style="font-size: 13px;">图形学</a> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 13px;">多线程</a> <a href="/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/" style="font-size: 13px;">多进程</a> <a href="/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/" style="font-size: 13px;">思维导图</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 13px;">排序</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13px;">操作系统</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/" style="font-size: 13.67px;">游戏引擎</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 13.83px;">算法</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.5px;">计算机网络</a> <a href="/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" style="font-size: 13px;">面试八股</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/08/">August 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">July 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/04/">April 2022</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/02/">February 2022</a><span class="archive-list-count">13</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/13/%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/" class="title">刷题常用C++ API</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-13T09:25:10.000Z" itemprop="datePublished">2022-08-13</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20LeetCode%20Hot100%E6%80%BB%E7%BB%93/" class="title">算法系列|LeetCode Hot100总结</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-03T09:25:10.000Z" itemprop="datePublished">2022-08-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" class="title">面试八股|C++篇</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-03T09:25:10.000Z" itemprop="datePublished">2022-08-03</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a>
              </p>
              <p class="item-title">
                <a href="/2022/08/01/Games-104/Games104--%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF9/" class="title">Games-104|第九课-高级动画技术</a>
              </p>
              <p class="item-date">
                <time datetime="2022-08-01T09:25:10.000Z" itemprop="datePublished">2022-08-01</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/">图形学</a>
              </p>
              <p class="item-title">
                <a href="/2022/07/31/Games-104/Games104--%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%808/" class="title">Games-104|第八课-动画技术基础</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-31T09:25:10.000Z" itemprop="datePublished">2022-07-31</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
  <aside class="sidebar sidebar-toc collapse   in  " id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1C-%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">面试八股C++篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#define%E5%92%8Cconst%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.</span> <span class="toc-text">define和const区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E4%B8%8D%E8%83%BD%E5%9C%A8%E7%B1%BB%E5%86%85%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">为什么静态成员不能在类内初始化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%EF%BC%8C%E5%8F%B3%E5%80%BC%EF%BC%8C%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%EF%BC%8C%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">左值，右值，左值引用，右值引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">虚函数和纯虚函数的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">虚函数原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text">类模板和函数模板的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">C11列表初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%92%8C%E5%87%BD%E6%95%B0%E5%86%85%E8%B5%8B%E5%80%BC%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.8.</span> <span class="toc-text">构造函数初始化列表和函数内赋值区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11-std-function%E5%92%8Clamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">C11 std::function和lamda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89std-function"><span class="toc-number">1.9.1.</span> <span class="toc-text">为什么要有std::function?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-function%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.9.2.</span> <span class="toc-text">std::function的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind%E5%BA%94%E7%94%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">std::bind应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lamda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">lamda表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-function%E5%92%8Clamda%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.9.5.</span> <span class="toc-text">std::function和lamda的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct%E5%92%8Cclass%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.10.</span> <span class="toc-text">struct和class的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%87%BD%E6%95%B0%E5%B1%95%E5%BC%80"><span class="toc-number">1.11.</span> <span class="toc-text">内联函数和宏函数展开</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">1.11.1.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%87%BD%E6%95%B0%E5%B1%95%E5%BC%80"><span class="toc-number">1.11.2.</span> <span class="toc-text">宏函数展开</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E7%94%A8%E6%B3%95%E5%92%8C%E4%B8%8E%E5%AE%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.12.</span> <span class="toc-text">const用法和与宏的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.13.</span> <span class="toc-text">C11智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">1.13.1.</span> <span class="toc-text">shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#make-shared-%E4%BC%98%E5%8A%BF"><span class="toc-number">1.13.2.</span> <span class="toc-text">make_shared()优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">1.13.3.</span> <span class="toc-text">weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">1.13.4.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.13.5.</span> <span class="toc-text">简单实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11-nullptr"><span class="toc-number">1.14.</span> <span class="toc-text">C11 nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11-final%E5%92%8Coverride%E5%92%8Cexplicit"><span class="toc-number">1.15.</span> <span class="toc-text">C11 final和override和explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C11-constexpr%E5%92%8Cconst%E5%8C%BA%E5%88%AB"><span class="toc-number">1.16.</span> <span class="toc-text">C11 constexpr和const区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87%EF%BC%9F"><span class="toc-number">1.17.</span> <span class="toc-text">为什么会产生内存碎片？</span></a></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-面试八股" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      面试八股|C++篇
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" class="article-date">
	  <time datetime="2022-08-03T09:25:10.000Z" itemprop="datePublished">2022-08-03</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/C/">C++</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" rel="tag">面试八股</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/#comments" class="article-comment-link">Comments</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 7.2k(words)</span>
	
	
		<span class="post-readcount hidden-xs" itemprop="timeRequired">Read Count: 27(minutes)</span>
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="面试八股C-篇"><a href="#面试八股C-篇" class="headerlink" title="面试八股C++篇"></a>面试八股C++篇</h1><h2 id="define和const区别"><a href="#define和const区别" class="headerlink" title="define和const区别"></a>define和const区别</h2><ul>
<li>define是在预处理阶段，const是在编译，运行阶段</li>
<li>define只是简单的字节流替换，而const是有类型的</li>
<li>define就只是宏展开，它定义的宏常量在内存中有多个（哪里使用哪里就有一块内存），而const定义的常量在内存中只有一个</li>
<li>const常量是可以调试的，而define是不可以调试的，因为在预处理阶段就被替换掉了</li>
</ul>
<p><strong>const优点：</strong></p>
<ul>
<li>因为const有类型，所以编译器可以对其进行类型安全检查，而define不可以</li>
<li>const可调试，define不可以</li>
<li>const内存中只有一个，省内存</li>
</ul>
<hr>
<h2 id="为什么静态成员不能在类内初始化？"><a href="#为什么静态成员不能在类内初始化？" class="headerlink" title="为什么静态成员不能在类内初始化？"></a><strong>为什么静态成员不能在类内初始化？</strong></h2><p>在C++中，类的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&spm=1001.2101.3001.7020">静态成员</a>（static member）必须在类内声明，在类外初始化，像下面这样。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count ; <span class="comment">// 类内声明 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类外定义并初始化，不必再加static关键字</span></span><br><span class="line"><span class="type">int</span> A::count = <span class="number">0</span> ; </span><br></pre></td></tr></table></figure>

<p>或者只进行定义不赋初始值，但是默认值是否是0，可能会与具体的编译器有关吧？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只进行定义不赋初始值，但默认值视编译器而定</span></span><br><span class="line"><span class="type">int</span> A::count;</span><br></pre></td></tr></table></figure>

<p>为什么？</p>
<p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致多个对象对该成员进行更改。<strong>第一个对象将它初始化count=0,在之后的程序流程中我们修改它为count=1,这是我们再实例化一个对象B，那么B在构造是就会更改count=0,这显然不对</strong></p>
<p>如果不增加int A::count = 0 ; //变量定义，在编译的时候将会报出：‘A::count’未定义的引用”错误。这是因为静态成员变量count未定义，也就是还没有分配内存，显然是不可以访问的。</p>
<p>《c++primer》里面说在类外定义和初始化是保证<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>成员变量只被定义一次的好方法。 但为什么static const int就可以在类里面初始化呢？<br>想起C中一个函数里定义一个static变量是为了保证只初始化一次。</p>
<p>那么，是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图更改了。</p>
<hr>
<h2 id="左值，右值，左值引用，右值引用"><a href="#左值，右值，左值引用，右值引用" class="headerlink" title="左值，右值，左值引用，右值引用"></a>左值，右值，左值引用，右值引用</h2><p><strong>左值：</strong></p>
<p>有地址能够取地址的就是左值，能放在=左边</p>
<ul>
<li>函数名，变量名</li>
<li>返回左值引用的函数调用</li>
<li>前置自增自减，++i,–i</li>
<li>解引用表达式 *p</li>
<li>赋值表达式 a=b;a+=b等</li>
<li>字符串型字面值“abcd”（因为它存在全局数据区，为了方便复用）</li>
</ul>
<p><strong>右值：</strong></p>
<p>右值分为纯右值和将亡值</p>
<p>纯右值：</p>
<ul>
<li>除了字符串类型的所有其他字面值， 比如 10（因为它是用的时候直接在寄存器里生成的）</li>
<li>返回非左值引用的函数调用</li>
<li>后置自增自减 –i；++i；</li>
<li>算数表达式 a+b；</li>
<li>取地址表达式 &amp;a</li>
<li>lamda表达式</li>
</ul>
<p>将亡值：</p>
<p>A&amp;&amp; ， std::move的返回值</p>
<p><strong>左值引用：</strong></p>
<p>能绑定左值的引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">// b 是左值引用</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// error，10 无法取地址，无法进行引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = <span class="number">10</span>; <span class="comment">// ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址</span></span><br></pre></td></tr></table></figure>

<p><strong>右值引用：</strong></p>
<p>绑定右值的引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;b = a; <span class="comment">// error, a 是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p><strong>深拷贝和浅拷贝：</strong></p>
<p>浅拷贝要注意防止析构时内存释放两次引发错误，所以我们用std::move和移动构造来避免这个，并且不要忘记把原来对象的指针置nullptr</p>
<p><strong>完美转发：</strong></p>
<p>完美转发应用场景：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_45698148/article/details/120692470">https://blog.csdn.net/qq_45698148/article/details/120692470</a></p>
<p>引用折叠：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp; &amp; 折叠成 A&amp;</span><br><span class="line">A&amp; &amp;&amp; 折叠成 A&amp;</span><br><span class="line">A&amp;&amp; &amp; 折叠成 A&amp;</span><br><span class="line">A&amp;&amp; &amp;&amp; 折叠成 A&amp;&amp;</span><br></pre></td></tr></table></figure>

<p>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::forward()内部实现就是static_cast成模板T的类型，从而实现完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::move()内部实现就是static_cast转换成右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type _Up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h2><p><strong>虚函数：</strong>是c++实现运行时多态的方式，通过基类指针指向子类对象从而调用子类的虚函数实现多态，具体实现就是虚函数表，虚函数表指针那一套。<strong>虚表指针是对象拥有的，和对象存储在一起（堆或栈），虚函数表是在全局数据区存储的，而每个虚函数是在代码区（编译时生成的）</strong></p>
<p><strong>纯虚函数：</strong>纯虚函数是为了保证面向对象的可读性，比如父类是动物，子类是老虎，大象之类的，很显然动物不能实例化对象（语义不通），这就有了纯虚函数的性质：</p>
<ul>
<li>含有纯虚拟函数的类称为抽象类，它不能生成对象。</li>
<li>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。所有继承它的子类必须要重写这个接口，不然该子类就还是抽象类，不能生成对象。</li>
<li>在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</li>
<li>友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</li>
<li>析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</li>
<li>定义纯虚函数就是为了让基类不可实例化化</li>
</ul>
<hr>
<h2 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a>虚函数原理</h2><p><a target="_blank" rel="noopener" href="https://xiaomaweifu.blog.csdn.net/article/details/81326699">https://xiaomaweifu.blog.csdn.net/article/details/81326699</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011857683/article/details/79790967">https://blog.csdn.net/u011857683/article/details/79790967</a></p>
<p><strong>总结：</strong></p>
<ul>
<li>虚表指针和对象存储在一起（堆或栈），虚函数表存储在全局区，虚函数存储在代码区</li>
<li>单继承只有一个虚表指针，在对象首部，子类和父类的虚函数表不是一个，子类重写对应虚函数的话，子类虚表就会覆盖对应地址</li>
<li>子类自己的虚函数按照顺序排在虚函数表后边，但是要注意不能用父类的指针去调用父类没有的子类自己的虚函数，会编译错误</li>
<li>多继承继承几个父类子类就有几个虚函数表，子类自己的虚函数存放在第一个虚函数表后边，并且多继承时子类对象的内存分布是一个父类一个父类来的，而不是所有的虚函数表指针都在最上边，而且要满足内存对齐规则</li>
<li>虚函数表区域结束以0x00000000为标志。</li>
</ul>
<hr>
<h2 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h2><ul>
<li><p>类模板默认参数必须从右往左（不能跳着），而函数模板没有这个规定</p>
</li>
<li><p>类模板实例化的时候必须显示指定，但函数模板不需要（可以自动推导）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//正确</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>; <span class="comment">//错误，因为不能自动推导</span></span><br></pre></td></tr></table></figure></li>
<li><p>C11支持变长参数模板</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; t, Args ... args)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="built_in">func</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="C11列表初始化"><a href="#C11列表初始化" class="headerlink" title="C11列表初始化"></a>C11列表初始化</h2><p><strong>规则:</strong></p>
<ul>
<li>聚合类型可以直接初始化列表，比如vector,Int[],char[]</li>
<li>类的话必须满足以下条件：<ul>
<li>没有用户声明的构造函数 </li>
<li>没有用户提供的构造函数(允许显示预置或弃置的构造函数) </li>
<li>没有私有或保护的非静态数据成员 </li>
<li>没有基类</li>
<li>没有虚函数 </li>
<li>没有{}和=直接初始化的非静态数据成员 </li>
<li>没有默认成员初始化器</li>
</ul>
</li>
</ul>
<p><strong>初始化列表怎么实现接收不同长度的参数的？</strong></p>
<p>通过std::initializer_list<int>实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//不同长度</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomVec</span> &#123;</span><br><span class="line">	std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">	<span class="built_in">CustomVec</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>(); iter != list.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">			data.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>初始化列表好处？</strong></p>
<ul>
<li><p>方便，且基本上可以替代括号初始化  </p>
</li>
<li><p>可以使用初始化列表接受任意长度 </p>
</li>
<li><p>可以防止类型窄化，避免精度丢失的隐式类型转换</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1.2</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1.2</span>&#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="构造函数初始化列表和函数内赋值区别？"><a href="#构造函数初始化列表和函数内赋值区别？" class="headerlink" title="构造函数初始化列表和函数内赋值区别？"></a>构造函数初始化列表和函数内赋值区别？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line"><span class="comment">//构造函数内赋值</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x, <span class="type">int</span> y)&#123;m_x = x;m_y = y;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>初始化列表是在实例化类对象给成员变量分配内存的时候就进行初始化了，而构造函数内赋值是全部分配完内存后再执行赋值操作，这就意味着某些情况下初始化列表效率更高</strong></p>
<ul>
<li>对于内置数据类型，复合类型（指针，应用）两者效率一致，都是要写入一次而已</li>
<li>对于类类型，初始化列表要快很多，因为它在分配的那块内存上直接调用类类型的构造函数构造这个类对象，而构造函数赋值，是先分配一个内存，然后进入构造函数体（栈），构造一个类对象，再把它拷贝到分配的内存那块，这就多增加一次拷贝的开销</li>
</ul>
<p><strong>必须使用初始化列表的情况：</strong></p>
<ul>
<li>成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。</li>
<li>const成员或reference引用类型的成员。const对象或引用类型只能初始化，不能对他们赋值。构造函数的函数体内只能做赋值而不是初始化，因此初始化const对象或引用的唯一机会是构造函数</li>
</ul>
<p><strong>引申知识点：</strong></p>
<p>不能在父类的构造函数中调用子类的构造函数，或初始化列表构造子类</p>
<p>因为子类对象的实例化是先实例化父类部分，再实例化子类部分，如果按照下边这种情况，就会无限循环，形成套娃</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A是B的父类，以下都不行 </span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">B</span>(x)&#123;&#125; </span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x)&#123;<span class="built_in">B</span>(x);&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/c1348208475/article/details/105354323">https://blog.csdn.net/c1348208475/article/details/105354323</a></p>
<hr>
<h2 id="C11-std-function和lamda表达式"><a href="#C11-std-function和lamda表达式" class="headerlink" title="C11 std::function和lamda表达式"></a>C11 std::function和lamda表达式</h2><h3 id="为什么要有std-function"><a href="#为什么要有std-function" class="headerlink" title="为什么要有std::function?"></a><strong>为什么要有std::function?</strong></h3><p>C++中有如下几种可调用对象：<strong>函数、函数指针、lambda表达式、bind对象、函数对象</strong>。其中，lambda表达式和bind对象是C++11标准中提出的(bind机制并不是新标准中首次提出，而是对旧版本中bind1st和bind2st的合并)。个人认为五种可调用对象中，函数和函数指针本质相同，而lambda表达式、bind对象及函数对象则异曲同工。</p>
<p><strong>函数：</strong>函数是存放在代码区的，fun()实际就是找到该函数在代码区的地址执行一遍</p>
<p><strong>函数指针：</strong>函数指针就是我们用一个指针来保存函数的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Ftype)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">Ftype fp = funAdd; <span class="comment">//实例化一个int(*Ftype)(int,int)的函数指针fp,funAdd函数在代码区</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(fp) &lt;&lt; endl;<span class="comment">//指针占8字节</span></span><br><span class="line"><span class="built_in">fp</span>(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure>

<p><strong>lamda表达式：</strong>lamda表达式是一个匿名对象(仿函数)，它实际上是一个右值临时对象（也叫闭包对象），它的类型是特殊的类类型（闭包类型），只要记得它是右值没地址就好，具体用法下边说</p>
<p><strong>bind对象：</strong>可以新产生一个可调用对象，参数&lt;=原来的可调用对象，用placeholder先绑定一部分参数</p>
<p><strong>函数对象：</strong>就是仿函数（实质是个类）重载了函数调用运算符<code>()</code>的类的对象，即为函数对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> a + b;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">myadd md;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(myadd) &lt;&lt; endl; <span class="comment">//和一般的类一样，sizeof是测试它的一个实例化对象的大小，这个对象在堆或栈区，大小遵循内存对齐，此例4字节</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">md</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>基于此，需要使用一个统一的方式保存可调用对象或者传递可调用对象。于是，<code>std::function</code>就诞生了。</strong></p>
<h3 id="std-function的应用"><a href="#std-function的应用" class="headerlink" title="std::function的应用"></a>std::function的应用</h3><p><strong>std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行</strong>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; comfun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> a % b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator, <span class="type">int</span> divisor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator/divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Ftype)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    comfun a = addFun;</span><br><span class="line">    comfun b = mod;</span><br><span class="line">	comfun c = <span class="built_in">divide</span>();</span><br><span class="line">    Ftype fp = addFun;</span><br><span class="line">    comfun d = fp;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">a</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">b</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//lamda</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">c</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//仿函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">d</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为<strong>回调函数</strong>使用。它比普通函数指针更加的灵活和便利。</p>
<p>故而，std::function的作用可以归结于：</p>
<ul>
<li><p>std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；</p>
</li>
<li><p>std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。</p>
</li>
<li><p>对于函数和函数指针，C11之前使用typedef定义函数指针类型，可读性差</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Ftype)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span> <span class="comment">//表示返回值int，参数（int,int)的函数指针</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="std-bind应用"><a href="#std-bind应用" class="headerlink" title="std::bind应用"></a>std::bind应用</h3><p>std::bind可以看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p>
<p>std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p>
<ul>
<li><p>将可调用对象和其参数绑定成一个仿函数；</p>
</li>
<li><p>只绑定部分参数，减少可调用对象传入的参数。</p>
<p>调用bind的一般形式：</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure>

<p>该形式表达的意思是：当调用newCallable时，会调用callable，并传给它arg_list中的参数。</p>
<p>需要注意的是：arg_list中的参数可能包含形如n的名字。其中n是一个整数，这些参数是占位符，表示newCallable的参数，它们占据了传递给newCallable的参数的位置。数值n表示生成的可调用对象中参数的位置：1为newCallable的第一个参数，_2为第二个参数，以此类推。</p>
<p><strong>总结：</strong></p>
<ul>
<li>预绑定的参数是以值传递的形式，不预绑定的参数要用std::placeholders(占位符)的形式占位，从_1开始，依次递增，是以引用传递的形式；</li>
<li>std::placeholders表示新的可调用对象的第几个参数，而且与原函数的该占位符所在位置的进行匹配；</li>
<li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，<strong>这是因为对象的成员函数需要有this指针。</strong>并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&amp;手动转换；</li>
<li>std::bind的返回值是可调用实体，可以直接赋给std::function。</li>
</ul>
<p>细节见：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38410730/article/details/103637778">https://blog.csdn.net/qq_38410730/article/details/103637778</a></p>
<h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>lambda 表达式可以说是 c++11 引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [capture] (params) opt -&gt; ret </span><br></pre></td></tr></table></figure>

<p>其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt 是函数选项(mutable 之类)， ret 是返回值类型，func_body 是函数体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func1 = [](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> func2 = [](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + <span class="number">2</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func1</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">func2</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>lambda 表达式允许捕获一定范围内的变量：</p>
<ul>
<li>[]不捕获任何变量</li>
<li>[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用</li>
<li>[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用</li>
<li>[=, &amp;a]值捕获外部作用域所有变量，按引用捕获 a 变量  </li>
<li>[a]只值捕获 a 变量，不捕获其它变量 </li>
<li>[this]捕获当前类中的 this 指针</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]()&#123; <span class="keyword">return</span> a; &#125;; <span class="comment">// 值捕获 a</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() &#123; <span class="keyword">return</span> a++; &#125;; <span class="comment">// 修改按值捕获的外部变量，error</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>代码中的 f2 是编译不过的，因为我们修改了按值捕获的外部变量，其实 lambda 表达式就相当于是一个仿函数，仿函数是一个有 operator()成员函数的类对象，这个 operator()默认是 const 的，所以不能修改成员变量，而加了 mutable，就是去掉const 属性。</strong></p>
<p>lamda还可以用作sort之类的函数的比较参数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span>&amp; a,<span class="type">const</span> <span class="type">int</span>&amp; b)&#123;<span class="keyword">return</span> a&lt;b;&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="std-function和lamda的比较"><a href="#std-function和lamda的比较" class="headerlink" title="std::function和lamda的比较"></a>std::function和lamda的比较</h3><p>lamda因为是匿名对象，生命周期只存在于当前作用域，所以其适用于写一个简单函数，此函数不复用，只用于当前作用域，比较灵活方便</p>
<p>std::function则更具有普遍性，可以包装<strong>函数，函数指针，bind，lamda，仿函数</strong>这五种可调用对象，尤其是在c++中要实现回调函数，一定要用std::function</p>
<hr>
<h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>C++中的struct相比C中有了很多新增功能，它可以有成员函数，也可以继承，也可以实现多态</p>
<p>和class的区别主要是：</p>
<ul>
<li>struct默认public，而class默认private</li>
<li>class可以用作定义模板时代替typename，struct不可以</li>
</ul>
<hr>
<h2 id="内联函数和宏函数展开"><a href="#内联函数和宏函数展开" class="headerlink" title="内联函数和宏函数展开"></a>内联函数和宏函数展开</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>由于普通的函数被调用时，要压函数栈，并且寄存器保存变量等比较浪费性能，所以对于比较短的函数可以使用内联函数，它可以在编译时展开，不需要调用函数压栈这些。</p>
<ul>
<li>内联函数在<strong>编译时</strong>展开，节省性能</li>
<li>内联函数声明和实现应该放在一起，放在头文件中，inline关键字</li>
<li>内联函数适用于比较短（十行以内的函数）</li>
<li>内联函数通过<strong>编译器</strong>控制实现的，宏是<strong>预处理</strong>时实现的</li>
<li>内联函数也是和宏展开一样，在每一个调用处都展开一遍，比较浪费内存（空间换时间）</li>
<li>内联函数是可以调试的，弥补了宏展开的不足</li>
</ul>
<h3 id="宏函数展开"><a href="#宏函数展开" class="headerlink" title="宏函数展开"></a>宏函数展开</h3><ul>
<li>宏展开只是简单的二进制字符串替换</li>
<li>宏展开是在<strong>预处理</strong>时完成的，运行时不花费时间</li>
<li>宏展开没有类型</li>
<li>宏展开和内联函数一样，在每一个它替换的地方都展开一遍，浪费内存</li>
</ul>
<hr>
<h2 id="const用法和与宏的区别"><a href="#const用法和与宏的区别" class="headerlink" title="const用法和与宏的区别"></a>const用法和与宏的区别</h2><p><strong>const作用：限制类型</strong></p>
<ol>
<li>const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li>
<li>被const修饰的变量是只读的</li>
</ol>
<p><strong>const的用法：</strong></p>
<ul>
<li><p>const修饰全局变量和数组，只能初始化不能被修改，他们是存放在<strong>全局数据区</strong>的</p>
</li>
<li><p>const修饰局部变量，是存放在<strong>栈</strong>上的，也是不可修改的</p>
</li>
<li><p>const修饰指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">int</span> *<span class="type">const</span> p ； p为只读，*p为变量。<span class="comment">//只看const右边是什么就行</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *p ； *p为只读，p为变量。</span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p ；*p、p都为只读。</span><br><span class="line"><span class="number">4.</span> <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p ；*p、p都为只读。</span><br></pre></td></tr></table></figure></li>
<li><p>const修饰函数参数，表明该函数不能修改这个参数</p>
</li>
<li><p>const修饰成员函数，放在函数尾后，表明该成员函数不能修改成员变量</p>
</li>
</ul>
<p><strong>const和宏定义的区别</strong></p>
<ul>
<li><p>就定义常量说的话， const 定义的常数是变量也带类型， #define 定义的只是个常数不带类型。</p>
</li>
<li><p>就起作用的阶段而言，#define 是在编译的<strong>预处理</strong>阶段起作用，而 const 是在<strong>编译、运行</strong>的时候起作用。</p>
</li>
<li><p>就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2+3     <span class="comment">// 我们预想的 N 值是 5，我们这样使用 </span></span></span><br><span class="line">Ndouble a = N/<span class="number">2</span>;  <span class="comment">// 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5</span></span><br></pre></td></tr></table></figure></li>
<li><p>就空间占用而言， 例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14     <span class="comment">//预处理后 占用代码段空间</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI=<span class="number">3.14</span>;    <span class="comment">// 本质上还是一个 float，占用数据段间</span></span><br></pre></td></tr></table></figure></li>
<li><p>从代码调试的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了</p>
</li>
<li><p>从是否可以再定义的角度而言, const 不足的地方，是与生俱来的，const 不能重定义，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义</p>
</li>
</ul>
<hr>
<h2 id="C11智能指针"><a href="#C11智能指针" class="headerlink" title="C11智能指针"></a>C11智能指针</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220807114227794.png" alt="image-20220807114227794"></p>
<p><strong>智能指针的本质是一个模板类，对普通指针进行了封装，通过在构造函数中初始化分配内存，在析构函数中释放内存，达到自己管理内存，不需要手动管理内存的效果</strong></p>
<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr通过引用计数来记录有多少个shared指针指向这块内存</p>
<p>具体原理和使用方法查看博客：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/YYY_77/article/details/123299662">https://blog.csdn.net/YYY_77/article/details/123299662</a></p>
<p><strong>注意事项：</strong></p>
<ul>
<li><p>不要用同一个裸指针初始化多个shared_ptr，会造成内存二次释放的错误</p>
</li>
<li><p>尽量不要和裸指针进行混用（通过p.get()获得裸指针），除非是传入模板参数时使用（因为模板不能传入智能指针，编译器推测不出来）</p>
</li>
<li><p>不要再函数参数里创建shared_ptr,因为它的创建<strong>不是原子</strong>的，编译器会进行一些顺序上的优化，就有可能发生异常内存泄漏的情况</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),  <span class="comment">//潜在的资源泄露 </span></span><br><span class="line">              <span class="built_in">computePriority</span>());     </span><br><span class="line"><span class="comment">//编译器可能会执行以下顺序优化</span></span><br><span class="line">执行“<span class="keyword">new</span> Widget”。</span><br><span class="line">执行computePriority。<span class="comment">//如果再这一步抛出异常，那么已经new了的widget就会泄露</span></span><br><span class="line">执行std::shared_ptr的构造函数。</span><br></pre></td></tr></table></figure>

<p><strong>可以使用make_shared（）来避免</strong></p>
</li>
<li><p>避免循环引用</p>
</li>
<li><p>线程安全问题（make_shared和引用计数加锁处理）</p>
</li>
<li><p>通过 shared_from_this()返回 this 指针，不要把 this 指针作为 shared_ptr 返回出来，因为this 指针本质就是裸指针，通过 this 返回可能 会导致重复析构，不能把 this 指针交给智能指针管理。</p>
</li>
<li><p>不要 delete get()返回来的裸指针。</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yagerfgcs/article/details/72886630">https://blog.csdn.net/yagerfgcs/article/details/72886630</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/bureau123/article/details/121300979">https://blog.csdn.net/bureau123/article/details/121300979</a></p>
<h3 id="make-shared-优势"><a href="#make-shared-优势" class="headerlink" title="make_shared()优势"></a>make_shared()优势</h3><ul>
<li>提升性能，通过裸指针创建shared_ptr实际上需要new两次（第一次new目标对象，第二次new引用计数），而make_shared()只需要new一次（把他们俩的内存一起分配了），并且它内部还使用了placement new（就是内存池那种用到再切一块），提高了性能</li>
<li>异常安全，就是上文提到的，因为shared_ptr裸指针创建不是<strong>原子的</strong>，在编译器的优化下会存在内存泄漏，而make_shared（）就是保证了这个时间的原子性</li>
</ul>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr本身也是一个模板类，但是不能直接用它来定义一个智能指针的对象，只能配合shared_ptr来使用，可以将shared_ptr的对象赋值给weak_ptr，并且这样并不会改变引用计数的值。查看weak_ptr的代码时发现，它主要有lock、swap、reset、expired、operator=、use_count几个函数，与shared_ptr相比多了lock、expired函数，但是却少了get函数，甚至连operator* 和 operator-&gt;都没有，可用的函数数量少的可怜，下面通过一些例子来了解一下weak_ptr的具体用法。</p>
<p><strong>注意点：</strong></p>
<ul>
<li>weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。</li>
<li>weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数</li>
<li>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。</li>
<li>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</li>
</ul>
<p><strong>核心函数：</strong></p>
<ul>
<li>expired（），由于weak_ptr指向的对象有可能已经被析构掉了，所以每次使用前要使用expired来判断是否已经过期了</li>
<li>lock(),如果是可用的，使用lock()函数获得对应shared_ptr的指针</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/albertsh/article/details/82286999">https://blog.csdn.net/albertsh/article/details/82286999</a></p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><strong>它持有对对象的独有权，即两个 unique_ptr 不能指向一个对象，不能进行复制操作只能进行移动操作。</strong></p>
<p>unique_ptr 之所以叫这个名字，是因为它<strong>只能指向一个对象</strong>，即当它指向其他对象时，之前所指向的对象会被摧毁。其次，当 unique_ptr 超出作用域时，指向的对象也会被自动摧毁，帮助程序员实现了自动释放的功能。</p>
<p>unique_ptr 也可能还未指向对象，这时的状态被称为 empty。</p>
<h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xp178171640/article/details/102674428">https://blog.csdn.net/xp178171640/article/details/102674428</a></p>
<hr>
<h2 id="C11-nullptr"><a href="#C11-nullptr" class="headerlink" title="C11 nullptr"></a>C11 nullptr</h2><p>C11新增了空指针nullptr，之前的NULL实际上是一个int值0，会产生而意性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 编译失败，会产生二义性</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出 func ptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="C11-final和override和explicit"><a href="#C11-final和override和explicit" class="headerlink" title="C11 final和override和explicit"></a>C11 final和override和explicit</h2><p>final关键字修饰类（放在类名后边）表明这个类不能被继承</p>
<p>override用于成员函数重写（放在函数名后边），表明重写父类的虚函数</p>
<p>explicit只能修饰构造函数，表明只能显示构造，不能隐式转换</p>
<hr>
<h2 id="C11-constexpr和const区别"><a href="#C11-constexpr和const区别" class="headerlink" title="C11 constexpr和const区别"></a>C11 constexpr和const区别</h2><p>constexpr是编译期常量，而const可以是编译器或运行期常量</p>
<p>比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种const就是编译器常量，会在编译期就生成一个ci的内存地址，它=100，且不能改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//这种const就是运行时常量，它只是保证了在运行期间ci不能改而已</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = a;cpp</span><br></pre></td></tr></table></figure>

<p>constexpr说明了对象是一个变量，程序运行期间不会改变他的值，并且在编译期间就能知道该对象的值是多少。（可以将其理解为第一类const）</p>
<hr>
<h2 id="为什么会产生内存碎片？"><a href="#为什么会产生内存碎片？" class="headerlink" title="为什么会产生内存碎片？"></a>为什么会产生内存碎片？</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/GoodLinGL/article/details/116027468">https://blog.csdn.net/GoodLinGL/article/details/116027468</a></p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://icecorn.github.io/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/" title="面试八股|C++篇" target="_blank" rel="external">http://icecorn.github.io/2022/08/03/面试八股/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Icecorn" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Icecorn" target="_blank"><span class="text-dark">Icecorn</span><small class="ml-1x">Life is Fantastic ~</small></a></h3>
        <div>一个喜欢推理小说和coding的宝可梦训练家~</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2022/08/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20LeetCode%20Hot100%E6%80%BB%E7%BB%93/" title="算法系列|LeetCode Hot100总结"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/08/01/Games-104/Games104--%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF9/" title="Games-104|第九课-高级动画技术"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn " data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">    <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
    <div class="copyright">
    	
        &copy; 2022 Icecorn
        
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>