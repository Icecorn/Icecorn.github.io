<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-07-25T03:44:03.945Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法系列|经典题目合集</title>
    <link href="http://icecorn.github.io/2022/07/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <id>http://icecorn.github.io/2022/07/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</id>
    <published>2022-07-09T09:25:10.000Z</published>
    <updated>2022-07-25T03:44:03.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h1><h2 id="二叉树最近公共祖先节点"><a href="#二叉树最近公共祖先节点" class="headerlink" title="二叉树最近公共祖先节点"></a>二叉树最近公共祖先节点</h2><p>剑指offer2–68</p><p>解题思路：</p><ul><li>思考递归的返回值的含义</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 若树里面存在p，也存在q，则返回他们的公共祖先。</span><br><span class="line"><span class="bullet">2.</span> 若树里面只存在p，或只存在q，则返回存在的那一个。</span><br><span class="line"><span class="bullet">3.</span> 若树里面即不存在p，也不存在q，则返回null。</span><br></pre></td></tr></table></figure><p>对每一个递归的元素先判断是否为null，为null返回null，如果为p或q，直接返回p或q</p><p>之后递归左右孩子，对左右孩子可能出现的情况进行讨论，分三种情况：<br>1.左右都为null，则说明左右子树都不包含p或q<br>2.如果左右一个为null，一个不为null，则返回不为null的那个<br>3.如果都不为null，说明左右子树分别包含了p和q，那么祖先自然就是root了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        root-&gt;right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp; root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>) <span class="keyword">return</span>  root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>( root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="盛水最多的容器lc-11"><a href="#盛水最多的容器lc-11" class="headerlink" title="盛水最多的容器lc-11"></a>盛水最多的容器lc-11</h3><p>思路就是对向的双指针，且每次求雨水面积，并且每次左右两边小的那个往中间移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="built_in">min</span>(height[l],height[r]);</span><br><span class="line">            area = <span class="built_in">max</span>(area,low*(r-l));</span><br><span class="line">            height[l]&lt;height[r]?l++:r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和lc-15"><a href="#三数之和lc-15" class="headerlink" title="三数之和lc-15"></a>三数之和lc-15</h3><p>思路是固定一个数，然后另外两个对象双指针，往里走。要注意剪枝，负数，边界条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//注意i&gt;0</span></span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]&gt;-nums[i]) r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]+nums[r]&lt;-nums[i]) l++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;<span class="comment">//注意l&lt;r,只要双指针就要带判断条件</span></span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r+<span class="number">1</span>]) r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="删除倒数第N个节点lc-19"><a href="#删除倒数第N个节点lc-19" class="headerlink" title="删除倒数第N个节点lc-19"></a>删除倒数第N个节点lc-19</h3><p><strong>很多链表的题有一个共性就是有时候要操作头节点，这时候就要考虑没有头节点的情况，很麻烦，我们可以采用新建一个node指向头节点这种方法避免考虑头节点的特殊性，最后返回dummy-&gt;next就可以啦</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* dummy =<span class="keyword">new</span> <span class="built_in">ListNode</span>();<span class="comment">//这里新建一个节点充当头节点</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prey = dummy;<span class="comment">//同时也方便了prey的操作</span></span><br><span class="line">        <span class="keyword">while</span>(n--) fast = fast-&gt;next;     </span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;   </span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            prey=prey-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prey-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(head);</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/yi-wen-dai-ni-shua-bian-er-fen-cha-zhao-dtadq/">https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/yi-wen-dai-ni-shua-bian-er-fen-cha-zhao-dtadq/</a></p><h3 id="旋转数组找target-lc-33"><a href="#旋转数组找target-lc-33" class="headerlink" title="旋转数组找target lc-33"></a>旋转数组找target lc-33</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line"><span class="string">此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span> </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[l]&lt;=nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[l]&amp;&amp;target&lt;nums[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r]) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">几个注意点,二分模板</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">if(nums[mid]==target) return mid;</span><br><span class="line">...</span><br><span class="line">l=mid+1;</span><br><span class="line">r=mid-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="最小栈lc-155"><a href="#最小栈lc-155" class="headerlink" title="最小栈lc-155"></a>最小栈lc-155</h2><h3 id="双栈方法"><a href="#双栈方法" class="headerlink" title="双栈方法"></a>双栈方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(x);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单栈方法"><a href="#单栈方法" class="headerlink" title="单栈方法"></a>单栈方法</h3><p>单栈方法栈中存放 val-min ,再用一个min变量存放最小值 val - min = stk.top();</p><p>这样递推就好了，top</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; m_stk;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_min;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_min=val;</span><br><span class="line">            m_stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_stk.<span class="built_in">push</span>(val-m_min);</span><br><span class="line">            <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>) m_min=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            m_min -= m_stk.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>) <span class="keyword">return</span> m_min;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m_stk.<span class="built_in">top</span>()+m_min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>此类题代表lc207，lc210主要是判断有向图是否有环</p><p>可以使用dfs和bfs两种方法来处理</p><h3 id="DFS："><a href="#DFS：" class="headerlink" title="DFS："></a><strong>DFS：</strong></h3><p>dfs的思路其实就是暴力递归，把所有节点视为起点进行遍历，节点分为三种状态，状态0代表未访问过，状态1代表当前dfs路径中访问过的，状态2表示已经访问完的。如果在同一个dfs路径中又经过了状态1的节点，说明有环。</p><p>关于为什么要分状态1和状态2，比如1-&gt;2-&gt;3-&gt;4; 5-&gt;3;这种情况第一次dfs路径1234如果不把他们标记成状态2还是状态1的话，下一条路径53是就会错误的识别成有环状态</p><p>另外我们可以用valid进行剪枝，已经有环了就不用继续dfs下去了，同时其他路径也不用在开始dfs了</p><p>dfs方法最后拓扑排序我们在每次节点变成状态2时存，必然是递归到最后出度为0的点，这样的结果是倒序的，需要最后reverse或者用stack来存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//存储结果用的res，是倒序的，也可以用stack来存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;<span class="comment">//剪枝1</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//识别有环</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;<span class="comment">//这里valid剪枝2</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">//逆序输出</span></span><br><span class="line">        <span class="keyword">return</span> valid?res:vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a><strong>BFS:</strong></h3><p>bfs的思路是先建立邻接矩阵，统计好所有节点的度，把所有度为0的节点入队，然后每次出队把当前节点连接的节点的度-1，如果为0的话就入队。每有一个出队就visit++，最终如果无环的环应该刚好每个节点visit一遍，也就是visit的值等于节点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pre:prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            indeg[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> visit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            visit++;</span><br><span class="line">            <span class="type">int</span> x= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; c:edges[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[c]==<span class="number">0</span>) q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visit==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>bfs比较好想且代码好写，并且稍微出队顺序就是拓扑排序的顺序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            visit++;</span><br><span class="line">            <span class="type">int</span> x= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(x);<span class="comment">//出队时加入节点就行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; c:edges[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[c]==<span class="number">0</span>) q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> res.<span class="built_in">size</span>()==numCourses?res:vector&lt;<span class="type">int</span>&gt;&#123;&#125;;<span class="comment">//有环的话输出空数组</span></span><br></pre></td></tr></table></figure><hr><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>又叫字典树，用来存储字符串并且可以实现快速查找字符串及前缀</p><p><strong>实现方式就是26叉树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典题目&quot;&gt;&lt;a href=&quot;#经典题目&quot; class=&quot;headerlink&quot; title=&quot;经典题目&quot;&gt;&lt;/a&gt;经典题目&lt;/h1&gt;&lt;h2 id=&quot;二叉树最近公共祖先节点&quot;&gt;&lt;a href=&quot;#二叉树最近公共祖先节点&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（五）|股票交易</title>
    <link href="http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/"/>
    <id>http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/</id>
    <published>2022-07-08T09:25:10.000Z</published>
    <updated>2022-07-25T03:43:18.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票交易问题"><a href="#股票交易问题" class="headerlink" title="股票交易问题"></a>股票交易问题</h1><p>股票交易通常使用动态规划来解决</p><h2 id="买卖股票最佳时机一-LC-121"><a href="#买卖股票最佳时机一-LC-121" class="headerlink" title="买卖股票最佳时机一 LC-121"></a>买卖股票最佳时机一 LC-121</h2><p>给一个数组，某一天买入，某一天卖出，算最大利润</p><p>这个不用dp，直接遍历一边，每天保存最小的买入价，遍历一边即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> res=INT_MIN,minP = INT_MAX;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> p:prices)</span><br><span class="line">       &#123;</span><br><span class="line">           minP = <span class="built_in">min</span>(minP,p);</span><br><span class="line">           res = <span class="built_in">max</span>(res,p-minP);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票最佳时机二-LC122"><a href="#买卖股票最佳时机二-LC122" class="headerlink" title="买卖股票最佳时机二 LC122"></a>买卖股票最佳时机二 LC122</h2><p>本题是能买卖无数次，但是同时只能买一只股票</p><p>dp来做，有两个状态，所以开两个vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]表示当天有股票的情况最大利润，dp[i][<span class="number">1</span>]表示当天无股票情况最大利润</span><br><span class="line">计算总利润时，买入就是-price[i]，卖出就是+price[i]</span><br><span class="line">初始条件dp[<span class="number">0</span>][<span class="number">0</span>] = -price[<span class="number">0</span>]</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>观察状态转移方程之和前一位有关，所以用两个变量代替两个数组即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f0 = -prices[<span class="number">0</span>];</span><br><span class="line"> <span class="type">int</span> f1=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> nf0 = <span class="built_in">max</span>(f0,f1-prices[i]);</span><br><span class="line">     f1 = <span class="built_in">max</span>(f1,f0+prices[i]);</span><br><span class="line">     f0 = nf0;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> f1;</span><br></pre></td></tr></table></figure><h2 id="买卖股票最佳时机三-LC123"><a href="#买卖股票最佳时机三-LC123" class="headerlink" title="买卖股票最佳时机三 LC123"></a>买卖股票最佳时机三 LC123</h2><p>这题条件是只能交易两次</p><p>因此有五种状态</p><ul><li>没买入</li><li>买入一次 buy1</li><li>卖出一次 sell1</li><li>买入两次 buy2</li><li>卖出两次 sell2</li></ul><p>通过五种状态很容易得到状态转移方程，<strong>要注意的是初始值buy2= -price[0]，这是因为在第一天买入一次卖出一次收益为0，再买入一次收益自然是-price[0]</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i]);</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="买入股票最佳时机四-LC-188"><a href="#买入股票最佳时机四-LC-188" class="headerlink" title="买入股票最佳时机四 LC-188"></a>买入股票最佳时机四 LC-188</h2><p>本题条件是最多交易k次，解法和3类似，升一维建立二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        k = <span class="built_in">min</span>(k, n / <span class="number">2</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buy</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sell</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            buy[<span class="number">0</span>][i] = sell[<span class="number">0</span>][i] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy[i][<span class="number">0</span>] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>][<span class="number">0</span>], sell[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                buy[i][j] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>][j], sell[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                sell[i][j] = <span class="built_in">max</span>(sell[i - <span class="number">1</span>][j], buy[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(sell[n - <span class="number">1</span>].<span class="built_in">begin</span>(), sell[n - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="含冷冻期的最大利润-LC-309"><a href="#含冷冻期的最大利润-LC-309" class="headerlink" title="含冷冻期的最大利润 LC-309"></a>含冷冻期的最大利润 LC-309</h2><p>有三个状态：</p><ul><li>此时有股票</li><li>此时无股票，且在冷冻期</li><li>此时无股票，且不在冷冻期</li></ul><p>想清楚每种状态怎么转移就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有股票：要么上一天也有股票，要么是今天买的，既然今天能买，那么上一天必须不在冷冻期</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">            <span class="comment">//无股票且在冷冻期：必须是上一天把股票卖了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            <span class="comment">//无股票且不在冷冻期：从上一天也是无股票状态转移过来，因为前一天如果有股票但今天无股票的话那么今天必然在冷冻期，有矛盾所以不能从有股票状态转移过来</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可用三个变量优化</p><h2 id="股票交易含手续费-LC714"><a href="#股票交易含手续费-LC714" class="headerlink" title="股票交易含手续费 LC714"></a>股票交易含手续费 LC714</h2><p>和二相比，只是多了一个手续费而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]-fee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;股票交易问题&quot;&gt;&lt;a href=&quot;#股票交易问题&quot; class=&quot;headerlink&quot; title=&quot;股票交易问题&quot;&gt;&lt;/a&gt;股票交易问题&lt;/h1&gt;&lt;p&gt;股票交易通常使用动态规划来解决&lt;/p&gt;
&lt;h2 id=&quot;买卖股票最佳时机一-LC-121&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（六）|二叉树前中后序遍历--迭代法</title>
    <link href="http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-07-08T09:25:10.000Z</published>
    <updated>2022-07-25T06:05:58.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h1><p>迭代法的二叉树前中后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">TreeNode</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法前序遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preyorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    stack&lt;TreeNode *&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法中序遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="comment">//当前结点不为空或者栈不为空</span></span><br><span class="line">    <span class="comment">//也就是说，循环结束条件是：</span></span><br><span class="line">    <span class="comment">//当前结点为空且栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前结点不为空，那么就放入栈，</span></span><br><span class="line">        <span class="comment">//然后当前指针指向其左孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前结点为空，说明已经到目前最左的尽头，</span></span><br><span class="line">        <span class="comment">//那么指向栈顶元素</span></span><br><span class="line">        <span class="comment">//此时的栈顶元素为以当前结点为根的子树的根</span></span><br><span class="line">        <span class="comment">//其左孩子因为已经为空，所以目前遍历根</span></span><br><span class="line">        <span class="comment">//遍历完后再让当前指针指向其右孩子结点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法后续遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;      <span class="comment">// ret保存遍历结果</span></span><br><span class="line">    stack&lt;TreeNode *&gt; st; <span class="comment">// st保存树的节点指针</span></span><br><span class="line">    TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *cur = root; <span class="comment">// cur指向当前遍历到的节点</span></span><br><span class="line">    <span class="comment">// cur不为空代表树没访问完， st不为空代表栈中还有数据</span></span><br><span class="line">    <span class="keyword">while</span> (cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur);    <span class="comment">//当前节点入栈</span></span><br><span class="line">            cur = cur-&gt;left; <span class="comment">//继续遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树遍历完，从栈顶取出cur并指向右子树继续遍历</span></span><br><span class="line">        TreeNode *top = st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">//右子树为null代表当前节点top左右子树都为空则输出，</span></span><br><span class="line">        <span class="comment">//但是可能死循环，因为判断节点右子树时可能会被访问两次</span></span><br><span class="line">        <span class="comment">//访问两次的标志就是当前节点的右树等于上一次访问的节点</span></span><br><span class="line">        <span class="keyword">if</span> (top-&gt;right == <span class="literal">nullptr</span> || top-&gt;right == prev)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(top-&gt;val);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            prev = top;</span><br><span class="line">            cur = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = top-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    root-&gt;val = <span class="number">3</span>;</span><br><span class="line">    TreeNode *n1 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n1-&gt;val = <span class="number">4</span>;</span><br><span class="line">    TreeNode *n2 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n2-&gt;val = <span class="number">5</span>;</span><br><span class="line">    TreeNode *n3 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n3-&gt;val = <span class="number">6</span>;</span><br><span class="line">    TreeNode *n4 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n4-&gt;val = <span class="number">7</span>;</span><br><span class="line">    TreeNode *n5 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n5-&gt;val = <span class="number">8</span>;</span><br><span class="line">    TreeNode *n6 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n6-&gt;val = <span class="number">9</span>;</span><br><span class="line">    root-&gt;left = n1;</span><br><span class="line">    root-&gt;right = n2;</span><br><span class="line">    n1-&gt;left = n3;</span><br><span class="line">    n1-&gt;right = n4;</span><br><span class="line">    n2-&gt;left = n5;</span><br><span class="line">    n2-&gt;right = n6;</span><br><span class="line">    n3-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n3-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    n4-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n4-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    n5-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n5-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    n6-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n6-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preyIt = <span class="built_in">preyorderTraversal</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; inIt = <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; postIt = <span class="built_in">postorderTraversal</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inIt.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; postIt[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的前中后序遍历&quot;&gt;&lt;a href=&quot;#二叉树的前中后序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的前中后序遍历&quot;&gt;&lt;/a&gt;二叉树的前中后序遍历&lt;/h1&gt;&lt;p&gt;迭代法的二叉树前中后序遍历&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图形学常见问题指针</title>
    <link href="http://icecorn.github.io/2022/07/05/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8C%87%E9%92%88/"/>
    <id>http://icecorn.github.io/2022/07/05/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8C%87%E9%92%88/</id>
    <published>2022-07-05T09:25:10.000Z</published>
    <updated>2022-07-23T02:39:05.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形学常见问题指针"><a href="#图形学常见问题指针" class="headerlink" title="图形学常见问题指针"></a>图形学常见问题指针</h1><h2 id="透视矫正的推导"><a href="#透视矫正的推导" class="headerlink" title="透视矫正的推导"></a>透视矫正的推导</h2><p><a href="https://zhuanlan.zhihu.com/p/403259571">https://zhuanlan.zhihu.com/p/403259571</a></p><h2 id="透视除法与齐次坐标"><a href="#透视除法与齐次坐标" class="headerlink" title="透视除法与齐次坐标"></a>透视除法与齐次坐标</h2><p><a href="https://www.jianshu.com/p/7e701d7bfd79">https://www.jianshu.com/p/7e701d7bfd79</a></p><h2 id="法向变换矩阵的推导"><a href="#法向变换矩阵的推导" class="headerlink" title="法向变换矩阵的推导"></a>法向变换矩阵的推导</h2><p>在计算机图形学中，<a href="https://www.zhihu.com/search?q=%E6%B3%95%E5%90%91%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">法向量</a>（垂直于某个面的向量）有着广泛的应用，比如处理光照需要用到法向量来计算光线的<a href="https://www.zhihu.com/search?q=%E5%85%A5%E5%B0%84%E8%A7%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">入射角</a>，最终渲染出逼真的场景。</p><p>3D<a href="https://www.zhihu.com/search?q=%E5%BB%BA%E6%A8%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">建模</a>工具设计出的模型文件一般都是包含了顶点坐标和每个面的法向量信息，也就是说法向量是已知的，模型一旦确定，每个面的法向量就确定了。但是，事情没有那么简单，场景要动起来才会丰富多彩，完全静止的东西往往缺乏生气，这就需要用到<a href="https://www.zhihu.com/search?q=%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">模型变换</a>，比如平移、缩放（等比例/不等比例）、旋转等，而不管如何变换，法向量和对应面的<a href="https://www.zhihu.com/search?q=%E5%9E%82%E7%9B%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">垂直</a>关系必须成立，否则场景渲染的效果就会失真甚至完全不正常。</p><p>3D模型是由大量的<a href="https://www.zhihu.com/search?q=%E9%A1%B6%E7%82%B9%E5%9D%90%E6%A0%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">顶点坐标</a>组成的，只要模型变换矩阵乘以顶点坐标就完成了模型的变换，但是法向量却不能直接与模型变换矩阵相乘，因为向量是有向的线段，而顶点坐标仅仅表示一个点，这个本质的不同导致<a href="https://www.zhihu.com/search?q=%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">变换矩阵</a>与法向量相乘后很可能不再和变换后的面垂直。</p><p>举个简单的例子，参见下图，假设针对3D模型做沿y轴向上平移1个单位的变换，向量p为垂直于其中某个面的法向量。如果向量p=(1,0)执行同样的平移操作，则变成了向量p’=(1,1)，p和p’并不是平行关系，显然针对法向量做相同的<a href="https://www.zhihu.com/search?q=%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">平移变换</a>之后，p’不可能再垂直于平移后的平面，因为平面沿y轴向上平移1个单位之后仍然与变换前平面平行。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-5c43f49040ee3be76a3534cba778ec79_b.jpg" alt="img"></p><p>这仅仅是平移变换带来的问题，还有众多其他类型的变换，不太可能分析所有变换对法向量的影响是怎样的，然后进行一一修正。显然，需要找到一种通用的方法来处理法向量的变换。</p><p>假设p0与p1是变换前某平面上的两个点，<a href="https://www.zhihu.com/search?q=%E5%88%87%E5%90%91%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">切向量</a>s=p1−p0，与之垂直的法向量为n；p0’和p1’为p0和p1变换后的点，变换后的切向量s′=p1′−p0′，变换后法向量为n’，其中模型变换矩阵为M，<a href="https://www.zhihu.com/search?q=%E6%B3%95%E5%90%91%E9%87%8F%E5%8F%98%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">法向量变换</a>矩阵为M’，变换后n’与s’需要互相垂直。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710212522068.png" alt="image-20220710212522068"> </p><p>使用公式可以表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-98f85d18e640a0f742d14ace76b8d6db_b.jpg" alt="img"></p><p>s’和n’互相垂直，可以得知n’和s’的点积为0，所以有：</p><p><img src="https://pic1.zhimg.com/v2-e0a4566106fae5036ca7b4ccb6c157b4_b.jpg" alt="img"></p><p>进一步对公式进行变换，可以得出：</p><p><img src="https://pic2.zhimg.com/v2-0c050d77bc6f8ca87ba4b5fb1d1dc851_b.jpg" alt="img"></p><blockquote><p>T表示矩阵的转置，就是将原矩阵的<a href="https://www.zhihu.com/search?q=%E8%A1%8C%E5%88%97%E4%BA%92%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">行列互换</a></p></blockquote><p>由于n⋅s=nT×s可以得出M′×M=I，因为只有I×s=s，这样就可以保证公式始终成立。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-9b64678336e9bc95f6b606528ee7a86b_b.jpg" alt="img"></p><blockquote><p>I表示<a href="https://www.zhihu.com/search?q=%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">单位矩阵</a></p></blockquote><p>由M′T×M=I可得M′T=M−1，最终得出M′=(M−1)T，即法向量的变换矩阵为模型变换矩阵的逆转置矩阵。</p><p><img src="https://pic1.zhimg.com/v2-bc61269f943a6c50cad79936bd44a318_b.jpg" alt="img"></p><p>本文来自知乎：<br>作者：一点鑫得<br>链接：<a href="https://zhuanlan.zhihu.com/p/479809019">https://zhuanlan.zhihu.com/p/479809019</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图形学常见问题指针&quot;&gt;&lt;a href=&quot;#图形学常见问题指针&quot; class=&quot;headerlink&quot; title=&quot;图形学常见问题指针&quot;&gt;&lt;/a&gt;图形学常见问题指针&lt;/h1&gt;&lt;h2 id=&quot;透视矫正的推导&quot;&gt;&lt;a href=&quot;#透视矫正的推导&quot; class=&quot;he</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="http://icecorn.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PBR渲染管线详解</title>
    <link href="http://icecorn.github.io/2022/07/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6/PBR%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://icecorn.github.io/2022/07/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6/PBR%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-04T09:25:10.000Z</published>
    <updated>2022-07-23T02:37:29.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PBR管线"><a href="#PBR管线" class="headerlink" title="PBR管线"></a>PBR管线</h1><p>基于物理的着色模型三要素</p><ol><li>基于微平面(Microfacet)的表面模型。</li><li>能量守恒。</li><li>应用基于物理的BRDF。</li></ol><h2 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h2><p>在微观尺度下，没有任何平面是完全光滑的。然而由于这些微平面已经微小到无法逐像素的继续对其进行区分，因此我们只有假设一个粗糙度(Roughness)参数，然后用统计学的方法来概略的估算微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出某个向量的方向与微平面平均取向方向一致的概率。</p><p>这个向量便是位于光线向量l和视线向量v之间的中间向量(Halfway Vector)。我们曾经在之前的[高级光照](<a href="https://learnopengl-cn.github.io/05">https://learnopengl-cn.github.io/05</a> Advanced Lighting/01 Advanced Lighting/)教程中谈到过中间向量，它的计算方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718213826545.png" alt="image-20220718213826545"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718213641496.png" alt="image-20220718213641496"></p><p>微平面的取向方向与中间向量的方向越是一致，镜面反射的效果就越是强烈越是锐利。然后再加上一个介于0到1之间的粗糙度参数，这样我们就能概略的估算微平面的取向情况了：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718213912201.png" alt="image-20220718213912201"></p><p>较高的粗糙度值显示出来的镜面反射的轮廓要更大一些。与之相反地，较小的粗糙值显示出的镜面反射轮廓则更小更锐利。</p><h2 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h2><p>微平面近似法使用了这样一种形式的能量守恒(Energy Conservation)：出射光线的能量永远不能超过入射光线的能量（发光面除外）。</p><p>为了遵守能量守恒定律，我们需要对<strong>漫反射光</strong>和<strong>镜面反射光</strong>之间做出明确的区分。</p><p>要注意的是漫反射实际上就是折射光的一部分，它们进入物体表面然后弹弹弹最终弹出表面，当然另一部分会消耗掉产生内能，这并不在我们的考虑范围内。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718214238611.png" alt="image-20220718214238611"></p><p><strong>在blinn-phong模型中我们并没有考虑能量守恒，而在PBR中，我们要严格控制镜面反射+漫反射=1</strong></p><p>首先计算镜面反射部分，它的值等于入射光线被反射的能量所占的百分比。然后折射光部分就可以直接由镜面反射部分计算得出：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718214712609.png" alt="image-20220718214712609"></p><p>而对于不同材质我们设置不同的属性，比如：</p><p><strong>金属材质：</strong>对于金属材质，只考虑<strong>镜面反射</strong>，认为其没有折射光/漫反射光</p><p><strong>非金属材质：</strong> 非金属材质要考虑<strong>镜面反射</strong>和<strong>漫反射</strong></p><p>当然所有的材质都要保证能量守恒，就是加起来=1</p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>D 法向分布函数：描述多少光反射出去</p><p>参数：Ｎ，Ｈ，粗糙度</p><p>Ｇ　几何函数：自遮挡阴影</p><p>参数：Ｎ　Ｖ　Ｌ　粗糙度ｋ，注意ｌ和ｖ方向都有遮挡</p><p>Ｆ　菲涅尔项：描述被反射法向和折射方向所占的比率，就是能量守恒里的ＫＳ</p><p>参数：ｆ0（是测出来的属性，非金属是0.04，金属是1，因为金属没有漫反射）</p><p>兰伯特光照：ｃ／ＰＩ，ｃ是纹理颜色</p><p>ＩＢＬ模拟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PBR管线&quot;&gt;&lt;a href=&quot;#PBR管线&quot; class=&quot;headerlink&quot; title=&quot;PBR管线&quot;&gt;&lt;/a&gt;PBR管线&lt;/h1&gt;&lt;p&gt;基于物理的着色模型三要素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于微平面(Microfacet)的表面模型。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="PBR渲染管线" scheme="http://icecorn.github.io/tags/PBR%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构|GPU渲染管线详解</title>
    <link href="http://icecorn.github.io/2022/07/03/GPU%E6%9E%B6%E6%9E%84/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://icecorn.github.io/2022/07/03/GPU%E6%9E%B6%E6%9E%84/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-03T09:25:10.000Z</published>
    <updated>2022-07-23T02:36:34.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU渲染管线详解"><a href="#GPU渲染管线详解" class="headerlink" title="GPU渲染管线详解"></a>GPU渲染管线详解</h1><p>顶点和片元着色器想必大家已然十分熟悉，但它们之间<strong>各种弯弯绕绕的固定管线操作</strong>，由于一直被GPU所承包，我们反倒陌生了起来。本文将<strong>以三角形的第一人称视角展开叙述</strong>，让读者更加沉浸式地踏上GPU这片土地，希望大家看得开心~</p><h2 id="Ⅰ-从CPU到GPU：来自异世界的召唤"><a href="#Ⅰ-从CPU到GPU：来自异世界的召唤" class="headerlink" title="Ⅰ 从CPU到GPU：来自异世界的召唤"></a>Ⅰ 从CPU到GPU：来自异世界的召唤</h2><h3 id="从硬盘到显存：在故土的最后时光"><a href="#从硬盘到显存：在故土的最后时光" class="headerlink" title="从硬盘到显存：在故土的最后时光"></a>从硬盘到显存：在故土的最后时光</h3><p>我，是一个三角形，跟周围成千上万个三角形没有什么不同。可能跟你们熟悉的世界不太一样，我们虽然都拥有三个顶点，但是<strong>顶点很可能需要跟其他三角形共用</strong>，真正能体现我作为个体而存在的，是三个<strong>顶点索引</strong>。如果我的样子让你觉得无趣，我很抱歉：</p><ul><li>顶点缓冲区：······、*<strong>vertex231*<strong>、</strong>*vertex232**<em>、vertex233、vertex234、vertex235、</em></strong>vertex236***、······</li><li>索引缓冲区：······、231、232、233、*<strong>231*<strong>、</strong>*232**<em>、</em></strong>236***、······</li></ul><p>那一天，我同往常一样，和同伴们躺在广袤无垠而又冰冷刺骨的<strong>硬盘</strong>中。时间仿佛停滞一般，看不到来处也望不见尽头，我甚至都不记得自己是何时出现在这里。我对未来也没有什么期待，毕竟，在这拥挤的空间里，梦想根本无处落脚。</p><p>似乎是来自CPU的指令，人群开始骚动，我跟着同伴不停辗转，温度逐渐升高起来。这里的人似乎都很忙碌，仿佛有着用不完的活力，可能因为这里是<strong>内存</strong>吧。</p><p>正当我们不知所措的时候，天地骤变，我们来到了一个完全陌生的环境，这个叫做<strong>DRAM或是显存</strong>的地方。而危险，才刚刚开始。</p><h3 id="从图形API到GPU指令：一切绝非偶然"><a href="#从图形API到GPU指令：一切绝非偶然" class="headerlink" title="从图形API到GPU指令：一切绝非偶然"></a>从图形API到GPU指令：一切绝非偶然</h3><p>我也是事后听前辈们叙述，才隐约知晓，原来这场突如其来的异世界之旅——并非偶然。这一切，都要从那些高居庙堂的图形API说起。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1207f575b64a008e909658c8cf391488_720w.jpg" alt="img"></p><p>所有的不幸都来源于这些图形API<strong>，</strong>它们<strong>被驱动程序翻译成GPU可读编码，存放在Pushbuffer中</strong>。就像子弹上了膛，装满了或者来自高层的一声令下，就会被发射出去。最终GPU的<strong>Host Interface</strong>承接了这些指令，并把它们丢给了<strong>Front End</strong>处理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-6cbf847e12f18647edf329a866ac2700_720w.jpg" alt="img"></p><p>Front End将这些指令解码分类，我们从内存来到DRAM属于State类的操作：有一些会被立即执行，有一些会等到光栅化后再执行；有一些重复多余的状态设置则会被丢弃。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-377b734519bbf9484369d25a88dff10c_720w.jpg" alt="img"></p><p>而万恶之源的Drawcall，则开启了我们不幸的旅途。</p><h3 id="图元分发（Primitive-Distributor）：大家族的瓦解"><a href="#图元分发（Primitive-Distributor）：大家族的瓦解" class="headerlink" title="图元分发（Primitive Distributor）：大家族的瓦解"></a>图元分发（Primitive Distributor）：大家族的瓦解</h3><p>这个世界有它自己的规则，它<strong>厌恶一切巨大和完整，但却对细碎和海量情有独钟</strong>。于是，我们这个紧密团结的三角形大家族，在一开始就将面对必然解体的命运。</p><p>我们被无情地撕碎，<strong>最多32个顶点或32个图元</strong>（在这个故事中，也就是我，三角形），被称为<strong>Batch</strong>，这是我们最后的体面了。</p><p>先代表我们的顶点索引也被极限压缩，<strong>重复的索引被剔除</strong>，那我们岂不是要魂飞魄散了？幸好，我们还有利用价值，我们得到了<strong>更精简的顶点索引的索引</strong>来标识自己。因为原先的大家族已经不复存在了，原先那么长的索引也便失去了存在的意义，往后的路，我们几个可怜的三角形就要作为一个Batch，独自走下去了。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-e4849ee7e591fd7821bc70b79f771dd0_720w.jpg" alt="img"></p><p>其他三角形们会去哪里呢？我不知道，可能再也没有相见的机会了吧。或许有幸落入同一个SM，那么我们可能会在某次的Warp切换中擦肩而过；但更可能的情况是，我们会在不同的SM里甚至不同的GPC中，经历着相似但毫无联系的人生。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-ec9602e257abaf1a67d10a20c16b7e2e_720w.jpg" alt="img"></p><p>那些在Batch边缘的顶点，在之前很可能是被不同三角形共用的，而现在被撕碎后天各一方，意味着<strong>这些顶点需要被重复计算</strong>，但是我想，对于这个并行高于一切的世界而言，这一切都是值得的。</p><h3 id="顶点获取（Vertex-Fetch）：灵魂需要安息之所"><a href="#顶点获取（Vertex-Fetch）：灵魂需要安息之所" class="headerlink" title="顶点获取（Vertex Fetch）：灵魂需要安息之所"></a>顶点获取（<strong>Vertex Fetch</strong>）：灵魂需要安息之所</h3><p>我所在的Batch被分配到了某一个GPC的某一个SM中，看着密密麻麻的格子间，我预感，我将会在这个地方经历许多。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-85750a54bd8654c5a4778c6403484c4c_720w.jpg" alt="img"></p><p>我的灵魂（顶点索引）在Primitive Distributor中被重组，并被发配到了这种地方；而我的肉体（顶点数据）总不能一直躺在DRAM中。好在这个世界在效率方面总是不会令人失望，当我被决定了目的地的时候，<strong>顶点数据也同步被Polymorph Engine的Vertex Fetch单元运到了SM中的L1 cache中</strong>。</p><h2 id="Ⅱ-几何阶段：大灾变前的狂欢"><a href="#Ⅱ-几何阶段：大灾变前的狂欢" class="headerlink" title="Ⅱ 几何阶段：大灾变前的狂欢"></a>Ⅱ 几何阶段：大灾变前的狂欢</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-9748f581381396a4b061eab364f4d41e_720w.jpg" alt="img"></p><p>据说我来到的这个SM，相比<a href="https://zhuanlan.zhihu.com/p/416334635">上一代</a>，有着诸多改进。格子间明显多了不少（不论是计算核心还是纹理单元），计算单元也变强了许多（<strong>FMA改进了MAD，支持双精度</strong>），<strong>Warp调度机制也变成了双调度以满足如此繁多的元器件指令需求</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1ff785a541a2692cba1c53938c5d1d34_720w.jpg" alt="img"></p><p>每个周期中，Warp Scheduler可以将<strong>一个或两个</strong>Warp，发送到四个执行块中的任何两个：16CUDA核的块<em>2、4SFUs</em>2、16加载/存储单元*1。从图中可以发现，Fermi架构和Tesla架构一样，<strong>Warp的切换周期仍然是两个处理器周期</strong>。</p><p>除了调度机制，最大的改变我想还是这个PolyMorph Engine，毕竟，就是它的Vertex Fetch把我们的顶点运送到这的。我对它颇有好感，我觉得我们之间还有许多故事要发生。</p><h3 id="顶点着色器：共进退但无法联系的伙伴"><a href="#顶点着色器：共进退但无法联系的伙伴" class="headerlink" title="顶点着色器：共进退但无法联系的伙伴"></a>顶点着色器：共进退但无法联系的伙伴</h3><p>顶点数据已经就位，周围的环境也已经熟悉，紧接着，就进入了我们<strong>必经的</strong>顶点着色器阶段。我们一个Batch，满载的话是32个顶点，刚好是一个Warp。</p><p>在这个Warp里，我将暂时忘记自己三角形的身份，作为顶点和其他31个顶点同生共死。虽然我们每次执行顶点着色器指令的时候，<strong>身处不同的Core中，彼此无法联系</strong>，但我知道它们也一定在和我做着相同的事。</p><p>我们不会一次执行完所有的指令，<strong>大多数时候我们都是走走停停</strong>，因为我们所处的这个SM中还有许多其他的Warp：它们可能是跟我们一样正在执行顶点着色器的顶点，也可能是正在执行片元着色器的片元，甚至可能是CUDA核程序的32个线程……虽然我们出身不同，但在SM中并没有什么高低贵贱之分，都只是<strong>由Warp调度器拿捏</strong>的Warp罢了。</p><p>Warp调度器一声令下，我们就由Dispatch单元指挥着，从寄存器文件中拿上我们之前暂存的数据，继续到各自的Core中执行下一条顶点着色器指令。执行了一条或者若干条指令后，Warp调度器可能又是一声令下，我们就得立刻放下手头的工作，把数据在寄存器文件中存好，乖乖回去睡觉，让其他Warp上场。</p><p>我们在执行所有着色器指令的时候，都是这样一个流程，好在<strong>如何调度其实并不需要我们操心</strong>。我们只需要听从指令，行尸走肉般，在一个个格子间——Core中，做完着色器分配给我们的工作。</p><p>如今的顶点着色器大多没有太过繁杂的指令，最主要的任务还是<strong>将我们这种在世界空间中自由自在惯了的顶点约束到一个裁剪空间中</strong>。不过，如果有细分和几何着色器的存在，那么这一重大任务交给它们来做也不是不行，因为只要在光栅化前转换到裁剪空间，之前的位置都只是中间过程罢了。</p><p>很不幸的是，我的这趟旅程，是如此的完整，即使是可选的细分和几何着色器阶段，也逃不了了。</p><h3 id="TCS-Hull：裂变前的最后抉择"><a href="#TCS-Hull：裂变前的最后抉择" class="headerlink" title="TCS/Hull：裂变前的最后抉择"></a>TCS/Hull：裂变前的最后抉择</h3><p>在经过了顶点着色器的一番热身之后，除了顶点被修整一番，我仍然是快乐的三角形。但接下来，可能就没那么轻松了。紧接着需要执行的是<strong>细分控制着色器</strong>，很幸运的是，我们不需要长途跋涉，在<strong>同一个SM</strong>中就可以执行。</p><p>这次，我又可以换回自己三角形的身份了，准确的说，是patch。<strong>patch</strong>是类似primitive但只能用于细分的概念，在drawcall的时候指定，每个patch可以包含最多32个顶点（具体上限取决于实现，但肯定不超过32，毕竟我们一个batch也就32个顶点）。那既然我作为三角形一路走到了这里，那么这个drawcall指定的patch顶点数自然是3咯。</p><p>TCS可以在着色器中通过layout指定要输出的顶点数，而<strong>这个输出的顶点数就是一个patch要开的线程数</strong>，每个线程分配一个gl_InvocationID。</p><p>与顶点着色器每个线程对应一个顶点，输入输出彼此隔绝十分自闭不同，TCS自由得多，<strong>一个patch内的所有线程可以访问这个patch的所有输入（来自顶点着色器）和输出</strong>。这意味着可能会出现同步问题，需要用<strong>barrier()<strong>同步。因此，</strong>TCS更像一个有特殊任务在身的计算着色器</strong>。</p><p>不过，不要被迷惑了，<strong>TCS输出的顶点只是数据</strong>，是作为之后TES里的输入，供TES插值用的，并不代表最终的顶点数。事实上，常见的TCS没那么多戏，只是当个工具人，把顶点着色器输入的顶点属性一一对应地传给TES罢了。</p><p>身为细分控制着色器，它最重要的职责，是通过填写gl_TessLevelInner和gl_TessLevelOuter两组细分因子，<strong>告诉接下来的Tessellator该如何细分每一个patch</strong>。</p><p>现在，让我们来整理一下心情，看看现在我们这些可怜的三角形（patch）究竟变成什么样了：我们目前仍然是一堆patch，patch数没有发生变化，然而顶点可能已经面目全非。事实上，这些顶点目前只是一堆数据，<strong>每个patch之后会被细分成多少个真正的顶点，只取决于细分因子，与TCS输出的顶点数据没有任何关系</strong>。如果把细分因子通过API提前设置好，TCS甚至都不是细分所必须的。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d10d5ac52530495a36fb46e3e7c972d0_720w.jpg" alt="img"></p><p>原本以为会在一个SM上孤独终老，没想到这么快就要重新踏上旅程了。我们会通过Work Distribution Crossbar在不同的SM之间穿梭，因为<strong>接下来我们的顶点数很可能急剧膨胀，当前的SM很可能承接不了</strong>。提前根据细分因子选择一个较为空闲的SM，是个明智之举。</p><h3 id="Tessellator：裂变之所"><a href="#Tessellator：裂变之所" class="headerlink" title="Tessellator：裂变之所"></a><strong>Tessellator：裂变之所</strong></h3><p>我们刚一来到这个新SM，就进入了polymorph引擎中的Tessellator。</p><p>Tessellator的工作除了需要之前TCS输出的至关重要的细分因子外，还需之后的TES中指定的各种参数：<strong>图元生成域、细分的顶点空间划分规则、图元面部朝向、是否开启点模式</strong>。</p><p>而其中最重要的是图元生成域，它决定了Tessellator将在什么样的<strong>抽象patch</strong>中插入新的点，并生成对应的图元。有三种图元生成域：<strong>triangles、quads或isolines</strong>。前两种最终生成三角形，后一种生成线，开启点模式，全都能画成点。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-f7f622e9b67a913784cb936397331811_720w.jpg" alt="img"></p><p>这个抽象patch，意味着TCS原来处理的patch有多少顶点、最后输出多少顶点，它们长啥样，全都不重要。Tessellator只会在一个抽象的三角形/正方形/等值线上，根据前面所需的那些信息去插入新的顶点，最终输出的是一些0到1之间的，标记<strong>其在抽象patch中相对位置的归一化坐标</strong>。</p><h3 id="TES-Domain：裂变后的新生"><a href="#TES-Domain：裂变后的新生" class="headerlink" title="TES/Domain：裂变后的新生"></a><strong>TES/Domain：裂变后的新生</strong></h3><p>事实上，我们在Tessellator中并未提供任何顶点数据，我们现在仍然是之前的那副躯体。Tessellator只吐出来了一堆细分坐标gl_TessCoord，而这些就是<strong>新顶点的种子</strong>，它们会在我们旧的躯体上生根发芽。</p><p>随着新顶点的诞生，我<strong>旧的躯体和灵魂（patch）也随之灰飞烟灭</strong>了。我的新灵魂在<strong>Task Distributor</strong>中，由最终确定的图元类型（在这趟旅途中新图元仍然是三角形）和图元面部朝向，重新构筑成了一个全新的三角形——我的一些顶点有可能和原来的顶点位置一样，而更可能的情况是，我所有的顶点全是无中生有凭空产生的。</p><p>TES的每个线程负责一个新顶点的茁壮成长：它们可以拿到由TCS输出的，属于这个patch的所有顶点数据，<strong>通过gl_TessCoord插值后得到新的顶点数据</strong>。</p><p>虽然都是三角形，但，我还是原来的我吗？一切都是那么的匆匆，已没有时间让我多加思考，因为很快，我将陷入更深的迷茫和混乱之中。</p><h3 id="几何着色器：自由的代价"><a href="#几何着色器：自由的代价" class="headerlink" title="几何着色器：自由的代价"></a>几何着色器：自由的代价</h3><p>刚刚获得全新生命的我，就被<strong>Task Distributor</strong>分配了几何着色器的奇怪指令。</p><p>这一次，我将以三角形图元的身份，和其他31个三角形，组成Warp，完成几何着色器的任务。这意味着，几何着色器的每一个线程对应的是一个图元，它可以拿到我的所有顶点数据。</p><p>几何着色器可以做什么呢？它可以做的事过于疯狂：只需要提前定义好一个最大的顶点数，它就<strong>可以以任何顺序输出任意数量、任意类型的图元（点、线、三角形），并输出这些图元的顶点的各种属性</strong>。</p><p>我很震惊，这样潇洒自由的操作，这样一条条的绘图指令，竟是存在于一个着色器之中的，看起来更像是一个CPU端一大串的API调用程序。我还很困惑，我一个渺小的三角形，经过这么一番折腾之后会变成什么？</p><p>我可能还是一个三角形，也可能直接人间蒸发，又或是变成了多个三角形，甚至变成线、变成点，我有无数种可能。我甚至还可能<strong>实例化</strong>成多份：我的每一个分身，都运行一次几何着色器经历一番不同的捶打后，<strong>分层渲染</strong>到不同的帧缓冲，或者输出到多个流中。</p><p>我不禁心生疑虑，这样自由的代价，究竟是什么？<strong>在一个以细碎和海量为生存原则的并行世界里，塞入这么多串行的绘制指令，本身就是大逆不道的</strong>。</p><p>是的，几何着色器从出生开始，就是被诅咒的。为了<strong>维持图元绘制指令和其输出到帧缓冲的顺序一致性</strong>，必须缓存输出的所有顶点数据，以确保后续图形能按顺序进入光栅化器和ROP中。而<strong>几何着色器每个线程需要缓存的数据远高于顶点着色器和两个细分着色器</strong>！细分阶段虽然也会细分出大量的三角形和点，但是人家始终都是一个线程处理一个顶点的，不像几何着色器一样想着一口吃成胖子，结果吃撑了。</p><p>需要超大的缓存，该怎么办呢？NVIDIA的方案：把缓存强行存在片内，片内寸土寸金的地自然存不下多少，很快就塞满了，塞满后SM能够塞下的Warp就会受限，仓库堵了，工厂不就得跟着堵么？而AMD换了一种思路：它咬咬牙把缓存写到DRAM里，仓库是不堵了，但是仓库在十万八千里远的地方，那工厂很快就会因为货物迟迟未到全部歇业摸鱼了。</p><p>我把这个世界的原则铭记在心：对并行性的巨大破坏，终将受到惩罚。经历九九八十一难后的我，淡定地来到了我们熟悉的Polymorph Engine中。</p><h3 id="流输出：提前跑路"><a href="#流输出：提前跑路" class="headerlink" title="流输出：提前跑路"></a>流输出：提前跑路</h3><p>一波三折之后，我已经不复当年模样。据说在另一个平行世界中，我的这趟旅行就此终止了，我回到了显存的缓冲区中。之后的命运是被回读到冰冷的硬盘冰封起来，还是继续流转到GPU中再次进入渲染管线来一次痛苦的轮回，这我就不得而知了。</p><h3 id="顶点后处理：最后的筛选"><a href="#顶点后处理：最后的筛选" class="headerlink" title="顶点后处理：最后的筛选"></a>顶点后处理：最后的筛选</h3><p>在当前这条世界线中，我在Polymorph Engine中还得经历一道筛选流程：<strong>不在视锥范围内的三角形是不配继续在这个残酷的世界中存在的</strong>。</p><p>在此之前，我们需要先进行<strong>图元装配</strong>，让灵魂归位，从此以后我将是一个被盖棺认定的独立自主的三角形了。虽然在细分和几何着色器之前，我早就进行过简单的图元装配了。</p><p>作为一个独立的三角形，我将面临来自视锥的考验：</p><ul><li>如果我完全在视锥内：我得以通过测试，幸存下来</li><li>如果我完全在视锥外：那毫无争议的，我将被<strong>剔除</strong>，我的旅途便到此结束了</li><li>那么当我一半在视锥内一半在视锥外时：情况就比较尴尬了，我会被毫不留情地裁剪吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-47f66da373b0c96ec79e494671c82ef5_720w.jpg" alt="img">guard-band clipping</p><p>那得根据情况而定了：</p><ol><li><strong>如果我是和近平面相交：那么是一定要被裁剪的</strong>。理由有二：好算；不裁剪直接进行后续的透视除法会出错，整个三角形会被翻转。</li><li>如果我和其他面（透视投影的Frustum并不是横平竖直的）相交：裁剪则并不好算，那么原则就是，<strong>能不裁剪就不裁剪</strong>，反正不裁剪也不会有什么问题，超出视口的区域也不会被光栅化。</li><li>但是如果我大得离谱，导致顶点坐标大得离谱，超过了硬件的处理范围（硬件那肯定是抠抠搜搜的，坐标可不是用float来存的，也就上万，现实中的屏幕能多大它就给你设计多大，很会过日子）：那就不得不裁剪了。</li></ol><p>侥幸逃脱被剔除命运的我，苟延残喘至今，等待我的是什么呢？我先是进行了<strong>透视除法</strong>仪式：我的xyz坐标被除以w坐标；然后这个新坐标将进入Polymorph Engine的Viewport Transform模块中完成最后的<strong>视口变换</strong>仪式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/equation" alt="[公式]"></p><p>回望一路上的种种：先是大家族分崩离析的惨剧，紧接着不痛不痒的顶点着色器逐顶点变换后，经历过细分和几何着色器的各种折腾的我，获得了完全崭新的生命——作为一个全新的三角形，我最终闯过了剔除和裁剪的筛选，磕磕绊绊走到如今。我的<strong>三个顶点坐标被转化到NDC后，又立刻被转化到屏幕坐标</strong>，我预感到，我作为三角形的时间可能已经不多了。</p><hr><h2 id="Ⅲ-光栅阶段：黑暗降临"><a href="#Ⅲ-光栅阶段：黑暗降临" class="headerlink" title="Ⅲ 光栅阶段：黑暗降临"></a>Ⅲ 光栅阶段：黑暗降临</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-8684905909ad2dd3f28df3fe9df02ad1_720w.jpg" alt="img"></p><h3 id="Work-Distribution-Crossbar：光栅化前的洗礼"><a href="#Work-Distribution-Crossbar：光栅化前的洗礼" class="headerlink" title="Work Distribution Crossbar：光栅化前的洗礼"></a>Work Distribution Crossbar：光栅化前的洗礼</h3><p>接下来又是一段艰难的长途跋涉了，上一次离开SM的旅途还是在TCS之后，而这次我旅途的终点是——<strong>每个GPC中都有一个的Raster Engine</strong>。我们会就近被分配到当前GPC的Raster Engine吗？并不会。</p><p><strong>OWDX：将三角形包围盒切块，分发到对应光栅化器中</strong></p><p>是的，不止移动端在分块，Fermi的GPU既然有了多个Raster Engine，开始<strong>分块实现并行</strong>也是很自然的想法。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-b63ee123780bbd1875cdcbc7665f74d0_720w.jpg" alt="img"></p><p>不过，与移动端不同的是，并行处理这些块的只是Raster Engine，而不是SM，SM并不对应任何特定的块，自然也没有专属的帧缓冲，来达到移动端减少带宽的目的；当然也不延迟，来一个三角形处理一个三角形。</p><p>分块的大小还是有讲究的：切得太大，那并行性就差了；切得太小，三角形更容易横跨多块，而<strong>每一块都要做一次三角形设置</strong>，浪费会严重到得不偿失。</p><p>我一到这，它们就开始用<strong>包围盒</strong>（应该只是矩形）把我紧紧包裹住，然后开始切块。没想到，在还没到达Raster Engine之前，我就已经四分五裂了。我的每一块被打上具体Raster Engine的索引，被发往对应的Raster Engine。</p><blockquote><p>面剔除未明确是在哪个阶段发生，有资料表明是在光栅化时，我个人觉得这个阶段就直接剔除最合理。</p></blockquote><p><strong>SWDX：排序</strong></p><p>因为要<strong>保证按三角形提交顺序进入Raster Engine</strong>，所以在正式启程前，我还得先排队。为什么要排队呢，我很是不解，先到先得不好吗，ROP那里不是还会排序一次来保证三角形按照提交顺序输出到帧缓冲的吗？现在又是为什么呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-5382bb711de5d04142963797cb4e55bc_720w.jpg" alt="img"></p><p>这是为了避免三角形重叠时的闪烁问题：如果不排序先到先得，那么最终出现在屏幕上的是哪个三角形就无法唯一确定了。当然如果有十足的把握不会有重叠的三角形出现，现在<a href="https://link.zhihu.com/?target=https://gpuopen.com/learn/unlock-the-rasterizer-with-out-of-order-rasterization/">新的硬件</a>可以手动关掉排序，以提高效率。</p><h3 id="边设置（三角形设置1）：被打上烙印"><a href="#边设置（三角形设置1）：被打上烙印" class="headerlink" title="边设置（三角形设置1）：被打上烙印"></a>边设置（三角形设置1）：被打上烙印</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1ddda400bedd04459378f2b162f352d0_720w.jpg" alt="img"></p><p>终于轮到我了，我跟在上一个三角形后面进入了Raster Engine。准确地说，<strong>我只是三角形覆盖屏幕一定区域的某一块</strong>，其他块很可能在其他Raster Engine中排着队，或已经完成光栅化甚至渲染到了屏幕上，这就不得而知了。</p><p>首先，我来到的是Raster Engine负责<strong>边设置</strong>的第一个小房间，在这里，它们给我打上了属于我这个三角形的烙印。因为<strong>在光栅化进行三角形遍历时，想知道我具体覆盖了哪些像素，总得知道我是个什么样的三角形吧</strong>。</p><p>它们先为我的每一条边<strong>生成边方程</strong>：<img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710164101565.png" alt="image-20220710164101565"></p><p>边上的某一点容易，我有顶点的嘛；而边法线则要麻烦一点，它们让我的两个顶点互减得到这条边的向量，然后将这个向量旋转90度，最后得到的法线为： </p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710164135665.png" alt="image-20220710164135665"></p><p>代入边方程，稍作整理： <img src="https://www.zhihu.com/equation?tex=-+%5Cleft(+p_%7B1y%7D+-+p_%7B0y%7D++%5Cright)x+++%5Cleft(p_%7B1x%7D+-+p_%7B0x%7D+%5Cright)y+-+%5Cleft(+p_%7B1y%7D+++p_%7B0y%7D++%5Cright)p_%7B0x%7D+-+%5Cleft(p_%7B1x%7D+-+p_%7B0x%7D+%5Cright)p_%7B0y%7D=+0" alt="[公式]"></p><p>而如果把方程的左边看成一个边函数： <img src="https://www.zhihu.com/equation?tex=e_%7B2%7D%5Cleft(+x,y+%5Cright)+=+a_%7B2%7Dx+++b_%7B2%7Dy++++c_%7B2%7D" alt="[公式]"> ，那么方程则可以看成是函数值 <img src="https://www.zhihu.com/equation?tex=e_%7B2%7D%5Cleft(+x,y+%5Cright)+=+0" alt="[公式]"> 时的式子，使<strong>函数值为0的点正是在边上的点。那么函数值大于0的点呢？则是与边法线同侧的点。函数值小于0的点则相反。</strong>这正是之后判断像素是否处于三角形之内的核心奥秘。</p><p>而<strong>每个边函数所需要的这三个系数</strong>：a、b、c，它们全可以由顶点的屏幕空间坐标计算得到——这便是边设置阶段给我打上的烙印。</p><h3 id="光栅化（三角形遍历）：粉身碎骨浑不怕"><a href="#光栅化（三角形遍历）：粉身碎骨浑不怕" class="headerlink" title="光栅化（三角形遍历）：粉身碎骨浑不怕"></a>光栅化（三角形遍历）：粉身碎骨浑不怕</h3><p><strong>Inside Test</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-e634c3130f1fb6508e769d051763a914_720w.jpg" alt="img"></p><p>根据烙印，它们可以轻松地判断出屏幕上任何一点是否在我这个三角形内，<strong>只要这点代入我的三个边函数值都大于0，则证明该点在我体内</strong>。</p><p>代入<strong>屏幕像素中心的坐标</strong>去验证整个像素是否被我覆盖，是十分自然的想法。不过下下代架构的<strong>保守光栅化</strong>还有其他不同的选择，这就是后话了。</p><p>为了之后片元阶段能通过与邻居像素属性值求差来获得导数，像素都是4个一小队组成一个<strong>quad</strong>来工作的。它们<strong>一荣俱荣，只要一个像素被我覆盖，其他像素全部被拖下水</strong>，也会被光栅化成片元并占用之后warp的一个线程。</p><p>有一个跟DDA画线算法一样，很常见的加速套路：<strong>每次只要在前一个像素结果上加一个值就行，而不用真的代入原始的边函数去重新算一堆乘法</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=e%5Cleft(+x+1,y+%5Cright)=a(x+1)+++by+++c+=+a+ax++by+++c=a++e%5Cleft(+x,y+%5Cright)" alt="[公式]"></p><p>还有一个少见但却不得不考虑的特殊情况：像素坐标刚好落在我边上，即像素坐标代入后边函数恰好等于0的情况。这会有什么问题呢？<strong>需要有一个机制判断这个像素是否属于这个三角形</strong>。属不属于有那么重要吗？有的，就跟之前光栅化需要排序一个道理，当两个三角形共用一条边时：如果这个像素不属于任何一个三角形，那么就会出现缝隙；如果都属于，那前一个片元可能会被后一个片元覆盖，挺浪费的不够高效。</p><p>总是需要一个tie-breaker规则来打破僵局，方法其实有很多：有DirectX的<strong>top-left规则</strong>（DirectX），归边为左侧边或水平上边界的三角形所有；或使用<strong>离屏点规则</strong>，归与离屏点同一侧的三角形所有。</p><p>还有最后一个小问题，虽然我是一个三角形，可图元还可以是点和线呀，它们该如何被光栅化呢？事实上<strong>点和线被当成矩形</strong>，也就是两个三角形来对待了！给它们单独做一套算法和硬件当然会更快，但是整套硬件就变复杂了，在这个由各种昂贵元器件堆出来的世界里，<strong>没有什么十全十美，有的只是各种权衡</strong>：在三角形占据应用主流的情况下，<strong>所有图元共用一套三角形光栅化流水线</strong>，是明智的选择。</p><p><strong>多重采样</strong></p><p>基于抗锯齿的需要，一个像素只能非黑即白（要么被我覆盖要么不被我覆盖）的现状终究无法令人满意。因此一个像素多加几个采样点来最终判断这个像素的覆盖率的想法便出现了。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1b68a07a9d1af32bb6ff04ebd71daaea_720w.jpg" alt="img"></p><p><strong>MSAA</strong>：每个像素需要多个样本被光栅化，但无论有多少样本被我覆盖，<strong>片元着色器都只会运行一次</strong>，深度值和最终的颜色值会被写到多个被我覆盖的样本对应的帧缓冲内存上。是的，唯一的代价就在于，需要更大的帧缓冲，多加多少采样点，就得多加多少帧缓冲内存去存放着色结果。</p><p><strong>EQAA</strong>（AMD的方案）：以一层间接索引为代价，换来了帧缓冲内存的减少。</p><p><strong>CSAA</strong>（NVIDIA的方案，没想象中那么牛，后来给砍了）：需要光栅化的点再*4，但只是用来估算权重，帧缓冲相比MSAA没有扩大。每个像素只需要多加16bit的覆盖信息，用以记录四个子像素最终的权重。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-21f937a7c38881bf23431407fa80619c_720w.jpg" alt="img"></p><p><strong>分层遍历</strong></p><p>实际上，它们在遍历每个像素（或子像素）是否被我覆盖时，比我想象中聪明得多。它们会将装我的盒子继续分块。我们称这每一块为tile吧（如果想，多分几级也是可以的，tile里还可以有更小粒度的tile）。</p><p>每条边，<strong>只需要先遍历每个tile四个角中的一个点就行</strong>（具体是哪个点取决于边法线），在相当于一种<strong>加速结构</strong>：一个点可以代表该tile中所有64个点，它在边外其他点必然在边外，整个tile都不需要再遍历了。一样可以用<strong>增量</strong>的方式逐渐更新各个tile的顶点。</p><p>tile也<strong>按Z顺序遍历</strong>，讲究！按tile遍历而不是按扫描线遍历还有个好处：<strong>提高了cache命中率</strong>。因为相邻的像素需要同一个纹素的概率更大，而且纹理在GPU中本身也是按块存储的。在同一个块内的片元被打包成Warp，在之后读写的纹理、深度、颜色缓冲更容易抱团取暖，拿到同一块内的纹素。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d35a659a860aacecba7aa02ecf459d60_720w.jpg" alt="img"></p><h3 id="Z-Cull：被抹去的存在"><a href="#Z-Cull：被抹去的存在" class="headerlink" title="Z-Cull：被抹去的存在"></a>Z-Cull：被抹去的存在</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-6366c72ad7da0102d4d0eedf04ad5fdb_720w.jpg" alt="img"></p><p>实际上真正的逐像素（子像素）光栅化前，还会先进行一个对块的<strong>粗糙光栅化</strong>过程。（这个块和遍历时分的块不是一个概念）</p><p>Z-Cull单元会维护每一块的深度最大值，如果我在这一块里，光栅化出来的像素最小值大于它，那意味着我必然被之前的三角形遮挡了，那这一块也就没有继续逐像素光栅化的必要了。</p><p>保守评估我在每一块上的深度最小值的两种方法：</p><ol><li>我三个顶点的最小值</li><li>我在该块四个顶点处插值出来的深度值的最小值</li></ol><p>组合上面的两种方法，取各自最小值的最大值，可以得到更加高效的剔除效果。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-f7c2e3e65d090dccc3b25f77f673bdcf_720w.jpg" alt="img"></p><p>不过，Z-Cull只是用来节省逐像素深度测试的方法，而并不会节省后面的片元着色器，因为还有<strong>early-z</strong>挡着呢。</p><blockquote><p><strong>early-z</strong>：整套剔除要有比较好的效果，还是需要依赖从前往后的顺序提交三角形，移动端tdbr或者z-prepass算法才能无需排序。</p><p>关于early-z，z-culling，z-perpass，hi-z</p><p><a href="https://blog.csdn.net/a1047120490/article/details/106761430">https://blog.csdn.net/a1047120490/article/details/106761430</a></p><p><a href="https://blog.csdn.net/whitebreeze/article/details/118688150">https://blog.csdn.net/whitebreeze/article/details/118688150</a></p></blockquote><p>还可以反过来再做一次Z-Cull：存最小值，拿最大值，如果通过了，说明不会有任何遮挡，也能节省逐像素的深度测试时的读取（只要能提前确定，<strong>百分百被遮挡和百分百不被遮挡都可以节省无谓的深度测试</strong>）</p><p>整个块被我覆盖的可以直接更新其维护的最值，否则还得之后根据该块内逐像素深度的最值来更新（这会带来一定的延迟）</p><p>可以这么理解与分层遍历的区别：<strong>分层遍历是在屏幕空间上的加速，而Z-Cull则是在深度方向上的加速，它们二者都是基于块的思想，用一个块的比较来快速跳过块内每个像素的比较</strong>。</p><hr><h2 id="Ⅳ-片元阶段：美丽新世界"><a href="#Ⅳ-片元阶段：美丽新世界" class="headerlink" title="Ⅳ 片元阶段：美丽新世界"></a>Ⅳ 片元阶段：美丽新世界</h2><p>往日里，人们提到光栅化，脑子里也就只有那么一张简单的图：一个三角形被切成一个个像素。可是，当我亲身经历后，才发现压根就没有那么简单，<strong>硬件为了高效地将我四分五裂，穷尽各种可能来提高效率</strong>，以至于流程复杂得让我晕眩。</p><h3 id="属性设置-（三角形设置2）：落地生根"><a href="#属性设置-（三角形设置2）：落地生根" class="headerlink" title="属性设置 （三角形设置2）：落地生根"></a>属性设置 （三角形设置2）：落地生根</h3><p>现在有哪些像素（子像素）会被我覆盖已经一清二楚，但在真正发往片元着色器之前，还有一件很重要的事情需要完成。这些被覆盖的像素所需要的属性，还都没有着落呢，它们需要<strong>由我的三个顶点插值得到</strong>。</p><p>与三角形边设置一样，属性插值也需要提前计算一些值，这个过程发生在Polymorph Engine的<strong>属性设置</strong>单元中。我都已经记不清这是第几次踏入Polymorph Engine了，而且每一次踏入的还不一定是同一个，不过我想，这应该是最后一个了。</p><p>在Tesla架构中由一个单元全盘负责的三角形设置，在Fermi架构中被拆成了边设置和属性设置，一个位于Raster Engine中，一个位于Polymorph Engine中。</p><p>边设置有边方程，属性设置自然需要属性平面方程： <img src="https://www.zhihu.com/equation?tex=a%5Cleft(+u,v+%5Cright)+=+%5Cleft(1-+u+-+v+%5Cright)a_0+ua_1+va_2" alt="[公式]"></p><p>其中最重要的，是<strong>求得每个像素的质心坐标（u, v, w）</strong>，因为三者和为1，只需要求得两个即可。只要有了质心坐标，插值就是轻而易举的事了（在片元着色器阶段，由SM中的SFU负责）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-0d9ef4134bfc2fd32fd2791a6fbbb417_720w.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710174245566.png" alt="image-20220710174245566"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-a0ee912e6a9b1af49f113d3c9543c332_720w.jpg" alt="img"></p><p>可是，该死的透视变换，让一切变得复杂了起来，我们需要对属性做<strong>透视校正</strong>：分别插值 属性/w 和 1/w，然后将两者的结果相除。</p><p>因此，我们需要对质心坐标进行调整，而调整后的面积和也就不再是常数了，需要逐像素老老实实计算三个质心坐标了：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710174335142.png" alt="image-20220710174335142"></p><p>不过，深度值除外，它不需要透视校正。因为<strong>被扭曲过的深度值（在透视除法中已经被w除了），其在屏幕空间上刚好是线性的</strong>（<strong>还方便之后压缩</strong>），因此直接线性插值就可以。</p><blockquote><p>之所以深度特殊，是因为它要存的值本身就是要除以w的，之后自然线性插值即可；而其他属性除以w再插值则只是为了让属性过渡能符合近大远小的规律，但是顶点处要存的值仍然是原来的属性值，因此还得映射回去。</p></blockquote><h3 id="片元着色器：任劳任怨"><a href="#片元着色器：任劳任怨" class="headerlink" title="片元着色器：任劳任怨"></a><strong>片元着色器：任劳任怨</strong></h3><p>现在每个片元所需要的所有属性值已经准备齐全了，我已经从一个三角形彻底变成了一个单纯的小片元。我和其他三个片元一起组成了一个<strong>quad</strong>，我们是彼此需要互相利用求差取得导数的塑料姐妹花，因为除此之外，我们并不能做其他任何的交流。最后我们和其他quad被打包成一个warp，发往了片元着色器。</p><p>图形的大部分任务据说都是在这里完成的，这可能也是我这一趟旅途中<strong>最繁忙</strong>的一个阶段了。不过正因为它的复杂性完全来自于程序员们在shader中的天马行空，对于硬件而言，反倒没有什么过多可以赘述之事。因为无论多复杂，于我而言，无非都是听从Warp调度器行尸走肉般的节拍器生活罢了。</p><h3 id="ROP：飞蛾扑火"><a href="#ROP：飞蛾扑火" class="headerlink" title="ROP：飞蛾扑火"></a>ROP：飞蛾扑火</h3><p>结束了片元着色器工厂流水线的繁重作业后，我终于来到了旅途的真正终点。分布在GPC外的L2 Cache附近，密密麻麻的ROP中的某一个，将会是我的最终归宿。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d9789027b8ac208100e0b2ae8cfb6254_720w.jpg" alt="img"></p><p>和Raster Engine一样，每一个ROP单元分管屏幕像素的某些块，而我落在哪一块中，就会被发往哪一个ROP中。分块带来的好处显而易见，每个ROP只需要在负责的block里维持三角形的顺序就行了。</p><p>它们负责<strong>late depth test、模板测试、混合</strong>等，可谓是十分忙碌。如果开启了多重采样，它们还负责最终每个像素的<strong>resolve</strong>，混合多个子样本的颜色得到最终的像素值。</p><p>一路上见过了太多生离死别，能一直走到现在我已经看淡了许多。原本只是在硬盘中了无生趣的几个数据，能够拥有这么一段跌宕起伏的人生我已然足够幸运。</p><p>即便跨越重重险阻，颠沛流离至今，到最后也可能只是<strong>影响了数百万像素中某一个像素的些许光亮</strong>。但为了这十几毫秒的些许光亮，就足以让我们这些懵懂无知的三角形，一次又一次地踏上旅途——因为如果三角形没有梦想，那和咸鱼还有什么区别呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU渲染管线详解&quot;&gt;&lt;a href=&quot;#GPU渲染管线详解&quot; class=&quot;headerlink&quot; title=&quot;GPU渲染管线详解&quot;&gt;&lt;/a&gt;GPU渲染管线详解&lt;/h1&gt;&lt;p&gt;顶点和片元着色器想必大家已然十分熟悉，但它们之间&lt;strong&gt;各种弯弯绕绕的固定管</summary>
      
    
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/categories/GPU%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="GPU渲染管线" scheme="http://icecorn.github.io/tags/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构（二）|Fermi架构</title>
    <link href="http://icecorn.github.io/2022/07/02/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%BA%8C%EF%BC%89Fermi%E6%9E%B6%E6%9E%84/"/>
    <id>http://icecorn.github.io/2022/07/02/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%BA%8C%EF%BC%89Fermi%E6%9E%B6%E6%9E%84/</id>
    <published>2022-07-02T09:25:10.000Z</published>
    <updated>2022-07-23T02:35:42.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU架构系列-二）-Fermi架构"><a href="#GPU架构系列-二）-Fermi架构" class="headerlink" title="GPU架构系列(二）| Fermi架构"></a>GPU架构系列(二）| Fermi架构</h1><p>当Tesla架构在硬件上统一了各种着色器后，统一的可编程着色技术让我们得以驾轻就熟地逐像素做光照、实现各种后处理效果，似乎一切都很完美？但为什么还是与电影画面相去甚远？在2010的时间点上，电影每帧可以使用到的三角形可以达到数亿个，而游戏则只有一两百万个。<strong>三角形数量级上的差距，导致模型精细度上的巨大差异，光照再华丽又有什么意义呢？</strong></p><p>那到底是什么拖了实时渲染几何处理上的后腿呢？要回答这个问题，我们需要先来回顾一下Tesla架构：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-65a203eef8b3e730d2238f597f8b16f0_720w.jpg" alt="img"></p><p>看负责运算的百万民工（SM里的各种运算单元）浩浩荡荡整齐排列，而负责视口变换、裁剪、属性设置、光栅化、剔除等一系列<strong>固定管线的几何操作</strong>，却只能一起挤在角落瑟瑟发抖。从这，我们就不难猜出瓶颈出在何处了</p><p><strong>巧妇难为无米之炊：</strong></p><ol><li>一方面，由于<strong>CPU和GPU的带宽限制</strong>，GPU能够获取到的顶点数量本就有限，使得即使SM再多也只是暴殄天物；</li><li>另一方面，顶点着色器处理完后的顶点，要转化成片元最终传递到片元着色器上，<strong>都必须先经过固定管线的一系列几何操作</strong>，如果顶点太多，也会导致堵塞。</li></ol><p>我们知道，<strong>各类硬件的发展速度并不是齐头并进的</strong>。随着晶体管越来越小，计算单元的运算速度随着摩尔定律不断翻番，相比之下，内存带宽的进步就显得微不足道了，因此<strong>带宽这个瓶颈也就越来越突出</strong>。那么第一方面的瓶颈该如何解决呢？解决不了我们可以绕开嘛！<strong>来不及获取这么多顶点，那我就自己生成！</strong>这就是细分着色器登场的时代背景。</p><p>晶体管越来越小，也意味着我们<strong>可以在GPU里堆更多的SM，甚至可以往每个SM里塞入更多运算单元</strong>。以前，Tesla架构的SM其实并不算多，搭配一个负责这些几何操作的模块就能勉强达到平衡；而现在，塞满运算单元的Fermi架构，如果还是只有一个单元负责处理几何操作，生活就难以为继了。</p><p>那么，接下来就让我们走进Fermi这座全新工厂，看看它为解决第二方面的瓶颈，究竟做出了哪些架构调整。</p><h2 id="鸟枪换炮的独立王国"><a href="#鸟枪换炮的独立王国" class="headerlink" title="鸟枪换炮的独立王国"></a>鸟枪换炮的独立王国</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-82dc52b2af5388225e04fcba70d6ac9c_720w.jpg" alt="img"></p><p>跟上一张Tesla架构图一对比，我们仿佛从近代来到了现代。除了五彩斑斓的全新版本（误），我们可以发现主要的变化有：</p><h3 id="变富有了，什么东西都多了"><a href="#变富有了，什么东西都多了" class="headerlink" title="变富有了，什么东西都多了"></a>变富有了，什么东西都多了</h3><p>因为架构从90nm来到了40nm，自然就财大气粗了起来：</p><ul><li><strong>每个SM里都塞了满满当当一堆计算单元</strong>，一个SM里就八个计算单元搭伙过日子的窘迫生活一去不复返了</li><li>仓库DRAM和码头Memory Controller的组合还是只有6座，但是<strong>每个码头搭配的码头工人ROP（Raster Operation Processor）从1个扩招到了8个</strong>，住在L2 cache附近的ROP分区里（码头肯定要靠近内部的高速公路，才能跟SM们进行快速的货物运输）</li></ul><h3 id="TPC华丽转型为GPC"><a href="#TPC华丽转型为GPC" class="headerlink" title="TPC华丽转型为GPC"></a>TPC华丽转型为GPC</h3><p>Tesla中的主角——各大子公司TPC（Texture Processing Clusters），鸟枪换大炮<strong>变成了更加自给自足的独立王国 GPC（Graphics Processing Clusters）</strong>，只要能通过L2 cache跟外界接触，<strong>GPC自己就能完成整个GPU的绝大多数功能</strong>，这样不同价位的设备阉割起来就更加灵活了。</p><ul><li>Tesla一个纹理单元服务两个SM的安排，已经无法满足日益膨胀的SM了，<strong>纹理单元也因此被移入了SM</strong>（实际上在下一章中我们会发现，光一个SM就有四个纹理单元）</li><li>被移入SM的，还有<strong>打包了所有几何操作的PolyMorph Engine</strong>，这是<strong>解决我们前面所讨论的几何瓶颈的关键一招</strong>。有了它的加入，下面这些管线固定功能的部分也都可以<strong>随着大量SM并行</strong>了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-941edc12d44b710c7904bddbc9140219_720w.jpg" alt="img"></p><ul><li>GPC之所以能成为独立王国，自然不能少了Raster Engine。<strong>每个GPC都拥有一个Raster Engine</strong>，服务内部4个SM（所有这些硬件单元的配比，我们都不必太过在意。不同架构都在不停调整，是<strong>反复测试权衡后，最适应当时那个年代的独特配方</strong>）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-66da128e7f05518663d1946e4a8eac89_720w.jpg" alt="img"></p><p>至于PolyMorph Engine和Raster Engine里的各项功能，我们会在下一章跟随三角形进行惊心动魄的冒险之旅时，一一接触到。现在就先让我们来看看，英伟达究竟用这套配方，为我们熬制出了什么神奇的解药，以<strong>突破几何瓶颈的魔咒</strong>。</p><h2 id="双管齐下，以假乱真"><a href="#双管齐下，以假乱真" class="headerlink" title="双管齐下，以假乱真"></a>双管齐下，以假乱真</h2><h3 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h3><p>首先，前面我们分析过，CPU和GPU之间通过总线传递数据，是当时（甚至现在也是）令人无可奈何的短板，就像我们可以在地球上把高铁修到世界的每一个角落，却仍然难以自由地开展星际航行一样。但是办法总比困难多，<strong>供不应求那我GPU就自己生成顶点呗</strong>。</p><p>这就到了细分大显身手的时候了，细分的大致流程跟其他着色器不同，主要分为三步（OpenGL和dx两边名字不一样，但硬件都是这么一套，所以本质没区别）：</p><ol><li>Tessellation Control Shader（hull shader）：决定每个patch要<strong>细分到什么程度</strong></li><li>Tessellation Primitive Generation（tessellator）：根据Tessellation Control Shader传出的两个参数，<strong>执行内置的一套细分规则</strong></li><li>Tessellation Evaluation Shader（domain shader）：本质上和顶点着色器一样，只不过处理的是细分后的所有顶点（<strong>包含无中生有出来的顶点</strong>）</li></ol><blockquote><p>限于篇幅，这里没有展开，想要弄清整条管线的每个细节，可以看下一章哦~</p></blockquote><p>带Shader的1和3，自然和顶点、片元着色器一样，是可以随心所欲可编程的着色器啦，既然是统一着色器架构，那么它们理所当然都是<strong>由SM里密密麻麻的CUDA core负责执行</strong>的；而中间那步则是固定功能操作，是由谁负责的呢？想必大家也能猜到，那就是PolyMorph里的Tessellator。</p><p>我们现在或许可以理解，为什么每个SM里都有这么一个PolyMorph了，多了细分这么个整活的玩意儿，在顶点和片元之间又硬生生加了这么一段（几何着色器，因为众所周知的原因，我们就忽略吧(^_−)☆），如果把它扔外头，来自多个SM的海量细分请求，不仅处理上应接不暇，数据传输上也会爆炸。</p><p>Raster Engine也变多的原因也很容易理解，<strong>不管是CPU传过来的真实三角形，还是细分阶段凭空捏造的假三角形，它们都是要被光栅化的</strong>。三角形变多了，Raster Engine数量也水涨船高是合情合理的。</p><p>我们可以发现，每一个看似微小功能的增加，背后都会有大量基础设施的投入和调整，而每一次调整牵一发而动全身。这也是架构的精妙所在，它<strong>在这种微妙的动态平衡中，为图形和并行计算开辟崭新的道路</strong>。</p><h3 id="置换贴图"><a href="#置换贴图" class="headerlink" title="置换贴图"></a>置换贴图</h3><p>光是一个细分，就能逆转狂澜了吗？很难。因为细分也要讲究基本法，虽说是无中生有，但也是要在原有三角形上细分的，这就注定了，这顶多只是平滑，要想丰富更加精细的细节，困难重重。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-b16667b63bead0b36d1d68c91a56fa94_720w.jpg" alt="img"></p><p>如上图所示，细分只能帮忙把第一幅图，盘成第二幅图，想要雕刻成第三幅图就无能为力了。那要怎么办才好呢？着急，在线等。</p><p>遇事不决，贴图解决。在Tessellation Evaluation Shader后再贴上置换贴图，双管齐下无懈可击。同法线贴图、视差贴图等只影响最终光照的trick不同，置换贴图在光栅化前直接改变顶点位置，是一种更高级的trick~</p><p>把顶点“存到”贴图上，有诸多好处：</p><ol><li>相比直接读取顶点buffer，<strong>内存更加紧凑，带宽占用少</strong>，因此也能做更复杂的动画</li><li><strong>Mipmap天然就是LOD</strong>，一个模型吃遍天，不同设备、不同视距都不需要费力去生成一堆模型的LOD了</li><li>作为一张贴图，在游戏中实时修改要比直接去改网格容易得多，因此还能被用来做<strong>贴花（Decals）</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-22372c748d79cdc8f4d819b394de2f98_720w.jpg" alt="img"></p><p>总之，作为模型的一种紧凑的“压缩格式”，置换贴图好处多多。但其实这在影视行业已经是一种很古老的技术了，<strong>英伟达既然相中了它，势必要为它在游戏中的大规模应用铺好台阶</strong>。那么英伟达做了什么呢？一下子翻了八倍的ROP、每个SM里塞了四个纹理单元，我想已经很能说明用意了吧。</p><p>当然，大量纹理单元的引入，我们这批搞图形的，可不满足于只是拿来贴个置换贴图。整套PBR管线、延迟渲染等在游戏引擎里普及成为烂大街的技术，背后离不开大量纹理单元的支持。这种<strong>技术和硬件互相成就</strong>的历史，在之后的文章里还会反复上演。</p><p>不过在十年后，随着大众对品质的追求来到一个新的量级，这套靠一堆贴图维生的工作流，逐渐出现了新的瓶颈。然后UE5跳出来说：“我要扔掉纹理这个包袱，要自己做LOD，自己做光栅化”，这就是后话了。</p><hr><h2 id="三角形的异世界之旅（图形管线）"><a href="#三角形的异世界之旅（图形管线）" class="headerlink" title="三角形的异世界之旅（图形管线）"></a>三角形的异世界之旅（图形管线）</h2><p>本篇单开一篇博客记录：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU架构系列-二）-Fermi架构&quot;&gt;&lt;a href=&quot;#GPU架构系列-二）-Fermi架构&quot; class=&quot;headerlink&quot; title=&quot;GPU架构系列(二）| Fermi架构&quot;&gt;&lt;/a&gt;GPU架构系列(二）| Fermi架构&lt;/h1&gt;&lt;p&gt;当Tes</summary>
      
    
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/categories/GPU%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/tags/GPU%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构（一）|Tesla架构</title>
    <link href="http://icecorn.github.io/2022/07/01/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%B8%80)%20Tesla%E6%9E%B6%E6%9E%84/"/>
    <id>http://icecorn.github.io/2022/07/01/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%B8%80)%20Tesla%E6%9E%B6%E6%9E%84/</id>
    <published>2022-07-01T09:25:10.000Z</published>
    <updated>2022-07-23T02:34:59.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU架构-一-Tesla架构"><a href="#GPU架构-一-Tesla架构" class="headerlink" title="GPU架构(一) | Tesla架构"></a>GPU架构(一) | Tesla架构</h1><h2 id="SIMT"><a href="#SIMT" class="headerlink" title="SIMT"></a>SIMT</h2><p>SIMT：single instruction，multiple threads</p><p>SIMT类似CPU上的多线程。最简单的理解SIMT的是想象有这样一个多核系统，每一个core有自己的寄存器文件、自己的ALU、自己的data cache，但是没有独立的instruction cache、没有独立的解码器、没有独立的Program Counter register，命令是从单一的instruction cache同时被广播给多个SIMT core的。<strong>即所有的core是各有各的执行单元，数据不同，执行的命令确是相同的。多个线程各有各的处理单元，和SIMD公用一个ALU不同。</strong></p><p>因为大量的并行计算需求，从而导致了GPU的产生</p><h2 id="Tesla架构一览"><a href="#Tesla架构一览" class="headerlink" title="Tesla架构一览"></a>Tesla架构一览</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710133404872.png" alt="image-20220710133404872"></p><ul><li>最上面的是尊敬的甲方CPU；整个GPU是一个巨大的外包公司，负责干各种又脏又累的活</li><li>外包公司内，最上层的是各种大小包工头；中间是一堆负责干活的社畜；最下方是堆放原料和产品的码头和仓库</li><li>我们可能会发现一个特点，除了负责指挥的包工头，下面干活的社畜以及吞吐数据的码头和仓库，似乎有好几个，长得还一模一样，这就是<strong>GPU并行性在具体硬件结构上的体现</strong>。</li></ul><h3 id="各模块的作用"><a href="#各模块的作用" class="headerlink" title="各模块的作用"></a>各模块的作用</h3><ul><li><strong>Host Interface</strong>：外包公司的大包工头，负责收发来自甲方CPU的各种订单（多是枯燥无味重复单调，需要大量廉价劳动力，CPU自己不屑于干、做不来的活）并处理GPU在各种订单间的上下文切换；还负责获取来自内存等待加工的原材料（顶点数据、纹理数据、各种buffer等），将其存放到仓库（显存）中。</li><li><strong>Input Assembler</strong>：负责将甲方给的顶点数据进行简单组装（根据顶点索引与图元类型装配），并搭配上属于它们的顶点属性，才能传给Vertex Work Distribution。</li><li><strong>Vertex、Pixel、Compute Work Distribution</strong>：三个小包工头，负责将自己领域更加具体的工作分发给底下一大堆流水线工人们去做（从名字就可以看出，他们分别分发顶点、片元和计算着色器的任务）。</li><li><strong>TPC（Texture Processing Clusters）</strong>：这个名字比较令人困惑，里面有<strong>一个纹理单元和两个负责计算的SM（Streaming Multiprocessor）</strong>。都是干活的生力军，上面三个小包工头的活全都是它们完成的，从这里就可以看出所谓的统一的硬件结构是指什么了。这个结构下一章会具体展开，先让我们记住这个啥都能做的“全栈工程师”。</li><li><strong>Viewport/clip/setup/raster/zcull block</strong>：顶点着色器处理完，只是输出一堆裁剪坐标（还未透视除法）和一堆与其一起等待光栅化插值的属性，这个模块就是负责这些，流水线中到目前为止都未开放编程的固定功能部分。</li><li><strong>ROP（Raster Operations Processor）</strong>：除了格子间里流水线上的工人，身为码头工人的ROP也是任劳任怨的好员工。他们负责对片元着色器处理后的像素进行测试和装箱：同一个像素位置的<strong>深度/模板测试和写入、颜色混合、抗锯齿</strong>都由它完成。因为片元着色器处理一个位置的片元时，并不知道该位置其他片元的信息，所以需要有这么一位码头工人在最终将产品（像素颜色）发往仓库前，做最后的统筹合并修缮工作。</li><li><strong>L2 Cache、Memory Controller和DRAM</strong>：从图上可以看到，每个仓库（DRAM）搭配一个码头（图中未标的Memory Controller）、码头临时库存（L2 Cache）和一个码头工人（ROP），共有6组这样的搭配，每个搭配对应着显存六分之一的物理地址。格子间TPC里并行工作着的SM们发来了一条又一条的数据吞吐请求，会在码头集中处理，这些请求可能会被合并，并根据优先级从仓库获取数据<strong>以实现数据传输效率的最大化</strong>；被码头工人最终装箱完（颜色混合、硬件抗锯齿）的像素数据也会被码头发往仓库中的帧缓冲。</li></ul><hr><h3 id="干活主力TPC"><a href="#干活主力TPC" class="headerlink" title="干活主力TPC"></a>干活主力TPC</h3><p><strong>TPC（Texture Processing Clusters）</strong>，是统一的硬件架构，可以处理顶点，片元，计算着色器的任务。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710134553236.png" alt="image-20220710134553236"></p><p>我们可以将TPC看成一个个子公司，这家黑心企业里一共有8个，我们任意挑选一间来看看。</p><blockquote><p>跟<strong>数量</strong>相关的参数我们都不需要太过关注，因为不同架构各不一样，同一架构不同价位的GPU也不尽相同（毕竟老黄刀法了得），理解其工作原理更为重要，如果要为特定GPU做优化，可以去官网查看更为具体的参数信息。</p></blockquote><p><strong>Geometry Controller</strong>：从名称上看，它是光栅化前几何阶段的大管家，负责<strong>顶点属性</strong>在<strong>芯片内</strong>的输入输出事宜，几何着色器这种增减顶点改变拓扑结构的骚操作也得麻烦它。不过，<strong>顶点着色器和几何着色器的运算指令仍然是由SM执行的</strong>，Geometry Controller会把最终结果送到<strong>Viewport/clip/setup/raster/zcull block模块</strong>去进行光栅化等步骤，或者<strong>Stream Out</strong>回内存交给程序员们揉搓。（该部件在Fermi架构中被升级成了<strong>PolyMorph Engine</strong>，我们会在Fermi架构章节里进一步研究）</p><p><strong>SMC（SM controller）</strong>：正如上一章讨论的，Tesla是统一的图形和并行计算架构，顶点、几何、片元着色器，甚至与图形无关的并行运算任务（CUDA），都由同样的硬件SM来运算。SMC负责将来自总部的各种任务，<strong>拆分打包成Warp</strong>（下一节会详细介绍）交给其中一个部门（SM）处理。除此外，SMC还<strong>负责协调SM与共用部门Texture unit之间的工作</strong>，以实现对外部纹理资源的获取，而显存中其他非纹理资源的读写甚至原子操作则会<strong>通过ROP与外界打交道</strong>。整体来看，SMC又负责对接外界资源，又负责内部任务分配，以实现复杂但至关重要的<strong>负载平衡</strong>，是名副其实的子公司高管。</p><p><strong>Texture Unit</strong>：包含4个纹理地址生成器和8个滤波单元（支持全速的2:1各项向异性过滤）。与SM内的指令全是标量运算不同，纹理单元的指令源是<strong>纹理坐标</strong>，输出是经过<strong>插值</strong>的纹理值（最常见的如RGBA），都是向量。拿到的纹理数据会存Tex L1 cache里，因为千辛万苦从外面搬进来的数据以后没准还有用呢。</p><h3 id="一条船上的蚂蚱"><a href="#一条船上的蚂蚱" class="headerlink" title="一条船上的蚂蚱"></a>一条船上的蚂蚱</h3><p>采访完干活的人，咱们接下来就得看看他们所要做的事情了。那么，我们得从最源头找起，他们干的活，最初可能是一段着色器代码，也可能是一段CUDA Kernel程序，都是高级语言，它们会被编译成中间指令，然后被优化器转化为二进制GPU指令。<strong>中间指令如果是矢量指令（SIMD），也会被转换为多条 Tesla SM 标量指令</strong>，比如4维向量相加，会被拆成4个标量相加，因为英伟达已经在Tesla里干掉了运算SIMD指令的计算单元。</p><p><strong>ISA（Instruction Set Architecture）</strong>：那么都会生成哪些指令呢？主要有三类：</p><ol><li><strong>运算</strong>：浮点整数等加法乘法、最小最大、比较、类型转换等基础运算以及超越函数等复杂运算。</li><li><strong>流控制</strong>：分支、调用、返回、中断、同步</li><li><strong>内存访问</strong>：包括对各类内存的读写、原子操作</li></ol><p>说了这么多，其实只要知道，<strong>不管多复杂的程序，层层传递到SM里，最终交到社畜们手中的就是一条条的指令</strong>。那这些活到底有什么特殊的呢？交给CPU不也能做吗？之所以交给GPU做，就是因为这些指令不只需要做一遍。比如一个顶点着色器，每有一个顶点数据，就得开一个线程把这个指令做一遍。</p><p>而实际上，SMC拿到一个着色器的所有指令后，每次会把这些指令<strong>以32个线程为单位</strong>分发给SM，而<strong>负责执行完这个着色器所有指令的32线程，就称为一个Warp</strong>。指令存在了指令cache里，MT（multi-threaded） Issue<strong>每次拿出一条指令</strong>发给手底下的SP或SFU们执行。诶？可是一个SM里SP只有8个，怎么运行32个线程呀，答案是每个SP连续干四次不就行了嘛？（卧槽，真不要脸）。<strong>SP是负责干活的硬件，线程是逻辑上负责完整运行完一个着色器所有指令的概念</strong>，确实没必要一一对应。SFU也是同理。</p><p>一个MT Issue发号施令一次，手底下的SP或SFU就吭哧吭哧将一条指令合计执行32次，这就是<strong>SIMT（Single-instruction, multiplethread）</strong>，GPU正是基于SIMT而设计的。</p><p>但是仔细想想，每个线程真的一定执行相同的指令吗？程序可不是简简单单一条一条往下走，还有分支和循环等指令会改变程序流向，<strong>由于每个线程输入的数据不同，很有可能会进入不同的分支</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710135929296.png" alt="image-20220710135929296"></p><p>那该怎么办才好呢？</p><ul><li><strong>编译器可以进行特殊情况下的分支预测</strong>，来判断Warp中所有线程是否必然进入同一分支（比如条件是传入的定值，并非经过实际运算的值）</li><li>如果无法预测，则不得不在执行时付出点指令开销来进行<strong>Warp Voting</strong>，如果投票出来该Warp的所有线程还是只走一条分支，那么就还好，大家可以一起跳过其他所有分支，否则<strong>不同分支就只能串行，不进入某一分支的线程将被mask。</strong>即使只有一个线程进入了某一个分支，其他31个线程也得等着它执行完，这就是<strong>锁步运行。</strong></li></ul><p><strong>就像被绑到同一条船上的蚂蚱，同进退共生死，想要一条指令同时指挥32个线程，那么灵活性自然也在获得效率的时候被一并献祭了，因为凡事皆有代价。</strong></p><h3 id="活儿可以等，打工人不能等"><a href="#活儿可以等，打工人不能等" class="headerlink" title="活儿可以等，打工人不能等"></a>活儿可以等，打工人不能等</h3><p>看到这，总感觉也没有那么神奇，GPU无非就是仗着自己运算单元多一点儿所以算得快呗，创造大量就业的公司也能算黑心公司吗？别着急，对大量元器件的探访，对Warp概念的摸查，都是对最终Warp调度机制大揭秘的铺垫，真相即将浮出水面。</p><p>我们来看这么一个现状：当前硬件的计算速度比访问内存的速度快几个数量级，<strong>瓶颈往往在内存访问上</strong>。当SP遇到内存访问指令，会由SMC向外界请求数据（要么通过纹理单元要么通过ROP），那在漫长的等待过程中，SP是不是只能摸鱼了？</p><blockquote><p>社畜SP：“没办法呀，我也不是真的想摸鱼，但是没数据我干不了接下来的活呀 :）”<br>主管MT Issue：“是的，这个Warp只能等了，毕竟不同指令间有数据依赖，着色器里的代码总不能跳着执行。”<br>社畜SP：“是呀是呀，这活总得按部就班，才不会忙中出错嘛”<br>子公司高管SMC：“总部摊派给我们的活多着呢，我特意拆分成了好多个Warp让你们执行，就是想避免你们带薪拉屎。一个Warp要拿数据，我去帮你们联系就行，你们赶紧先去做其他Warp！”<br>于是，整个部门007的日常开始了。</p></blockquote><p>这就是<strong>延迟隐藏</strong>的真相了。是的，公司特意搞了一个指令cache，就是<strong>让SM能够存下足够多的Warp</strong>（Tesla架构最多24个，这些Warp可以是不同类型的，比如顶点着色器、片元着色器甚至是CUDA程序），以在出现内存阻塞时快速切换到其他可以执行的Warp上，等拿到数据了再切回原来的Warp就行。毕竟，读写数据并不需要SP们费心，有足够多的Warp让SP们007，这家公司才有可能蒸蒸日上。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-29d8a02a890d4174d8d30f9241b46d88_r.jpg" alt="preview"></p><p>原来这就是并行的真相：可不是简单的计算单元并行就可以了，而是<strong>所有元器件尽可能都不要停下来</strong>。说到所有元器件，自然MT Issue主管也跑不了，大家都是打工人，谁也不比谁高贵。</p><p>MT Issue从原来分发一个Warp的一条指令，变成了从多个Warp里挑出一个Warp执行其之前执行到的接下来的指令。至于如何调度，有<strong>复杂的计分板根据Warp类型、指令类型和公平性原则等来量化每一个待选的Warp</strong>，每两个处理器周期，MT Issue就从中挑出一个得分最高的Warp分配给对应的元器件去执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-07c156f620b46a6287e759dcf00f93cf_r.jpg" alt="preview"></p><p>每个SP只有8个，做完Warp一条指令需要4个周期，那么MT Issue为什么是两个处理器周期就分发一次指令呢？因为还有SFU啊！SP在运行的时候，SFU可不能闲着，2个周期分发一次指令的频率，就可以保证MT Issue有充足的时间给SFU挑选一个需要其运行的Warp，这样一来，<strong>所有员工就都能满负荷运转了，只要手里还有Warp没执行完，谁也别想停</strong>。</p><p>原来这就是高性能并行运算，原来这就是血汗工厂<strong>，一切都经过精心设计，势必要榨干每一个元器件的性能</strong>，背后的原因令人暖心。</p><p>最后还剩下一个小问题可以探讨，一个Warp线程的多少对性能有什么影响呢？如果粒度太粗，则可供调度的 Warp就会太少，不利于延迟隐藏； 如果粒度太小，则每次切换所执行的线程就太少， 切换 Warp的相对成本就变高了。</p><p>Warp调度是整个GPU架构最核心的内容了，<strong>不同的架构，元器件的名字可能会变，数量可能会变，会拆分或合并，但是延迟隐藏的这一特性却始终未变</strong>。</p><h2 id="从图形到通用计算"><a href="#从图形到通用计算" class="headerlink" title="从图形到通用计算"></a>从图形到通用计算</h2><p>如果我们仔细观察，可以发现，全称为图形处理单元的GPU，<strong>其最基本的计算部门——SM，已经跟图形没有半毛钱关系了</strong>。这一切都是NVIDIA有意为之，把各种图形相关的操作剥离成独立的硬件单元（Geometry Controller、Raster等），把计算单元SM解耦出来，以<strong>开启和拥抱更加广阔的并行计算市场</strong>。</p><p>因为图形任务的整体流程是固定的已知的，所以形成了<strong>相对固定的图形管线</strong>，只抠出几个重要的环节（如顶点着色器、片元着色器等）可供编程，GPU就可以弄出专门的硬件去做那些必定要做的不可编程的模块（比如光栅化）以提高效率。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-458a6b35cd6a371dc3838594422d9e4f_r.jpg" alt="preview"></p><p>然而，<strong>效率的提高意味着自由的丧失</strong>，在这条相对固定的图形管线，我们设置完最开始的<strong>顶点输入数据</strong>后，这些输入该如何分配线程运行，以及完成顶点计算后如何光栅化成片元，再继续分配多少线程去运行片元计算，这些事情其实都是<strong>对程序员隐藏</strong>的。</p><p>而在通用计算管线里，所有线程都不可避免要由程序员去分配与调用，因为既然“通用”，那就可能用来处理任何工作，<strong>每个线程要对应的任务就不再是固定的顶点或片元，而可能是任何我们想做的事</strong>。那么<strong>要分配多少线程，每个线程要负责处理什么工作</strong>（不仅是如何计算，还有要获取多少数据，要输出什么），所有的一切，事无巨细全都由程序员说了算。</p><p>除此之外，通用计算管线与图形管线相比，还有一个最大的不同：我们分配的这些线程是<strong>协作式</strong>的，我们<strong>可以根据它们的线程ID分配它们干不同的活，它们之间还需要数据传递</strong>。也不是说图形管线发出来的线程完全不需要协作和数据传递，只是所有的协作模式已经被定死了，不需要我们操心，比如：<strong>执行片元任务的时候是以每四个线程为单位的</strong>，以方便计算它们之间数据的差值（ddx、ddy）。</p><p>正因为通用管线释放了这么多的自由度，使得其性能的上限被提高了，我们可以<strong>根据具体任务，分配线程，并设计它们的协作模型以及数据依赖关系</strong>。不过，性能的上限是需要我们自己去探索达到的，如果缺乏对硬件的基本理解与优化技巧，深不可测的性能下限也在那等着我们。</p><h2 id="CUDA和计算着色器"><a href="#CUDA和计算着色器" class="headerlink" title="CUDA和计算着色器"></a>CUDA和计算着色器</h2><p>卖弄这么久的通用管线，是时候来看看它们到底是什么了。<strong>CUDA（Compute Unified Device Architecture）</strong>是最先被推出的，它轻装上阵彻底和图形划清了界限，成为了许多非图形学背景科研人员的并行计算平台。</p><p>后来，随着各种图形算法日益复杂，搞图形的人发现CUDA真香，也眼馋着想用上通用计算大杀器，所以各个API就相继推出了计算着色器。反正<strong>支持这套东西的底层硬件都是一样的</strong>，无非就是换了一堆名词来包装出这套一模一样的通用计算模型而已。</p><h3 id="线程组织结构"><a href="#线程组织结构" class="headerlink" title="线程组织结构"></a>线程组织结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d9689b21d2fcac3045886bdfcee3f565_720w.jpg" alt="img"></p><p>CUDA线程的三级组织结构为：<strong>Grid-Block-Thread</strong>，每个Block包含多少线程在核函数中写死，<strong>Block是协作发生的组织单位（因此也被称为CTA，cooperative thread array）</strong>，里面的线程可以<strong>通过共享内存传递数据</strong>。每个Grid包含多少Block，由应用程序在每次调用时指定，同一个Grid的所有Block之间则是完全独立的，没有数据依赖。</p><p>因为<strong>线程与任务之间的映射</strong>是由我们决定的，那么我们自然需要知道每一个线程的ID，才能通过它获取到对应的数据，执行对应的计算任务，将计算结果写到对应的内存中。不过因为其三级组织结构，而且每一级结构可以支持三维的索引（上图只显示了2维），光有一个ID可能不能满足我们的需求。当然我们都可以自己算出来，但鉴于其需要被高频使用，因此不同API全都提供了一堆内置变量，来描述ID的不同表示，以避免我们自己计算浪费性能。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-36f03e7fa80a9530c71ad87faca8034a_720w.jpg" alt="img"></p><h3 id="真正的并行单元是Warp"><a href="#真正的并行单元是Warp" class="headerlink" title="真正的并行单元是Warp"></a>真正的并行单元是Warp</h3><p>又是三级线程组织结构，又是三维的线程ID映射，初学起来让人头晕脑胀，但是我们别忘了，无论上层的概念如何复杂，<strong>底层的硬件执行单元都是SM，真正的并行单位始终是Warp</strong>。因此优化的基础大多是以Warp为主角的，比如：</p><ul><li><strong>最好为每个Block分配Warp线程数（32）的整数倍线程数</strong>。因为不管多少线程都要拆分成Warp单位去执行，33个线程与64个线程同样需要执行两个Warp。</li><li><strong>同一分支要尽可能挤到同一Warp里。</strong>如果设计的算法中，不同的线程不得不执行不同的分支，比如Warp1要执行分支A和B，Warp2也要执行分支A和B，如果能让Warp1只执行分支A，而Warp2只执行分支B，就能获得性能的提升。（因为每个线程要做什么都是我们说了算，因此给了我们这样的优化空间）</li><li><strong>如果内存读写指令都只由一个Warp执行，那么无需同步</strong>。因为一个Warp内的线程本身就是锁步运行的，因此肯定不需要同步。<strong>但如果是不同Warp之间存在数据依赖，则不得不同步</strong>。比如一个先写后读的常见例子：Warp1的线程要读取由Warp1其他线程写入到共享内存的数据，则无需同步，因为该数据必定已经被写入；而Warp1的线程要读取由Warp2线程写入到共享内存的数据，则必须同步，因为<strong>Warp1开始执行读取指令的时候，Warp2执行到哪里了则无法预料，因为Warp的调度是硬件决定的，对程序员是不透明的</strong>。</li></ul><h2 id="分级“物流”系统"><a href="#分级“物流”系统" class="headerlink" title="分级“物流”系统"></a>分级“物流”系统</h2><p>到目前为止，我们对GPU架构的理解，还差最后一块拼图：<strong>内存——支撑GPU这整座血汗工厂高速运转的物流系统</strong>。计算得再快，如果物流系统跟不上，那也白搭。（特别是当今硬件算力过剩，带宽吃紧的局面）</p><p>就像有国道省道，也会有村间小路，有主动脉肺动脉，也会有毛细血管一样，GPU中分级的“物流”系统，也是非常自然的设计。让我们以CUDA与各个内存如何打交道为例，一一介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-b3501fecde229b3f4223f609d67bda03_720w.jpg" alt="img"></p><h3 id="Global-Memory与L2-cache"><a href="#Global-Memory与L2-cache" class="headerlink" title="Global Memory与L2 cache"></a>Global Memory与L2 cache</h3><p>如果大家还有印象，第一章我们介绍过这两个东西。Global Memory（DRAM），就是位于显卡上（GPU外）的显存，<strong>每一块显存都会与GPU内的对应的一个L2 cache相连</strong>。L2 cache是在SM之外的，因此可以供所有SM共同使用。</p><p>不同Grid的执行是串行的，如果他们存在对同一块显存的数据依赖，则由硬件负责同步。<strong>一个Warp中的连续线程访问连续的内存，可以被合并为一条内存读取指令</strong>，能显著提高效率。</p><h3 id="Shared-Memory与L1-cache"><a href="#Shared-Memory与L1-cache" class="headerlink" title="Shared Memory与L1 cache"></a>Shared Memory与L1 cache</h3><p>共享内存和L1 cache位于SM中，Tesla架构的L1 cache只用于缓存纹理数据，之后的架构则和共享内存占据相同的硬件单元，并<strong>可以由用户配置两者的大小</strong>。</p><p>通用管线的协作线程模型能够高效运行的秘密全在共享内存上，<strong>因为其位于SM中，读写速度肯定远高于主存与L2 cache</strong></p><p>而共享内存是对一个block内的所有线程可见的，这意味着<strong>一个block内所有线程必定位于同一个SM中</strong>。而同一个grid的不同block则不一定，因此不同block之间是老死不相往来无法通信的（如果想实现更高自由度更多粒度的同步，可以使用<a href="https://link.zhihu.com/?target=https://developer.nvidia.com/blog/cooperative-groups/">合作组</a>）。这也是为什么一个block的最大线程数有所限制，因为一个SM能容纳的Warp是有限的。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710142551173.png" alt="image-20220710142551173"></p><p>一个warp32线程可能需要同时对共享内存进行读写，因此需要考虑<strong>bank冲突</strong>的问题。</p><p>简单讲，共享内存的带宽是有限制的，<strong>支持同时32个bank的读写，但是每个bank只能读写32位数据</strong>。多个地址会被映射到同一个bank，如果有多个线程想要同时读写同一个bank的数据，则不得不变成<strong>串行</strong>执行。</p><p>读内存现在的硬件都有<strong>广播</strong>的功能，不会出现bank冲突，但是写内存则需要小心的安排每个线程要写入的内存地址，<strong>尽量保持每个线程都映射到不同的bank中</strong>，以保持warp指令的并行性。</p><h3 id="Local-Memory与Register-Files"><a href="#Local-Memory与Register-Files" class="headerlink" title="Local Memory与Register Files"></a><strong>Local Memory与Register Files</strong></h3><p>每一个线程都有自己运行所需的局部变量，存放在<strong>寄存器文件</strong>中，如果存不下会溢出到L1 cache中，如果还存不下会被一路驱逐出去，贬谪到L2甚至到主存中。（性能会受到毁灭性打击）</p><p>最初的局部变量其他线程是无法访问的，但是较新的硬件支持了<strong>Shuffle操作</strong>，可以在一个Warp的线程间直接传递数据，比通过共享内存来回读写数据还快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU架构-一-Tesla架构&quot;&gt;&lt;a href=&quot;#GPU架构-一-Tesla架构&quot; class=&quot;headerlink&quot; title=&quot;GPU架构(一) | Tesla架构&quot;&gt;&lt;/a&gt;GPU架构(一) | Tesla架构&lt;/h1&gt;&lt;h2 id=&quot;SIMT&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/categories/GPU%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/tags/GPU%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单例模式|一文搞懂单例模式！</title>
    <link href="http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-29T09:25:10.000Z</published>
    <updated>2022-07-01T06:17:38.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文搞定单例模式"><a href="#一文搞定单例模式" class="headerlink" title="一文搞定单例模式"></a>一文搞定单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过单例模式， 可以做到：确保一个类只有一个实例被建立 ，也就是C++中定义全局的东西的一个通用做法。</p><p>在实现单例的过程中要注意如下问题：</p><ul><li>构造函数应该声明为非公有，从而禁止外界创建实例</li><li>拷贝操作和移动操作也该禁止</li><li>只能通过singleton的共有特定类操作访问它的唯一实例（c++中的一个公有静态成员函数）</li></ul><p>本文实现常见的饿汉式及懒汉式，以及多线程懒汉式的单例模式</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式顾名思义，就是我先准备好一个全局的实例，等到你需要getInstance的时候就直接获取就行了，普通的饿汉式的缺点就是以”空间换时间”，就是说在编译阶段已经给这个类在<strong>全局数据区</strong>分配好了内存并初始化了。</p><h3 id="C98的饿汉模式"><a href="#C98的饿汉模式" class="headerlink" title="C98的饿汉模式"></a>C98的饿汉模式</h3><p>在C++98版本，为了实现线程安全，要把istance实现成一个类内的成员变量，并且要在类外初始化它，不然编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------C98饿汉模式单例-----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton98</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="built_in">CSingleton98</span>()      </span><br><span class="line">    &#123;   </span><br><span class="line">a = <span class="number">98</span>; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c98饿汉模式单例使用全局静态对象，在编译时已经调用单例类构造函数分配内存并实例化出来了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton98 * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> CSingleton98 instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a; <span class="comment">//类中其他变量,这里懒得写get/set方法</span></span><br><span class="line">&#125;; </span><br><span class="line">CSingleton98 CSingleton98:: instance;<span class="comment">//在类外初始化</span></span><br></pre></td></tr></table></figure><p>我们在main函数中什么都不做打印试试看：</p><p>可以看到执行了单例类的构造函数，说明这种饿汉模式是在编译阶段已经在全局数据区分配了内存并初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701124104249.png" alt="image-20220701124104249"></p><p>接着我们用如下代码测试，可以看到两次获取实例对象的地址是一致的，单例ok！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CSingleton98* inst98= CSingleton98::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingleton98* inst981= CSingleton98::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst98-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;(*inst98) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;(*inst981) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701124532493.png" alt="image-20220701124532493"></p><h3 id="C11的饿汉模式"><a href="#C11的饿汉模式" class="headerlink" title="C11的饿汉模式"></a>C11的饿汉模式</h3><p>C11的饿汉模式表现在我们是将单例的instance作为一个局部static变量处理的（在函数内）</p><p><strong>优点：</strong></p><ul><li><strong>只有在程序第一次执行到GetInstance()函数的时候才会在全局数据区开辟内存并且初始化，也就是说我们没有在编译的时候就开辟内存，节省了不必要的空间开销！</strong></li><li><strong>解决了static变量初始化的问题</strong></li></ul><blockquote><p>C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。</p><p>然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局唯一的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。</p><p>这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。</p><p>而<code>Meyers&#39; Singleton</code>写法中，单例对象是第一次访问的时候（也就是第一次调用<code>getInstance()</code>函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先<code>getInstance()</code>再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！</p><p>讲到这，我们对<code>Meyers&#39; Singleton</code>的盲目鼓吹也需冷静一下，因为C++同样能保证所有文件内（非函数内）的static变量在main()函数开始运行之后肯定是都能做完初始化的。所以如果你是在main()函数运行之后，用日志管理器的单例访问配置文件的单例，那么其实也是没有问题的… 这就引出<code>Meyers&#39; Singleton</code>的第二个优势，那就是当产生继承的时候。</p></blockquote><p><strong>这里有一个遗留问题：就是编译器在编译阶段如何决定先编译哪一个单例文件呢，由此产生的文件依赖问题怎么解决呢？</strong></p><ul><li>解决了单例的继承问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;Singleton::isOn = <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;Singleton::isOn = <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">state</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Singleton::isOn;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isOn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span>: <span class="keyword">public</span> Singleton &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addBrightness</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; brightness += val;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">subBrightness</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; brightness -= val;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getBrightness</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brightness;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> brightness;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果有子类继承这一父类，来拓展成新的子类，比如Monitor显示器类有开关状态，同时扩展了一个亮度的成员。但是父子类的static成员变量是共享的，其isOn成员会有问题。</p><p>场景：比如一个显示器类，一个灯类。他们都是singleton的子类。但是灯是否打开，不应该影响显示器是否打开</p><p><strong>静态局部对象：</strong></p><ul><li>在程序执行到该对象的定义处时，创建对象并调用相应的构造函数！</li><li>如果在定义对象时没有提供初始指，则会暗中调用默认构造函数，如果没有默认构造函数，则自动初始化为0。</li><li>如果在定义对象时提供了初始值，则会暗中调用类型匹配的带参的构造函数（包括拷贝构造函数），如果没有定义这样的构造函数，编译器可能报错！</li><li>直到main（）结束后才会调用析构函数！</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton11</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="built_in">CSingleton11</span>()      </span><br><span class="line">    &#123;    </span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C11饿汉模式使用的是局部static变量，是在调用的时候分配到全局存储区的，不是在编译时就分配哦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是因为C11的编译器可以帮我们保证线程安全，俺们就不用操心啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton11 * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line"><span class="comment">//静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</span></span><br><span class="line">        <span class="type">static</span> CSingleton11 instance;     </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>以下是测试：</p><p>首先是main函数什么都不做：</p><p>结果就是什么都不会发生（笑，想起了莫里亚篇索隆对山治说的话，和最近的CP0段子哈哈哈）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701125704906.png" alt="image-20220701125704906"></p><p>调用GetInstance：</p><p>此时会在全局数据区开辟内存，并调用构造函数初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSingleton11* inst11= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701125910795.png" alt="image-20220701125910795"></p><p>调用两次GetInstance：</p><p>此时只会调用一次构造函数，这正是局部static变量的特性（静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSingleton11* inst11= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingleton11* inst112= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;(*inst11) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;(*inst112) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701130227454.png" alt="image-20220701130227454"></p><p><strong>这里顺便加深下记忆：</strong></p><p>如果是全局static变量声明两次的话，编译器会报错的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;                   <span class="comment">//打咩！</span></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701130526478.png" alt="image-20220701130526478"></p><p>这是C11下优化的饿汉模式单例，至于怎么保证线程安全的（不用加锁），这是C11编译器保证的！以后有时间再看！</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式的特点就是延迟加载，只有到用到的时候才实例化instance</p><p><strong>这里又有一个疑问：这么考虑的话上文的C11饿汉模式不应该是懒汉模式嘛？</strong></p><p>注意这里最下边一行实际上在编译之前实例化一个指针变量，但是相比于类变量，一个指针才4个字节而已，who cares！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingletonL</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line"><span class="function"><span class="type">static</span> CSingletonL* <span class="title">GetInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span> ( m_pInstance == <span class="literal">nullptr</span> )    </span><br><span class="line">m_pInstance = <span class="keyword">new</span> <span class="built_in">CSingletonL</span>();  </span><br><span class="line"><span class="keyword">return</span> m_pInstance;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="built_in">CSingletonL</span>()&#123;lazy = <span class="number">3</span>;&#125;  </span><br><span class="line">    <span class="type">static</span> CSingletonL* m_pInstance;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> lazy;</span><br><span class="line">&#125;;</span><br><span class="line">CSingletonL* CSingletonL::m_pInstance;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSingletonL* instlazy = CSingletonL::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingletonL* instlazy1 = CSingletonL::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; instlazy-&gt;lazy &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp; (*instlazy) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp; (*instlazy1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701132606657.png" alt="image-20220701132606657"></p><h3 id="懒汉模式存在的问题"><a href="#懒汉模式存在的问题" class="headerlink" title="懒汉模式存在的问题"></a>懒汉模式存在的问题</h3><p>在懒汉式的单例类中，其实有两个状态，单例未初始化和单例已经初始化。假设单例还未初始化，有两个线程同时调用GetInstance方法，这时执行 m_pInstance == NULL 肯定为真，然后两个线程都初始化一个单例，最后得到的指针并不是指向同一个地方，不满足单例类的定义了，所以懒汉式的写法会出现线程安全的问题！在多线程环境下，要对其进行修改。</p><h2 id="深入的理解懒汉和饿汉"><a href="#深入的理解懒汉和饿汉" class="headerlink" title="深入的理解懒汉和饿汉"></a>深入的理解懒汉和饿汉</h2><p>其实就是看定义的事静态成员对象变量还是静态成员对象指针变量，因为如果定义了静态成员对象变量，程序在运行之初已经分配了空间，就要调用构造函数了，而你在调用getinstance的时候，不会再调用构造函数了，因为之前已经调用过了，你就是用的现成的，就是所谓的饿汉模式，上来先把吃的准备好了，因为饿怕了，怕后期准备会挨饿。</p><p>而定义了静态成员对象指针变量，程序运行之初也会分配空间，但是那个是指针的空间，而不是对象的空间，所以不会调用对象的构造函数，而只有调用getinstance进行new操作的时候，才会对其调用构造函数，就是现上轿现扎耳朵眼，比较懒惰，所以叫懒汉模式。</p><h2 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h2><p>使用double-check来保证不会每次进来都去获取锁，来提高性能，先判断不为空的话，直接返回了数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">static</span> Singleton* m_instance;  </span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">Lock</span>();<span class="comment">//借用其它类来实现，如boost  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">UnLock</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> m_instance;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="面试单例代码"><a href="#面试单例代码" class="headerlink" title="面试单例代码"></a>面试单例代码</h2><p>最后是面试的简单单例代码，用C11饿汉实现哦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singletonPractice</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singletonPractice* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> singletonPractice m_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">singletonPractice</span>(<span class="type">const</span> singletonPractice&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    singletonPractice&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singletonPractice&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">singletonPractice</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    singletonPractice* in1 = singletonPractice:: <span class="built_in">getInstance</span>();</span><br><span class="line">    singletonPractice* in2 = singletonPractice:: <span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;(*in1) &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; &amp;(*in2) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<br><a href="https://blog.csdn.net/zhanghuaichao/article/details/79459130">https://blog.csdn.net/zhanghuaichao/article/details/79459130</a><br><a href="https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA">https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文搞定单例模式&quot;&gt;&lt;a href=&quot;#一文搞定单例模式&quot; class=&quot;headerlink&quot; title=&quot;一文搞定单例模式&quot;&gt;&lt;/a&gt;一文搞定单例模式&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="C++" scheme="http://icecorn.github.io/categories/C/"/>
    
    <category term="设计模式" scheme="http://icecorn.github.io/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://icecorn.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（四）|排序合集</title>
    <link href="http://icecorn.github.io/2022/06/28/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://icecorn.github.io/2022/06/28/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-28T09:25:10.000Z</published>
    <updated>2022-07-09T08:02:01.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220708130351003.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220708130434985.png" alt="image-20220708130434985"></p><p><a href="https://blog.csdn.net/qq_54850622/article/details/115729733">https://blog.csdn.net/qq_54850622/article/details/115729733</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序的基本思想：</strong><br>快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p><strong>快速排序的三个步骤：</strong><br>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）<br>(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大<br>(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p><strong>选择基准的方式：</strong><br>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列<br>这里选择基准可以采用<strong>固定位置</strong>，<strong>随机选取</strong>，<strong>选三个数取中间的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = l,right = r;</span><br><span class="line">    <span class="type">int</span> pivot = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//这里必须从右边开始，因为我们选择的pivot是左边第一个</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]&gt;=pivot) right--;</span><br><span class="line">nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]&lt;=pivot) left++;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = pivot;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums,l,left<span class="number">-1</span>);<span class="comment">//左闭右闭的方式，要排除已经排序好的元素</span></span><br><span class="line">    <span class="built_in">QuickSort</span>(nums,left+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快排的空间复杂度是O(1)的，在原来的vector上排序就行，不需要新开空间<br>平均时间复杂度是O（nlogn）<br>最坏时间复杂度是O（n2）|<br>举例：{1,2,3,4,5,6,7,8,9,10} 就要n2，原因在于每次分治划分不均匀，当然和pivot的选取也有关系。</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>对于要找数组中第k大或第k小的问题，不需要完整的快排，只需要快速选择的方法即可</p><p> 方法1：快速排序的分区思想，快排的思想是一次找出一个数的正确位置，并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。</p><p>方法二：堆排序，在pop k个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随机取一个数作为基准</span></span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">        <span class="type">int</span> random = <span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">        <span class="type">int</span> base = nums[random];</span><br><span class="line">        <span class="comment">// 将该数放到待快排区间开头第一个元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[random]);</span><br><span class="line">        <span class="type">int</span> index = start;</span><br><span class="line">        <span class="comment">// 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素</span></span><br><span class="line">        <span class="comment">// 交换到index + 1位置，index++，使得最终index前面的元素都比base大。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= base) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[index + <span class="number">1</span>], nums[i]);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[index], nums[start]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，</span></span><br><span class="line">        <span class="comment">// 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">            <span class="built_in">quickPartition</span>(nums, index + <span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">            <span class="built_in">quickPartition</span>(nums, start, index - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，</span></span><br><span class="line">        <span class="comment">// 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k</span></span><br><span class="line"><span class="comment">// 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickPartition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>同样是分治的思想，利用分治+二分，将整个数组分到最小粒度再进行处理</p><p><strong>重点是归并需要新开一个与原来数组等长的数组，空间复杂度为O(n),时间复杂度O(logn)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line"><span class="comment">// conquer</span></span><br><span class="line"><span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">temp[i++] = nums[p++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[i++] = nums[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">nums[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>复杂度O（n2)，就类似抓扑克牌 ：）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; --j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>复杂度O(n2)，相邻的比较交换，是稳定的排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次选出最小的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//選擇排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mid = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[mid])</span><br><span class="line">&#123;</span><br><span class="line">mid = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[mid], nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>大顶堆</strong>：根节点大于等于自己的两个孩子节点。<br><strong>小顶堆</strong>：根节点小于等于自己的两个孩子节点。</p><p>堆排序总共分为两步：<br>1、初始化建堆：<br>找到一个树的最后一个非叶节点， 计算公式为 (n-1)/2 -1， 然后遍历树的每个非叶节点，使其符合堆的规则。</p><p>2、排序重建堆：<br>将堆的顶部，与最后一个元素交换，然后将数组长度减一，将剩下的元素重新建成一个堆。</p><p>时间复杂度：初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为O(n+nlogn)=O(nlogn)。</p><p>空间复杂度：O(1)。</p><p><strong>堆排序 建堆，初始化二叉树，上浮和下沉操作维护堆的性质（小根堆：父节点要比子节点小，大根堆相反）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums, <span class="type">int</span> root, <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span>*root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span>*root + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> max = root;</span><br><span class="line">        <span class="keyword">if</span>( left &lt; length &amp;&amp; nums[left] &gt; nums[max])</span><br><span class="line">                max = left;</span><br><span class="line">        <span class="keyword">if</span>( right &lt; length &amp;&amp; nums[right] &gt; nums[max])</span><br><span class="line">                max = right;</span><br><span class="line">        <span class="keyword">if</span>(max != root)&#123;</span><br><span class="line">                <span class="built_in">swap</span>( nums[max], nums[root]);</span><br><span class="line">                <span class="built_in">adjust_heap</span>(nums, max, length);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化建堆：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                <span class="built_in">adjust_heap</span>(nums, i, len);</span><br><span class="line">         <span class="comment">//排序重建堆     </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);           <span class="comment">//堆顶元素和末尾元素进行交换</span></span><br><span class="line">                <span class="built_in">adjust_heap</span>(nums, <span class="number">0</span> , i);        <span class="comment">// 对顶点进行一次堆排序</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220708152514369.png" alt="image-20220708152514369"></p><p>顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属 性），然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶 [1,2,3,4]，它们的值分别 为 [4,2,1,1]，表示每个数字出现的次数。</p><p>紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种 排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说， 因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]， 表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line"><span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;num : nums)</span><br><span class="line">&#123;</span><br><span class="line">max_count = <span class="built_in">max</span>(max_count, ++counts[num]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : counts)</span><br><span class="line">&#123;</span><br><span class="line">buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span> &amp;&amp; ans.<span class="built_in">size</span>() &lt; k; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;num : buckets[i])</span><br><span class="line">&#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(num);</span><br><span class="line"><span class="keyword">if</span> (ans.<span class="built_in">size</span>() == k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="排序的适用场景"><a href="#排序的适用场景" class="headerlink" title="排序的适用场景"></a>排序的适用场景</h2><p>（1）当数据规模较小时候，可以使用简单的直接插入排序或者直接选择排序。</p><p>（2）当文件的初态已经基本有序，可以用直接插入排序和冒泡排序。</p><p>（3）当数据规模较大时，应用速度最快的排序算法，可以考虑使用快速排序。当记录随机分布的时候，快速排序平均时间最短，但是出现最坏的情况，这个时候的时间复杂度是O(n^2)，且递归深度为n,所需的占空间为O(n)。</p><p>（4）堆排序不会出现快排那样最坏情况，且堆排序所需的辅助空间比快排要少，但是这两种算法都不是稳定的，要求排序时是稳定的，可以考虑用归并排序。</p><p>（5）归并排序可以用于内部排序，也可以使用于外部排序。在外部排序时，通常采用多路归并，并且通过解决长顺串的合并，缠上长的初始串，提高主机与外设并行能力等，以减少访问外存额外次数，提高外排的效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;常见排序算法&quot;&gt;&lt;a href=&quot;#常见排序算法&quot; class=&quot;headerlink&quot; title=&quot;常见排序算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://icecorn.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（三）|分治法</title>
    <link href="http://icecorn.github.io/2022/06/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E6%B2%BB/"/>
    <id>http://icecorn.github.io/2022/06/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E6%B2%BB/</id>
    <published>2022-06-27T09:25:10.000Z</published>
    <updated>2022-07-07T14:56:51.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治算法详解"><a href="#分治算法详解" class="headerlink" title="分治算法详解"></a>分治算法详解</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>分治发的基本思想是自上而下的去处理问题，将一个复杂问题分成一些子问题分解成规模较小的问题处理。<strong>本质就是先分，再治</strong>，至于算法的时间复杂度可以通过<strong>主定理</strong>求解，暂不叙述</p><ul><li><p>divide </p><p>解题时找到divide的方式后，不要考虑太多，比如说处理一个字符串s，我们第一步将它分成left和right两段，那么就相当于我们有了left和right两个字串的求解结果，直接用就行，这样依次divide直到划分到最小为止<strong>（常常可以结合二分和dfs）</strong></p></li><li><p>conquer</p><p>分完之后就要治了，考虑两个方面</p><ul><li>其一是有了左右两个结果，怎么通过这两个来得到当前（最终）的结果</li><li>其二是考虑边界情况，分到最小粒度了，有没有特殊处理</li></ul></li></ul><p><strong>总结起来就一句话，画图求解和dfs一样直接干，不要想太多，你的脑袋才能压几个栈啊！</strong></p><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序就是经典的分治问题：</p><p><a href="https://blog.csdn.net/qq_35344198/article/details/106857042">https://blog.csdn.net/qq_35344198/article/details/106857042</a></p><p>利用二分进行divide，conquer时注意细节即可</p><p>需要注意的是归并排序空间复杂度是O（n）的，需要开辟一个与原数组等长的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line"><span class="comment">// conquer</span></span><br><span class="line"><span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">temp[i++] = nums[p++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[i++] = nums[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">nums[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h2><p>Lc-241</p><p>这种问题一般是给一个字符串，有各种算式，问你加括号的方式有多少种。我们可以以每个算符作为分割点进行divide，算出左右两边的值的个数，然后在conquer</p><p>这里要注意的是，分到最小粒度的时候我们直接把它作为结果存进去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = expression.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;+&#x27;</span>||expression[i]==<span class="string">&#x27;-&#x27;</span>||expression[i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> l:left)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> r:right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> c = expression[i];</span><br><span class="line">                        <span class="keyword">switch</span>(c)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: res.<span class="built_in">push_back</span>(l+r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: res.<span class="built_in">push_back</span>(l-r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: res.<span class="built_in">push_back</span>(l*r);<span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(expression));</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然因为在递归过程中我们有很多重复计算，可以使用记忆化搜索来优化一下：<br>实际上就是用一个hashmap来记录当前字符串s的返回结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,vector&lt;<span class="type">int</span>&gt;&gt; memo;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(expression)!=memo.<span class="built_in">end</span>()) <span class="keyword">return</span> memo[expression];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = expression.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;+&#x27;</span>||expression[i]==<span class="string">&#x27;-&#x27;</span>||expression[i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> l:left)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> r:right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> c = expression[i];</span><br><span class="line">                        <span class="keyword">switch</span>(c)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: res.<span class="built_in">push_back</span>(l+r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: res.<span class="built_in">push_back</span>(l-r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: res.<span class="built_in">push_back</span>(l*r);<span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(expression));</span><br><span class="line">        &#125;    </span><br><span class="line">        memo[expression] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="平面点集最短距离问题"><a href="#平面点集最短距离问题" class="headerlink" title="平面点集最短距离问题"></a>平面点集最短距离问题</h2><p><a href="https://blog.csdn.net/weixin_44772995/article/details/93749863">https://blog.csdn.net/weixin_44772995/article/details/93749863</a></p><blockquote><p>题目描述<br>有一天，小明得到了二维平面上的若干个点，他现在想知道这些点中距离最近的两个点之间的距离是多少？</p></blockquote><blockquote><p>输入<br>第一行输入一个整数T，共有T组测试数据（T&lt;=30)。<br>每组输入数据第一行输入一个n，表示有n个点。第二行有n*2的数字，相邻两个数代表一个点的x,y坐标。<br>1&lt;n&lt;=100, -100000000=&lt;x,y&lt;=100000000</p></blockquote><blockquote><p>输出<br>输出有T行，每行包括一个整数，代表所有距离的最小值（因为小明不在意小数，所以结果向下取整）。</p></blockquote><blockquote><p>样例输入 Copy<br>2<br>2<br>0 0 1 1<br>2<br>0 0 100000000 100000000<br>样例输出 Copy<br>1<br>141421356</p></blockquote><p>核心思路就是分治，divide使用二分法，conquer的技巧在于分割线两边的点之间的距离，另外还要注意的事划分到最小粒度是一边只有两个点或三个点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分治算法详解&quot;&gt;&lt;a href=&quot;#分治算法详解&quot; class=&quot;headerlink&quot; title=&quot;分治算法详解&quot;&gt;&lt;/a&gt;分治算法详解&lt;/h1&gt;&lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="divide&amp;conquer" scheme="http://icecorn.github.io/tags/divide-conquer/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（二）|动态规划专题</title>
    <link href="http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-06-25T09:25:10.000Z</published>
    <updated>2022-07-25T01:57:13.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解动态规划"><a href="#详解动态规划" class="headerlink" title="详解动态规划"></a>详解动态规划</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>动态规划是一种自下而上的思想，每一个问题，把它们转化成相同原理的更小的子问题，解题关键主要有两点：</p><ul><li>找到状态转移方程</li><li>初始值的设置，这里可以开辟一个大一些的数组，防止段错误</li></ul><p><strong>另外还有一个重点是，一定要细心，通常解题中会有dp数组和原始的数据数组，什么时候用什么下标一定要仔细考虑，比如dp数组大小设置成了n+1,那么i=1时，原始数据数组应该用nums[0],虽然很弱智，但不注意搞错了debug就会很难受</strong></p><hr><h2 id="基本DP：一维"><a href="#基本DP：一维" class="headerlink" title="基本DP：一维"></a>基本DP：一维</h2><p>典型的就是青蛙跳这种，比较简单，状态转移方程类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><p>另一种比较特殊的，我们不能用dp[i]来存储最终结果，我们要用dp[i]来存储<strong>以当前i节点结尾的满足题意的状态</strong>，然后对整个dp数组求和。</p><p>比如：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706152248411.png" alt="image-20220706152248411"></p><p>这里我们用dp[i]来表示以该位置结尾的等差数列个数，因为等差数列随时可能会断掉，断掉的位置i的dp[i]就设置为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>] - nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="基本DP：二维"><a href="#基本DP：二维" class="headerlink" title="基本DP：二维"></a>基本DP：二维</h2><p>这里比较代表性的就是给一个二维矩阵，机器人从左上到右下经过的最短路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br></pre></td></tr></table></figure><p>特殊一些的比如lc-221题，算最大全是1的正方形面积，这种题就需要找到题目的一些规律性，寻找状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="分割类问题"><a href="#分割类问题" class="headerlink" title="分割类问题"></a>分割类问题</h2><p>代表例子lc-279，lc-139，核心思路就是在dp遍历里边套一层枚举，就是说dp的每一个元素有很多种可能，我们要枚举出来，然后根据题意选最大或最小之类的</p><p>lc-139<br>给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字 符串都可以在集合内找到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> string &amp; word: wordDict) &#123;</span><br><span class="line"><span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span> (i &gt;= len &amp;&amp; s.<span class="built_in">substr</span>(i - len, len) == word) &#123;</span><br><span class="line">dp[i] = dp[i] || dp[i - len];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对每一个dp[i]，从后往前减去一段，把它变成一个子问题再处理，类似用硬币组成数字问题。</p><hr><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>还是一样的思路，dp[i]表示以i结尾的数组的最长递增子序列，里边枚举一下i之前的所有dp，如果nums[i] &gt; nums[j]就是长度+1，如果&lt;=则dp[i] = 0;</p><p><strong>要注意的是此题有很多种其他的问法<br>比如给一个数组，让你去掉k个数，使之变成单调递增的数组，其实就是求最长递增子序列，再用总数n-最长递增子序列=k</strong><br><strong>还有变成单调递减，先递增再递减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> max_length = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题for循环内还可以改成二分法加快速度</p><p>就是在已经有的递增数组里边找dp[i]的位置，再替换即可</p><hr><h2 id="公共元素问题"><a href="#公共元素问题" class="headerlink" title="公共元素问题"></a>公共元素问题</h2><h3 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h3><p>这种题目思路就是我们要开一个二维数组，dp【i】【j】，代表以i，j结尾的两个a，b的子字符串从后往前有几个公共的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;abcbced&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;acbcbce&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706150443331.png" alt="image-20220706150443331"></p><p>然后相同的地方设置为1，不同的地方设置为0，然后我们最后就是找最长的连续的对角线的长度就是最长的公共子串了</p><p>很容易得到状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然题目可能是让你返回最长的长度，或者最长字符串，因题返回就好。</p><p><strong>注意这里的最长子串需要遍历dp才能得到，而不是直接返回最后的元素</strong></p><hr><h3 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h3><p>子序列和子字符串不同的地方在于它不那么严格，就是不连续的也可以，所以它的转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706183545329.png" alt="image-20220706183545329"></p><p>如图所示，得到状态转移方程：<br>i是有多少种物品，j是背包的容积<br>核心思想就是对一个dp元素，我们有两种选择，一种是选当前的i物品，一种是不选。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&gt;=V[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">     dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-V[i<span class="number">-1</span>]]+ W[i<span class="number">-1</span>]);</span><br><span class="line"> &#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>全部代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706183951928.png" alt="image-20220706183951928"></p><p>我们可以发现状态转移方程只和上一行有关，那么很自然的想到可以将二维dp矩阵优化成一位来进行处理。</p><p><strong>这里的问题是，如果我们还是从前往后处理的话，那么后边元素所依赖的“上一行”的结果就会被覆盖掉，所以要从后往前遍历</strong>，而且对于不选的情况，直接使用上一行的结果就行了，不用特殊处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line"><span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w; --j) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>可以在01背包的基础上考虑，01是每一行物品只有一个，要么拿，要么不拿，完全背包呢，是一个东西可以无限拿，那么自然的想到，在每个dp里加一个循环，枚举出拿几个当前物品，一直到拿爆为止。</p><p>首先写一个二维dp基础版本的：</p><p>这里要注意的是k取0的时候其实就把“不取”这个情况给做了。</p><p>需要注意的是这种没优化过的超级暴力代码，有三层循环，1000*1000的用例是没法过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;v+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*V[i]&lt;=j;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-k*V[i]]+k*W[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[n][v]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来优化成用一维数组，同样要倒序进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*V[i]&lt;=j;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*V[i]]+k*W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码只是空间上优化了一丢丢，本质上还是O（n3）的，要想办法在时间复杂度上进行优化。</p><p><strong>想一下，我们不从后往前进行，直接从前往后进行处理，这样后一个dp[j]状态转移获取dp[j-x]的时候，其实dp[i-x]已经“拿了一些该物品的状态“，也就是说dp[j-x]在它的那个位置已经达到了一个最优解，那么到dp[j]的位置的时候我们实际上只要考虑再拿一次物品i，或者不拿物品i</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;v+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=V[i]) <span class="comment">//这里一定要注意要判断当前的空间j能不能装下物品V[i]</span></span><br><span class="line">                &#123;           </span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-V[i]]+W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<strong>完全背包</strong>和<strong>01背包</strong>在优化到最后的形态其实只有<strong>正序处理</strong>和<strong>反序处理</strong>之分，这里我们清楚知道它的原理就行，笔试直接写优化后的简单形式，简单粗暴！</p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>多重背包实际上就是完全背包的拓展，或者说完全背包是多重背包的一种特殊情况，区别于完全背包，多重背包显示的告诉了我们一个物品最多拿几次，那么我们只需要枚举每种可能就好啦~</p><p>当然也是要逆向处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w,t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w&gt;&gt;t;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">            num[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=num[i];++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k*V[i]&lt;=j)<span class="comment">//需要我们判断不要拿爆了！</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*V[i]]+k*W[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包的优化"><a href="#多重背包的优化" class="headerlink" title="多重背包的优化"></a>多重背包的优化</h3><ul><li>一种是用二进制优化，核心思路是把多重背包拆成很多个01背包</li><li>单调队列优化</li></ul><p>这里先不写了，毕竟是面向找工作学算法：），已经过了打ACM的年纪了55555</p><p>关于背包还有一些变种问题：</p><p>混合背包，二维费用背包，分组背包，有依赖的背包，背包求方案数等等，都先不考虑了，留个指针之后看：</p><p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html">https://www.cnblogs.com/jbelial/articles/2116074.html</a></p><p><a href="https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317">https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317</a></p><p><a href="https://www.acwing.com/problem/">https://www.acwing.com/problem/</a></p><hr><h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><p>Lc-72：</p><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可 以将两个字符串变成相同</p><p>想法就是用dp每一位代表的是当前word1串截止到i的长度和word2串截止到j的长度，它们转换的最小次数。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706222023638.png" alt="image-20220706222023638"></p><hr><h2 id="打字问题"><a href="#打字问题" class="headerlink" title="打字问题"></a>打字问题</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220707173533200.png" alt="image-20220707173533200"></p><p>这个题想法就是对于该字符串的任意长度，该位置都有两种情况（大写字母或者小写字母），在打这个字母之前的状态可能是caps的大写或小写，同时打完这个字母之后caps的状态也可以是大写或小写,需要分类讨论</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220707173853805.png" alt="image-20220707173853805"></p><h2 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h2><p>这个先放着，之后单独算一个专题来写吧</p><hr><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>LC 337</p><p>思路就是变量二叉树，把每个节点选与不选的两个状态存起来（用哈希表），</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;TreeNode*, <span class="type">int</span>&gt; f, g;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left);<span class="comment">//因为状态是从下往上转移的，所以必须后序遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">//选这个点，则不能选它的孩子，那么就选g状态的左右孩子，注意不是只能选一条路径</span></span><br><span class="line">        f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">        <span class="comment">//不选这个点，则可以选也可以不选它的孩子，取最大值</span></span><br><span class="line">        g[node] = <span class="built_in">max</span>(f[node-&gt;left], g[node-&gt;left]) + <span class="built_in">max</span>(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[root], g[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详解动态规划&quot;&gt;&lt;a href=&quot;#详解动态规划&quot; class=&quot;headerlink&quot; title=&quot;详解动态规划&quot;&gt;&lt;/a&gt;详解动态规划&lt;/h1&gt;&lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第七课-渲染管线-后处理-其他渲染知识</title>
    <link href="http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/"/>
    <id>http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/</id>
    <published>2022-06-19T09:25:10.000Z</published>
    <updated>2022-06-29T16:26:46.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七课-渲染管线-后处理–其他渲染知识"><a href="#第七课-渲染管线-后处理–其他渲染知识" class="headerlink" title="第七课 渲染管线-后处理–其他渲染知识"></a>第七课 渲染管线-后处理–其他渲染知识</h2><h3 id="环境光遮蔽-AO"><a href="#环境光遮蔽-AO" class="headerlink" title="环境光遮蔽 AO"></a>环境光遮蔽 AO</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181526.png"></p><p>预计算出AO贴图</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181837.png"></p><p>SSAO</p><p>在屏幕上存储深度信息，设置一些采样点，根据采样点和z-buffer的深度比较来计算最终的光强</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181923.png"></p><p>SSAO+</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182321.png"></p><p>HBAO</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182427.png"></p><p>GTAO</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182556.png"></p><h3 id="雾效-Fog"><a href="#雾效-Fog" class="headerlink" title="雾效 Fog"></a>雾效 Fog</h3><p>简单的fog，根据深度Z从近到远透明度逐渐减小</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182921.png"></p><p>考虑到高度信息时，简单的fog公式就不起作用了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183105.png"></p><hr><h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>采样率不够就会导致走样</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183444.png"></p><h4 id="SSAA和MSAA"><a href="#SSAA和MSAA" class="headerlink" title="SSAA和MSAA"></a>SSAA和MSAA</h4><p>SSAA就是最简单朴素的横竖都扩大一倍采样率，带来的性能代价是很高的。MSAA相比SSAA有一个改动就是在最后pixel shading的时候把一些不必要的shading’去掉了，减少最后shading的次数。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183748.png"></p><h4 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a>FXAA</h4><p>因为锯齿大多发生在边缘轮廓，所以从轮廓着手找到轮廓线再用一个滤波器去插值，已达到抗锯齿的效果。</p><p>注意这里阈值是0.05，这个卷积核和sobel卷积核不一样，不是常规意义上的提取轮廓。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531184456.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531185020.png"></p><p> 混合附近像素的颜色，算插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200105.png"></p><h4 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h4><p>时序反走样</p><p>同时可做鬼影，拖尾等效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200246.png"></p><hr><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><p>Bloom，Tone mapping（曝光），ColornGrading（调色）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200631.png"></p><h4 id="Bloom"><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h4><p>首先把图片亮度高的地方提取出来（注意是RGB，不是灰度）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200945.png"></p><p>加一个模糊效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201109.png"></p><p>这里针对光晕大但是不能使高斯核太大的情况，采用downsample几次再upsample的hack，大概和dualkawase模糊差不多？</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201307.png"></p><p>最后叠加在原图上</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201741.png"></p><h4 id="Tone-Mapping"><a href="#Tone-Mapping" class="headerlink" title="Tone Mapping"></a>Tone Mapping</h4><p>因为真实世界的光照强度range很宽，假设是0-50，那么要把0-50的range映射到0-1这就是Tone Mapping</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201910.png"></p><p>一个映射曲线的shader</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202043.png"></p><p>电影工业界的颜色曝光曲线</p><p>这个东西其实都是人为根据经验来拟合出来的曲线</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202436.png"></p><h4 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h4><p>LUT映射</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202543.png"></p><p>一般lut不用存256*256那么大，因为颜色是连续的，可以只存32 * 32的采样，然后插值即可</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202617.png"></p><h3 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531203320.png"></p><h4 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h4><p>前向渲染两个问题</p><ul><li>处理透明物体的渲染顺序会出问题。一般是由远及近来渲染。</li><li>处理多光源很吃性能。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531203556.png"></p><h4 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h4><p>就是分两个pass，第一个pass渲染一遍所有的物体但是不考虑光照，把物体材质信息存储到G-buffer里</p><p>第二个pass在像素级别上处理光照就好</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531204017.png"></p><p>怎样减少读写G-buffer消耗的资源？</p><p>可以把屏幕分成一个个小块（Tiles），这样每个像素只要读对应的小块纹理而不用整张g-buffer都读进去。这样还有另一个好处是光源也不用每次都遍历所有的了，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531204627.png"></p><p>更进一步，可以做Early-Z，就是说在世界空间下，我们就能知道每个光源所能照到的深度信息，从而在渲染光的时候进行剪枝。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531205034.png"></p><h4 id="Visibility-Buffer"><a href="#Visibility-Buffer" class="headerlink" title="Visibility Buffer"></a>Visibility Buffer</h4><p>现代渲染中，很多时候模型的面片比像素还多，这时候可以存VisibilityBuffer存几何信息反向查找材质信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531205652.png"></p><h4 id="Frame-Graph"><a href="#Frame-Graph" class="headerlink" title="Frame Graph"></a>Frame Graph</h4><p>现代游戏pipline过于复杂，要借助Frame Graph工具将每个步骤算法所用的内存之类的管理起来，方便开发，定位bug</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531210350.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第七课-渲染管线-后处理–其他渲染知识&quot;&gt;&lt;a href=&quot;#第七课-渲染管线-后处理–其他渲染知识&quot; class=&quot;headerlink&quot; title=&quot;第七课 渲染管线-后处理–其他渲染知识&quot;&gt;&lt;/a&gt;第七课 渲染管线-后处理–其他渲染知识&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第六课-渲染系统-地形大气和云的渲染</title>
    <link href="http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/"/>
    <id>http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/</id>
    <published>2022-06-16T09:25:10.000Z</published>
    <updated>2022-06-29T16:26:59.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六课-地形大气和云的渲染"><a href="#第六课-地形大气和云的渲染" class="headerlink" title="第六课 地形大气和云的渲染"></a>第六课 地形大气和云的渲染</h2><h3 id="地形的几何"><a href="#地形的几何" class="headerlink" title="地形的几何"></a>地形的几何</h3><h4 id="Heightfield"><a href="#Heightfield" class="headerlink" title="Heightfield"></a>Heightfield</h4><p>数学上的分形方法</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529152911.png"></p><p>每隔1m画一个10000*1000的网格，然后根据高度场，轮廓场等进行映射就可以</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153037.png"></p><p><strong>LOD技术</strong></p><p>就是根据距离远近应用不同分辨率的网格，这里要根据FOV视角的范围进行各向异性的加密或简化网格。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153427.png"></p><p>细分方法</p><p>注意T-Junctions的问题</p><ul><li><p>三角形剖分<img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153733.png"></p></li><li><p>四叉树细分</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153833.png"></p><p>解决T-Junction问题，就把剖分次数多的一边中间的节点平滑到另一边的角点上是两个点重合，这样实际上就产生了一个面积为0的三角形，也就是网格的退化，一般面积为0的三角形在渲染时直接不渲染。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529154514.png"></p></li></ul><h4 id="TIN方法"><a href="#TIN方法" class="headerlink" title="TIN方法"></a>TIN方法</h4><p>Triangulated Irregular Network</p><p>就是直接用不规则的三角形来表达地形，简化不必要的顶点，并加上需要的特征</p><p>好处是可以减少很多三角形，比之前的方法少了一个数量级</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529154829.png"></p><p>显卡架构，有细分着色器，domainshader等等，可以直接再gpu里边生成细分网格甚至能完成映射扰动的实现。</p><p>最新的显卡架构把以上这些着色器整合成了MeshShader更加方便，有了gpu的加持，甚至可以实现runtime的事实地形交互，比如炮弹打到地上使得网格发生形变出现个坑。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529155134.png"></p><h4 id="制作山洞的一个hack方法"><a href="#制作山洞的一个hack方法" class="headerlink" title="制作山洞的一个hack方法"></a>制作山洞的一个hack方法</h4><p>直接把山体网格要打洞的顶点那里给一个属性把他的position设置成NAN，这样再显卡中就会把所有包含这个顶点的三角形都忽略掉不渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160422.png"></p><h4 id="体素化表达"><a href="#体素化表达" class="headerlink" title="体素化表达"></a>体素化表达</h4><p>虽然目前游戏引擎还没有大规模应用，但是其实可以考虑直接用体素来表达地形模型，而不是二维流形网格，这样实际上就直接有了三维的信息，也就是说地形山体等都不是空心的了，可以跟直接的操作打洞等等。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160719.png"></p><hr><h3 id="地形的材质"><a href="#地形的材质" class="headerlink" title="地形的材质"></a>地形的材质</h3><p>就用之前的MR材质，存一些东西</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160847.png"></p><p>Height贴图的作用，就是这种地形需要沙子和石头之间渐变的时候，根据高度信息进行混合。</p><p>当然这种渐变过程中因为数值精度可能会有一些抖动，这时可以设置一些扰动保证稳定性。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161010.png"></p><p>通过不同的权重和不同的材质来混合得到想要的效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161300.png"></p><h4 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h4><p>parallax mapping就是扰动法线贴图使视觉上具有更强的凹凸感，而displacement mapping则是更彻底的用高度信息直接更改地形网格面片</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161441.png"></p><p><strong>问题：性能代价</strong></p><p>因为纹理采样实际上是一个很费的操作，如果每一个像素都混合4张纹理，那么就需要重复采样很多次，性能爆炸</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161924.png"></p><p><strong>解决办法：虚拟纹理</strong></p><p>这里就是和虚拟内存一样的概念，就是把纹理分块，实际用到哪块就读哪块进入内存而不是整个纹理都读进来，因为我们在游戏中视锥呈现的范围实际上只有纹理中的一小块。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162015.png"></p><h4 id="新的技术"><a href="#新的技术" class="headerlink" title="新的技术"></a>新的技术</h4><p>传统的读纹理都是cpu读进内存，然后解压，然后传给gpu。 </p><p>而DirectStorage技术就是cpu读进内存不解压直接传到gpu在gpu中完成解压，提高性能</p><p>而更牛逼的DMA技术就是直接从硬盘读到gpu显存里去了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162715.png"></p><h4 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h4><p>网格数量越大，越精细就会引起精度不够用的问题，因为float使用32个bit组成的，这样就会出现摩尔纹和锯齿问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162824.png"></p><p>解决方法：</p><p>粗暴的方法就是扩展精度，比如用double来存</p><p>还可以用下图中把相机重置到gameobject坐标中，搞成相对距离解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163105.png"></p><h4 id="植被道路贴花"><a href="#植被道路贴花" class="headerlink" title="植被道路贴花"></a>植被道路贴花</h4><p>树专门的LOD方法，近处用网格，远处就插片，越远越稀疏</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163422.png"></p><p>Decorator Rendering</p><p>渲染小石头，草，灌木丛等等，一般用小面片，也有很专门的技术</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163512.png"></p><p>道路系统渲染</p><p>用样条曲线编辑道路</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163641.png"></p><hr><h3 id="大气散射理论"><a href="#大气散射理论" class="headerlink" title="大气散射理论"></a>大气散射理论</h3><h4 id="简单的模型"><a href="#简单的模型" class="headerlink" title="简单的模型"></a>简单的模型</h4><p>根据物理规律拟合一个模型，需要两个参数一个是向上看的角度到天顶的夹角（一般是0-Π），另一个是现在看到高度和太阳的夹角。根据这两个夹角去查表LUT</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529190658.png"></p><h4 id="粒子媒介"><a href="#粒子媒介" class="headerlink" title="粒子媒介"></a>粒子媒介</h4><p>使用更加精细的模型渲染天空，大气由很多粒子，气溶胶组成</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529191019.png"></p><p>光在大气中的规律用四个参数描述：</p><p>从左到右依次为：吸收多少光，像四面八法散射多少，自发光强度，其他粒子对该粒子入射的光</p><p>实际上就是4中不同的梯度</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529191159.png"></p><p>VRE：对上边梯度进行积分</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529191739233.png" alt="image-20220529191739233"></p><p>Transmittance：通透度，意思就是在远处看到一个东西，它有多少能透视到当前点。</p><p>Scattering part：光路打到路径上的气体分子发生一些散射，这些散射路径返回了多少能量。</p><h4 id="大气物理学"><a href="#大气物理学" class="headerlink" title="大气物理学"></a>大气物理学</h4><p>真是的大气物理，主要的元素是太阳，向外辐射不同波长的光，然后大气中有气体分子（它们的大小一般小于阳光波长），还有气溶胶分子（它们的大小一般和阳光波长差不多）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529192645.png"></p><p>两种</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529192851.png"></p><p>//TODO  mark以下，下次再看这一块</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六课-地形大气和云的渲染&quot;&gt;&lt;a href=&quot;#第六课-地形大气和云的渲染&quot; class=&quot;headerlink&quot; title=&quot;第六课 地形大气和云的渲染&quot;&gt;&lt;/a&gt;第六课 地形大气和云的渲染&lt;/h2&gt;&lt;h3 id=&quot;地形的几何&quot;&gt;&lt;a href=&quot;#地形的几</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第五课-渲染系统-光照与材质</title>
    <link href="http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/"/>
    <id>http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/</id>
    <published>2022-06-10T09:25:10.000Z</published>
    <updated>2022-06-29T16:11:21.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五课-渲染系统–光照和材质"><a href="#第五课-渲染系统–光照和材质" class="headerlink" title="第五课 渲染系统–光照和材质"></a>第五课 渲染系统–光照和材质</h2><h3 id="渲染方程与挑战"><a href="#渲染方程与挑战" class="headerlink" title="渲染方程与挑战"></a>渲染方程与挑战</h3><h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>渲染方程就是一个解积分的过程，一个点最终的光照=它本身的发光强度+所有其他方向的入射光在对应角度的投影</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529091653.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529091714.png"></p><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><ul><li><p>阴影效果</p><p>一个点是否能看得见，是否被遮挡时很难判断处理的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092310.png"></p></li><li><p>光源本身很复杂</p><p>比如面光源</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529092529789.png" alt="image-20220529092529789"></p></li><li><p>积分怎么做</p><p>渲染方程里的积分部分怎么处理，光和材质的卷积如何计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092816.png"></p></li><li><p>光的不断反射形成复杂的光影效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092932.png"></p></li></ul><hr><h3 id="基础光照解决方案"><a href="#基础光照解决方案" class="headerlink" title="基础光照解决方案"></a>基础光照解决方案</h3><p>使用点光源等简单光源当做主光，其他光源用低频环境光来模拟</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093254.png"></p><p>使用环境光贴图来模拟反射光等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093551.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093716.png"></p><h4 id="布林-冯模型"><a href="#布林-冯模型" class="headerlink" title="布林-冯模型"></a>布林-冯模型</h4><p>环境光+漫反射+镜面反射 </p><p>一个问题是它的能量不守恒，渲染什么东西都像塑料：）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529094311.png"></p><h4 id="shadow处理"><a href="#shadow处理" class="headerlink" title="shadow处理"></a>shadow处理</h4><p>shadow map</p><p>思路就是从像素位置反向追踪到每个光源，看看到下一次反射的距离是否等于到光源的距离，从而判断出这个像素对这个光源来说是否可见</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529094812.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过以上方法将复杂的渲染抽象简化，解决几个挑战，当然效果不是特别理想</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529095257.png"></p><hr><h3 id="基于预计算的全局光照"><a href="#基于预计算的全局光照" class="headerlink" title="基于预计算的全局光照"></a>基于预计算的全局光照</h3><p><strong>预计算：就是空间换时间的一种手段，把一些场景中不动的地方全部预计算存储起来</strong></p><p><strong>全局光照：就是考虑间接光照对场景的影响，也就是说要算光的几次反射，迭代收敛</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529095728.png"></p><p>那么如果迭代计算几次光照，这样产生的计算量是指数增加的，所以要找一个高效的方法来计算</p><h4 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h4><p>把时域信息转到频域信息上去处理，这样可以大幅度压缩信息的数据</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529100142.png"></p><h4 id="球面调和函数"><a href="#球面调和函数" class="headerlink" title="球面调和函数"></a>球面调和函数</h4><p>是一组sin cos的函数集组成的基函数</p><p>这块和下边的部分没听懂，大概目的是为了把数据降维参数化到低维进行处理简化计算，具体的方法用到时再查吧</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529100252.png"></p><h4 id="Lightmap"><a href="#Lightmap" class="headerlink" title="Lightmap"></a>Lightmap</h4><p>预计算光照贴图，把整个场景的光照烘焙到一张纹理上</p><p>这里也有参数化（展UV）的问题</p><p>本质上就是离线baking然后存储下来，在runtime时直接拿纹理用 </p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529101123.png"></p><h4 id="Light-Probes-和-Reflection-Probes"><a href="#Light-Probes-和-Reflection-Probes" class="headerlink" title="Light Probes 和 Reflection Probes"></a>Light Probes 和 Reflection Probes</h4><p>对动态的物体采样光，没看懂存个指针==</p><hr><h3 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h3><h4 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h4><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529102141.png"></p><p>光打在表面后只有两种情况，一种时反射出去（镜面反射），一种是射到物体里面在里边弹弹弹然后随机方向射出去（漫反射）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529102211.png"></p><p>针对镜面反射来讲，有DFG理论，每一个字母代表一种光学现象</p><p>D == Normal Distribution Fuction</p><p>描述发现的发散程度，引入roughness粗糙度的参数</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529125633.png"></p><p>G == Geometric attenuation term（self-shadowing）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130248.png"></p><p>F == Fresnel Equation 菲涅尔项</p><p>描述不同材质的反射程度，大牛推出的5次方</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130528.png"></p><h4 id="迪士尼准则"><a href="#迪士尼准则" class="headerlink" title="迪士尼准则"></a>迪士尼准则</h4><ul><li>参数要由艺术家的直觉决定</li><li>参数越少越好</li><li>所有参数最好都是0-1</li><li>只有当参数超出门限是有实际意义的时候才可以超出0-1</li><li>所有的参数组合后需要足够鲁棒，不能有奇奇怪怪的结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130817.png"></p><h4 id="主流PBR模型"><a href="#主流PBR模型" class="headerlink" title="主流PBR模型"></a>主流PBR模型</h4><h5 id="Specular-Glossiness模型"><a href="#Specular-Glossiness模型" class="headerlink" title="Specular Glossiness模型"></a>Specular Glossiness模型</h5><p>这个模型一切参数存在图里</p><ul><li>Diffuse 存在diffuse图里</li><li>菲涅尔项存在Specular图里</li><li>roughness项存在Glossiness图里</li></ul><p>然后就可以通过+-*/运算写shader进行渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529131312.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529131445.png"></p><h5 id="Metallic-Roughness模型"><a href="#Metallic-Roughness模型" class="headerlink" title="Metallic Roughness模型"></a>Metallic Roughness模型</h5><p>相当于在SG模型上包了一层，在外边加了一些判断防止使用错误，比如说有一个参数判断模型是金属还是非金属，如果是金属就把颜色传递，非金属就不传递颜色</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529132208.png"></p><hr><h3 id="基于图像的光照"><a href="#基于图像的光照" class="headerlink" title="基于图像的光照"></a>基于图像的光照</h3><p>IBL的基本思想就是通过预计算的方式提前将环境光照算出来然后直接和环境中的材质进行卷积算出结果，本质上也是空间换时间的。</p><p><strong>这个和全局光照的区别我理解就是全局光照只预计算到光照那一步，而IBL继续预计算到光照和材质卷积完的结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529132522.png"></p><p>这里也是分diffuse和specular两种情况，本质上就是预计算再LUT的情况，至于怎么搞的，用时再看把：（</p><hr><h3 id="经典阴影方法"><a href="#经典阴影方法" class="headerlink" title="经典阴影方法"></a>经典阴影方法</h3><p>cascade shadow</p><p>主要思想就是根据远近进行shadow map分级管理，就类似mipmap</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529145741.png"></p><h5 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h5><p>PCF   PCSS方法</p><p>具体去看Games 202</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>3A游戏的渲染</p><ul><li>Lightmap + Lightprobe</li><li>PBR + IBL</li><li>CascadeShadow + VSSM</li></ul><h3 id="前沿技术"><a href="#前沿技术" class="headerlink" title="前沿技术"></a>前沿技术</h3><p>实时光追</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529150407.png"></p><h3 id="Shader管理"><a href="#Shader管理" class="headerlink" title="Shader管理"></a>Shader管理</h3><p>因为GPU是并发的，对于判断语句会执行等待然后一起结束，所以shader中最好没有判断，那么在游戏中就会有上万数量级的shader资产，而在软件工程中这些零散的东西显然是不好维护的，这是就可以开发一个UberShader工具，其实就可以理解为一类shader有一个父类，当我要修改时，会重新生成子类shader</p><p>同时面对不同图形API要做好处理</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529151139636.png" alt="image-20220529151139636"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第五课-渲染系统–光照和材质&quot;&gt;&lt;a href=&quot;#第五课-渲染系统–光照和材质&quot; class=&quot;headerlink&quot; title=&quot;第五课 渲染系统–光照和材质&quot;&gt;&lt;/a&gt;第五课 渲染系统–光照和材质&lt;/h2&gt;&lt;h3 id=&quot;渲染方程与挑战&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第四课-渲染数据组织</title>
    <link href="http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/"/>
    <id>http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/</id>
    <published>2022-06-07T09:25:10.000Z</published>
    <updated>2022-06-29T16:09:25.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四课-渲染数据组织"><a href="#第四课-渲染数据组织" class="headerlink" title="第四课 渲染数据组织"></a>第四课 渲染数据组织</h2><h3 id="游戏中的渲染"><a href="#游戏中的渲染" class="headerlink" title="游戏中的渲染"></a>游戏中的渲染</h3><p>面临的挑战：</p><ul><li>大量的GO渲染，所用到的渲染算法不一样，比如水体，人物，毛发</li><li>适配硬件，不同的CPU和GPU</li><li>帧率要稳定，比如塞尔达的呀哈哈森林疯狂掉帧体验感很差，所以渲染一帧必须在一个固定的非常短的时间里</li><li>渲染所分配的资源不能占全部cpu和内存，还要分给gameplay，logic</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528202409.png"></p><hr><h3 id="渲染系统的对象"><a href="#渲染系统的对象" class="headerlink" title="渲染系统的对象"></a>渲染系统的对象</h3><p>光栅化管线</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528202600.png"></p><p>将一系列的顶点进行MVP变换，并且裁剪，然后光栅化，最后进行着色。</p><p>纹理对象的渲染，涉及到采样频率小引发的摩尔纹，锯齿等现象，所以引出了抗锯齿技术等</p><hr><h3 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h3><p>SIMD：单指令多数据，一条指令可以发给很多单元同时处理数据，就是显卡里的SM</p><p>SIMT：单指令多线程，一条指令分给好多个线程并发执行</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528203240.png"></p><p>SM就是最基础的单元用于并行计算</p><p>Texture Units是处理纹理的单元</p><p>SMU：sin cos 向量运算等比较高阶的运算单元</p><p>Warp：warp是逻辑上的单位不是物理上的，一个warp可能包含32个线程，每个线程交给一个SM去执行，但是显卡中一组SM可能只有8个，那么就是说一个warp要控制这8个SM执行4次</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528203431.png"></p><p>CPU-&gt;GPU 数据的交互</p><p>cpu发送数据到gpu的显存上，这一步比较耗费时间，同时一般情况下最好只是单向的数据传递，也就是说尽量不要gpu处理完数据传回cpu</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204315.png"></p><p>高速缓存cache</p><p>cathe是很快的，比普通内存速度高出一个数量级，所以我们处理数据最后一次把要用到的所有数据同时放进cathe而不用再去内存中去取，这样可以提高速度</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204257.png"></p><hr><h3 id="可渲染物体"><a href="#可渲染物体" class="headerlink" title="可渲染物体"></a>可渲染物体</h3><p>GO上基础的可渲染的对象，比如人身体的网格，材质等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204819.png"></p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>mesh类的构造，这里有不同的数据结构，比如半边数据结构等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204948.png"></p><p>为了节省cpu传到gpu显存上的数据量，一位一个三角形有三个点，相邻三角形会共用顶点，所以可以只存一次，然后再存一个索引值，这样来节省内存</p><p>要存的内容可能有：顶点位置，法向，颜色等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528205145.png"></p><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p>视觉上的材质</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528205810.png"></p><p>phone Model，PBR Model</p><p>纹理，shaderCode</p><p>shader虽然是代码，但是也算是render需要数据的一种，是一些已经编译好的二进制文件，可以应用在不同的渲染对象上</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220528210138989.png" alt="image-20220528210138989"></p><hr><h4 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h4><p>把vertexBuffer,indexBuffer，纹理，shader传递给显卡，显卡就会渲染对应物体</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528210338.png"></p><p>由于将一个3维中的2维流形映射回2维参数化的过程（展uv）会有扭曲的情况发生，也就是说模型不同位置对应到二维的纹理上可能会重叠也可能一部分曲率大顶点多的地方映射的面积会很小，这样会导致精度不够的问题，所以目前业界一般会把一个模型分割成几个小部分，比如头，四肢这样。<strong>当然分成submesh还有另一个重要原因是因为一个模型通常有很多不同的材质，比如人的皮肤和衣服</strong></p><p>但是从cpu像gpu传递数据时还是一整个模型一起传递，只不过我们可以标记index，比如1-100是头，101-200是胳膊这种。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528210837.png"></p><p>在游戏中，会有很多一样的GO，比如小兵，这样每一个小兵GO的网格，纹理材质信息都是一样的，为了避免内存浪费，我们可能建立一个Pool，一个东西只存一遍，公用就行了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211100.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211132.png"></p><p>因为渲染流程实际上是一个状态机的模式，参考opengl，也就是说显卡一次处理一个东西，比如先渲染物体A它使用的是材质1，然后渲染物体B使用的是材质2，然后渲染物体C使用的也是材质1，这就会导致切换了两次材质造成性能下降，所以我们可以用材质来排序，一次性把材质1的GO（submesh）都渲染完，在切换材质2去渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211556.png"></p><p>针对完全重复的同一个对象，比如一堆树，可以在GPU中加一个offerset，一次drawcall全部渲染完毕，节省了重新传递vbo，ibo，drawcall的时间</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211731.png"></p><h4 id="可见性裁剪culling"><a href="#可见性裁剪culling" class="headerlink" title="可见性裁剪culling"></a>可见性裁剪culling</h4><p>在游戏过程中，要使用事件锥来裁剪可见的对象</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211949.png"></p><p>这里就要用包围盒来判断一个GO是否在事件锥的范围内</p><p>包围盒的种类：球，AABB，OBB，凸包等等</p><p>然后还要结合8叉树，BVH等空间划分算法来计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212124.png"></p><p>BVH的优点是对运动的物体culling很快</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212347.png"></p><p>PVS算法：主要思路就是根据所在位置看，能看到那些块就渲染哪些块</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212440.png"></p><p>利用光线追踪来判断哪些是可见的</p><p>PVS算法比Octree等算法快很多，并且一个更大的优点是<strong>可以判断哪些资源需要加载</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212632.png"></p><p>目前的算力已经很高了，显卡可以直接计算出哪些物体能看见，哪些被挡住了</p><p>Early Z：这个就是根据深度信息，可以提前判断好多物体不可见不用渲染，舍弃掉把它们光栅化的过程，节省性能</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212916.png"></p><h4 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h4><p>图片的存储格式不能够随机访问，所以游戏引擎必须对都进来的图片进行转化，记得opengl里好像有一个函数叫gl_readpixel,这个就是用来读图的，而且有按照1字节读和4字节读的接口（RGBA通道）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528213249.png"></p><p>压缩纹理的方法</p><p>先找一个4*4块的最亮和最暗的值，其他值都可以插值出来</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528213624.png"></p><h4 id="建模工具"><a href="#建模工具" class="headerlink" title="建模工具"></a>建模工具</h4><p>blender，3dsMax，Houdini</p><p>一些建模方法：</p><ul><li>样条模型，贝塞尔曲线</li><li>点云扫描</li><li>雕刻建模</li><li>AI辅助建模</li></ul><h4 id="新的模型管线"><a href="#新的模型管线" class="headerlink" title="新的模型管线"></a>新的模型管线</h4><p>时代发展，算力膨胀，有了GPU驱动的渲染</p><p>因为有了几何着色器，细分着色器，可以凭空生成很多的三角形，可以根据相机的远近来生成不同分辨率的模型（类似QEM）</p><p>所以可以把gpu每个sm处理的粒度变得更小，像下图中的龙一样，一个patch只有32个小三角形这种</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528214122.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li> 游戏引擎和硬件架构和算力息息相关</li><li>针对多材质的模型使用submesh分割</li><li>在绘制中尽可能的使要渲染的东西少，culling裁剪看不见的东西</li><li>Gpu越来越牛逼，未来可能直接靠算力就可以搞定很多东西</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四课-渲染数据组织&quot;&gt;&lt;a href=&quot;#第四课-渲染数据组织&quot; class=&quot;headerlink&quot; title=&quot;第四课 渲染数据组织&quot;&gt;&lt;/a&gt;第四课 渲染数据组织&lt;/h2&gt;&lt;h3 id=&quot;游戏中的渲染&quot;&gt;&lt;a href=&quot;#游戏中的渲染&quot; class=&quot;</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第1-3课-引擎架构分层&amp;数据组织管理</title>
    <link href="http://icecorn.github.io/2022/06/05/Games-104/Games104--%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AF%BC%E8%AE%BA%E4%B8%8E%E6%9E%B6%E6%9E%84(1-3)/"/>
    <id>http://icecorn.github.io/2022/06/05/Games-104/Games104--%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AF%BC%E8%AE%BA%E4%B8%8E%E6%9E%B6%E6%9E%84(1-3)/</id>
    <published>2022-06-05T09:25:10.000Z</published>
    <updated>2022-06-29T16:08:22.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一课：-现代游戏引擎导论"><a href="#第一课：-现代游戏引擎导论" class="headerlink" title="第一课： 现代游戏引擎导论"></a>第一课： 现代游戏引擎导论</h2><h3 id="游戏引擎架构与层级"><a href="#游戏引擎架构与层级" class="headerlink" title="游戏引擎架构与层级"></a>游戏引擎架构与层级</h3><ul><li><p><strong>基础元素构建</strong></p><p>了解游戏引擎的分层，以及为什么采用这样的架构</p></li><li><p><strong>渲染系统</strong></p><p>Model，Material, Shader, Texture</p><p>渲染管线，光影</p><p>学习对渲染对象组合不同算法进行渲染</p></li><li><p><strong>动画系统</strong></p><p>学习从3dsmax等导出的动画，如何把它们组装起来，构建工具</p></li><li><p><strong>物理系统</strong></p><p>学习游戏中的物理系统（刚体，软体，流体）</p></li><li><p><strong>GamePlay</strong></p><p>游戏中的核心玩法部分</p></li><li><p><strong>其他系统</strong></p><p>特效系统，寻路系统，相机系统</p></li><li><p><strong>工具链</strong></p><p>C++反射机制，数据库模式</p></li><li><p><strong>网络游戏</strong></p><p>数据同步</p></li><li><p><strong>前沿技术</strong></p><p>动态捕捉，面向数据变成DOP，任务系统Job System</p><p>全局光照Lumen，多面片Nanite</p></li></ul><hr><h2 id="第二课-引擎架构分层，整体Pipeline"><a href="#第二课-引擎架构分层，整体Pipeline" class="headerlink" title="第二课 引擎架构分层，整体Pipeline"></a>第二课 引擎架构分层，整体Pipeline</h2><p><strong>游戏引擎主要分成5个架构分层以及第三方库，自顶向下分别是：工具层，功能层，资源层，核心层，平台层</strong></p><h3 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h3><p>引擎最直观的，可以直接交互的层级，及引擎编辑器UI显示，可以直接利用GUI操作编辑一些游戏内容。</p><p>工具层通常以编辑器的形式存在，可用多种编程语言，开发效率优先，更加强调用户的便捷性。由于很多游戏资源是在Maya、3ds Max、Houdini等DCC（别人工具生成的资产）中完成的，工具层通常包含导入、导出器用于导入、导出游戏资源为统一的assets。</p><p>工具链是数据之间的互导。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528153615.png"></p><h3 id="功能层"><a href="#功能层" class="headerlink" title="功能层"></a>功能层</h3><p>为了使游戏呈现在屏幕上，需要渲染系统对虚拟世界进行渲染。动画系统将艺术家设计的动作动画在引擎中进行组合、过渡，让游戏人物在游戏动起来。逼真的虚拟世界也离不开物理，物理系统将使用刚体、软体、流体等去表达世界，使得人与人、人与物不会发生碰撞。游戏中的玩法以及NPC人物，也都离不开脚本、事件、AI系统等。为了实现游戏中的人机交互，还需要与输入、输出设备连接。（Rending、Camera、 Animation、physics、Script,FSM and AI）</p><p>功能层将使得整个虚拟世界变得栩栩如生：每隔tick时间，分别执行逻辑与绘制–tickLogic与tickRender。tickLogic主要用于模拟世界，包括处理输入输出，计算物理并进行碰撞检测等；tickRender将tickLogic计算的结果（人物位置等）进行绘制。考虑到功能层需要实现大量功能并对运行时间存在要求，功能层复杂性高，并通常需要借助多线程计算。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151730.png"></p><p><strong>在功能层，一定要区分开tickLogic和tickRender，不要耦合在一起</strong></p><p><strong>复杂性</strong>：功能层非常复杂、庞大，提供了游戏引擎中大部分功能模块，但哪些功能属于游戏，哪些功能属于引擎，界限不明确。</p><p><strong>多线程</strong>：现代计算机CPU通常有多个核心，主流引擎将拆分适合并行计算的任务，分配到多个线程运算，但一些计算互相依赖，不适用于并行执行。在未来，引擎将所有任务变为原子计算，将任务分配到每个核上。</p><p><strong>拆分成更小的粒度，最大限度压榨多核CPU</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151945.png"></p><h3 id="资源层"><a href="#资源层" class="headerlink" title="资源层"></a>资源层</h3><p>游戏引擎中通常包含大量数据和文件，这些文件通常以不同的形式存在，例如Photoshop中的专用格式psd文件或者3ds Max中的max文件，上万、上十万的数据文件由<strong>资源层进行加载与管理。</strong></p><p>Photoshop中的psd、3ds Max中的max等数据格式比较复杂， 包含大量与引擎无关的数据，如psd格式将保存Photoshop中所有的图层，包含通道、参考线、注解和颜色模式等信息。为了避免在使用资源时频繁调度并减少不必要的内存消耗，在导入资源时<strong>进行转换</strong>，将不同资源（纹理、模型几何、动画等）都转换为资产文件，即<strong>assest文件</strong>（.ast）。</p><p>比如引擎中最常使用的贴图数据，可使用png、jpg格式进行存储，上述格式对应相应的压缩算法，但这些压缩算法不是GPU高效的算法，直接在GPU中使用会浪费性能，通常在引擎中被转换成dds格式。dds格式针对纹理设计，支持很多其他图像格式不支持的功能，如Mipmap等。对于一个游戏人物，可能需要绑定网格、动画、贴图、材质等资源，定义Composite asset文件（如XML）关联不同资源，并使用Guid唯一识别号对资产进行管理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151127.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151252.png"></p><p>在游戏实际运行时，需要使用**资产管理器*（Asset Manager）*<strong>根据</strong>资产生命周期*（Asset Life Cycle）***对资产进行管理，包括资产实时加载卸载、资源池分配、垃圾回收与延迟加载等。</p><p><strong>资源管理很重要，因为硬件资源显存内存永远是有限的，所以就要把资源合理利用，类似虚拟内存这种，塞尔达每次场景切换都很慢，也许就是垃圾回收部分不太高效？</strong></p><h3 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h3><p>工具层、功能层、资源层会频繁调用底层代码，使用容器创建、内存分配、数学库、多线程等底层功能，而<strong>核心层</strong>能够提供上述功能。</p><p>核心层是游戏引擎的基础，提供各种功能模块所需的工具，包括数学库、数据结构与容器、内存管理等。对于数学库，当前已有很多成熟的第三方库，例如Eigen。但游戏引擎需要<strong>为效率服务</strong>，可使用<strong>近似计算</strong>或者<strong>SIMD（单指令多数据流，可并行处理多个数据的指令）</strong>提高运算效率。对于数据结构与容器，编程语言中的数据结构可能不满足要求，比如C++一些标准实现会产生内存空洞，引擎中实现的数据结构更加方便内存管理，提高访问效率。对于内存管理，引擎内存管理与操作系统类似，内存性能瓶颈主要在内存池（分配器）、缓存缺失、内存对齐等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528152533.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528152618.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528153037.png"></p><h3 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h3><p>引擎或者游戏需要发布在不同平台上，可能需要使用不同的图形API。此外，用户使用的输入设备、硬件设备可能也完全不同，这都需要平台层进行处理。平台层使得游戏能兼容不同平台、不同硬件设备，为上层提供平台无关的服务和信息。对于图形API（如OpenGL、DirectX、Vulkan等），平台层需要使用RHI（Render Hardware Interface）去除不同API的差异，上层使用时无需关心渲染使用的是何种API。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528153308.png"></p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>第三方库或中间件通过SDK的形式或者文件格式转化，各种软件比如PS，3ds Max这些做出资产然后导入游戏引擎变成asset</p><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><p>为了将游戏引擎解耦并降低复杂度，每一层都将独立，底层提供基础服务，顶层无需知道底层的具体实现，也有利于开发与版本迭代。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>游戏引擎分5层架构</li><li>在架构分层中，越往上越灵活，越往下越稳定</li><li>只能上层调用下层，反过来不行</li><li>虚拟世界由一系列tick时间组成</li></ul><hr><h2 id="第三课-数据组织和管理"><a href="#第三课-数据组织和管理" class="headerlink" title="第三课 数据组织和管理"></a>第三课 数据组织和管理</h2><p><strong>Dynamic Game Objects – 可交互动态物体（人物，坦克等）</strong></p><p><strong>Static Game Objects – 不可交互的静态物体（房子）</strong></p><p><strong>Environments – 环境 Sky天空、Vegetation植被、Terrain地形</strong></p><p><strong>Other Game Obhects – TriggerArea触发检测体、AirWall空气墙、NavigationMesh导航网格、Ruler游戏规则</strong></p><p><strong>这些都可以统一抽象为GameObject（GO）</strong></p><h3 id="面向对象与GO"><a href="#面向对象与GO" class="headerlink" title="面向对象与GO"></a>面向对象与GO</h3><p>GO都可以由属性Property和行为Behaviour组成。可以使用继承的方式来不断的扩展一个GO的新属性。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528155449.png"></p><h3 id="组件系统与GO"><a href="#组件系统与GO" class="headerlink" title="组件系统与GO"></a>组件系统与GO</h3><p>但是对于另外的一些GameObject，通过继承方式不理想，比如一个水陆两栖坦克，既有船的能力，也有坦克的能力，那么它应该继承自谁呢？可以利用组合的方式，通过<strong>Component来</strong>自定义的组合他们的能力；使用组件化思想，用组合代替继承。用组件的方式另外一个好处就是灵活，可替换，需要哪个能力就用哪个组件，不需要就卸掉。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528155746.png"></p><p>以无人机为例，此时各种能力和属性都可以抽成一个个的组件，如 TransformComp（位置），ModelComp（外形），MotorComp（运动），AIComp，PhysicsComp 等，此时无人机里只需要有一个 ComponentBase 的数组即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161008.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160951.png"></p><p>**这里注意可能组件也好，面向对象也好，最上层可能都是有一个基类，里面属性和方法都没有，但是也很有必要，因为这类似于句柄，在释放和管理的时候会需要。***注意 Unreal 和 Unity 中的 Object 与上述的 GameObject 并不相同。Unreal 中 AActor 是类似 GameObject 的概念，UObject 更类似于高级语言中的 Object。</p><p>组件模式有什么缺点？</p><p>效率没有直接写一个class高,ECS很重要，就是把同样的组件放一起，后面处理很方便</p><p>组件内部还需要通信，时间代价</p><h3 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h3><p>每隔一段时间让世界向前走一步：让每个 GameObject 中的每一个 Component 去 Tick 一次。在实际中，现代游戏引擎更多的通常不是逐对象逐组件去 Tick ，而是逐系统，比如先去做所有的和碰撞相关的事情，再去做所有和动画相关的事情，这样用类似流水线的方式，更有效率。</p><p>一个 Tick 的时间过长怎么处理？</p><ul><li>Tick 的时候将步长传入，依赖步长进行数据的补偿；</li><li>直接跳过下一个 Tick；二帧很危险</li><li>通常还是需要进行策略优化；分几批处理，化成几帧处理完毕</li></ul><h3 id="Event（GO之间交互）"><a href="#Event（GO之间交互）" class="headerlink" title="Event（GO之间交互）"></a>Event（GO之间交互）</h3><p>对于GameObject 间的交互，如一个炸弹爆炸，对其他不同的 GO 的影响，早期硬编码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160928.png"></p><p>这样的代码明显违反设计模式的原则，由此引出 Event（事件），有点类似观察者模式，通过事件派发的方式进行解耦，接收/绑定了这个事件的对象再去处理该事件。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160910.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160845.png"></p><p>最核心的是可扩展的消息系统，开发者可以在此基础之上定制消息类型和处理消息类型的组件对事件进行处理。</p><p>如何管理GO？发生的事情如何通知到每个GO？</p><h3 id="GO管理"><a href="#GO管理" class="headerlink" title="GO管理"></a>GO管理</h3><p>每个GO都有一个ID唯一标识uid和一个位置（空间位置）</p><p><strong>场景管理</strong></p><ul><li>通过唯一 ID 进行标识管理；</li><li>通过 object 的位置进行管理；</li></ul><p>每个场景中管理GO，如果不管理需要通过遍历场景中半径范围内所有的对象，进行消息的通知。例如一个GO寻找周围GO时就遍历所有的GO。<br>通过画格子优化：将地图分为几块，每块中的物体分别管理。先找邻近的格子，没有就不再找别的格子了。缺点：如果各个格子中GO分布不均，不高效。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161312.png"></p><p>优化方式：四叉树，八叉树，BVH，BSP</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161545.png"></p><h3 id="其他复杂问题"><a href="#其他复杂问题" class="headerlink" title="其他复杂问题"></a>其他复杂问题</h3><p>绑定问题</p><p>比如人和车，人上了车，这两个GO就绑定在一起了，这样一般先tick车，再tick人</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161901.png"></p><p>如果按照Component类别来Tick，可能会分散到不同的CPU上，顺序是不能保证的，不同的Tick顺序会产生不同的结果。如果每次输入是一样的，那么结果也需要是一样的。比如实现游戏录像功能。</p><p>根本原因：Component在发送消息，其他Component在当前帧接收到消息还是下一帧接收到消息，接收到消息立即处理，还是等到下一帧处理。都会产生不同结果。</p><p>在实际的事件传递中，时序很重要，如游戏的回放功能，实际是记录用户的输入，如果各用户是依次执行，则没有问题，但如果用户同时进行同一事件的操作则会有问题，因此需要引入一个 “邮局”，各个操作先发到邮局，邮局去保证时序接着进行发送，常用引擎中的类似 PreTick，PostTick 的函数都是为了处理时序问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一课：-现代游戏引擎导论&quot;&gt;&lt;a href=&quot;#第一课：-现代游戏引擎导论&quot; class=&quot;headerlink&quot; title=&quot;第一课： 现代游戏引擎导论&quot;&gt;&lt;/a&gt;第一课： 现代游戏引擎导论&lt;/h2&gt;&lt;h3 id=&quot;游戏引擎架构与层级&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>快手实习总结|渲染&amp;shader</title>
    <link href="http://icecorn.github.io/2022/05/31/%E5%BF%AB%E6%89%8B%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://icecorn.github.io/2022/05/31/%E5%BF%AB%E6%89%8B%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-31T09:25:10.000Z</published>
    <updated>2022-06-29T16:32:33.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快手实习总结"><a href="#快手实习总结" class="headerlink" title="快手实习总结"></a>快手实习总结</h1><h2 id="零散知识"><a href="#零散知识" class="headerlink" title="零散知识"></a>零散知识</h2><p>混合模式及LUT：<a href="https://www.jianshu.com/p/2f188d2b79f1">https://www.jianshu.com/p/2f188d2b79f1</a></p><p>ffmpeg常用命令：<a href="https://www.cnblogs.com/frost-yen/p/5848781.html">https://www.cnblogs.com/frost-yen/p/5848781.html</a></p><p>shader学习：<a href="https://www.shadertoy.com/">https://www.shadertoy.com</a></p><p>数字图像，滤波器基础：<a href="https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html">https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html</a></p><h2 id="火焰效果"><a href="#火焰效果" class="headerlink" title="火焰效果"></a>火焰效果</h2><p>用两张噪声图，一张作为底（然后偏移），一张作为扰动</p><p>暴雪暗黑的燥波造火特效万能公式  <a href="https://youtu.be/YPy2hytwDLM?t=1504">https://youtu.be/YPy2hytwDLM?t=1504</a> </p><p>纯数学生成水波，uv扭曲、时间循环计算、双燥波无缝混合等等数学干货  <a href="https://catlikecoding.com/unity/tutorials/flow/texture-distortion/">https://catlikecoding.com/unity/tutorials/flow/texture-distortion/</a> </p><ul><li>对于火焰，要用大理石噪波，或者cell噪波作为底（因为这些噪波有尖锐的角，符合火焰形态），用柏林噪声作为扰动，然后smoothstep等将两张噪波偏移叠加，然后在对不同的灰度进行颜色映射，映射出外焰和内焰不同的颜色</li><li>对于云，这种用柏林噪声为底更为合适，因为它比较圆，形态像一团东西更像云彩</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> textureCoordinate; <span class="comment">//fs坐标</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> bgImage;  <span class="comment">//输入人体分割mask</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> noiseTexture;  <span class="comment">//噪声图1</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> lastTexture; <span class="comment">//上一帧的mask，人体背景分割黑白图</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> noiseTexture1; <span class="comment">//噪声图2</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> RATIO;  <span class="comment">//显示长宽比  默认720/1280</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;  <span class="comment">//当前time*1000</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> fadein; <span class="comment">//火焰渐现参数 0-10s</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> flameSpeed; <span class="comment">//火焰运动速度 1-10  实际值是 25000/(speed*speed)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> flameRadius;<span class="comment">//火焰宽度 0.57-0.97</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> flameColorInner;<span class="comment">//火焰内颜色</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> flameColorOuter;<span class="comment">//火焰外颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> blend_normal(<span class="type">vec4</span> overlay, <span class="type">vec4</span> base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> overlay + base*(<span class="number">1.</span>-overlay.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> timeSampler = <span class="type">float</span>(<span class="built_in">mod</span>(uTime, flameSpeed)) / flameSpeed;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="type">vec2</span>(textureCoordinate.x, <span class="number">1.0</span> - textureCoordinate.y);</span><br><span class="line">    <span class="type">vec2</span> scale = <span class="type">vec2</span>(RATIO,<span class="number">1.2</span>);</span><br><span class="line"><span class="comment">//采样噪声1，加入time使其朝向右下方移动,这个噪声1作为噪声2的扰动</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> noise_1 = <span class="built_in">texture2D</span>(noiseTexture, uv * scale - timeSampler * <span class="number">0.55</span>);</span><br><span class="line">    <span class="comment">//采样噪声2，用噪声1作为扰动达到一个动态噪声的效果，最后*2-1是为了造出一些黑色的地带，这就是两张噪声叠加的效果</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise_2 = (<span class="number">1.0</span> - <span class="built_in">texture2D</span>(noiseTexture, uv * scale + noise_1.yx * <span class="number">0.065</span> + timeSampler * <span class="number">0.15</span>).xy) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">  <span class="comment">//采样一个噪声3，这个只是为了最后混合人体mask里边的地方</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise_3_tmp = noise_2 * <span class="built_in">texture2D</span>(noiseTexture, uv * scale * <span class="number">5.0</span> - timeSampler * <span class="number">1.55</span>).yx;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> noise_3 = <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(noise_3_tmp, noise_3_tmp));</span><br><span class="line">  <span class="comment">//计算火焰强度</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> flameIntensity = <span class="built_in">clamp</span>(noise_1.y + <span class="number">0.5</span>, <span class="number">0.0</span>, flameRadius);</span><br><span class="line">  <span class="comment">//采样上一帧的纹理，这里是人体的mask图，并且加扰动是白色区域向外扩散，并且扩散区域的透明度递减</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> lastClr = <span class="built_in">texture2D</span>(lastTexture, textureCoordinate + noise_2 * <span class="number">0.015</span>);</span><br><span class="line">  <span class="comment">//每一个像素算出不同的透明度</span></span><br><span class="line">    <span class="type">float</span> alpha = flameIntensity * lastClr.w;</span><br><span class="line">  <span class="comment">//由于采样上一帧的纹理，轮廓边缘的透明度肯定是越来越小的，这样就能体现出内焰和外焰</span></span><br><span class="line">    <span class="type">vec3</span> clr = (flameColorInner * lastClr.w + flameColorOuter * (<span class="number">1.0</span> - lastClr.w)) * alpha;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> flameClr = <span class="type">vec4</span>(clr, alpha);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是有拿了另一张噪波图做一遍同样的操作</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> noise1_1 = <span class="built_in">texture2D</span>(noiseTexture1, uv * scale - timeSampler * <span class="number">0.55</span>);</span><br><span class="line"><span class="comment">//    lowp vec2 noise1_2 = texture2D(noiseTexture1, uv * scale + noise_1.yx * 0.065 + timeSampler * 0.15).yx * 2.0 - 1.0;</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise1_2 = (<span class="number">1.0</span> - <span class="built_in">texture2D</span>(noiseTexture1, uv * scale + noise1_1.yx * <span class="number">0.065</span> + timeSampler * <span class="number">0.15</span>).xy) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise1_3_tmp = noise1_2 * <span class="built_in">texture2D</span>(noiseTexture1, uv * scale * <span class="number">5.0</span> - timeSampler * <span class="number">1.55</span>).yx;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> noise1_3 = <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(noise1_3_tmp, noise1_3_tmp));</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> flameIntensity1 = <span class="built_in">clamp</span>(noise1_1.y + <span class="number">0.5</span>, <span class="number">0.0</span>, flameRadius);</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> lastClr1 = <span class="built_in">texture2D</span>(lastTexture, textureCoordinate + noise1_2 * <span class="number">0.015</span>);</span><br><span class="line">    <span class="type">float</span> alpha1 = flameIntensity1 * lastClr1.w;</span><br><span class="line">    <span class="type">vec3</span> clr1 = (flameColorInner * lastClr1.w + flameColorOuter * (<span class="number">1.0</span> - lastClr1.w)) * alpha;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> flameClr1 = <span class="type">vec4</span>(clr1, alpha1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    flameClr.rgb = flameClr.rgb * flameClr1.rgb * 4.;这里可以随便叠加不同，看效果</span></span><br><span class="line">    flameClr.rgb = flameClr.rgb + flameClr1.rgb;</span><br><span class="line"><span class="comment">//这里获取人体分割mask</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> bgClr = <span class="built_in">texture2D</span>(bgImage, textureCoordinate);</span><br><span class="line"><span class="comment">//最后或者一下并且后边有一个火焰渐现的效果</span></span><br><span class="line">    flameClr = (flameClr + bgClr * noise_3 * <span class="number">3.5</span>) * <span class="built_in">smoothstep</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,uTime/(fadein*<span class="number">1000.0</span>));</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = flameClr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作纹理记得在cpu里set warp ，否则超出边界会出现硬边</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE1)</span><br><span class="line"><span class="comment">-- set warp</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, mNoiseTex)</span><br></pre></td></tr></table></figure><p>![image-20220526151520368](/Users/jun/Library/Application Support/typora-user-images/image-20220526151520368.png)</p><h2 id="描边效果"><a href="#描边效果" class="headerlink" title="描边效果"></a>描边效果</h2><h3 id="1-边缘检测"><a href="#1-边缘检测" class="headerlink" title="1.边缘检测"></a>1.边缘检测</h3><p>​        描边效果的实质是边缘检测，所谓边缘是指其周围像素灰度急剧变化的那些像素的集合，即数学上图像梯度突变的区域。通过边缘检测算子即可得到边缘，常用的有Sobel算子，Canny算子，Laplacian算子等等，其本质都是高通滤波器。Sobel算子由于结构比较简单，检测效率较高比较常用。</p><p>参考：<a href="https://blog.csdn.net/linqianbi/article/details/78673903">https://blog.csdn.net/linqianbi/article/details/78673903</a></p><h3 id="2-图像膨胀，腐蚀"><a href="#2-图像膨胀，腐蚀" class="headerlink" title="2.图像膨胀，腐蚀"></a>2.图像膨胀，腐蚀</h3><p>​        输入一个黑白图mask，对其进行膨胀或腐蚀，在把原图混合上去剔除留下边缘信息，实现外描边和内描边</p><p>参考：<a href="https://blog.csdn.net/Du_Shuang/article/details/82952962?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-82952962-blog-79928835.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/Du_Shuang/article/details/82952962?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-82952962-blog-79928835.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><p><strong>效果：</strong></p><ul><li><p>全图描边，findcountours</p></li><li><p>物体描边</p></li><li><p>边缘线条光感Bloom，原图模糊+原图 = bloom</p></li><li><p>描边上色</p><p>彩虹描边，通过uv相对中心的位置转换为角度，再映射到颜色值</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> toCenter = <span class="type">vec2</span>(<span class="number">0.5</span>) - uv;</span><br><span class="line"><span class="type">float</span> angle = <span class="built_in">atan</span>(toCenter.y,toCenter.x);</span><br><span class="line">angle = (angle / PI2) + <span class="number">0.5</span>;</span><br><span class="line">outColor = <span class="built_in">clamp</span>(<span class="built_in">abs</span>(<span class="built_in">mod</span>(angle * <span class="number">6.0</span> + u_changeTime * <span class="number">21.0</span> + <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>), <span class="number">6.0</span>) - <span class="number">3.0</span>) - <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>描边移动，滚动等，结合不同静态mask，和mask序列帧实现各种效果</p></li></ul><hr><h2 id="噪点效果"><a href="#噪点效果" class="headerlink" title="噪点效果"></a>噪点效果</h2><p>通过随机噪声映射产生噪点图，再与原图进行混合</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> inputImageTexture;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> textureCoord;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> intensity;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> mode;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rand1(<span class="type">vec2</span> co)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rand2(<span class="type">vec2</span> co)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy, <span class="type">vec2</span>(<span class="number">72.1241</span>, <span class="number">21.5234</span>))) * <span class="number">19842.1245</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rand3(<span class="type">vec2</span> co)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy, <span class="type">vec2</span>(<span class="number">66.1321</span>, <span class="number">9.5234</span>))) * <span class="number">1942.1245</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> blend(<span class="type">vec3</span> src1, <span class="type">vec3</span> src2, <span class="type">float</span> alpha)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(src1, src1 * (alpha * src1 + (<span class="number">2.0</span> * alpha * src2 * (<span class="number">1.0</span> - src1))) + src1 * (<span class="number">1.0</span> - alpha), alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec4</span> bgColor = <span class="built_in">texture2D</span>(inputImageTexture, textureCoord);</span><br><span class="line">    <span class="type">vec3</span> custom;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        custom = <span class="type">vec3</span>(rand1(<span class="type">vec2</span>(rand2(textureCoord), uTime)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        custom = <span class="type">vec3</span>(rand1(<span class="type">vec2</span>(rand2(textureCoord), uTime)), rand2(<span class="type">vec2</span>(rand3(textureCoord), uTime)), rand3(<span class="type">vec2</span>(rand1(textureCoord), uTime)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> after = blend(bgColor.xyz, custom, intensity);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(after, bgColor.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a>模糊效果</h2><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>利用高斯分布（正太分布）作为采样系数进行卷积，通常采用两个pass之间来回倒（先上下再左右）这种来优化效率，从数学上可以证明和直接卷积是等价的。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> direction;<span class="comment">//采样方向 上下或左右</span></span><br><span class="line">   <span class="keyword">uniform</span> <span class="type">vec2</span> dimensions;<span class="comment">//屏幕分辨率</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uniform</span> <span class="type">float</span> sigma;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> main()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">float</span> twoSigma2 = <span class="number">2.0</span> * sigma * sigma;</span><br><span class="line">       <span class="type">int</span> halfWidth = <span class="type">int</span>(<span class="built_in">ceil</span>(<span class="number">2.0</span> * sigma));</span><br><span class="line"></span><br><span class="line">       <span class="type">vec4</span> sum = <span class="type">vec4</span>(<span class="number">0.0</span>);</span><br><span class="line">       <span class="type">float</span> norm = <span class="number">0.0</span>;</span><br><span class="line">       <span class="keyword">if</span> (halfWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = -halfWidth; i &lt;= halfWidth; ++i) &#123;</span><br><span class="line">               <span class="type">vec2</span> pr = <span class="type">float</span>(i)*direction;</span><br><span class="line">               <span class="type">float</span> kernel = <span class="built_in">exp</span>(-<span class="built_in">dot</span>(pr, pr) / twoSigma2);</span><br><span class="line">               <span class="type">vec4</span> c = <span class="built_in">texture2D</span>(inputImageTexture, textureCoordinate + pr / dimensions).rgba;</span><br><span class="line">               sum += kernel * c;</span><br><span class="line">               norm += kernel;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           sum = <span class="built_in">texture2D</span>(inputImageTexture, textureCoordinate).rgba;</span><br><span class="line">           norm = <span class="number">1.0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(sum / norm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移位模糊"><a href="#移位模糊" class="headerlink" title="移位模糊"></a>移位模糊</h3><p>本质上就是选择一个在纵向给一个不同的采样权重</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> v;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> r;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec4</span> sum = <span class="type">vec4</span>( <span class="number">0.0</span> );</span><br><span class="line"><span class="type">float</span> vv = v * <span class="built_in">abs</span>( r - vUv.y );</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">4.0</span> * vv ) ) * <span class="number">0.051</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">3.0</span> * vv ) ) * <span class="number">0.0918</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">2.0</span> * vv ) ) * <span class="number">0.12245</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">1.0</span> * vv ) ) * <span class="number">0.1531</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y ) ) * <span class="number">0.1633</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">1.0</span> * vv ) ) * <span class="number">0.1531</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">2.0</span> * vv ) ) * <span class="number">0.12245</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">3.0</span> * vv ) ) * <span class="number">0.0918</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">4.0</span> * vv ) ) * <span class="number">0.051</span>;</span><br><span class="line"><span class="built_in">gl_FragColor</span> = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Tone-mapping及色彩空间"><a href="#Tone-mapping及色彩空间" class="headerlink" title="Tone-mapping及色彩空间"></a>Tone-mapping及色彩空间</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> toneMappingExposure;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> toneMappingWhitePoint;</span><br><span class="line"><span class="type">vec3</span> LinearToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line"><span class="keyword">return</span> toneMappingExposure * color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec3</span> ReinhardToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line">color *= toneMappingExposure;</span><br><span class="line"><span class="keyword">return</span> saturate( color / ( <span class="type">vec3</span>( <span class="number">1.0</span> ) + color ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )</span></span><br><span class="line"><span class="type">vec3</span> Uncharted2ToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line">color *= toneMappingExposure;</span><br><span class="line"><span class="keyword">return</span> saturate( Uncharted2Helper( color ) / Uncharted2Helper( <span class="type">vec3</span>( toneMappingWhitePoint ) ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec3</span> OptimizedCineonToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line">color *= toneMappingExposure;</span><br><span class="line">color = <span class="built_in">max</span>( <span class="type">vec3</span>( <span class="number">0.0</span> ), color - <span class="number">0.004</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>( ( color * ( <span class="number">6.2</span> * color + <span class="number">0.5</span> ) ) / ( color * ( <span class="number">6.2</span> * color + <span class="number">1.7</span> ) + <span class="number">0.06</span> ), <span class="type">vec3</span>( <span class="number">2.2</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> toneMapping( <span class="type">vec3</span> color ) &#123; <span class="keyword">return</span> LinearToneMapping( color ); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> LinearToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> GammaToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> gammaFactor ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">pow</span>( value.xyz, <span class="type">vec3</span>( gammaFactor ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToGamma( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> gammaFactor ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">pow</span>( value.xyz, <span class="type">vec3</span>( <span class="number">1.0</span> / gammaFactor ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> sRGBToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">mix</span>( <span class="built_in">pow</span>( value.rgb * <span class="number">0.9478672986</span> + <span class="type">vec3</span>( <span class="number">0.0521327014</span> ), <span class="type">vec3</span>( <span class="number">2.4</span> ) ), value.rgb * <span class="number">0.0773993808</span>, <span class="type">vec3</span>( <span class="built_in">lessThanEqual</span>( value.rgb, <span class="type">vec3</span>( <span class="number">0.04045</span> ) ) ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearTosRGB( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">mix</span>( <span class="built_in">pow</span>( value.rgb, <span class="type">vec3</span>( <span class="number">0.41666</span> ) ) * <span class="number">1.055</span> - <span class="type">vec3</span>( <span class="number">0.055</span> ), value.rgb * <span class="number">12.92</span>, <span class="type">vec3</span>( <span class="built_in">lessThanEqual</span>( value.rgb, <span class="type">vec3</span>( <span class="number">0.0031308</span> ) ) ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> RGBEToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb * <span class="built_in">exp2</span>( value.a * <span class="number">255.0</span> - <span class="number">128.0</span> ), <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToRGBE( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="type">float</span> maxComponent = <span class="built_in">max</span>( <span class="built_in">max</span>( value.r, value.g ), value.b );</span><br><span class="line"><span class="type">float</span> fExp = <span class="built_in">clamp</span>( <span class="built_in">ceil</span>( <span class="built_in">log2</span>( maxComponent ) ), <span class="number">-128.0</span>, <span class="number">127.0</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb / <span class="built_in">exp2</span>( fExp ), ( fExp + <span class="number">128.0</span> ) / <span class="number">255.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> RGBMToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.xyz * value.w * maxRange, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToRGBM( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="type">float</span> maxRGB = <span class="built_in">max</span>( value.x, <span class="built_in">max</span>( value.g, value.b ) );</span><br><span class="line"><span class="type">float</span> M      = <span class="built_in">clamp</span>( maxRGB / maxRange, <span class="number">0.0</span>, <span class="number">1.0</span> );</span><br><span class="line">M            = <span class="built_in">ceil</span>( M * <span class="number">255.0</span> ) / <span class="number">255.0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb / ( M * maxRange ), M );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> RGBDToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb * ( ( maxRange / <span class="number">255.0</span> ) / value.a ), <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToRGBD( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="type">float</span> maxRGB = <span class="built_in">max</span>( value.x, <span class="built_in">max</span>( value.g, value.b ) );</span><br><span class="line"><span class="type">float</span> D      = <span class="built_in">max</span>( maxRange / maxRGB, <span class="number">1.0</span> );</span><br><span class="line">D            = <span class="built_in">min</span>( <span class="built_in">floor</span>( D ) / <span class="number">255.0</span>, <span class="number">1.0</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb * ( D * ( <span class="number">255.0</span> / maxRange ) ), D );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> cLogLuvM = <span class="type">mat3</span>( <span class="number">0.2209</span>, <span class="number">0.3390</span>, <span class="number">0.4184</span>, <span class="number">0.1138</span>, <span class="number">0.6780</span>, <span class="number">0.7319</span>, <span class="number">0.0102</span>, <span class="number">0.1130</span>, <span class="number">0.2969</span> );</span><br><span class="line"><span class="type">vec4</span> LinearToLogLuv( <span class="keyword">in</span> <span class="type">vec4</span> value )  &#123;</span><br><span class="line"><span class="type">vec3</span> Xp_Y_XYZp = value.rgb * cLogLuvM;</span><br><span class="line">Xp_Y_XYZp = <span class="built_in">max</span>(Xp_Y_XYZp, <span class="type">vec3</span>(<span class="number">1e-6</span>, <span class="number">1e-6</span>, <span class="number">1e-6</span>));</span><br><span class="line"><span class="type">vec4</span> vResult;</span><br><span class="line">vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;</span><br><span class="line"><span class="type">float</span> Le = <span class="number">2.0</span> * <span class="built_in">log2</span>(Xp_Y_XYZp.y) + <span class="number">127.0</span>;</span><br><span class="line">vResult.w = <span class="built_in">fract</span>(Le);</span><br><span class="line">vResult.z = (Le - (<span class="built_in">floor</span>(vResult.w*<span class="number">255.0</span>))/<span class="number">255.0</span>)/<span class="number">255.0</span>;</span><br><span class="line"><span class="keyword">return</span> vResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> cLogLuvInverseM = <span class="type">mat3</span>( <span class="number">6.0014</span>, <span class="number">-2.7008</span>, <span class="number">-1.7996</span>, <span class="number">-1.3320</span>, <span class="number">3.1029</span>, <span class="number">-5.7721</span>, <span class="number">0.3008</span>, <span class="number">-1.0882</span>, <span class="number">5.6268</span> );</span><br><span class="line"><span class="type">vec4</span> LogLuvToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="type">float</span> Le = value.z * <span class="number">255.0</span> + value.w;</span><br><span class="line"><span class="type">vec3</span> Xp_Y_XYZp;</span><br><span class="line">Xp_Y_XYZp.y = <span class="built_in">exp2</span>((Le - <span class="number">127.0</span>) / <span class="number">2.0</span>);</span><br><span class="line">Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;</span><br><span class="line">Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;</span><br><span class="line"><span class="type">vec3</span> vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">max</span>(vRGB, <span class="number">0.0</span>), <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> mapTexelToLinear( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br><span class="line"><span class="type">vec4</span> envMapTexelToLinear( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br><span class="line"><span class="type">vec4</span> emissiveMapTexelToLinear( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br><span class="line"><span class="type">vec4</span> linearToOutputTexel( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="一些后处理效果"><a href="#一些后处理效果" class="headerlink" title="一些后处理效果"></a>一些后处理效果</h2><h3 id="像素化"><a href="#像素化" class="headerlink" title="像素化"></a>像素化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> p = vUv;</span><br><span class="line">    p.x = <span class="built_in">floor</span>(p.x * pixelsX)/pixelsX + <span class="number">0.5</span>/pixelsX;</span><br><span class="line">    p.y = <span class="built_in">floor</span>(p.y * pixelsY)/pixelsY + <span class="number">0.5</span>/pixelsY;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h3><p>就是抖uv，手动生成噪声常用fract，sin等函数</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> p = vUv;</span><br><span class="line"><span class="type">vec2</span> <span class="keyword">offset</span> = (<span class="type">vec2</span>(random1d(time),random1d(time + <span class="number">999.99</span>)) - <span class="number">0.5</span>) * amount;</span><br><span class="line">p += <span class="keyword">offset</span>;</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="彩虹滚动效果"><a href="#彩虹滚动效果" class="headerlink" title="彩虹滚动效果"></a>彩虹滚动效果</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> rainbow2( <span class="keyword">in</span> <span class="type">float</span> t )&#123;</span><br><span class="line"><span class="type">vec3</span> d = <span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">0.33</span>,<span class="number">0.67</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> + <span class="number">0.5</span>*<span class="built_in">cos</span>( <span class="number">6.28318</span>*(t+d) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> p = vUv;</span><br><span class="line"><span class="type">vec3</span> origCol = <span class="built_in">texture2D</span>( tDiffuse, p ).rgb;</span><br><span class="line"><span class="type">vec2</span> off = <span class="built_in">texture2D</span>( tDiffuse, p ).rg - <span class="number">0.5</span>;</span><br><span class="line">p += off * <span class="keyword">offset</span>;</span><br><span class="line"><span class="type">vec3</span> rb = rainbow2( (p.x + p.y + time * <span class="number">2.0</span>) * <span class="number">0.5</span>);</span><br><span class="line"><span class="type">vec3</span> col = <span class="built_in">mix</span>(origCol,rb,amount);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"><span class="keyword">highp</span> <span class="type">float</span> rand( <span class="keyword">const</span> <span class="keyword">in</span> <span class="type">vec2</span> uv ) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">highp</span> <span class="type">float</span> a = <span class="number">12.9898</span>, b = <span class="number">78.233</span>, c = <span class="number">43758.5453</span>;</span><br><span class="line"><span class="keyword">highp</span> <span class="type">float</span> dt = <span class="built_in">dot</span>( uv.xy, <span class="type">vec2</span>( a,b ) ), sn = <span class="built_in">mod</span>( dt, PI );</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(sn) * c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec4</span> cTextureScreen = <span class="built_in">texture2D</span>( tDiffuse, vUv );</span><br><span class="line"><span class="type">float</span> dx = rand( vUv + time );</span><br><span class="line"><span class="type">vec3</span> cResult = cTextureScreen.rgb * dx * noiseAmount;</span><br><span class="line"><span class="type">float</span> lineAmount = height * <span class="number">1.8</span> * count;</span><br><span class="line"><span class="type">vec2</span> sc = <span class="type">vec2</span>( <span class="built_in">sin</span>( vUv.y * lineAmount), <span class="built_in">cos</span>( vUv.y * lineAmount) );</span><br><span class="line">cResult += cTextureScreen.rgb * <span class="type">vec3</span>( sc.x, sc.y, sc.x ) * linesAmount;</span><br><span class="line">cResult = cTextureScreen.rgb + ( cResult );</span><br><span class="line"><span class="built_in">gl_FragColor</span> =  <span class="type">vec4</span>( cResult, cTextureScreen.a );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RGB抖动"><a href="#RGB抖动" class="headerlink" title="RGB抖动"></a>RGB抖动</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> amount;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> speed;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"><span class="type">float</span> random1d(<span class="type">float</span> n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(n) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> random2d(<span class="type">vec2</span> n) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(n, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">4.1414</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> randomRange (<span class="keyword">in</span> <span class="type">vec2</span> seed, <span class="keyword">in</span> <span class="type">float</span> <span class="built_in">min</span>, <span class="keyword">in</span> <span class="type">float</span> <span class="built_in">max</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span> + random2d(seed) * (<span class="built_in">max</span> - <span class="built_in">min</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> insideRange(<span class="type">float</span> v, <span class="type">float</span> bottom, <span class="type">float</span> top) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">step</span>(bottom, v) - <span class="built_in">step</span>(top, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> rand(<span class="type">vec2</span> co)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy ,<span class="type">vec2</span>(<span class="number">12.9898</span>,<span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = vUv;</span><br><span class="line">    <span class="type">float</span> sTime = <span class="built_in">floor</span>(time * speed * <span class="number">6.0</span> * <span class="number">24.0</span>);</span><br><span class="line">    <span class="type">vec3</span> inCol = <span class="built_in">texture2D</span>(tDiffuse, uv).rgb;</span><br><span class="line">    <span class="type">vec3</span> outCol = inCol;</span><br><span class="line">    <span class="type">float</span> maxOffset = amount/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">vec2</span> uvOff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> i = <span class="number">0.0</span>; i &lt; <span class="number">10.0</span>; i += <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10.0</span> * amount) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">float</span> sliceY = random2d(<span class="type">vec2</span>(sTime + amount, <span class="number">2345.0</span> + <span class="type">float</span>(i)));</span><br><span class="line">        <span class="type">float</span> sliceH = random2d(<span class="type">vec2</span>(sTime + amount, <span class="number">9035.0</span> + <span class="type">float</span>(i))) * <span class="number">0.25</span>;</span><br><span class="line">        <span class="type">float</span> hOffset = randomRange(<span class="type">vec2</span>(sTime + amount, <span class="number">9625.0</span> + <span class="type">float</span>(i)), -maxOffset, maxOffset);</span><br><span class="line">        uvOff = uv;</span><br><span class="line">        uvOff.x += hOffset;</span><br><span class="line">        <span class="type">vec2</span> uvOff = <span class="built_in">fract</span>(uvOff);</span><br><span class="line">        <span class="keyword">if</span> (insideRange(uv.y, sliceY, <span class="built_in">fract</span>(sliceY+sliceH)) == <span class="number">1.0</span> )&#123;</span><br><span class="line">            outCol = <span class="built_in">texture2D</span>(tDiffuse, uvOff).rgb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> maxColOffset = amount/<span class="number">6.0</span>;</span><br><span class="line">    <span class="type">vec2</span> colOffset = <span class="type">vec2</span>(randomRange(<span class="type">vec2</span>(sTime + amount, <span class="number">3545.0</span>),-maxColOffset,maxColOffset), randomRange(<span class="type">vec2</span>(sTime , <span class="number">7205.0</span>),-maxColOffset,maxColOffset));</span><br><span class="line">    uvOff = <span class="built_in">fract</span>(uv + colOffset);</span><br><span class="line">    <span class="type">float</span> rnd = random2d(<span class="type">vec2</span>(sTime + amount, <span class="number">9545.0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rnd &lt; <span class="number">0.33</span>)&#123;</span><br><span class="line">    outCol.r = <span class="built_in">texture2D</span>(tDiffuse, uvOff).r;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rnd &lt; <span class="number">0.66</span>)&#123;</span><br><span class="line">    outCol.g = <span class="built_in">texture2D</span>(tDiffuse, uvOff).g;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    outCol.b = <span class="built_in">texture2D</span>(tDiffuse, uvOff).b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(outCol,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扭曲（沿着圆形轨迹）"><a href="#扭曲（沿着圆形轨迹）" class="headerlink" title="扭曲（沿着圆形轨迹）"></a>扭曲（沿着圆形轨迹）</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> p = <span class="number">-1.0</span> + <span class="number">2.0</span> * vUv;</span><br><span class="line"> <span class="comment">//后边加length那项额外加了一个扭曲项，相当于uv抖动把像素位置考虑进去了</span></span><br><span class="line"><span class="type">float</span> pos = time * TWO_PI + <span class="built_in">length</span>(p * size);</span><br><span class="line"> <span class="comment">//下边uv抖动按照圆形轨迹周期抖动，strength是强度</span></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, vUv + strength * <span class="type">vec2</span>(<span class="built_in">cos</span>(pos), <span class="built_in">sin</span>(pos)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错位效果"><a href="#错位效果" class="headerlink" title="错位效果"></a>错位效果</h3><p>从上到下很多条线错位切割</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> slices;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> <span class="keyword">offset</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> speedV;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="type">float</span> steppedVal(<span class="type">float</span> v, <span class="type">float</span> steps)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">floor</span>(v*steps)/steps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> random1d(<span class="type">float</span> n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(n) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> noise1d(<span class="type">float</span> p)&#123;</span><br><span class="line"><span class="type">float</span> fl = <span class="built_in">floor</span>(p);</span><br><span class="line"><span class="type">float</span> fc = <span class="built_in">fract</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mix</span>(random1d(fl), random1d(fl + <span class="number">1.0</span>), fc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> TWO_PI = <span class="number">6.283185307179586</span>;</span><br><span class="line">    <span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = vUv;</span><br><span class="line">    <span class="type">float</span> n = noise1d(uv.y * slices + time * speedV * <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">float</span> ns = steppedVal(<span class="built_in">fract</span>(n  ),slices) + <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> nsr = random1d(ns);</span><br><span class="line">    <span class="type">vec2</span> uvn = uv;</span><br><span class="line">    uvn.x += nsr * <span class="built_in">sin</span>(time * TWO_PI + nsr * <span class="number">20.0</span>) * <span class="keyword">offset</span>;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, uvn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边缘描边"><a href="#边缘描边" class="headerlink" title="边缘描边"></a>边缘描边</h3><p>使用sobel算子</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> amount;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> passthru;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="type">vec2</span> texel = <span class="type">vec2</span>(<span class="number">1.0</span> /<span class="number">512.0</span>);</span><br><span class="line"><span class="type">mat3</span> G[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> g0 = <span class="type">mat3</span>( <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">-2.0</span>, <span class="number">-1.0</span> );</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> g1 = <span class="type">mat3</span>( <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">-2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span> );</span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">mat3</span> I;</span><br><span class="line"><span class="type">float</span> cnv[<span class="number">2</span>];</span><br><span class="line"><span class="type">vec3</span> <span class="keyword">sample</span>;</span><br><span class="line">G[<span class="number">0</span>] = g0;</span><br><span class="line">G[<span class="number">1</span>] = g1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> i=<span class="number">0.0</span>; i&lt;<span class="number">3.0</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> j=<span class="number">0.0</span>; j&lt;<span class="number">3.0</span>; j++) &#123;</span><br><span class="line"><span class="keyword">sample</span> = <span class="built_in">texture2D</span>( tDiffuse, vUv + texel * <span class="type">vec2</span>(i<span class="number">-1.0</span>,j<span class="number">-1.0</span>) ).rgb;</span><br><span class="line">I[<span class="type">int</span>(i)][<span class="type">int</span>(j)] = <span class="built_in">length</span>(<span class="keyword">sample</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="type">float</span> dp3 = <span class="built_in">dot</span>(G[i][<span class="number">0</span>], I[<span class="number">0</span>]) + <span class="built_in">dot</span>(G[i][<span class="number">1</span>], I[<span class="number">1</span>]) + <span class="built_in">dot</span>(G[i][<span class="number">2</span>], I[<span class="number">2</span>]);</span><br><span class="line">cnv[i] = dp3 * dp3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> orig = <span class="built_in">texture2D</span>( tDiffuse, vUv);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = orig * passthru + <span class="type">vec4</span>(<span class="number">0.5</span> * <span class="built_in">sqrt</span>(cnv[<span class="number">0</span>]*cnv[<span class="number">0</span>]+cnv[<span class="number">1</span>]*cnv[<span class="number">1</span>])) * amount;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="Fibonacci采样"><a href="#Fibonacci采样" class="headerlink" title="Fibonacci采样"></a>Fibonacci采样</h2><p>通常我们会使用 4 个或者 8 个矩形边缘上的采样来进行扩张 / 收缩 / 模糊的效果</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> r;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// 里面四个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    phi += PI * <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi)) * r;</span><br><span class="line">    result += <span class="built_in">texture2D</span>(basetex, uv + <span class="keyword">offset</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外面四个</span></span><br><span class="line">r *= <span class="built_in">sqrt</span>(<span class="number">2.0</span>);</span><br><span class="line">phi += PI * <span class="number">0.25</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    phi += PI * <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi)) * r;</span><br><span class="line">    result += <span class="built_in">texture2D</span>(basetex, uv + <span class="keyword">offset</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过使用这种方法生成的 pattern 对水平或者垂直的边缘不是很友好。间隔稍微大一点就能看到明显的artifact，步长一大很容易出现这种一条条的情况.</p><p>fibonacci采样最初是用于生成在空间中【均匀】分布的点的方法，在该平面上生成个采样点的公式</p><p>这里使用了黄金分割比的一个奇妙的性质，来让球面上的点分布更加均匀</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> r;</span><br><span class="line"><span class="type">float</span> rad = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> i = <span class="number">0.0</span>; i &lt; SAMPLE_CNT; i += <span class="number">1.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rad = <span class="built_in">sqrt</span>((i + <span class="number">0.5</span>) / SAMPLE_CNT); <span class="comment">// 简单地加个小 offset 保证不会每次都采样到原点</span></span><br><span class="line">    phi += GOLDEN_ANGLE; <span class="comment">// 预计算的 $1 / \phi$</span></span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi)) * r * rad;</span><br><span class="line">    result += <span class="built_in">texture2D</span>(basetex, uv + <span class="keyword">offset</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加入噪声"><a href="#加入噪声" class="headerlink" title="加入噪声"></a>加入噪声</h2><p>为了降低迭代次数，引入噪声来做到一个给均匀采样的效果，这种技术将走样现象转化为噪声，从而减少视觉上的怪异感。在实现上这边偷了个懒。由于计算中采样位置的值是逐次累加的，通过对它的初始值进行随机扰动就可以保证在采样的概率密度不变的情况下做出扰动了（其实就相当于转了一下采样的圆盘）。</p><p>如果让噪声动起来这样人眼就更不能发现锯齿了，但是又有一个问题是噪声太闪了。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phi += someRandomNumberGenerator(time, uv);</span><br></pre></td></tr></table></figure><h2 id="Temporal-Denoising"><a href="#Temporal-Denoising" class="headerlink" title="Temporal Denoising"></a>Temporal Denoising</h2><p>从时间维度入手，引入上一帧的信息，可以解决噪声每帧都在变（太闪了）的问题。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> tfactor; <span class="comment">// 上式中的 $\alpha$</span></span><br><span class="line"><span class="type">vec4</span> lastcol = <span class="built_in">texture2D</span>(lasttex, uv);</span><br><span class="line"><span class="type">vec4</span> currcol = <span class="built_in">texture2D</span>(currtex, uv);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="built_in">mix</span>(currcol, lastcol, tfactor);</span><br></pre></td></tr></table></figure><h2 id="Joint-Bilateral-Filtering"><a href="#Joint-Bilateral-Filtering" class="headerlink" title="Joint Bilateral Filtering"></a>Joint Bilateral Filtering</h2><p>隆重介绍联合双向滤波。这一方法最开始被用于进行可以保留边缘的模糊效果，多见于对实时光线追踪进行降噪的过程中。GAMES202课程的最后一个作业实现了这样的一个算法，它利用GBuffer中的多项信息对图像进行滤波。</p><p>最基础的一种滤波方法是以颜色差异判断当前物体是否在移动。当前像素的色差超过某一阈值时就认为当前位置在运动，此时可以抛弃旧的采样以避免残影的问题。但只用这一种作为滤波手段的效果极差，很容易就会弄出更多的残影来，因此一般推荐这个滤波手段要加入更多还在使用的其它东西（比如遮罩）一同作用。</p><p>其实就是双边滤波，滤波时不止考虑远近这一维度的信息，还考虑前一帧和当前帧颜色数值的差值，如果大于阈值就直接舍弃上一帧的信息。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filtering</span></span><br><span class="line"><span class="type">vec3</span> diff = <span class="built_in">abs</span>(currcol.rgb - lastcol.rgb);</span><br><span class="line"><span class="type">float</span> diffmax = <span class="built_in">max</span>(<span class="built_in">max</span>(diff.r, diff.g), diff.b);</span><br><span class="line"><span class="type">float</span> colorfactor = <span class="number">1.0</span> - <span class="built_in">smoothstep</span>(<span class="built_in">max</span>(<span class="number">0.0</span>, thres - softthres), thres, diffmax);</span><br></pre></td></tr></table></figure><h2 id="拖尾效果"><a href="#拖尾效果" class="headerlink" title="拖尾效果"></a>拖尾效果</h2><p>Temporal还能用来实现拖尾，鬼影等效果</p><p>基本思想就是对一个运动的物体，把它前一帧的图像和当前帧的图像混合，并且根据时间因素设置透明度，比如拖尾10帧，当前帧是1，前一帧是0.9，再前一帧是0.8，这样10帧后透明度就是0了，就实现了拖尾效果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// draw current circle</span></span><br><span class="line"><span class="type">vec2</span> dpos = (uv - center) * canvasSize;</span><br><span class="line"><span class="type">float</span> dist = <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(dpos, dpos));</span><br><span class="line"><span class="type">float</span> vcurr = dist &lt; radius ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// distrub uv</span></span><br><span class="line"><span class="type">float</span> time = t * <span class="number">0.1</span>;</span><br><span class="line"><span class="type">vec2</span> uv_disturb = mirroredUV(uv + time);</span><br><span class="line">uv_disturb = uv + (<span class="built_in">texture2D</span>(noise, uv_disturb).xy * <span class="number">2.0</span> - <span class="number">1.0</span>) * disturbAmp / canvasSize + speed + <span class="type">vec2</span>(<span class="number">0.0008</span>, <span class="number">0.0004</span>);</span><br><span class="line">uv_disturb = mirroredUV(uv_disturb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread last</span></span><br><span class="line"><span class="type">float</span> vlast = <span class="built_in">texture2D</span>(last, uv_disturb).x;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  phi += PI * <span class="number">0.5</span>;</span><br><span class="line">  <span class="type">vec2</span> duv = spread * <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi));</span><br><span class="line">  vlast = <span class="built_in">max</span>(vlast, <span class="built_in">texture2D</span>(last, uv_disturb + duv).x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mix and return</span></span><br><span class="line"><span class="type">float</span> v = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">0.0</span>, vlast - dval), vcurr);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(v), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h2 id="时间上的身体描边效果"><a href="#时间上的身体描边效果" class="headerlink" title="时间上的身体描边效果"></a>时间上的身体描边效果</h2><p>找到前5帧的缓存，每一帧的fbo给一个颜色，再混合，就实现了几层彩色的描边效果</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> uv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> pi = <span class="number">3.1415927</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> blend_normal(<span class="type">vec4</span> overlay, <span class="type">vec4</span> base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> overlay + base*(<span class="number">1.0</span> - overlay.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> getColor(<span class="type">sampler2D</span> img, <span class="type">vec2</span> coord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(coord.x &lt; <span class="number">0.</span> || coord.x &gt; <span class="number">1.</span> || coord.y &lt; <span class="number">0.</span> || coord.y &gt; <span class="number">1.</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">vec4</span>(<span class="number">0.</span>); <span class="comment">//注意此处为透明而不是黑色！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">texture2D</span>(img, coord);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">float</span> time = uTime;</span><br><span class="line">  <span class="type">vec4</span> bg_Image0 = getColor(bgImage0,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image1 = getColor(bgImage1,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image2 = getColor(bgImage2,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image3 = getColor(bgImage3,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image4 = getColor(bgImage4,uv);</span><br><span class="line"></span><br><span class="line">  <span class="type">vec4</span> yan_Image = getColor(y_Image,uv);</span><br><span class="line"></span><br><span class="line">  <span class="type">vec4</span> mattingColor = <span class="built_in">mix</span>(<span class="type">vec4</span>(<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>),yan_Image,bg_Image4.r);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//第三层绿色拖影</span></span><br><span class="line">  <span class="type">vec4</span> color = <span class="built_in">mix</span>(yan_Image,greenCode * <span class="number">1.0</span>,bg_Image2.a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二层黄色拖影</span></span><br><span class="line">  color = <span class="built_in">mix</span>(color,yellowCode * <span class="number">1.0</span>,bg_Image1.a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一层粉色拖影</span></span><br><span class="line">  color = <span class="built_in">mix</span>(color,pinkCode * <span class="number">1.0</span>,bg_Image0.a);</span><br><span class="line"></span><br><span class="line">  color = <span class="built_in">mix</span>(color,mattingColor,mattingColor.a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">gl_FragColor</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快手实习总结&quot;&gt;&lt;a href=&quot;#快手实习总结&quot; class=&quot;headerlink&quot; title=&quot;快手实习总结&quot;&gt;&lt;/a&gt;快手实习总结&lt;/h1&gt;&lt;h2 id=&quot;零散知识&quot;&gt;&lt;a href=&quot;#零散知识&quot; class=&quot;headerlink&quot; title=&quot;零</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="shader" scheme="http://icecorn.github.io/tags/shader/"/>
    
    <category term="openGL" scheme="http://icecorn.github.io/tags/openGL/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（一）|链表，树，递归，回溯</title>
    <link href="http://icecorn.github.io/2022/05/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%A0%91%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%9B%9E%E6%BA%AF/"/>
    <id>http://icecorn.github.io/2022/05/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%A0%91%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%9B%9E%E6%BA%AF/</id>
    <published>2022-05-25T09:25:10.000Z</published>
    <updated>2022-06-29T15:58:10.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题系列（一）"><a href="#算法题系列（一）" class="headerlink" title="算法题系列（一）"></a>算法题系列（一）</h1><p>主要掌握知识点，滑动窗口，双指针，动态规划，字符串，数组，二叉树，并查集，单调栈，DFS，BFS等；其中字符串操作(子串)，数组(二维数组遍历)是重点。二维数组要记住leetcode上俄罗斯套娃信封问题，里面有个排序思想能解决二维数组的很多问题，比如堆积木，快递问题，小朋友身高体重问题，主要多刷题，总结刷题思路和模板</p><h2 id="常见算法题型"><a href="#常见算法题型" class="headerlink" title="常见算法题型"></a>常见算法题型</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>一个问题的解可以分解为几个子问题的解</li><li>子问题求解思路和原问题一致</li><li>存在基线/终止条件</li></ul><p>Lc21题：合并两个有序链表<br>Lc83题：删除链表重复元素</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>链表判断是否有环</strong></p><p>方法：双指针，遍历，哈希<br>Lc141题：环形链表<br>Lc206题：反转链表<br>Lc234题：回文链表</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>一篇解决：<br><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/</a></p><p><strong>解题模板</strong><br>下面给出二叉树对称性递归的解题模板<br><strong>1、递归结束条件：特殊情况的判断</strong><br>如果是单树问题，一般来说只要进行以下判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br></pre></td></tr></table></figure><p>如果是双树问题(根节点分别为p,q)，一般来说进行以下判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!p || !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析</p><p><strong>2、返回值</strong><br>通常对称性递归的返回值是多个条件的复合判断语句<br>可能是以下几种条件判断的组合：<br>节点非空的判断<br>节点值比较判断<br>(单树)调用根节点左右子树的递归函数进行递归判断<br>(双树)调用两棵树的左右子树的递归函数进行判断</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>比较，匹配，解析<br>重点题：回文字符串<br>思路就是以每个字符为中心，像左右发散判断是否回文（分一个字符中心，和两个字符中心）</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><strong>DFS:</strong><br>应用：暴力搜索（其实就是枚举），检测环路<br>dfs可以搜索到所有的解，根据题意应用一些剪枝的策略<br><strong>解题步骤：</strong></p><ul><li>找到搜索的下一个状态（往哪搜索）</li><li>考虑搜索跳出的条件</li><li>设置搜索状态（标记已经搜索过了）</li><li>考虑剪枝情况优化搜索</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220625130916.png"></p><p>经典题目：迷宫路径，宝石最大价值（暴力+剪枝）</p><p><strong>BFS：</strong></p><p>应用：bfs主要用来算最短路径，找一个“值”，火烧法，通过queue来实现</p><p>经典题：二叉树层序遍历，每层的最大值，在while循环里获取当前queue的size，for循环size次<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220625131519.png"></p><p><strong>回溯法：</strong></p><p>一篇解决：<br><a href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p><p>回溯和dfs的区别是，dfs是无脑往下一个状态搜，回溯是搜索达到结束条件后，撤销这一步的选择，然后再继续搜，通常带有一些“状态东西“，比如一个vector之类的（想一下麻将胡牌问题）</p><p><strong>回溯应用：一般用在要查找所有解，要维护一个和搜索过程无关的状态集合</strong></p><p><strong>解题步骤：</strong></p><ul><li>画出递归树，找到状态变量（回溯函数的参数）</li><li>根据题意，确立结束条件</li><li>找准选择列表（与函数参数相关）</li><li>判断剪枝</li><li>做出选择</li><li>递归调用</li><li>撤销选择</li></ul><p><strong>题型：</strong></p><ul><li><p>子集，组合</p><p>核心在于设置一个标志位int start，从而选定下一步可选集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//sort(candidates.begin(),candidates.end());</span></span><br><span class="line">        <span class="built_in">backtrace</span>(candidates,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第一步</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt; candidates,<span class="type">int</span> start,<span class="type">int</span> target)</span> </span>&#123;      <span class="comment">//第二步</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//第四步</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);<span class="comment">//第五步</span></span><br><span class="line">            <span class="built_in">backtrace</span>(candidates,i,target-candidates[i]);<span class="comment">//第六步</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//第七步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>全排列Lc47</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backTrace</span>(nums,visited,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; visited,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里可以直接path.size()==nums.size(),不用传pos</span></span><br><span class="line">        <span class="keyword">if</span>(pos==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">//这个!visited[i-1]没想到，必须前一个也能选才要剪枝</span></span><br><span class="line">                <span class="comment">//注意是i&gt;0,其实不用传pos</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;!visited[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">backTrace</span>(nums,visited,pos+<span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>搜索</p></li></ul><hr><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="是否是数字，字母"><a href="#是否是数字，字母" class="headerlink" title="是否是数字，字母"></a>是否是数字，字母</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="built_in">isdigit</span>(a); <span class="comment">//校验字符是不是十进制数</span></span><br><span class="line"><span class="built_in">isalpha</span>(a); <span class="comment">//校验字符是不是英文字母</span></span><br></pre></td></tr></table></figure><h3 id="n进制字符串转换成10进制"><a href="#n进制字符串转换成10进制" class="headerlink" title="n进制字符串转换成10进制"></a><strong>n进制字符串转换成10进制</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">stoi</span>(字符串，起始位置，n进制);</span><br><span class="line">示例：</span><br><span class="line"><span class="built_in">stoi</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//直接一个参数也行 结果123</span></span><br><span class="line"><span class="built_in">stoi</span>(str,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//将str从位置0到末尾转化为10进制</span></span><br></pre></td></tr></table></figure><h3 id="字符串转换成整数"><a href="#字符串转换成整数" class="headerlink" title="字符串转换成整数"></a>字符串转换成整数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;       <span class="comment">//str-&gt;int</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;<span class="comment">//str-&gt;long</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">atoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;<span class="comment">//str-&gt;long long</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">atoq</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;<span class="comment">//str-&gt; long long</span></span><br><span class="line">示例：</span><br><span class="line">ii=<span class="built_in">atoi</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br></pre></td></tr></table></figure><h3 id="string转C风格字符串"><a href="#string转C风格字符串" class="headerlink" title="string转C风格字符串"></a>string转C风格字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">c_str</span>();</span><br><span class="line">string s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">//输出 &quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">C风格转string可以直接赋值</span><br><span class="line"><span class="type">char</span>* chstr;</span><br><span class="line"><span class="type">char</span> arstr[];</span><br><span class="line">string str = chstr;</span><br><span class="line">string str = arstr;</span><br></pre></td></tr></table></figure><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><p><strong>拼接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+号拼接</span><br><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot; world&quot;</span>;</span><br><span class="line">str1 += str2; <span class="comment">// str1 = &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">函数拼接</span><br><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">append</span>(<span class="string">&quot; world&quot;</span>); <span class="comment">//str1 = &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str2.<span class="built_in">append</span>(<span class="string">&quot; world&quot;</span>,<span class="number">3</span>);  <span class="comment">//str1 = &quot;hello wo&quot;,参数3代表只要前3个</span></span><br><span class="line"></span><br><span class="line">string str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot; w orld&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//str1 = &quot;hello or&quot;,参数2代表从下标2开始,参数3代表要3个字符</span></span><br></pre></td></tr></table></figure><p><strong>查找子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abcdefdef&quot;</span>;</span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;def&quot;</span>);  <span class="comment">//结果是3，从左往右找</span></span><br><span class="line">str1.<span class="built_in">rfind</span>(<span class="string">&quot;def&quot;</span>); <span class="comment">//结果是6，从右往左找</span></span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;hhh&quot;</span>);  <span class="comment">//结果为-1，没有这个子串结果就是-1</span></span><br></pre></td></tr></table></figure><p><strong>替换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abcdssw&quot;</span>;</span><br><span class="line">str1.<span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;1111&quot;</span>); <span class="comment">//代表主串从0的位置开始，两个字符被替换掉；此处的结果为1111cdssw</span></span><br></pre></td></tr></table></figure><p><strong>比较</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">compare</span>(str2);  <span class="comment">//结果为0代表相等，否则为不相等</span></span><br><span class="line"></span><br><span class="line">string str1 = <span class="string">&quot;helpo&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">compare</span>(str2);  <span class="comment">//结果不为0，为p-l,两个字符的ASCII值求差</span></span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;111&quot;</span>); <span class="comment">//在1的位置插入,结果为&quot;h111ello&quot;</span></span><br></pre></td></tr></table></figure><p><strong>获取子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">str1.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//从下标为1的位置截取长度为3的子串</span></span><br><span class="line"><span class="comment">//结果为ell</span></span><br><span class="line">str1.<span class="built_in">substr</span>(<span class="number">1</span>) <span class="comment">//返回的就是下标1到最后的子串</span></span><br></pre></td></tr></table></figure><p><strong>删除子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">str1.<span class="built_in">erase</span>(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//从下标为1的位置起，删除长度为3的子串</span></span><br><span class="line"><span class="comment">//结果为&quot;ho world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//最后的参数是初始值，一般为0</span></span><br></pre></td></tr></table></figure><hr><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pair的使用</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p = <span class="built_in">makepair</span>(i,j);</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(i,j)</span></span>;</span><br><span class="line">pair-&gt;first;   pair-&gt;second;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵构造  注意右边是vector&lt;int&gt; 不要忘记泛型</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; mat = <span class="built_in">vector</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//写递归时注意，前边return true，要在上一级的递归函数中用上</span></span><br><span class="line"><span class="built_in">backtrace</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(xxx) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(backtrace)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>cin&gt;&gt;    一次处理一行</p><p>思路是重新生成字符串，双指针处理，i指针遍历字符串，j指针跟着遍历但找到符合条件要删除的就j–，然后s[j++] = s[i]组成新的字符串，最后返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[j++]=s[i];   <span class="comment">//j还没用</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">3</span>&amp;&amp;s[j<span class="number">-1</span>]==s[j<span class="number">-2</span>]&amp;&amp;s[j<span class="number">-2</span>]==s[j<span class="number">-3</span>]) </span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">4</span>&amp;&amp;s[j<span class="number">-1</span>]==s[j<span class="number">-2</span>]&amp;&amp;s[j<span class="number">-3</span>]==s[j<span class="number">-4</span>]) </span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+j,s.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="贪心问题"><a href="#贪心问题" class="headerlink" title="贪心问题"></a>贪心问题</h2><h3 id="n个建筑藏3个人"><a href="#n个建筑藏3个人" class="headerlink" title="n个建筑藏3个人"></a>n个建筑藏3个人</h3><p>且最大距离不超过d，处理有序数组的题目</p><p>思路：</p><ul><li>遍历数组，找出每一次可选元素，双指针i j，v[i]-v[j]&lt;=d筛选</li><li>贪心处理，组合问题，假定每一次i的值都被选，那么count=前边的数中选2个人</li></ul><hr><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="麻将问题"><a href="#麻将问题" class="headerlink" title="麻将问题"></a>麻将问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">(<span class="number">720</span>)<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">card</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查剩余的牌能否组成n个顺子或刻子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasTrible</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;card.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">//因为仍是从1开始查验，因此若检查到其牌数&gt;=3，则必定是刻子</span></span><br><span class="line">        <span class="keyword">if</span>(card[i]&gt;<span class="number">2</span>)&#123;   </span><br><span class="line">            card[i] -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hasTrible</span>(n<span class="number">-1</span>))&#123;   <span class="comment">//检查余下的牌能否组成n-1个顺子或刻子</span></span><br><span class="line">                card[i] += <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            card[i] += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则只能是顺子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;card.<span class="built_in">size</span>()<span class="number">-2</span> &amp;&amp; card[i]&gt;<span class="number">0</span> &amp;&amp; card[i+<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; card[i+<span class="number">2</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                card[i]--;</span><br><span class="line">                card[i+<span class="number">1</span>]--;</span><br><span class="line">                card[i+<span class="number">2</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">hasTrible</span>(n<span class="number">-1</span>))&#123;</span><br><span class="line">                    card[i]++;</span><br><span class="line">                    card[i+<span class="number">1</span>]++;</span><br><span class="line">                    card[i+<span class="number">2</span>]++;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                card[i]++;</span><br><span class="line">                card[i+<span class="number">1</span>]++;</span><br><span class="line">                card[i+<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查14张牌能否和牌</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)&#123;  <span class="comment">//依次把1~9作为雀头拿出来，检查剩下的12张牌能否顺或刻子</span></span><br><span class="line">        <span class="keyword">if</span>(card[i]&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        card[i] -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">hasTrible</span>(<span class="number">4</span>))&#123;    </span><br><span class="line">            card[i] += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        card[i] += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        card[tmp<span class="number">-1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)&#123;  <span class="comment">//1~9依次添加，检查是否可以和牌</span></span><br><span class="line">        <span class="keyword">if</span>(card[i]&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        card[i]++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isWin</span>())           <span class="comment">//如果添加的这张牌可以和牌，则将其加入输出结果</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        card[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题系列（一）&quot;&gt;&lt;a href=&quot;#算法题系列（一）&quot; class=&quot;headerlink&quot; title=&quot;算法题系列（一）&quot;&gt;&lt;/a&gt;算法题系列（一）&lt;/h1&gt;&lt;p&gt;主要掌握知识点，滑动窗口，双指针，动态规划，字符串，数组，二叉树，并查集，单调栈，DFS，B</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第十四章-多线程编程</title>
    <link href="http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-15T09:25:10.000Z</published>
    <updated>2022-06-29T15:43:07.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>创建和调度线程无需内核干预, 速度很快.<br>不占用额外的内核资源, 对系统影响较小<br>但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>优缺点正好与上一个相反</li><li>双层调度<br>结合了前两个的优点<br>不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br><span class="line">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class="line">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class="line">执行后不会返回到调用者, 而且永远不会失败</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span></span></span><br><span class="line"><span class="function">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span></span><br><span class="line"><span class="function">成功时返回0, 失败返回错误码</span></span><br><span class="line"><span class="function">等待其他线程结束</span></span><br><span class="line"><span class="function">thread 线程标识符</span></span><br><span class="line"><span class="function">retval 目标线程的退出返回信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">错误码如下</span></span><br><span class="line"><span class="function">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span></span><br><span class="line"><span class="function">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span></span><br><span class="line"><span class="function">`ESRCH`目标线程不存在</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br><span class="line"><span class="function">异常终止一个线程, 即为取消线程</span></span><br><span class="line"><span class="function">成功返回0, 失败返回错误码</span></span><br></pre></td></tr></table></figure><p><strong>线程属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class="line"><span class="comment">// 启动线程取消</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcancelstart</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span>* oldstate)</span></span></span><br><span class="line"><span class="function">第一个参数</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到</span></span><br><span class="line"><span class="function">这个线程允许被取消</span></span><br><span class="line"><span class="function">第二个参数 返回之前设定的状态</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置线程取消类型</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span>* oldtype)</span></span></span><br><span class="line"><span class="function">第一个参数</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数</span></span><br><span class="line"><span class="function">最好使用pthread_testcancel函数设置取消点</span></span><br><span class="line"><span class="function">设置取消类型<span class="params">(如何取消)</span></span></span><br><span class="line"><span class="function">第二个参数</span></span><br><span class="line"><span class="function">原来的取消类型</span></span><br></pre></td></tr></table></figure><p><strong>设置脱离线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化线程属性对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁线程属性对象, 直到再次初始化前都不能用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 参数取值</span></span></span><br><span class="line"><span class="function"><span class="comment">// -PTHREAD_CREATE_JOINABLE 线程可回收</span></span></span><br><span class="line"><span class="function"><span class="comment">// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 可以直接设置为脱离线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure><h2 id="线程同步机制的使用场景"><a href="#线程同步机制的使用场景" class="headerlink" title="线程同步机制的使用场景"></a>线程同步机制的使用场景</h2><p>POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值<br>两份计数值容易出错</p><p>互斥锁-对临界资源的独占式访问</p><p>条件变量-等待某个条件满足<br>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</p><p>读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写</p><p>自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景</p><h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join()</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="comment">// 用于初始化一个未命名的信号量.</span></span><br><span class="line"><span class="comment">// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享</span></span><br><span class="line"><span class="comment">// value指定参数的初始值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁信号量, 释放其占用的系统资源</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destory</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 原子操作将信号量的值 +1</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure><p>初始化已经存在的信号量会导致无法预期的结果</p><p>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</p><p>例子如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kNumberMax = <span class="number">10</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">number</span><span class="params">(kNumberMax)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kThreadNum = <span class="number">10</span>;</span><br><span class="line"><span class="type">sem_t</span> sems[kThreadNum];</span><br><span class="line"><span class="type">pthread_t</span> threads[kThreadNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kPrintTime = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">t</span><span class="params">(<span class="type">void</span> *no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start_sub = *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(no);</span><br><span class="line">    <span class="type">int</span> sub =start_sub;</span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++time &lt;= kPrintTime)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 锁住本线程 释放下一个线程</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sems[start_sub]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number[sub]);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sems[(start_sub + <span class="number">1</span>) % kThreadNum]);</span><br><span class="line"><span class="comment">// 计算下一次要打印的下标</span></span><br><span class="line">        sub = (sub + kThreadNum) % kNumberMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">iota</span>(number.<span class="built_in">begin</span>(), number.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sems[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; kThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sems[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, t, &amp;number[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 等待最后一个线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(threads[kThreadNum - <span class="number">1</span>], <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kThreadNum个进程依次打印<code>[0, kNumberMax)</code><br>每个进程打印kPrintTime次<br>最后一个进程打印完后主线程才能结束</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁目标互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对普通锁加锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>销毁一个已经加锁的互斥锁 会发生不可预期的后果<br>也可使使用宏<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化一个互斥锁<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p><p><strong>互斥锁属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destory</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTHREAD_PROCESS_SHARED 跨进程共享</span></span><br><span class="line"><span class="comment">// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_NORMAL 普通锁 默认类型</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_ERRORCHECK 检错锁</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_RECURSVE 嵌套锁</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_DEFAULT 默认锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>PTHREAD_MUTEX_NORMAL<br>一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平<br>A线程对一个<code>已经加锁</code>的普通锁<code>再次加锁(也是A线程)</code>-同一线程在解锁前再次加锁引发死锁<br>对一个已经<code>被其他线程加锁</code>的普通锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的普通锁–解锁-不可预期后果</p><p>PTHREAD_MUTEX_ERRORCHECK<br>线程对<code>已经加锁</code>的检错锁<code>再次加锁</code>–加锁-加锁操作返回EDEADLK<br>对一个已经<code>被其他线程加锁</code>的检错锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的检错锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_RECURSVE<br>允许一个线程在释放锁前多次加锁 而不发生死锁.<br>如果<code>其他线程</code>要获得这个锁, 则<code>当前锁拥有者</code>必须执行相应次数的解锁操作–加锁<br>对于<code>已经被其他进程</code>加锁的嵌套锁解锁, 或者对<code>已经解锁</code>的再次解锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_DEFAULT<br>这种锁的实现可能为上面三种之一<br>对已经加锁的默认锁再次加锁<br>对被其他线程加锁的默认锁解锁<br>再次解锁已经解锁的默认锁<br>都将会发生不可预料后果</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">t</span><span class="params">(<span class="type">void</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thread[i], <span class="literal">nullptr</span>, t, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> pthread_condattr *cond_attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cont_destory</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播式的唤醒所有等待目标条件变量的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cont_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒一个等待目标条件变量的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待目标条件变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>将各个字段初始化为0</p><p>pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁<br>掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.<br>函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁</p><p>从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值<br>也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,<br>将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">int</span> good = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> produce_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> consume_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Producer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(produce_count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        good++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        produce_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;produce a good\n&quot;</span>);</span><br><span class="line"><span class="comment">// 通知一个线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (consume_count &lt; <span class="number">13</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 传入前需要加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (good &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            good--;</span><br><span class="line">            consume_count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consume a good, reset %d\n&quot;</span>, good);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;good is 0\n&quot;</span>);</span><br><span class="line">            <span class="comment">// wait pthread_cond_signal</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">    <span class="type">pthread_t</span> producer, consumer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer, <span class="literal">nullptr</span>, Consumer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer, <span class="literal">nullptr</span>, Producer, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h2 id="线程同步包装类-多线程环境"><a href="#线程同步包装类-多线程环境" class="headerlink" title="线程同步包装类-多线程环境"></a>线程同步包装类-多线程环境</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;sem_, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;sem_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;sem_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;sem_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;cond_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里我一开始没有想到..</span></span><br><span class="line">            <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond_);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;cond_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件</p><p>多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程<br>子进程只有一个线程-调用fork线程的完美复制</p><p>但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但<code>不是由</code>调用fork线程<br>锁住的, 此时<code>子进程</code>再次对这个互斥锁<code>执行加锁</code>操作将会<code>死锁</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, lock the mutex\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 解锁后 Prepare才能加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个函数在fork创建子进程前被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行</span></span><br><span class="line">    <span class="comment">// 这个函数执行完毕前fork不会创建子进程</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fork创建线程后 返回前 会在子进程和父进程中执行这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Infork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// pthread_atfork(Prepare, Infork, Infork);</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;emmm????\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(id, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process, want to get the lock\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i cann&#x27;t run to here, opps....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait start\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait over\n&quot;</span>); <span class="comment">// 没有打印 因为子进程不会终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $ in child thread, lock the mutex</span></span><br><span class="line"><span class="comment">// $ wait start</span></span><br><span class="line"><span class="comment">// $ child process, want to get the lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $ in child thread, lock the mutex</span></span><br><span class="line"><span class="comment">// $ wait start</span></span><br><span class="line"><span class="comment">// $ child process, want to get the lock</span></span><br><span class="line"><span class="comment">// $ i cann&#x27;t run to here, opps....</span></span><br><span class="line"><span class="comment">// $ wait over</span></span><br></pre></td></tr></table></figure><p>原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_atfork</span> <span class="params">(<span class="type">void</span> (*__prepare) (<span class="type">void</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> (*__parent) (<span class="type">void</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> (*__child) (<span class="type">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>第一个句柄 在fork创建子进程前执行<br>第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行<br>第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十四章-多线程编程&quot;&gt;&lt;a href=&quot;#第十四章-多线程编程&quot; class=&quot;headerlink&quot; title=&quot;第十四章 多线程编程&quot;&gt;&lt;/a&gt;第十四章 多线程编程&lt;/h1&gt;&lt;p&gt;根据运行环境和调度者身份, 线程可以分为两种&lt;br&gt;内核线程&lt;br&gt;运行在内</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    <category term="系统编程" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="多线程" scheme="http://icecorn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
</feed>
