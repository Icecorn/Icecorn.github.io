<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-07-01T06:17:38.760Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式|一文搞懂单例模式！</title>
    <link href="http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-29T09:25:10.000Z</published>
    <updated>2022-07-01T06:17:38.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文搞定单例模式"><a href="#一文搞定单例模式" class="headerlink" title="一文搞定单例模式"></a>一文搞定单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过单例模式， 可以做到：确保一个类只有一个实例被建立 ，也就是C++中定义全局的东西的一个通用做法。</p><p>在实现单例的过程中要注意如下问题：</p><ul><li>构造函数应该声明为非公有，从而禁止外界创建实例</li><li>拷贝操作和移动操作也该禁止</li><li>只能通过singleton的共有特定类操作访问它的唯一实例（c++中的一个公有静态成员函数）</li></ul><p>本文实现常见的饿汉式及懒汉式，以及多线程懒汉式的单例模式</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式顾名思义，就是我先准备好一个全局的实例，等到你需要getInstance的时候就直接获取就行了，普通的饿汉式的缺点就是以”空间换时间”，就是说在编译阶段已经给这个类在<strong>全局数据区</strong>分配好了内存并初始化了。</p><h3 id="C98的饿汉模式"><a href="#C98的饿汉模式" class="headerlink" title="C98的饿汉模式"></a>C98的饿汉模式</h3><p>在C++98版本，为了实现线程安全，要把istance实现成一个类内的成员变量，并且要在类外初始化它，不然编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------C98饿汉模式单例-----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton98</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="built_in">CSingleton98</span>()      </span><br><span class="line">    &#123;   </span><br><span class="line">a = <span class="number">98</span>; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c98饿汉模式单例使用全局静态对象，在编译时已经调用单例类构造函数分配内存并实例化出来了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton98 * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> CSingleton98 instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a; <span class="comment">//类中其他变量,这里懒得写get/set方法</span></span><br><span class="line">&#125;; </span><br><span class="line">CSingleton98 CSingleton98:: instance;<span class="comment">//在类外初始化</span></span><br></pre></td></tr></table></figure><p>我们在main函数中什么都不做打印试试看：</p><p>可以看到执行了单例类的构造函数，说明这种饿汉模式是在编译阶段已经在全局数据区分配了内存并初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701124104249.png" alt="image-20220701124104249"></p><p>接着我们用如下代码测试，可以看到两次获取实例对象的地址是一致的，单例ok！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CSingleton98* inst98= CSingleton98::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingleton98* inst981= CSingleton98::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst98-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;(*inst98) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;(*inst981) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701124532493.png" alt="image-20220701124532493"></p><h3 id="C11的饿汉模式"><a href="#C11的饿汉模式" class="headerlink" title="C11的饿汉模式"></a>C11的饿汉模式</h3><p>C11的饿汉模式表现在我们是将单例的instance作为一个局部static变量处理的（在函数内）</p><p><strong>优点：</strong></p><ul><li><strong>只有在程序第一次执行到GetInstance()函数的时候才会在全局数据区开辟内存并且初始化，也就是说我们没有在编译的时候就开辟内存，节省了不必要的空间开销！</strong></li><li><strong>解决了static变量初始化的问题</strong></li></ul><blockquote><p>C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。</p><p>然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局唯一的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。</p><p>这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。</p><p>而<code>Meyers&#39; Singleton</code>写法中，单例对象是第一次访问的时候（也就是第一次调用<code>getInstance()</code>函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先<code>getInstance()</code>再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！</p><p>讲到这，我们对<code>Meyers&#39; Singleton</code>的盲目鼓吹也需冷静一下，因为C++同样能保证所有文件内（非函数内）的static变量在main()函数开始运行之后肯定是都能做完初始化的。所以如果你是在main()函数运行之后，用日志管理器的单例访问配置文件的单例，那么其实也是没有问题的… 这就引出<code>Meyers&#39; Singleton</code>的第二个优势，那就是当产生继承的时候。</p></blockquote><p><strong>这里有一个遗留问题：就是编译器在编译阶段如何决定先编译哪一个单例文件呢，由此产生的文件依赖问题怎么解决呢？</strong></p><ul><li>解决了单例的继承问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;Singleton::isOn = <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;Singleton::isOn = <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">state</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Singleton::isOn;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isOn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span>: <span class="keyword">public</span> Singleton &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addBrightness</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; brightness += val;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">subBrightness</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; brightness -= val;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getBrightness</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brightness;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> brightness;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果有子类继承这一父类，来拓展成新的子类，比如Monitor显示器类有开关状态，同时扩展了一个亮度的成员。但是父子类的static成员变量是共享的，其isOn成员会有问题。</p><p>场景：比如一个显示器类，一个灯类。他们都是singleton的子类。但是灯是否打开，不应该影响显示器是否打开</p><p><strong>静态局部对象：</strong></p><ul><li>在程序执行到该对象的定义处时，创建对象并调用相应的构造函数！</li><li>如果在定义对象时没有提供初始指，则会暗中调用默认构造函数，如果没有默认构造函数，则自动初始化为0。</li><li>如果在定义对象时提供了初始值，则会暗中调用类型匹配的带参的构造函数（包括拷贝构造函数），如果没有定义这样的构造函数，编译器可能报错！</li><li>直到main（）结束后才会调用析构函数！</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton11</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="built_in">CSingleton11</span>()      </span><br><span class="line">    &#123;    </span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C11饿汉模式使用的是局部static变量，是在调用的时候分配到全局存储区的，不是在编译时就分配哦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是因为C11的编译器可以帮我们保证线程安全，俺们就不用操心啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton11 * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line"><span class="comment">//静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</span></span><br><span class="line">        <span class="type">static</span> CSingleton11 instance;     </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>以下是测试：</p><p>首先是main函数什么都不做：</p><p>结果就是什么都不会发生（笑，想起了莫里亚篇索隆对山治说的话，和最近的CP0段子哈哈哈）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701125704906.png" alt="image-20220701125704906"></p><p>调用GetInstance：</p><p>此时会在全局数据区开辟内存，并调用构造函数初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSingleton11* inst11= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701125910795.png" alt="image-20220701125910795"></p><p>调用两次GetInstance：</p><p>此时只会调用一次构造函数，这正是局部static变量的特性（静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSingleton11* inst11= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingleton11* inst112= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;(*inst11) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;(*inst112) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701130227454.png" alt="image-20220701130227454"></p><p><strong>这里顺便加深下记忆：</strong></p><p>如果是全局static变量声明两次的话，编译器会报错的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;                   <span class="comment">//打咩！</span></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701130526478.png" alt="image-20220701130526478"></p><p>这是C11下优化的饿汉模式单例，至于怎么保证线程安全的（不用加锁），这是C11编译器保证的！以后有时间再看！</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式的特点就是延迟加载，只有到用到的时候才实例化instance</p><p><strong>这里又有一个疑问：这么考虑的话上文的C11饿汉模式不应该是懒汉模式嘛？</strong></p><p>注意这里最下边一行实际上在编译之前实例化一个指针变量，但是相比于类变量，一个指针才4个字节而已，who cares！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingletonL</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line"><span class="function"><span class="type">static</span> CSingletonL* <span class="title">GetInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span> ( m_pInstance == <span class="literal">nullptr</span> )    </span><br><span class="line">m_pInstance = <span class="keyword">new</span> <span class="built_in">CSingletonL</span>();  </span><br><span class="line"><span class="keyword">return</span> m_pInstance;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="built_in">CSingletonL</span>()&#123;lazy = <span class="number">3</span>;&#125;  </span><br><span class="line">    <span class="type">static</span> CSingletonL* m_pInstance;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> lazy;</span><br><span class="line">&#125;;</span><br><span class="line">CSingletonL* CSingletonL::m_pInstance;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSingletonL* instlazy = CSingletonL::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingletonL* instlazy1 = CSingletonL::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; instlazy-&gt;lazy &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp; (*instlazy) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp; (*instlazy1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701132606657.png" alt="image-20220701132606657"></p><h3 id="懒汉模式存在的问题"><a href="#懒汉模式存在的问题" class="headerlink" title="懒汉模式存在的问题"></a>懒汉模式存在的问题</h3><p>在懒汉式的单例类中，其实有两个状态，单例未初始化和单例已经初始化。假设单例还未初始化，有两个线程同时调用GetInstance方法，这时执行 m_pInstance == NULL 肯定为真，然后两个线程都初始化一个单例，最后得到的指针并不是指向同一个地方，不满足单例类的定义了，所以懒汉式的写法会出现线程安全的问题！在多线程环境下，要对其进行修改。</p><h2 id="深入的理解懒汉和饿汉"><a href="#深入的理解懒汉和饿汉" class="headerlink" title="深入的理解懒汉和饿汉"></a>深入的理解懒汉和饿汉</h2><p>其实就是看定义的事静态成员对象变量还是静态成员对象指针变量，因为如果定义了静态成员对象变量，程序在运行之初已经分配了空间，就要调用构造函数了，而你在调用getinstance的时候，不会再调用构造函数了，因为之前已经调用过了，你就是用的现成的，就是所谓的饿汉模式，上来先把吃的准备好了，因为饿怕了，怕后期准备会挨饿。</p><p>而定义了静态成员对象指针变量，程序运行之初也会分配空间，但是那个是指针的空间，而不是对象的空间，所以不会调用对象的构造函数，而只有调用getinstance进行new操作的时候，才会对其调用构造函数，就是现上轿现扎耳朵眼，比较懒惰，所以叫懒汉模式。</p><h2 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h2><p>使用double-check来保证不会每次进来都去获取锁，来提高性能，先判断不为空的话，直接返回了数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">static</span> Singleton* m_instance;  </span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">Lock</span>();<span class="comment">//借用其它类来实现，如boost  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">UnLock</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> m_instance;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="面试单例代码"><a href="#面试单例代码" class="headerlink" title="面试单例代码"></a>面试单例代码</h2><p>最后是面试的简单单例代码，用C11饿汉实现哦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singletonPractice</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singletonPractice* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> singletonPractice m_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">singletonPractice</span>(<span class="type">const</span> singletonPractice&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    singletonPractice&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singletonPractice&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">singletonPractice</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    singletonPractice* in1 = singletonPractice:: <span class="built_in">getInstance</span>();</span><br><span class="line">    singletonPractice* in2 = singletonPractice:: <span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;(*in1) &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; &amp;(*in2) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<br><a href="https://blog.csdn.net/zhanghuaichao/article/details/79459130">https://blog.csdn.net/zhanghuaichao/article/details/79459130</a><br><a href="https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA">https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文搞定单例模式&quot;&gt;&lt;a href=&quot;#一文搞定单例模式&quot; class=&quot;headerlink&quot; title=&quot;一文搞定单例模式&quot;&gt;&lt;/a&gt;一文搞定单例模式&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="C++" scheme="http://icecorn.github.io/categories/C/"/>
    
    <category term="设计模式" scheme="http://icecorn.github.io/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://icecorn.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（二）|动态规划专题</title>
    <link href="http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E7%84%B6%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E7%84%B6%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-06-25T09:25:10.000Z</published>
    <updated>2022-07-06T15:35:04.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解动态规划"><a href="#详解动态规划" class="headerlink" title="详解动态规划"></a>详解动态规划</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>动态规划是一种自下而上的思想，每一个问题，把它们转化成相同原理的更小的子问题，解题关键主要有两点：</p><ul><li>找到状态转移方程</li><li>初始值的设置，这里可以开辟一个大一些的数组，防止段错误</li></ul><p><strong>另外还有一个重点是，一定要细心，通常解题中会有dp数组和原始的数据数组，什么时候用什么下标一定要仔细考虑，比如dp数组大小设置成了n+1,那么i=1时，原始数据数组应该用nums[0],虽然很弱智，但不注意搞错了debug就会很难受</strong></p><hr><h2 id="基本DP：一维"><a href="#基本DP：一维" class="headerlink" title="基本DP：一维"></a>基本DP：一维</h2><p>典型的就是青蛙跳这种，比较简单，状态转移方程类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><p>另一种比较特殊的，我们不能用dp[i]来存储最终结果，我们要用dp[i]来存储<strong>以当前i节点结尾的满足题意的状态</strong>，然后对整个dp数组求和。</p><p>比如：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706152248411.png" alt="image-20220706152248411"></p><p>这里我们用dp[i]来表示以该位置结尾的等差数列个数，因为等差数列随时可能会断掉，断掉的位置i的dp[i]就设置为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>] - nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="基本DP：二维"><a href="#基本DP：二维" class="headerlink" title="基本DP：二维"></a>基本DP：二维</h2><p>这里比较代表性的就是给一个二维矩阵，机器人从左上到右下经过的最短路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br></pre></td></tr></table></figure><p>特殊一些的比如lc-221题，算最大全是1的正方形面积，这种题就需要找到题目的一些规律性，寻找状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="分割类问题"><a href="#分割类问题" class="headerlink" title="分割类问题"></a>分割类问题</h2><p>代表例子lc-279，lc-139，核心思路就是在dp遍历里边套一层枚举，就是说dp的每一个元素有很多种可能，我们要枚举出来，然后根据题意选最大或最小之类的</p><p>lc-139<br>给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字 符串都可以在集合内找到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> string &amp; word: wordDict) &#123;</span><br><span class="line"><span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span> (i &gt;= len &amp;&amp; s.<span class="built_in">substr</span>(i - len, len) == word) &#123;</span><br><span class="line">dp[i] = dp[i] || dp[i - len];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对每一个dp[i]，从后往前减去一段，把它变成一个子问题再处理，类似用硬币组成数字问题。</p><hr><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>还是一样的思路，dp[i]表示以i结尾的数组的最长递增子序列，里边枚举一下i之前的所有dp，如果nums[i] &gt; nums[j]就是长度+1，如果&lt;=则dp[i] = 0;</p><p><strong>要注意的是此题有很多种其他的问法<br>比如给一个数组，让你去掉k个数，使之变成单调递增的数组，其实就是求最长递增子序列，再用总数n-最长递增子序列=k</strong><br><strong>还有变成单调递减，先递增再递减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> max_length = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题for循环内还可以改成二分法加快速度</p><p>就是在已经有的递增数组里边找dp[i]的位置，再替换即可</p><hr><h2 id="公共元素问题"><a href="#公共元素问题" class="headerlink" title="公共元素问题"></a>公共元素问题</h2><h3 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h3><p>这种题目思路就是我们要开一个二维数组，dp【i】【j】，代表以i，j结尾的两个a，b的子字符串从后往前有几个公共的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;abcbced&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;acbcbce&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706150443331.png" alt="image-20220706150443331"></p><p>然后相同的地方设置为1，不同的地方设置为0，然后我们最后就是找最长的连续的对角线的长度就是最长的公共子串了</p><p>很容易得到状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然题目可能是让你返回最长的长度，或者最长字符串，因题返回就好。</p><p><strong>注意这里的最长子串需要遍历dp才能得到，而不是直接返回最后的元素</strong></p><hr><h3 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h3><p>子序列和子字符串不同的地方在于它不那么严格，就是不连续的也可以，所以它的转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706183545329.png" alt="image-20220706183545329"></p><p>如图所示，得到状态转移方程：<br>i是有多少种物品，j是背包的容积<br>核心思想就是对一个dp元素，我们有两种选择，一种是选当前的i物品，一种是不选。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&gt;=V[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">     dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-V[i<span class="number">-1</span>]]+ W[i<span class="number">-1</span>]);</span><br><span class="line"> &#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>全部代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706183951928.png" alt="image-20220706183951928"></p><p>我们可以发现状态转移方程只和上一行有关，那么很自然的想到可以将二维dp矩阵优化成一位来进行处理。</p><p><strong>这里的问题是，如果我们还是从前往后处理的话，那么后边元素所依赖的“上一行”的结果就会被覆盖掉，所以要从后往前遍历</strong>，而且对于不选的情况，直接使用上一行的结果就行了，不用特殊处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line"><span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w; --j) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>可以在01背包的基础上考虑，01是每一行物品只有一个，要么拿，要么不拿，完全背包呢，是一个东西可以无限拿，那么自然的想到，在每个dp里加一个循环，枚举出拿几个当前物品，一直到拿爆为止。</p><p>首先写一个二维dp基础版本的：</p><p>这里要注意的是k取0的时候其实就把“不取”这个情况给做了。</p><p>需要注意的是这种没优化过的超级暴力代码，有三层循环，1000*1000的用例是没法过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;v+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*V[i]&lt;=j;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-k*V[i]]+k*W[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[n][v]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来优化成用一维数组，同样要倒序进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*V[i]&lt;=j;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*V[i]]+k*W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码只是空间上优化了一丢丢，本质上还是O（n3）的，要想办法在时间复杂度上进行优化。</p><p><strong>想一下，我们不从后往前进行，直接从前往后进行处理，这样后一个dp[j]状态转移获取dp[j-x]的时候，其实dp[i-x]已经“拿了一些该物品的状态“，也就是说dp[j-x]在它的那个位置已经达到了一个最优解，那么到dp[j]的位置的时候我们实际上只要考虑再拿一次物品i，或者不拿物品i</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;v+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=V[i]) <span class="comment">//这里一定要注意要判断当前的空间j能不能装下物品V[i]</span></span><br><span class="line">                &#123;           </span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-V[i]]+W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<strong>完全背包</strong>和<strong>01背包</strong>在优化到最后的形态其实只有<strong>正序处理</strong>和<strong>反序处理</strong>之分，这里我们清楚知道它的原理就行，笔试直接写优化后的简单形式，简单粗暴！</p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>多重背包实际上就是完全背包的拓展，或者说完全背包是多重背包的一种特殊情况，区别于完全背包，多重背包显示的告诉了我们一个物品最多拿几次，那么我们只需要枚举每种可能就好啦~</p><p>当然也是要逆向处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w,t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w&gt;&gt;t;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">            num[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=num[i];++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k*V[i]&lt;=j)<span class="comment">//需要我们判断不要拿爆了！</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*V[i]]+k*W[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包的优化"><a href="#多重背包的优化" class="headerlink" title="多重背包的优化"></a>多重背包的优化</h3><ul><li>一种是用二进制优化，核心思路是把多重背包拆成很多个01背包</li><li>单调队列优化</li></ul><p>这里先不写了，毕竟是面向找工作学算法：），已经过了打ACM的年纪了55555</p><p>关于背包还有一些变种问题：</p><p>混合背包，二维费用背包，分组背包，有依赖的背包，背包求方案数等等，都先不考虑了，留个指针之后看：</p><p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html">https://www.cnblogs.com/jbelial/articles/2116074.html</a></p><p><a href="https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317">https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317</a></p><p><a href="https://www.acwing.com/problem/">https://www.acwing.com/problem/</a></p><hr><h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><p>Lc-72：</p><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可 以将两个字符串变成相同</p><p>想法就是用dp每一位代表的是当前word1串截止到i的长度和word2串截止到j的长度，它们转换的最小次数。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706222023638.png" alt="image-20220706222023638"></p><hr><h2 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h2><p>这个先放着，之后单独算一个专题来写吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详解动态规划&quot;&gt;&lt;a href=&quot;#详解动态规划&quot; class=&quot;headerlink&quot; title=&quot;详解动态规划&quot;&gt;&lt;/a&gt;详解动态规划&lt;/h1&gt;&lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第七课-渲染管线-后处理-其他渲染知识</title>
    <link href="http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/"/>
    <id>http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/</id>
    <published>2022-06-19T09:25:10.000Z</published>
    <updated>2022-06-29T16:26:46.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七课-渲染管线-后处理–其他渲染知识"><a href="#第七课-渲染管线-后处理–其他渲染知识" class="headerlink" title="第七课 渲染管线-后处理–其他渲染知识"></a>第七课 渲染管线-后处理–其他渲染知识</h2><h3 id="环境光遮蔽-AO"><a href="#环境光遮蔽-AO" class="headerlink" title="环境光遮蔽 AO"></a>环境光遮蔽 AO</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181526.png"></p><p>预计算出AO贴图</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181837.png"></p><p>SSAO</p><p>在屏幕上存储深度信息，设置一些采样点，根据采样点和z-buffer的深度比较来计算最终的光强</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181923.png"></p><p>SSAO+</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182321.png"></p><p>HBAO</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182427.png"></p><p>GTAO</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182556.png"></p><h3 id="雾效-Fog"><a href="#雾效-Fog" class="headerlink" title="雾效 Fog"></a>雾效 Fog</h3><p>简单的fog，根据深度Z从近到远透明度逐渐减小</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182921.png"></p><p>考虑到高度信息时，简单的fog公式就不起作用了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183105.png"></p><hr><h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>采样率不够就会导致走样</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183444.png"></p><h4 id="SSAA和MSAA"><a href="#SSAA和MSAA" class="headerlink" title="SSAA和MSAA"></a>SSAA和MSAA</h4><p>SSAA就是最简单朴素的横竖都扩大一倍采样率，带来的性能代价是很高的。MSAA相比SSAA有一个改动就是在最后pixel shading的时候把一些不必要的shading’去掉了，减少最后shading的次数。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183748.png"></p><h4 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a>FXAA</h4><p>因为锯齿大多发生在边缘轮廓，所以从轮廓着手找到轮廓线再用一个滤波器去插值，已达到抗锯齿的效果。</p><p>注意这里阈值是0.05，这个卷积核和sobel卷积核不一样，不是常规意义上的提取轮廓。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531184456.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531185020.png"></p><p> 混合附近像素的颜色，算插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200105.png"></p><h4 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h4><p>时序反走样</p><p>同时可做鬼影，拖尾等效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200246.png"></p><hr><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><p>Bloom，Tone mapping（曝光），ColornGrading（调色）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200631.png"></p><h4 id="Bloom"><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h4><p>首先把图片亮度高的地方提取出来（注意是RGB，不是灰度）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200945.png"></p><p>加一个模糊效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201109.png"></p><p>这里针对光晕大但是不能使高斯核太大的情况，采用downsample几次再upsample的hack，大概和dualkawase模糊差不多？</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201307.png"></p><p>最后叠加在原图上</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201741.png"></p><h4 id="Tone-Mapping"><a href="#Tone-Mapping" class="headerlink" title="Tone Mapping"></a>Tone Mapping</h4><p>因为真实世界的光照强度range很宽，假设是0-50，那么要把0-50的range映射到0-1这就是Tone Mapping</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201910.png"></p><p>一个映射曲线的shader</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202043.png"></p><p>电影工业界的颜色曝光曲线</p><p>这个东西其实都是人为根据经验来拟合出来的曲线</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202436.png"></p><h4 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h4><p>LUT映射</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202543.png"></p><p>一般lut不用存256*256那么大，因为颜色是连续的，可以只存32 * 32的采样，然后插值即可</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202617.png"></p><h3 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531203320.png"></p><h4 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h4><p>前向渲染两个问题</p><ul><li>处理透明物体的渲染顺序会出问题。一般是由远及近来渲染。</li><li>处理多光源很吃性能。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531203556.png"></p><h4 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h4><p>就是分两个pass，第一个pass渲染一遍所有的物体但是不考虑光照，把物体材质信息存储到G-buffer里</p><p>第二个pass在像素级别上处理光照就好</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531204017.png"></p><p>怎样减少读写G-buffer消耗的资源？</p><p>可以把屏幕分成一个个小块（Tiles），这样每个像素只要读对应的小块纹理而不用整张g-buffer都读进去。这样还有另一个好处是光源也不用每次都遍历所有的了，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531204627.png"></p><p>更进一步，可以做Early-Z，就是说在世界空间下，我们就能知道每个光源所能照到的深度信息，从而在渲染光的时候进行剪枝。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531205034.png"></p><h4 id="Visibility-Buffer"><a href="#Visibility-Buffer" class="headerlink" title="Visibility Buffer"></a>Visibility Buffer</h4><p>现代渲染中，很多时候模型的面片比像素还多，这时候可以存VisibilityBuffer存几何信息反向查找材质信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531205652.png"></p><h4 id="Frame-Graph"><a href="#Frame-Graph" class="headerlink" title="Frame Graph"></a>Frame Graph</h4><p>现代游戏pipline过于复杂，要借助Frame Graph工具将每个步骤算法所用的内存之类的管理起来，方便开发，定位bug</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531210350.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第七课-渲染管线-后处理–其他渲染知识&quot;&gt;&lt;a href=&quot;#第七课-渲染管线-后处理–其他渲染知识&quot; class=&quot;headerlink&quot; title=&quot;第七课 渲染管线-后处理–其他渲染知识&quot;&gt;&lt;/a&gt;第七课 渲染管线-后处理–其他渲染知识&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第六课-渲染系统-地形大气和云的渲染</title>
    <link href="http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/"/>
    <id>http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/</id>
    <published>2022-06-16T09:25:10.000Z</published>
    <updated>2022-06-29T16:26:59.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六课-地形大气和云的渲染"><a href="#第六课-地形大气和云的渲染" class="headerlink" title="第六课 地形大气和云的渲染"></a>第六课 地形大气和云的渲染</h2><h3 id="地形的几何"><a href="#地形的几何" class="headerlink" title="地形的几何"></a>地形的几何</h3><h4 id="Heightfield"><a href="#Heightfield" class="headerlink" title="Heightfield"></a>Heightfield</h4><p>数学上的分形方法</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529152911.png"></p><p>每隔1m画一个10000*1000的网格，然后根据高度场，轮廓场等进行映射就可以</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153037.png"></p><p><strong>LOD技术</strong></p><p>就是根据距离远近应用不同分辨率的网格，这里要根据FOV视角的范围进行各向异性的加密或简化网格。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153427.png"></p><p>细分方法</p><p>注意T-Junctions的问题</p><ul><li><p>三角形剖分<img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153733.png"></p></li><li><p>四叉树细分</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153833.png"></p><p>解决T-Junction问题，就把剖分次数多的一边中间的节点平滑到另一边的角点上是两个点重合，这样实际上就产生了一个面积为0的三角形，也就是网格的退化，一般面积为0的三角形在渲染时直接不渲染。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529154514.png"></p></li></ul><h4 id="TIN方法"><a href="#TIN方法" class="headerlink" title="TIN方法"></a>TIN方法</h4><p>Triangulated Irregular Network</p><p>就是直接用不规则的三角形来表达地形，简化不必要的顶点，并加上需要的特征</p><p>好处是可以减少很多三角形，比之前的方法少了一个数量级</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529154829.png"></p><p>显卡架构，有细分着色器，domainshader等等，可以直接再gpu里边生成细分网格甚至能完成映射扰动的实现。</p><p>最新的显卡架构把以上这些着色器整合成了MeshShader更加方便，有了gpu的加持，甚至可以实现runtime的事实地形交互，比如炮弹打到地上使得网格发生形变出现个坑。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529155134.png"></p><h4 id="制作山洞的一个hack方法"><a href="#制作山洞的一个hack方法" class="headerlink" title="制作山洞的一个hack方法"></a>制作山洞的一个hack方法</h4><p>直接把山体网格要打洞的顶点那里给一个属性把他的position设置成NAN，这样再显卡中就会把所有包含这个顶点的三角形都忽略掉不渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160422.png"></p><h4 id="体素化表达"><a href="#体素化表达" class="headerlink" title="体素化表达"></a>体素化表达</h4><p>虽然目前游戏引擎还没有大规模应用，但是其实可以考虑直接用体素来表达地形模型，而不是二维流形网格，这样实际上就直接有了三维的信息，也就是说地形山体等都不是空心的了，可以跟直接的操作打洞等等。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160719.png"></p><hr><h3 id="地形的材质"><a href="#地形的材质" class="headerlink" title="地形的材质"></a>地形的材质</h3><p>就用之前的MR材质，存一些东西</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160847.png"></p><p>Height贴图的作用，就是这种地形需要沙子和石头之间渐变的时候，根据高度信息进行混合。</p><p>当然这种渐变过程中因为数值精度可能会有一些抖动，这时可以设置一些扰动保证稳定性。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161010.png"></p><p>通过不同的权重和不同的材质来混合得到想要的效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161300.png"></p><h4 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h4><p>parallax mapping就是扰动法线贴图使视觉上具有更强的凹凸感，而displacement mapping则是更彻底的用高度信息直接更改地形网格面片</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161441.png"></p><p><strong>问题：性能代价</strong></p><p>因为纹理采样实际上是一个很费的操作，如果每一个像素都混合4张纹理，那么就需要重复采样很多次，性能爆炸</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161924.png"></p><p><strong>解决办法：虚拟纹理</strong></p><p>这里就是和虚拟内存一样的概念，就是把纹理分块，实际用到哪块就读哪块进入内存而不是整个纹理都读进来，因为我们在游戏中视锥呈现的范围实际上只有纹理中的一小块。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162015.png"></p><h4 id="新的技术"><a href="#新的技术" class="headerlink" title="新的技术"></a>新的技术</h4><p>传统的读纹理都是cpu读进内存，然后解压，然后传给gpu。 </p><p>而DirectStorage技术就是cpu读进内存不解压直接传到gpu在gpu中完成解压，提高性能</p><p>而更牛逼的DMA技术就是直接从硬盘读到gpu显存里去了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162715.png"></p><h4 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h4><p>网格数量越大，越精细就会引起精度不够用的问题，因为float使用32个bit组成的，这样就会出现摩尔纹和锯齿问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162824.png"></p><p>解决方法：</p><p>粗暴的方法就是扩展精度，比如用double来存</p><p>还可以用下图中把相机重置到gameobject坐标中，搞成相对距离解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163105.png"></p><h4 id="植被道路贴花"><a href="#植被道路贴花" class="headerlink" title="植被道路贴花"></a>植被道路贴花</h4><p>树专门的LOD方法，近处用网格，远处就插片，越远越稀疏</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163422.png"></p><p>Decorator Rendering</p><p>渲染小石头，草，灌木丛等等，一般用小面片，也有很专门的技术</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163512.png"></p><p>道路系统渲染</p><p>用样条曲线编辑道路</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163641.png"></p><hr><h3 id="大气散射理论"><a href="#大气散射理论" class="headerlink" title="大气散射理论"></a>大气散射理论</h3><h4 id="简单的模型"><a href="#简单的模型" class="headerlink" title="简单的模型"></a>简单的模型</h4><p>根据物理规律拟合一个模型，需要两个参数一个是向上看的角度到天顶的夹角（一般是0-Π），另一个是现在看到高度和太阳的夹角。根据这两个夹角去查表LUT</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529190658.png"></p><h4 id="粒子媒介"><a href="#粒子媒介" class="headerlink" title="粒子媒介"></a>粒子媒介</h4><p>使用更加精细的模型渲染天空，大气由很多粒子，气溶胶组成</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529191019.png"></p><p>光在大气中的规律用四个参数描述：</p><p>从左到右依次为：吸收多少光，像四面八法散射多少，自发光强度，其他粒子对该粒子入射的光</p><p>实际上就是4中不同的梯度</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529191159.png"></p><p>VRE：对上边梯度进行积分</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529191739233.png" alt="image-20220529191739233"></p><p>Transmittance：通透度，意思就是在远处看到一个东西，它有多少能透视到当前点。</p><p>Scattering part：光路打到路径上的气体分子发生一些散射，这些散射路径返回了多少能量。</p><h4 id="大气物理学"><a href="#大气物理学" class="headerlink" title="大气物理学"></a>大气物理学</h4><p>真是的大气物理，主要的元素是太阳，向外辐射不同波长的光，然后大气中有气体分子（它们的大小一般小于阳光波长），还有气溶胶分子（它们的大小一般和阳光波长差不多）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529192645.png"></p><p>两种</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529192851.png"></p><p>//TODO  mark以下，下次再看这一块</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六课-地形大气和云的渲染&quot;&gt;&lt;a href=&quot;#第六课-地形大气和云的渲染&quot; class=&quot;headerlink&quot; title=&quot;第六课 地形大气和云的渲染&quot;&gt;&lt;/a&gt;第六课 地形大气和云的渲染&lt;/h2&gt;&lt;h3 id=&quot;地形的几何&quot;&gt;&lt;a href=&quot;#地形的几</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第五课-渲染系统-光照与材质</title>
    <link href="http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/"/>
    <id>http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/</id>
    <published>2022-06-10T09:25:10.000Z</published>
    <updated>2022-06-29T16:11:21.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五课-渲染系统–光照和材质"><a href="#第五课-渲染系统–光照和材质" class="headerlink" title="第五课 渲染系统–光照和材质"></a>第五课 渲染系统–光照和材质</h2><h3 id="渲染方程与挑战"><a href="#渲染方程与挑战" class="headerlink" title="渲染方程与挑战"></a>渲染方程与挑战</h3><h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>渲染方程就是一个解积分的过程，一个点最终的光照=它本身的发光强度+所有其他方向的入射光在对应角度的投影</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529091653.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529091714.png"></p><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><ul><li><p>阴影效果</p><p>一个点是否能看得见，是否被遮挡时很难判断处理的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092310.png"></p></li><li><p>光源本身很复杂</p><p>比如面光源</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529092529789.png" alt="image-20220529092529789"></p></li><li><p>积分怎么做</p><p>渲染方程里的积分部分怎么处理，光和材质的卷积如何计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092816.png"></p></li><li><p>光的不断反射形成复杂的光影效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092932.png"></p></li></ul><hr><h3 id="基础光照解决方案"><a href="#基础光照解决方案" class="headerlink" title="基础光照解决方案"></a>基础光照解决方案</h3><p>使用点光源等简单光源当做主光，其他光源用低频环境光来模拟</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093254.png"></p><p>使用环境光贴图来模拟反射光等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093551.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093716.png"></p><h4 id="布林-冯模型"><a href="#布林-冯模型" class="headerlink" title="布林-冯模型"></a>布林-冯模型</h4><p>环境光+漫反射+镜面反射 </p><p>一个问题是它的能量不守恒，渲染什么东西都像塑料：）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529094311.png"></p><h4 id="shadow处理"><a href="#shadow处理" class="headerlink" title="shadow处理"></a>shadow处理</h4><p>shadow map</p><p>思路就是从像素位置反向追踪到每个光源，看看到下一次反射的距离是否等于到光源的距离，从而判断出这个像素对这个光源来说是否可见</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529094812.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过以上方法将复杂的渲染抽象简化，解决几个挑战，当然效果不是特别理想</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529095257.png"></p><hr><h3 id="基于预计算的全局光照"><a href="#基于预计算的全局光照" class="headerlink" title="基于预计算的全局光照"></a>基于预计算的全局光照</h3><p><strong>预计算：就是空间换时间的一种手段，把一些场景中不动的地方全部预计算存储起来</strong></p><p><strong>全局光照：就是考虑间接光照对场景的影响，也就是说要算光的几次反射，迭代收敛</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529095728.png"></p><p>那么如果迭代计算几次光照，这样产生的计算量是指数增加的，所以要找一个高效的方法来计算</p><h4 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h4><p>把时域信息转到频域信息上去处理，这样可以大幅度压缩信息的数据</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529100142.png"></p><h4 id="球面调和函数"><a href="#球面调和函数" class="headerlink" title="球面调和函数"></a>球面调和函数</h4><p>是一组sin cos的函数集组成的基函数</p><p>这块和下边的部分没听懂，大概目的是为了把数据降维参数化到低维进行处理简化计算，具体的方法用到时再查吧</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529100252.png"></p><h4 id="Lightmap"><a href="#Lightmap" class="headerlink" title="Lightmap"></a>Lightmap</h4><p>预计算光照贴图，把整个场景的光照烘焙到一张纹理上</p><p>这里也有参数化（展UV）的问题</p><p>本质上就是离线baking然后存储下来，在runtime时直接拿纹理用 </p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529101123.png"></p><h4 id="Light-Probes-和-Reflection-Probes"><a href="#Light-Probes-和-Reflection-Probes" class="headerlink" title="Light Probes 和 Reflection Probes"></a>Light Probes 和 Reflection Probes</h4><p>对动态的物体采样光，没看懂存个指针==</p><hr><h3 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h3><h4 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h4><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529102141.png"></p><p>光打在表面后只有两种情况，一种时反射出去（镜面反射），一种是射到物体里面在里边弹弹弹然后随机方向射出去（漫反射）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529102211.png"></p><p>针对镜面反射来讲，有DFG理论，每一个字母代表一种光学现象</p><p>D == Normal Distribution Fuction</p><p>描述发现的发散程度，引入roughness粗糙度的参数</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529125633.png"></p><p>G == Geometric attenuation term（self-shadowing）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130248.png"></p><p>F == Fresnel Equation 菲涅尔项</p><p>描述不同材质的反射程度，大牛推出的5次方</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130528.png"></p><h4 id="迪士尼准则"><a href="#迪士尼准则" class="headerlink" title="迪士尼准则"></a>迪士尼准则</h4><ul><li>参数要由艺术家的直觉决定</li><li>参数越少越好</li><li>所有参数最好都是0-1</li><li>只有当参数超出门限是有实际意义的时候才可以超出0-1</li><li>所有的参数组合后需要足够鲁棒，不能有奇奇怪怪的结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130817.png"></p><h4 id="主流PBR模型"><a href="#主流PBR模型" class="headerlink" title="主流PBR模型"></a>主流PBR模型</h4><h5 id="Specular-Glossiness模型"><a href="#Specular-Glossiness模型" class="headerlink" title="Specular Glossiness模型"></a>Specular Glossiness模型</h5><p>这个模型一切参数存在图里</p><ul><li>Diffuse 存在diffuse图里</li><li>菲涅尔项存在Specular图里</li><li>roughness项存在Glossiness图里</li></ul><p>然后就可以通过+-*/运算写shader进行渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529131312.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529131445.png"></p><h5 id="Metallic-Roughness模型"><a href="#Metallic-Roughness模型" class="headerlink" title="Metallic Roughness模型"></a>Metallic Roughness模型</h5><p>相当于在SG模型上包了一层，在外边加了一些判断防止使用错误，比如说有一个参数判断模型是金属还是非金属，如果是金属就把颜色传递，非金属就不传递颜色</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529132208.png"></p><hr><h3 id="基于图像的光照"><a href="#基于图像的光照" class="headerlink" title="基于图像的光照"></a>基于图像的光照</h3><p>IBL的基本思想就是通过预计算的方式提前将环境光照算出来然后直接和环境中的材质进行卷积算出结果，本质上也是空间换时间的。</p><p><strong>这个和全局光照的区别我理解就是全局光照只预计算到光照那一步，而IBL继续预计算到光照和材质卷积完的结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529132522.png"></p><p>这里也是分diffuse和specular两种情况，本质上就是预计算再LUT的情况，至于怎么搞的，用时再看把：（</p><hr><h3 id="经典阴影方法"><a href="#经典阴影方法" class="headerlink" title="经典阴影方法"></a>经典阴影方法</h3><p>cascade shadow</p><p>主要思想就是根据远近进行shadow map分级管理，就类似mipmap</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529145741.png"></p><h5 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h5><p>PCF   PCSS方法</p><p>具体去看Games 202</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>3A游戏的渲染</p><ul><li>Lightmap + Lightprobe</li><li>PBR + IBL</li><li>CascadeShadow + VSSM</li></ul><h3 id="前沿技术"><a href="#前沿技术" class="headerlink" title="前沿技术"></a>前沿技术</h3><p>实时光追</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529150407.png"></p><h3 id="Shader管理"><a href="#Shader管理" class="headerlink" title="Shader管理"></a>Shader管理</h3><p>因为GPU是并发的，对于判断语句会执行等待然后一起结束，所以shader中最好没有判断，那么在游戏中就会有上万数量级的shader资产，而在软件工程中这些零散的东西显然是不好维护的，这是就可以开发一个UberShader工具，其实就可以理解为一类shader有一个父类，当我要修改时，会重新生成子类shader</p><p>同时面对不同图形API要做好处理</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529151139636.png" alt="image-20220529151139636"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第五课-渲染系统–光照和材质&quot;&gt;&lt;a href=&quot;#第五课-渲染系统–光照和材质&quot; class=&quot;headerlink&quot; title=&quot;第五课 渲染系统–光照和材质&quot;&gt;&lt;/a&gt;第五课 渲染系统–光照和材质&lt;/h2&gt;&lt;h3 id=&quot;渲染方程与挑战&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第四课-渲染数据组织</title>
    <link href="http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/"/>
    <id>http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/</id>
    <published>2022-06-07T09:25:10.000Z</published>
    <updated>2022-06-29T16:09:25.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四课-渲染数据组织"><a href="#第四课-渲染数据组织" class="headerlink" title="第四课 渲染数据组织"></a>第四课 渲染数据组织</h2><h3 id="游戏中的渲染"><a href="#游戏中的渲染" class="headerlink" title="游戏中的渲染"></a>游戏中的渲染</h3><p>面临的挑战：</p><ul><li>大量的GO渲染，所用到的渲染算法不一样，比如水体，人物，毛发</li><li>适配硬件，不同的CPU和GPU</li><li>帧率要稳定，比如塞尔达的呀哈哈森林疯狂掉帧体验感很差，所以渲染一帧必须在一个固定的非常短的时间里</li><li>渲染所分配的资源不能占全部cpu和内存，还要分给gameplay，logic</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528202409.png"></p><hr><h3 id="渲染系统的对象"><a href="#渲染系统的对象" class="headerlink" title="渲染系统的对象"></a>渲染系统的对象</h3><p>光栅化管线</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528202600.png"></p><p>将一系列的顶点进行MVP变换，并且裁剪，然后光栅化，最后进行着色。</p><p>纹理对象的渲染，涉及到采样频率小引发的摩尔纹，锯齿等现象，所以引出了抗锯齿技术等</p><hr><h3 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h3><p>SIMD：单指令多数据，一条指令可以发给很多单元同时处理数据，就是显卡里的SM</p><p>SIMT：单指令多线程，一条指令分给好多个线程并发执行</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528203240.png"></p><p>SM就是最基础的单元用于并行计算</p><p>Texture Units是处理纹理的单元</p><p>SMU：sin cos 向量运算等比较高阶的运算单元</p><p>Warp：warp是逻辑上的单位不是物理上的，一个warp可能包含32个线程，每个线程交给一个SM去执行，但是显卡中一组SM可能只有8个，那么就是说一个warp要控制这8个SM执行4次</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528203431.png"></p><p>CPU-&gt;GPU 数据的交互</p><p>cpu发送数据到gpu的显存上，这一步比较耗费时间，同时一般情况下最好只是单向的数据传递，也就是说尽量不要gpu处理完数据传回cpu</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204315.png"></p><p>高速缓存cache</p><p>cathe是很快的，比普通内存速度高出一个数量级，所以我们处理数据最后一次把要用到的所有数据同时放进cathe而不用再去内存中去取，这样可以提高速度</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204257.png"></p><hr><h3 id="可渲染物体"><a href="#可渲染物体" class="headerlink" title="可渲染物体"></a>可渲染物体</h3><p>GO上基础的可渲染的对象，比如人身体的网格，材质等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204819.png"></p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>mesh类的构造，这里有不同的数据结构，比如半边数据结构等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204948.png"></p><p>为了节省cpu传到gpu显存上的数据量，一位一个三角形有三个点，相邻三角形会共用顶点，所以可以只存一次，然后再存一个索引值，这样来节省内存</p><p>要存的内容可能有：顶点位置，法向，颜色等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528205145.png"></p><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p>视觉上的材质</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528205810.png"></p><p>phone Model，PBR Model</p><p>纹理，shaderCode</p><p>shader虽然是代码，但是也算是render需要数据的一种，是一些已经编译好的二进制文件，可以应用在不同的渲染对象上</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220528210138989.png" alt="image-20220528210138989"></p><hr><h4 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h4><p>把vertexBuffer,indexBuffer，纹理，shader传递给显卡，显卡就会渲染对应物体</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528210338.png"></p><p>由于将一个3维中的2维流形映射回2维参数化的过程（展uv）会有扭曲的情况发生，也就是说模型不同位置对应到二维的纹理上可能会重叠也可能一部分曲率大顶点多的地方映射的面积会很小，这样会导致精度不够的问题，所以目前业界一般会把一个模型分割成几个小部分，比如头，四肢这样。<strong>当然分成submesh还有另一个重要原因是因为一个模型通常有很多不同的材质，比如人的皮肤和衣服</strong></p><p>但是从cpu像gpu传递数据时还是一整个模型一起传递，只不过我们可以标记index，比如1-100是头，101-200是胳膊这种。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528210837.png"></p><p>在游戏中，会有很多一样的GO，比如小兵，这样每一个小兵GO的网格，纹理材质信息都是一样的，为了避免内存浪费，我们可能建立一个Pool，一个东西只存一遍，公用就行了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211100.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211132.png"></p><p>因为渲染流程实际上是一个状态机的模式，参考opengl，也就是说显卡一次处理一个东西，比如先渲染物体A它使用的是材质1，然后渲染物体B使用的是材质2，然后渲染物体C使用的也是材质1，这就会导致切换了两次材质造成性能下降，所以我们可以用材质来排序，一次性把材质1的GO（submesh）都渲染完，在切换材质2去渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211556.png"></p><p>针对完全重复的同一个对象，比如一堆树，可以在GPU中加一个offerset，一次drawcall全部渲染完毕，节省了重新传递vbo，ibo，drawcall的时间</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211731.png"></p><h4 id="可见性裁剪culling"><a href="#可见性裁剪culling" class="headerlink" title="可见性裁剪culling"></a>可见性裁剪culling</h4><p>在游戏过程中，要使用事件锥来裁剪可见的对象</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211949.png"></p><p>这里就要用包围盒来判断一个GO是否在事件锥的范围内</p><p>包围盒的种类：球，AABB，OBB，凸包等等</p><p>然后还要结合8叉树，BVH等空间划分算法来计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212124.png"></p><p>BVH的优点是对运动的物体culling很快</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212347.png"></p><p>PVS算法：主要思路就是根据所在位置看，能看到那些块就渲染哪些块</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212440.png"></p><p>利用光线追踪来判断哪些是可见的</p><p>PVS算法比Octree等算法快很多，并且一个更大的优点是<strong>可以判断哪些资源需要加载</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212632.png"></p><p>目前的算力已经很高了，显卡可以直接计算出哪些物体能看见，哪些被挡住了</p><p>Early Z：这个就是根据深度信息，可以提前判断好多物体不可见不用渲染，舍弃掉把它们光栅化的过程，节省性能</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212916.png"></p><h4 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h4><p>图片的存储格式不能够随机访问，所以游戏引擎必须对都进来的图片进行转化，记得opengl里好像有一个函数叫gl_readpixel,这个就是用来读图的，而且有按照1字节读和4字节读的接口（RGBA通道）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528213249.png"></p><p>压缩纹理的方法</p><p>先找一个4*4块的最亮和最暗的值，其他值都可以插值出来</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528213624.png"></p><h4 id="建模工具"><a href="#建模工具" class="headerlink" title="建模工具"></a>建模工具</h4><p>blender，3dsMax，Houdini</p><p>一些建模方法：</p><ul><li>样条模型，贝塞尔曲线</li><li>点云扫描</li><li>雕刻建模</li><li>AI辅助建模</li></ul><h4 id="新的模型管线"><a href="#新的模型管线" class="headerlink" title="新的模型管线"></a>新的模型管线</h4><p>时代发展，算力膨胀，有了GPU驱动的渲染</p><p>因为有了几何着色器，细分着色器，可以凭空生成很多的三角形，可以根据相机的远近来生成不同分辨率的模型（类似QEM）</p><p>所以可以把gpu每个sm处理的粒度变得更小，像下图中的龙一样，一个patch只有32个小三角形这种</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528214122.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li> 游戏引擎和硬件架构和算力息息相关</li><li>针对多材质的模型使用submesh分割</li><li>在绘制中尽可能的使要渲染的东西少，culling裁剪看不见的东西</li><li>Gpu越来越牛逼，未来可能直接靠算力就可以搞定很多东西</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四课-渲染数据组织&quot;&gt;&lt;a href=&quot;#第四课-渲染数据组织&quot; class=&quot;headerlink&quot; title=&quot;第四课 渲染数据组织&quot;&gt;&lt;/a&gt;第四课 渲染数据组织&lt;/h2&gt;&lt;h3 id=&quot;游戏中的渲染&quot;&gt;&lt;a href=&quot;#游戏中的渲染&quot; class=&quot;</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第1-3课-引擎架构分层&amp;数据组织管理</title>
    <link href="http://icecorn.github.io/2022/06/05/Games-104/Games104--%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AF%BC%E8%AE%BA%E4%B8%8E%E6%9E%B6%E6%9E%84(1-3)/"/>
    <id>http://icecorn.github.io/2022/06/05/Games-104/Games104--%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AF%BC%E8%AE%BA%E4%B8%8E%E6%9E%B6%E6%9E%84(1-3)/</id>
    <published>2022-06-05T09:25:10.000Z</published>
    <updated>2022-06-29T16:08:22.273Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一课：-现代游戏引擎导论"><a href="#第一课：-现代游戏引擎导论" class="headerlink" title="第一课： 现代游戏引擎导论"></a>第一课： 现代游戏引擎导论</h2><h3 id="游戏引擎架构与层级"><a href="#游戏引擎架构与层级" class="headerlink" title="游戏引擎架构与层级"></a>游戏引擎架构与层级</h3><ul><li><p><strong>基础元素构建</strong></p><p>了解游戏引擎的分层，以及为什么采用这样的架构</p></li><li><p><strong>渲染系统</strong></p><p>Model，Material, Shader, Texture</p><p>渲染管线，光影</p><p>学习对渲染对象组合不同算法进行渲染</p></li><li><p><strong>动画系统</strong></p><p>学习从3dsmax等导出的动画，如何把它们组装起来，构建工具</p></li><li><p><strong>物理系统</strong></p><p>学习游戏中的物理系统（刚体，软体，流体）</p></li><li><p><strong>GamePlay</strong></p><p>游戏中的核心玩法部分</p></li><li><p><strong>其他系统</strong></p><p>特效系统，寻路系统，相机系统</p></li><li><p><strong>工具链</strong></p><p>C++反射机制，数据库模式</p></li><li><p><strong>网络游戏</strong></p><p>数据同步</p></li><li><p><strong>前沿技术</strong></p><p>动态捕捉，面向数据变成DOP，任务系统Job System</p><p>全局光照Lumen，多面片Nanite</p></li></ul><hr><h2 id="第二课-引擎架构分层，整体Pipeline"><a href="#第二课-引擎架构分层，整体Pipeline" class="headerlink" title="第二课 引擎架构分层，整体Pipeline"></a>第二课 引擎架构分层，整体Pipeline</h2><p><strong>游戏引擎主要分成5个架构分层以及第三方库，自顶向下分别是：工具层，功能层，资源层，核心层，平台层</strong></p><h3 id="工具层"><a href="#工具层" class="headerlink" title="工具层"></a>工具层</h3><p>引擎最直观的，可以直接交互的层级，及引擎编辑器UI显示，可以直接利用GUI操作编辑一些游戏内容。</p><p>工具层通常以编辑器的形式存在，可用多种编程语言，开发效率优先，更加强调用户的便捷性。由于很多游戏资源是在Maya、3ds Max、Houdini等DCC（别人工具生成的资产）中完成的，工具层通常包含导入、导出器用于导入、导出游戏资源为统一的assets。</p><p>工具链是数据之间的互导。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528153615.png"></p><h3 id="功能层"><a href="#功能层" class="headerlink" title="功能层"></a>功能层</h3><p>为了使游戏呈现在屏幕上，需要渲染系统对虚拟世界进行渲染。动画系统将艺术家设计的动作动画在引擎中进行组合、过渡，让游戏人物在游戏动起来。逼真的虚拟世界也离不开物理，物理系统将使用刚体、软体、流体等去表达世界，使得人与人、人与物不会发生碰撞。游戏中的玩法以及NPC人物，也都离不开脚本、事件、AI系统等。为了实现游戏中的人机交互，还需要与输入、输出设备连接。（Rending、Camera、 Animation、physics、Script,FSM and AI）</p><p>功能层将使得整个虚拟世界变得栩栩如生：每隔tick时间，分别执行逻辑与绘制–tickLogic与tickRender。tickLogic主要用于模拟世界，包括处理输入输出，计算物理并进行碰撞检测等；tickRender将tickLogic计算的结果（人物位置等）进行绘制。考虑到功能层需要实现大量功能并对运行时间存在要求，功能层复杂性高，并通常需要借助多线程计算。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151730.png"></p><p><strong>在功能层，一定要区分开tickLogic和tickRender，不要耦合在一起</strong></p><p><strong>复杂性</strong>：功能层非常复杂、庞大，提供了游戏引擎中大部分功能模块，但哪些功能属于游戏，哪些功能属于引擎，界限不明确。</p><p><strong>多线程</strong>：现代计算机CPU通常有多个核心，主流引擎将拆分适合并行计算的任务，分配到多个线程运算，但一些计算互相依赖，不适用于并行执行。在未来，引擎将所有任务变为原子计算，将任务分配到每个核上。</p><p><strong>拆分成更小的粒度，最大限度压榨多核CPU</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151945.png"></p><h3 id="资源层"><a href="#资源层" class="headerlink" title="资源层"></a>资源层</h3><p>游戏引擎中通常包含大量数据和文件，这些文件通常以不同的形式存在，例如Photoshop中的专用格式psd文件或者3ds Max中的max文件，上万、上十万的数据文件由<strong>资源层进行加载与管理。</strong></p><p>Photoshop中的psd、3ds Max中的max等数据格式比较复杂， 包含大量与引擎无关的数据，如psd格式将保存Photoshop中所有的图层，包含通道、参考线、注解和颜色模式等信息。为了避免在使用资源时频繁调度并减少不必要的内存消耗，在导入资源时<strong>进行转换</strong>，将不同资源（纹理、模型几何、动画等）都转换为资产文件，即<strong>assest文件</strong>（.ast）。</p><p>比如引擎中最常使用的贴图数据，可使用png、jpg格式进行存储，上述格式对应相应的压缩算法，但这些压缩算法不是GPU高效的算法，直接在GPU中使用会浪费性能，通常在引擎中被转换成dds格式。dds格式针对纹理设计，支持很多其他图像格式不支持的功能，如Mipmap等。对于一个游戏人物，可能需要绑定网格、动画、贴图、材质等资源，定义Composite asset文件（如XML）关联不同资源，并使用Guid唯一识别号对资产进行管理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151127.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528151252.png"></p><p>在游戏实际运行时，需要使用**资产管理器*（Asset Manager）*<strong>根据</strong>资产生命周期*（Asset Life Cycle）***对资产进行管理，包括资产实时加载卸载、资源池分配、垃圾回收与延迟加载等。</p><p><strong>资源管理很重要，因为硬件资源显存内存永远是有限的，所以就要把资源合理利用，类似虚拟内存这种，塞尔达每次场景切换都很慢，也许就是垃圾回收部分不太高效？</strong></p><h3 id="核心层"><a href="#核心层" class="headerlink" title="核心层"></a>核心层</h3><p>工具层、功能层、资源层会频繁调用底层代码，使用容器创建、内存分配、数学库、多线程等底层功能，而<strong>核心层</strong>能够提供上述功能。</p><p>核心层是游戏引擎的基础，提供各种功能模块所需的工具，包括数学库、数据结构与容器、内存管理等。对于数学库，当前已有很多成熟的第三方库，例如Eigen。但游戏引擎需要<strong>为效率服务</strong>，可使用<strong>近似计算</strong>或者<strong>SIMD（单指令多数据流，可并行处理多个数据的指令）</strong>提高运算效率。对于数据结构与容器，编程语言中的数据结构可能不满足要求，比如C++一些标准实现会产生内存空洞，引擎中实现的数据结构更加方便内存管理，提高访问效率。对于内存管理，引擎内存管理与操作系统类似，内存性能瓶颈主要在内存池（分配器）、缓存缺失、内存对齐等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528152533.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528152618.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528153037.png"></p><h3 id="平台层"><a href="#平台层" class="headerlink" title="平台层"></a>平台层</h3><p>引擎或者游戏需要发布在不同平台上，可能需要使用不同的图形API。此外，用户使用的输入设备、硬件设备可能也完全不同，这都需要平台层进行处理。平台层使得游戏能兼容不同平台、不同硬件设备，为上层提供平台无关的服务和信息。对于图形API（如OpenGL、DirectX、Vulkan等），平台层需要使用RHI（Render Hardware Interface）去除不同API的差异，上层使用时无需关心渲染使用的是何种API。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528153308.png"></p><h3 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h3><p>第三方库或中间件通过SDK的形式或者文件格式转化，各种软件比如PS，3ds Max这些做出资产然后导入游戏引擎变成asset</p><h3 id="为什么要分层？"><a href="#为什么要分层？" class="headerlink" title="为什么要分层？"></a>为什么要分层？</h3><p>为了将游戏引擎解耦并降低复杂度，每一层都将独立，底层提供基础服务，顶层无需知道底层的具体实现，也有利于开发与版本迭代。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>游戏引擎分5层架构</li><li>在架构分层中，越往上越灵活，越往下越稳定</li><li>只能上层调用下层，反过来不行</li><li>虚拟世界由一系列tick时间组成</li></ul><hr><h2 id="第三课-数据组织和管理"><a href="#第三课-数据组织和管理" class="headerlink" title="第三课 数据组织和管理"></a>第三课 数据组织和管理</h2><p><strong>Dynamic Game Objects – 可交互动态物体（人物，坦克等）</strong></p><p><strong>Static Game Objects – 不可交互的静态物体（房子）</strong></p><p><strong>Environments – 环境 Sky天空、Vegetation植被、Terrain地形</strong></p><p><strong>Other Game Obhects – TriggerArea触发检测体、AirWall空气墙、NavigationMesh导航网格、Ruler游戏规则</strong></p><p><strong>这些都可以统一抽象为GameObject（GO）</strong></p><h3 id="面向对象与GO"><a href="#面向对象与GO" class="headerlink" title="面向对象与GO"></a>面向对象与GO</h3><p>GO都可以由属性Property和行为Behaviour组成。可以使用继承的方式来不断的扩展一个GO的新属性。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528155449.png"></p><h3 id="组件系统与GO"><a href="#组件系统与GO" class="headerlink" title="组件系统与GO"></a>组件系统与GO</h3><p>但是对于另外的一些GameObject，通过继承方式不理想，比如一个水陆两栖坦克，既有船的能力，也有坦克的能力，那么它应该继承自谁呢？可以利用组合的方式，通过<strong>Component来</strong>自定义的组合他们的能力；使用组件化思想，用组合代替继承。用组件的方式另外一个好处就是灵活，可替换，需要哪个能力就用哪个组件，不需要就卸掉。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528155746.png"></p><p>以无人机为例，此时各种能力和属性都可以抽成一个个的组件，如 TransformComp（位置），ModelComp（外形），MotorComp（运动），AIComp，PhysicsComp 等，此时无人机里只需要有一个 ComponentBase 的数组即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161008.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160951.png"></p><p>**这里注意可能组件也好，面向对象也好，最上层可能都是有一个基类，里面属性和方法都没有，但是也很有必要，因为这类似于句柄，在释放和管理的时候会需要。***注意 Unreal 和 Unity 中的 Object 与上述的 GameObject 并不相同。Unreal 中 AActor 是类似 GameObject 的概念，UObject 更类似于高级语言中的 Object。</p><p>组件模式有什么缺点？</p><p>效率没有直接写一个class高,ECS很重要，就是把同样的组件放一起，后面处理很方便</p><p>组件内部还需要通信，时间代价</p><h3 id="Tick"><a href="#Tick" class="headerlink" title="Tick"></a>Tick</h3><p>每隔一段时间让世界向前走一步：让每个 GameObject 中的每一个 Component 去 Tick 一次。在实际中，现代游戏引擎更多的通常不是逐对象逐组件去 Tick ，而是逐系统，比如先去做所有的和碰撞相关的事情，再去做所有和动画相关的事情，这样用类似流水线的方式，更有效率。</p><p>一个 Tick 的时间过长怎么处理？</p><ul><li>Tick 的时候将步长传入，依赖步长进行数据的补偿；</li><li>直接跳过下一个 Tick；二帧很危险</li><li>通常还是需要进行策略优化；分几批处理，化成几帧处理完毕</li></ul><h3 id="Event（GO之间交互）"><a href="#Event（GO之间交互）" class="headerlink" title="Event（GO之间交互）"></a>Event（GO之间交互）</h3><p>对于GameObject 间的交互，如一个炸弹爆炸，对其他不同的 GO 的影响，早期硬编码如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160928.png"></p><p>这样的代码明显违反设计模式的原则，由此引出 Event（事件），有点类似观察者模式，通过事件派发的方式进行解耦，接收/绑定了这个事件的对象再去处理该事件。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160910.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528160845.png"></p><p>最核心的是可扩展的消息系统，开发者可以在此基础之上定制消息类型和处理消息类型的组件对事件进行处理。</p><p>如何管理GO？发生的事情如何通知到每个GO？</p><h3 id="GO管理"><a href="#GO管理" class="headerlink" title="GO管理"></a>GO管理</h3><p>每个GO都有一个ID唯一标识uid和一个位置（空间位置）</p><p><strong>场景管理</strong></p><ul><li>通过唯一 ID 进行标识管理；</li><li>通过 object 的位置进行管理；</li></ul><p>每个场景中管理GO，如果不管理需要通过遍历场景中半径范围内所有的对象，进行消息的通知。例如一个GO寻找周围GO时就遍历所有的GO。<br>通过画格子优化：将地图分为几块，每块中的物体分别管理。先找邻近的格子，没有就不再找别的格子了。缺点：如果各个格子中GO分布不均，不高效。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161312.png"></p><p>优化方式：四叉树，八叉树，BVH，BSP</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161545.png"></p><h3 id="其他复杂问题"><a href="#其他复杂问题" class="headerlink" title="其他复杂问题"></a>其他复杂问题</h3><p>绑定问题</p><p>比如人和车，人上了车，这两个GO就绑定在一起了，这样一般先tick车，再tick人</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528161901.png"></p><p>如果按照Component类别来Tick，可能会分散到不同的CPU上，顺序是不能保证的，不同的Tick顺序会产生不同的结果。如果每次输入是一样的，那么结果也需要是一样的。比如实现游戏录像功能。</p><p>根本原因：Component在发送消息，其他Component在当前帧接收到消息还是下一帧接收到消息，接收到消息立即处理，还是等到下一帧处理。都会产生不同结果。</p><p>在实际的事件传递中，时序很重要，如游戏的回放功能，实际是记录用户的输入，如果各用户是依次执行，则没有问题，但如果用户同时进行同一事件的操作则会有问题，因此需要引入一个 “邮局”，各个操作先发到邮局，邮局去保证时序接着进行发送，常用引擎中的类似 PreTick，PostTick 的函数都是为了处理时序问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一课：-现代游戏引擎导论&quot;&gt;&lt;a href=&quot;#第一课：-现代游戏引擎导论&quot; class=&quot;headerlink&quot; title=&quot;第一课： 现代游戏引擎导论&quot;&gt;&lt;/a&gt;第一课： 现代游戏引擎导论&lt;/h2&gt;&lt;h3 id=&quot;游戏引擎架构与层级&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>快手实习总结|渲染&amp;shader</title>
    <link href="http://icecorn.github.io/2022/05/31/%E5%BF%AB%E6%89%8B%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://icecorn.github.io/2022/05/31/%E5%BF%AB%E6%89%8B%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2022-05-31T09:25:10.000Z</published>
    <updated>2022-06-29T16:32:33.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快手实习总结"><a href="#快手实习总结" class="headerlink" title="快手实习总结"></a>快手实习总结</h1><h2 id="零散知识"><a href="#零散知识" class="headerlink" title="零散知识"></a>零散知识</h2><p>混合模式及LUT：<a href="https://www.jianshu.com/p/2f188d2b79f1">https://www.jianshu.com/p/2f188d2b79f1</a></p><p>ffmpeg常用命令：<a href="https://www.cnblogs.com/frost-yen/p/5848781.html">https://www.cnblogs.com/frost-yen/p/5848781.html</a></p><p>shader学习：<a href="https://www.shadertoy.com/">https://www.shadertoy.com</a></p><p>数字图像，滤波器基础：<a href="https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html">https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html</a></p><h2 id="火焰效果"><a href="#火焰效果" class="headerlink" title="火焰效果"></a>火焰效果</h2><p>用两张噪声图，一张作为底（然后偏移），一张作为扰动</p><p>暴雪暗黑的燥波造火特效万能公式  <a href="https://youtu.be/YPy2hytwDLM?t=1504">https://youtu.be/YPy2hytwDLM?t=1504</a> </p><p>纯数学生成水波，uv扭曲、时间循环计算、双燥波无缝混合等等数学干货  <a href="https://catlikecoding.com/unity/tutorials/flow/texture-distortion/">https://catlikecoding.com/unity/tutorials/flow/texture-distortion/</a> </p><ul><li>对于火焰，要用大理石噪波，或者cell噪波作为底（因为这些噪波有尖锐的角，符合火焰形态），用柏林噪声作为扰动，然后smoothstep等将两张噪波偏移叠加，然后在对不同的灰度进行颜色映射，映射出外焰和内焰不同的颜色</li><li>对于云，这种用柏林噪声为底更为合适，因为它比较圆，形态像一团东西更像云彩</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> textureCoordinate; <span class="comment">//fs坐标</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> bgImage;  <span class="comment">//输入人体分割mask</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> noiseTexture;  <span class="comment">//噪声图1</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> lastTexture; <span class="comment">//上一帧的mask，人体背景分割黑白图</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> noiseTexture1; <span class="comment">//噪声图2</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> RATIO;  <span class="comment">//显示长宽比  默认720/1280</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;  <span class="comment">//当前time*1000</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> fadein; <span class="comment">//火焰渐现参数 0-10s</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> flameSpeed; <span class="comment">//火焰运动速度 1-10  实际值是 25000/(speed*speed)</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> flameRadius;<span class="comment">//火焰宽度 0.57-0.97</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> flameColorInner;<span class="comment">//火焰内颜色</span></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec3</span> flameColorOuter;<span class="comment">//火焰外颜色</span></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> blend_normal(<span class="type">vec4</span> overlay, <span class="type">vec4</span> base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> overlay + base*(<span class="number">1.</span>-overlay.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main ()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> timeSampler = <span class="type">float</span>(<span class="built_in">mod</span>(uTime, flameSpeed)) / flameSpeed;</span><br><span class="line">    <span class="type">vec2</span> uv = <span class="type">vec2</span>(textureCoordinate.x, <span class="number">1.0</span> - textureCoordinate.y);</span><br><span class="line">    <span class="type">vec2</span> scale = <span class="type">vec2</span>(RATIO,<span class="number">1.2</span>);</span><br><span class="line"><span class="comment">//采样噪声1，加入time使其朝向右下方移动,这个噪声1作为噪声2的扰动</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> noise_1 = <span class="built_in">texture2D</span>(noiseTexture, uv * scale - timeSampler * <span class="number">0.55</span>);</span><br><span class="line">    <span class="comment">//采样噪声2，用噪声1作为扰动达到一个动态噪声的效果，最后*2-1是为了造出一些黑色的地带，这就是两张噪声叠加的效果</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise_2 = (<span class="number">1.0</span> - <span class="built_in">texture2D</span>(noiseTexture, uv * scale + noise_1.yx * <span class="number">0.065</span> + timeSampler * <span class="number">0.15</span>).xy) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">  <span class="comment">//采样一个噪声3，这个只是为了最后混合人体mask里边的地方</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise_3_tmp = noise_2 * <span class="built_in">texture2D</span>(noiseTexture, uv * scale * <span class="number">5.0</span> - timeSampler * <span class="number">1.55</span>).yx;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> noise_3 = <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(noise_3_tmp, noise_3_tmp));</span><br><span class="line">  <span class="comment">//计算火焰强度</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> flameIntensity = <span class="built_in">clamp</span>(noise_1.y + <span class="number">0.5</span>, <span class="number">0.0</span>, flameRadius);</span><br><span class="line">  <span class="comment">//采样上一帧的纹理，这里是人体的mask图，并且加扰动是白色区域向外扩散，并且扩散区域的透明度递减</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> lastClr = <span class="built_in">texture2D</span>(lastTexture, textureCoordinate + noise_2 * <span class="number">0.015</span>);</span><br><span class="line">  <span class="comment">//每一个像素算出不同的透明度</span></span><br><span class="line">    <span class="type">float</span> alpha = flameIntensity * lastClr.w;</span><br><span class="line">  <span class="comment">//由于采样上一帧的纹理，轮廓边缘的透明度肯定是越来越小的，这样就能体现出内焰和外焰</span></span><br><span class="line">    <span class="type">vec3</span> clr = (flameColorInner * lastClr.w + flameColorOuter * (<span class="number">1.0</span> - lastClr.w)) * alpha;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> flameClr = <span class="type">vec4</span>(clr, alpha);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//这是有拿了另一张噪波图做一遍同样的操作</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> noise1_1 = <span class="built_in">texture2D</span>(noiseTexture1, uv * scale - timeSampler * <span class="number">0.55</span>);</span><br><span class="line"><span class="comment">//    lowp vec2 noise1_2 = texture2D(noiseTexture1, uv * scale + noise_1.yx * 0.065 + timeSampler * 0.15).yx * 2.0 - 1.0;</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise1_2 = (<span class="number">1.0</span> - <span class="built_in">texture2D</span>(noiseTexture1, uv * scale + noise1_1.yx * <span class="number">0.065</span> + timeSampler * <span class="number">0.15</span>).xy) * <span class="number">2.0</span> - <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec2</span> noise1_3_tmp = noise1_2 * <span class="built_in">texture2D</span>(noiseTexture1, uv * scale * <span class="number">5.0</span> - timeSampler * <span class="number">1.55</span>).yx;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> noise1_3 = <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(noise1_3_tmp, noise1_3_tmp));</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">float</span> flameIntensity1 = <span class="built_in">clamp</span>(noise1_1.y + <span class="number">0.5</span>, <span class="number">0.0</span>, flameRadius);</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> lastClr1 = <span class="built_in">texture2D</span>(lastTexture, textureCoordinate + noise1_2 * <span class="number">0.015</span>);</span><br><span class="line">    <span class="type">float</span> alpha1 = flameIntensity1 * lastClr1.w;</span><br><span class="line">    <span class="type">vec3</span> clr1 = (flameColorInner * lastClr1.w + flameColorOuter * (<span class="number">1.0</span> - lastClr1.w)) * alpha;</span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> flameClr1 = <span class="type">vec4</span>(clr1, alpha1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//    flameClr.rgb = flameClr.rgb * flameClr1.rgb * 4.;这里可以随便叠加不同，看效果</span></span><br><span class="line">    flameClr.rgb = flameClr.rgb + flameClr1.rgb;</span><br><span class="line"><span class="comment">//这里获取人体分割mask</span></span><br><span class="line">    <span class="keyword">lowp</span> <span class="type">vec4</span> bgClr = <span class="built_in">texture2D</span>(bgImage, textureCoordinate);</span><br><span class="line"><span class="comment">//最后或者一下并且后边有一个火焰渐现的效果</span></span><br><span class="line">    flameClr = (flameClr + bgClr * noise_3 * <span class="number">3.5</span>) * <span class="built_in">smoothstep</span>(<span class="number">0.0</span>,<span class="number">1.0</span>,uTime/(fadein*<span class="number">1000.0</span>));</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = flameClr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作纹理记得在cpu里set warp ，否则超出边界会出现硬边</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">glActiveTexture(GL_TEXTURE1)</span><br><span class="line"><span class="comment">-- set warp</span></span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);</span><br><span class="line">glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);</span><br><span class="line">glBindTexture(GL_TEXTURE_2D, mNoiseTex)</span><br></pre></td></tr></table></figure><p>![image-20220526151520368](/Users/jun/Library/Application Support/typora-user-images/image-20220526151520368.png)</p><h2 id="描边效果"><a href="#描边效果" class="headerlink" title="描边效果"></a>描边效果</h2><h3 id="1-边缘检测"><a href="#1-边缘检测" class="headerlink" title="1.边缘检测"></a>1.边缘检测</h3><p>​        描边效果的实质是边缘检测，所谓边缘是指其周围像素灰度急剧变化的那些像素的集合，即数学上图像梯度突变的区域。通过边缘检测算子即可得到边缘，常用的有Sobel算子，Canny算子，Laplacian算子等等，其本质都是高通滤波器。Sobel算子由于结构比较简单，检测效率较高比较常用。</p><p>参考：<a href="https://blog.csdn.net/linqianbi/article/details/78673903">https://blog.csdn.net/linqianbi/article/details/78673903</a></p><h3 id="2-图像膨胀，腐蚀"><a href="#2-图像膨胀，腐蚀" class="headerlink" title="2.图像膨胀，腐蚀"></a>2.图像膨胀，腐蚀</h3><p>​        输入一个黑白图mask，对其进行膨胀或腐蚀，在把原图混合上去剔除留下边缘信息，实现外描边和内描边</p><p>参考：<a href="https://blog.csdn.net/Du_Shuang/article/details/82952962?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-82952962-blog-79928835.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">https://blog.csdn.net/Du_Shuang/article/details/82952962?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-82952962-blog-79928835.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3</a></p><p><strong>效果：</strong></p><ul><li><p>全图描边，findcountours</p></li><li><p>物体描边</p></li><li><p>边缘线条光感Bloom，原图模糊+原图 = bloom</p></li><li><p>描边上色</p><p>彩虹描边，通过uv相对中心的位置转换为角度，再映射到颜色值</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> toCenter = <span class="type">vec2</span>(<span class="number">0.5</span>) - uv;</span><br><span class="line"><span class="type">float</span> angle = <span class="built_in">atan</span>(toCenter.y,toCenter.x);</span><br><span class="line">angle = (angle / PI2) + <span class="number">0.5</span>;</span><br><span class="line">outColor = <span class="built_in">clamp</span>(<span class="built_in">abs</span>(<span class="built_in">mod</span>(angle * <span class="number">6.0</span> + u_changeTime * <span class="number">21.0</span> + <span class="type">vec3</span>(<span class="number">0.0</span>, <span class="number">4.0</span>, <span class="number">2.0</span>), <span class="number">6.0</span>) - <span class="number">3.0</span>) - <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>描边移动，滚动等，结合不同静态mask，和mask序列帧实现各种效果</p></li></ul><hr><h2 id="噪点效果"><a href="#噪点效果" class="headerlink" title="噪点效果"></a>噪点效果</h2><p>通过随机噪声映射产生噪点图，再与原图进行混合</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> inputImageTexture;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> textureCoord;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> uTime;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> intensity;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">int</span> mode;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rand1(<span class="type">vec2</span> co)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rand2(<span class="type">vec2</span> co)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy, <span class="type">vec2</span>(<span class="number">72.1241</span>, <span class="number">21.5234</span>))) * <span class="number">19842.1245</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rand3(<span class="type">vec2</span> co)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy, <span class="type">vec2</span>(<span class="number">66.1321</span>, <span class="number">9.5234</span>))) * <span class="number">1942.1245</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> blend(<span class="type">vec3</span> src1, <span class="type">vec3</span> src2, <span class="type">float</span> alpha)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(src1, src1 * (alpha * src1 + (<span class="number">2.0</span> * alpha * src2 * (<span class="number">1.0</span> - src1))) + src1 * (<span class="number">1.0</span> - alpha), alpha);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec4</span> bgColor = <span class="built_in">texture2D</span>(inputImageTexture, textureCoord);</span><br><span class="line">    <span class="type">vec3</span> custom;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        custom = <span class="type">vec3</span>(rand1(<span class="type">vec2</span>(rand2(textureCoord), uTime)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        custom = <span class="type">vec3</span>(rand1(<span class="type">vec2</span>(rand2(textureCoord), uTime)), rand2(<span class="type">vec2</span>(rand3(textureCoord), uTime)), rand3(<span class="type">vec2</span>(rand1(textureCoord), uTime)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">vec3</span> after = blend(bgColor.xyz, custom, intensity);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(after, bgColor.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="模糊效果"><a href="#模糊效果" class="headerlink" title="模糊效果"></a>模糊效果</h2><h3 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h3><p>利用高斯分布（正太分布）作为采样系数进行卷积，通常采用两个pass之间来回倒（先上下再左右）这种来优化效率，从数学上可以证明和直接卷积是等价的。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> direction;<span class="comment">//采样方向 上下或左右</span></span><br><span class="line">   <span class="keyword">uniform</span> <span class="type">vec2</span> dimensions;<span class="comment">//屏幕分辨率</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">uniform</span> <span class="type">float</span> sigma;</span><br><span class="line"></span><br><span class="line">   <span class="type">void</span> main()</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">float</span> twoSigma2 = <span class="number">2.0</span> * sigma * sigma;</span><br><span class="line">       <span class="type">int</span> halfWidth = <span class="type">int</span>(<span class="built_in">ceil</span>(<span class="number">2.0</span> * sigma));</span><br><span class="line"></span><br><span class="line">       <span class="type">vec4</span> sum = <span class="type">vec4</span>(<span class="number">0.0</span>);</span><br><span class="line">       <span class="type">float</span> norm = <span class="number">0.0</span>;</span><br><span class="line">       <span class="keyword">if</span> (halfWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> i = -halfWidth; i &lt;= halfWidth; ++i) &#123;</span><br><span class="line">               <span class="type">vec2</span> pr = <span class="type">float</span>(i)*direction;</span><br><span class="line">               <span class="type">float</span> kernel = <span class="built_in">exp</span>(-<span class="built_in">dot</span>(pr, pr) / twoSigma2);</span><br><span class="line">               <span class="type">vec4</span> c = <span class="built_in">texture2D</span>(inputImageTexture, textureCoordinate + pr / dimensions).rgba;</span><br><span class="line">               sum += kernel * c;</span><br><span class="line">               norm += kernel;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           sum = <span class="built_in">texture2D</span>(inputImageTexture, textureCoordinate).rgba;</span><br><span class="line">           norm = <span class="number">1.0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(sum / norm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="移位模糊"><a href="#移位模糊" class="headerlink" title="移位模糊"></a>移位模糊</h3><p>本质上就是选择一个在纵向给一个不同的采样权重</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> v;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> r;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec4</span> sum = <span class="type">vec4</span>( <span class="number">0.0</span> );</span><br><span class="line"><span class="type">float</span> vv = v * <span class="built_in">abs</span>( r - vUv.y );</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">4.0</span> * vv ) ) * <span class="number">0.051</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">3.0</span> * vv ) ) * <span class="number">0.0918</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">2.0</span> * vv ) ) * <span class="number">0.12245</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y - <span class="number">1.0</span> * vv ) ) * <span class="number">0.1531</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y ) ) * <span class="number">0.1633</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">1.0</span> * vv ) ) * <span class="number">0.1531</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">2.0</span> * vv ) ) * <span class="number">0.12245</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">3.0</span> * vv ) ) * <span class="number">0.0918</span>;</span><br><span class="line">sum += <span class="built_in">texture2D</span>( tDiffuse, <span class="type">vec2</span>( vUv.x, vUv.y + <span class="number">4.0</span> * vv ) ) * <span class="number">0.051</span>;</span><br><span class="line"><span class="built_in">gl_FragColor</span> = sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Tone-mapping及色彩空间"><a href="#Tone-mapping及色彩空间" class="headerlink" title="Tone-mapping及色彩空间"></a>Tone-mapping及色彩空间</h2><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> toneMappingExposure;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> toneMappingWhitePoint;</span><br><span class="line"><span class="type">vec3</span> LinearToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line"><span class="keyword">return</span> toneMappingExposure * color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec3</span> ReinhardToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line">color *= toneMappingExposure;</span><br><span class="line"><span class="keyword">return</span> saturate( color / ( <span class="type">vec3</span>( <span class="number">1.0</span> ) + color ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )</span></span><br><span class="line"><span class="type">vec3</span> Uncharted2ToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line">color *= toneMappingExposure;</span><br><span class="line"><span class="keyword">return</span> saturate( Uncharted2Helper( color ) / Uncharted2Helper( <span class="type">vec3</span>( toneMappingWhitePoint ) ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec3</span> OptimizedCineonToneMapping( <span class="type">vec3</span> color ) &#123;</span><br><span class="line">color *= toneMappingExposure;</span><br><span class="line">color = <span class="built_in">max</span>( <span class="type">vec3</span>( <span class="number">0.0</span> ), color - <span class="number">0.004</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">pow</span>( ( color * ( <span class="number">6.2</span> * color + <span class="number">0.5</span> ) ) / ( color * ( <span class="number">6.2</span> * color + <span class="number">1.7</span> ) + <span class="number">0.06</span> ), <span class="type">vec3</span>( <span class="number">2.2</span> ) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> toneMapping( <span class="type">vec3</span> color ) &#123; <span class="keyword">return</span> LinearToneMapping( color ); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> LinearToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> GammaToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> gammaFactor ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">pow</span>( value.xyz, <span class="type">vec3</span>( gammaFactor ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToGamma( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> gammaFactor ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">pow</span>( value.xyz, <span class="type">vec3</span>( <span class="number">1.0</span> / gammaFactor ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> sRGBToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">mix</span>( <span class="built_in">pow</span>( value.rgb * <span class="number">0.9478672986</span> + <span class="type">vec3</span>( <span class="number">0.0521327014</span> ), <span class="type">vec3</span>( <span class="number">2.4</span> ) ), value.rgb * <span class="number">0.0773993808</span>, <span class="type">vec3</span>( <span class="built_in">lessThanEqual</span>( value.rgb, <span class="type">vec3</span>( <span class="number">0.04045</span> ) ) ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearTosRGB( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">mix</span>( <span class="built_in">pow</span>( value.rgb, <span class="type">vec3</span>( <span class="number">0.41666</span> ) ) * <span class="number">1.055</span> - <span class="type">vec3</span>( <span class="number">0.055</span> ), value.rgb * <span class="number">12.92</span>, <span class="type">vec3</span>( <span class="built_in">lessThanEqual</span>( value.rgb, <span class="type">vec3</span>( <span class="number">0.0031308</span> ) ) ) ), value.w );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> RGBEToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb * <span class="built_in">exp2</span>( value.a * <span class="number">255.0</span> - <span class="number">128.0</span> ), <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToRGBE( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="type">float</span> maxComponent = <span class="built_in">max</span>( <span class="built_in">max</span>( value.r, value.g ), value.b );</span><br><span class="line"><span class="type">float</span> fExp = <span class="built_in">clamp</span>( <span class="built_in">ceil</span>( <span class="built_in">log2</span>( maxComponent ) ), <span class="number">-128.0</span>, <span class="number">127.0</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb / <span class="built_in">exp2</span>( fExp ), ( fExp + <span class="number">128.0</span> ) / <span class="number">255.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> RGBMToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.xyz * value.w * maxRange, <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToRGBM( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="type">float</span> maxRGB = <span class="built_in">max</span>( value.x, <span class="built_in">max</span>( value.g, value.b ) );</span><br><span class="line"><span class="type">float</span> M      = <span class="built_in">clamp</span>( maxRGB / maxRange, <span class="number">0.0</span>, <span class="number">1.0</span> );</span><br><span class="line">M            = <span class="built_in">ceil</span>( M * <span class="number">255.0</span> ) / <span class="number">255.0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb / ( M * maxRange ), M );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> RGBDToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb * ( ( maxRange / <span class="number">255.0</span> ) / value.a ), <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> LinearToRGBD( <span class="keyword">in</span> <span class="type">vec4</span> value, <span class="keyword">in</span> <span class="type">float</span> maxRange ) &#123;</span><br><span class="line"><span class="type">float</span> maxRGB = <span class="built_in">max</span>( value.x, <span class="built_in">max</span>( value.g, value.b ) );</span><br><span class="line"><span class="type">float</span> D      = <span class="built_in">max</span>( maxRange / maxRGB, <span class="number">1.0</span> );</span><br><span class="line">D            = <span class="built_in">min</span>( <span class="built_in">floor</span>( D ) / <span class="number">255.0</span>, <span class="number">1.0</span> );</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( value.rgb * ( D * ( <span class="number">255.0</span> / maxRange ) ), D );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> cLogLuvM = <span class="type">mat3</span>( <span class="number">0.2209</span>, <span class="number">0.3390</span>, <span class="number">0.4184</span>, <span class="number">0.1138</span>, <span class="number">0.6780</span>, <span class="number">0.7319</span>, <span class="number">0.0102</span>, <span class="number">0.1130</span>, <span class="number">0.2969</span> );</span><br><span class="line"><span class="type">vec4</span> LinearToLogLuv( <span class="keyword">in</span> <span class="type">vec4</span> value )  &#123;</span><br><span class="line"><span class="type">vec3</span> Xp_Y_XYZp = value.rgb * cLogLuvM;</span><br><span class="line">Xp_Y_XYZp = <span class="built_in">max</span>(Xp_Y_XYZp, <span class="type">vec3</span>(<span class="number">1e-6</span>, <span class="number">1e-6</span>, <span class="number">1e-6</span>));</span><br><span class="line"><span class="type">vec4</span> vResult;</span><br><span class="line">vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;</span><br><span class="line"><span class="type">float</span> Le = <span class="number">2.0</span> * <span class="built_in">log2</span>(Xp_Y_XYZp.y) + <span class="number">127.0</span>;</span><br><span class="line">vResult.w = <span class="built_in">fract</span>(Le);</span><br><span class="line">vResult.z = (Le - (<span class="built_in">floor</span>(vResult.w*<span class="number">255.0</span>))/<span class="number">255.0</span>)/<span class="number">255.0</span>;</span><br><span class="line"><span class="keyword">return</span> vResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> cLogLuvInverseM = <span class="type">mat3</span>( <span class="number">6.0014</span>, <span class="number">-2.7008</span>, <span class="number">-1.7996</span>, <span class="number">-1.3320</span>, <span class="number">3.1029</span>, <span class="number">-5.7721</span>, <span class="number">0.3008</span>, <span class="number">-1.0882</span>, <span class="number">5.6268</span> );</span><br><span class="line"><span class="type">vec4</span> LogLuvToLinear( <span class="keyword">in</span> <span class="type">vec4</span> value ) &#123;</span><br><span class="line"><span class="type">float</span> Le = value.z * <span class="number">255.0</span> + value.w;</span><br><span class="line"><span class="type">vec3</span> Xp_Y_XYZp;</span><br><span class="line">Xp_Y_XYZp.y = <span class="built_in">exp2</span>((Le - <span class="number">127.0</span>) / <span class="number">2.0</span>);</span><br><span class="line">Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;</span><br><span class="line">Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;</span><br><span class="line"><span class="type">vec3</span> vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;</span><br><span class="line"><span class="keyword">return</span> <span class="type">vec4</span>( <span class="built_in">max</span>(vRGB, <span class="number">0.0</span>), <span class="number">1.0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> mapTexelToLinear( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br><span class="line"><span class="type">vec4</span> envMapTexelToLinear( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br><span class="line"><span class="type">vec4</span> emissiveMapTexelToLinear( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br><span class="line"><span class="type">vec4</span> linearToOutputTexel( <span class="type">vec4</span> value ) &#123; <span class="keyword">return</span> LinearToLinear( value ); &#125;</span><br></pre></td></tr></table></figure><hr><h2 id="一些后处理效果"><a href="#一些后处理效果" class="headerlink" title="一些后处理效果"></a>一些后处理效果</h2><h3 id="像素化"><a href="#像素化" class="headerlink" title="像素化"></a>像素化</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> p = vUv;</span><br><span class="line">    p.x = <span class="built_in">floor</span>(p.x * pixelsX)/pixelsX + <span class="number">0.5</span>/pixelsX;</span><br><span class="line">    p.y = <span class="built_in">floor</span>(p.y * pixelsY)/pixelsY + <span class="number">0.5</span>/pixelsY;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="震动"><a href="#震动" class="headerlink" title="震动"></a>震动</h3><p>就是抖uv，手动生成噪声常用fract，sin等函数</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> p = vUv;</span><br><span class="line"><span class="type">vec2</span> <span class="keyword">offset</span> = (<span class="type">vec2</span>(random1d(time),random1d(time + <span class="number">999.99</span>)) - <span class="number">0.5</span>) * amount;</span><br><span class="line">p += <span class="keyword">offset</span>;</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="彩虹滚动效果"><a href="#彩虹滚动效果" class="headerlink" title="彩虹滚动效果"></a>彩虹滚动效果</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> rainbow2( <span class="keyword">in</span> <span class="type">float</span> t )&#123;</span><br><span class="line"><span class="type">vec3</span> d = <span class="type">vec3</span>(<span class="number">0.0</span>,<span class="number">0.33</span>,<span class="number">0.67</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span> + <span class="number">0.5</span>*<span class="built_in">cos</span>( <span class="number">6.28318</span>*(t+d) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> p = vUv;</span><br><span class="line"><span class="type">vec3</span> origCol = <span class="built_in">texture2D</span>( tDiffuse, p ).rgb;</span><br><span class="line"><span class="type">vec2</span> off = <span class="built_in">texture2D</span>( tDiffuse, p ).rg - <span class="number">0.5</span>;</span><br><span class="line">p += off * <span class="keyword">offset</span>;</span><br><span class="line"><span class="type">vec3</span> rb = rainbow2( (p.x + p.y + time * <span class="number">2.0</span>) * <span class="number">0.5</span>);</span><br><span class="line"><span class="type">vec3</span> col = <span class="built_in">mix</span>(origCol,rb,amount);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(col, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define PI 3.14159265359</span></span><br><span class="line"><span class="keyword">highp</span> <span class="type">float</span> rand( <span class="keyword">const</span> <span class="keyword">in</span> <span class="type">vec2</span> uv ) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">highp</span> <span class="type">float</span> a = <span class="number">12.9898</span>, b = <span class="number">78.233</span>, c = <span class="number">43758.5453</span>;</span><br><span class="line"><span class="keyword">highp</span> <span class="type">float</span> dt = <span class="built_in">dot</span>( uv.xy, <span class="type">vec2</span>( a,b ) ), sn = <span class="built_in">mod</span>( dt, PI );</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(sn) * c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec4</span> cTextureScreen = <span class="built_in">texture2D</span>( tDiffuse, vUv );</span><br><span class="line"><span class="type">float</span> dx = rand( vUv + time );</span><br><span class="line"><span class="type">vec3</span> cResult = cTextureScreen.rgb * dx * noiseAmount;</span><br><span class="line"><span class="type">float</span> lineAmount = height * <span class="number">1.8</span> * count;</span><br><span class="line"><span class="type">vec2</span> sc = <span class="type">vec2</span>( <span class="built_in">sin</span>( vUv.y * lineAmount), <span class="built_in">cos</span>( vUv.y * lineAmount) );</span><br><span class="line">cResult += cTextureScreen.rgb * <span class="type">vec3</span>( sc.x, sc.y, sc.x ) * linesAmount;</span><br><span class="line">cResult = cTextureScreen.rgb + ( cResult );</span><br><span class="line"><span class="built_in">gl_FragColor</span> =  <span class="type">vec4</span>( cResult, cTextureScreen.a );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RGB抖动"><a href="#RGB抖动" class="headerlink" title="RGB抖动"></a>RGB抖动</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> amount;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> speed;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"><span class="type">float</span> random1d(<span class="type">float</span> n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(n) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> random2d(<span class="type">vec2</span> n) &#123; </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(n, <span class="type">vec2</span>(<span class="number">12.9898</span>, <span class="number">4.1414</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> randomRange (<span class="keyword">in</span> <span class="type">vec2</span> seed, <span class="keyword">in</span> <span class="type">float</span> <span class="built_in">min</span>, <span class="keyword">in</span> <span class="type">float</span> <span class="built_in">max</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span> + random2d(seed) * (<span class="built_in">max</span> - <span class="built_in">min</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> insideRange(<span class="type">float</span> v, <span class="type">float</span> bottom, <span class="type">float</span> top) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">step</span>(bottom, v) - <span class="built_in">step</span>(top, v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> rand(<span class="type">vec2</span> co)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(<span class="built_in">dot</span>(co.xy ,<span class="type">vec2</span>(<span class="number">12.9898</span>,<span class="number">78.233</span>))) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = vUv;</span><br><span class="line">    <span class="type">float</span> sTime = <span class="built_in">floor</span>(time * speed * <span class="number">6.0</span> * <span class="number">24.0</span>);</span><br><span class="line">    <span class="type">vec3</span> inCol = <span class="built_in">texture2D</span>(tDiffuse, uv).rgb;</span><br><span class="line">    <span class="type">vec3</span> outCol = inCol;</span><br><span class="line">    <span class="type">float</span> maxOffset = amount/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">vec2</span> uvOff;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">float</span> i = <span class="number">0.0</span>; i &lt; <span class="number">10.0</span>; i += <span class="number">1.0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">10.0</span> * amount) <span class="keyword">break</span>;</span><br><span class="line">        <span class="type">float</span> sliceY = random2d(<span class="type">vec2</span>(sTime + amount, <span class="number">2345.0</span> + <span class="type">float</span>(i)));</span><br><span class="line">        <span class="type">float</span> sliceH = random2d(<span class="type">vec2</span>(sTime + amount, <span class="number">9035.0</span> + <span class="type">float</span>(i))) * <span class="number">0.25</span>;</span><br><span class="line">        <span class="type">float</span> hOffset = randomRange(<span class="type">vec2</span>(sTime + amount, <span class="number">9625.0</span> + <span class="type">float</span>(i)), -maxOffset, maxOffset);</span><br><span class="line">        uvOff = uv;</span><br><span class="line">        uvOff.x += hOffset;</span><br><span class="line">        <span class="type">vec2</span> uvOff = <span class="built_in">fract</span>(uvOff);</span><br><span class="line">        <span class="keyword">if</span> (insideRange(uv.y, sliceY, <span class="built_in">fract</span>(sliceY+sliceH)) == <span class="number">1.0</span> )&#123;</span><br><span class="line">            outCol = <span class="built_in">texture2D</span>(tDiffuse, uvOff).rgb;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">float</span> maxColOffset = amount/<span class="number">6.0</span>;</span><br><span class="line">    <span class="type">vec2</span> colOffset = <span class="type">vec2</span>(randomRange(<span class="type">vec2</span>(sTime + amount, <span class="number">3545.0</span>),-maxColOffset,maxColOffset), randomRange(<span class="type">vec2</span>(sTime , <span class="number">7205.0</span>),-maxColOffset,maxColOffset));</span><br><span class="line">    uvOff = <span class="built_in">fract</span>(uv + colOffset);</span><br><span class="line">    <span class="type">float</span> rnd = random2d(<span class="type">vec2</span>(sTime + amount, <span class="number">9545.0</span>));</span><br><span class="line">    <span class="keyword">if</span> (rnd &lt; <span class="number">0.33</span>)&#123;</span><br><span class="line">    outCol.r = <span class="built_in">texture2D</span>(tDiffuse, uvOff).r;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (rnd &lt; <span class="number">0.66</span>)&#123;</span><br><span class="line">    outCol.g = <span class="built_in">texture2D</span>(tDiffuse, uvOff).g;</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">    outCol.b = <span class="built_in">texture2D</span>(tDiffuse, uvOff).b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(outCol,<span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扭曲（沿着圆形轨迹）"><a href="#扭曲（沿着圆形轨迹）" class="headerlink" title="扭曲（沿着圆形轨迹）"></a>扭曲（沿着圆形轨迹）</h3><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"><span class="type">vec2</span> p = <span class="number">-1.0</span> + <span class="number">2.0</span> * vUv;</span><br><span class="line"> <span class="comment">//后边加length那项额外加了一个扭曲项，相当于uv抖动把像素位置考虑进去了</span></span><br><span class="line"><span class="type">float</span> pos = time * TWO_PI + <span class="built_in">length</span>(p * size);</span><br><span class="line"> <span class="comment">//下边uv抖动按照圆形轨迹周期抖动，strength是强度</span></span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, vUv + strength * <span class="type">vec2</span>(<span class="built_in">cos</span>(pos), <span class="built_in">sin</span>(pos)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="错位效果"><a href="#错位效果" class="headerlink" title="错位效果"></a>错位效果</h3><p>从上到下很多条线错位切割</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> slices;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> <span class="keyword">offset</span>;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> time;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> speedV;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="type">float</span> steppedVal(<span class="type">float</span> v, <span class="type">float</span> steps)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">floor</span>(v*steps)/steps;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> random1d(<span class="type">float</span> n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fract</span>(<span class="built_in">sin</span>(n) * <span class="number">43758.5453</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">float</span> noise1d(<span class="type">float</span> p)&#123;</span><br><span class="line"><span class="type">float</span> fl = <span class="built_in">floor</span>(p);</span><br><span class="line"><span class="type">float</span> fc = <span class="built_in">fract</span>(p);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">mix</span>(random1d(fl), random1d(fl + <span class="number">1.0</span>), fc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> TWO_PI = <span class="number">6.283185307179586</span>;</span><br><span class="line">    <span class="type">void</span> main() &#123;</span><br><span class="line">    <span class="type">vec2</span> uv = vUv;</span><br><span class="line">    <span class="type">float</span> n = noise1d(uv.y * slices + time * speedV * <span class="number">3.0</span>);</span><br><span class="line">    <span class="type">float</span> ns = steppedVal(<span class="built_in">fract</span>(n  ),slices) + <span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> nsr = random1d(ns);</span><br><span class="line">    <span class="type">vec2</span> uvn = uv;</span><br><span class="line">    uvn.x += nsr * <span class="built_in">sin</span>(time * TWO_PI + nsr * <span class="number">20.0</span>) * <span class="keyword">offset</span>;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="built_in">texture2D</span>(tDiffuse, uvn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="边缘描边"><a href="#边缘描边" class="headerlink" title="边缘描边"></a>边缘描边</h3><p>使用sobel算子</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> tDiffuse;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> amount;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> passthru;</span><br><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> vUv;</span><br><span class="line"><span class="type">vec2</span> texel = <span class="type">vec2</span>(<span class="number">1.0</span> /<span class="number">512.0</span>);</span><br><span class="line"><span class="type">mat3</span> G[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> g0 = <span class="type">mat3</span>( <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">-2.0</span>, <span class="number">-1.0</span> );</span><br><span class="line"><span class="keyword">const</span> <span class="type">mat3</span> g1 = <span class="type">mat3</span>( <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span>, <span class="number">2.0</span>, <span class="number">0.0</span>, <span class="number">-2.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">-1.0</span> );</span><br><span class="line"><span class="type">void</span> main(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">mat3</span> I;</span><br><span class="line"><span class="type">float</span> cnv[<span class="number">2</span>];</span><br><span class="line"><span class="type">vec3</span> <span class="keyword">sample</span>;</span><br><span class="line">G[<span class="number">0</span>] = g0;</span><br><span class="line">G[<span class="number">1</span>] = g1;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> i=<span class="number">0.0</span>; i&lt;<span class="number">3.0</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> j=<span class="number">0.0</span>; j&lt;<span class="number">3.0</span>; j++) &#123;</span><br><span class="line"><span class="keyword">sample</span> = <span class="built_in">texture2D</span>( tDiffuse, vUv + texel * <span class="type">vec2</span>(i<span class="number">-1.0</span>,j<span class="number">-1.0</span>) ).rgb;</span><br><span class="line">I[<span class="type">int</span>(i)][<span class="type">int</span>(j)] = <span class="built_in">length</span>(<span class="keyword">sample</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="type">float</span> dp3 = <span class="built_in">dot</span>(G[i][<span class="number">0</span>], I[<span class="number">0</span>]) + <span class="built_in">dot</span>(G[i][<span class="number">1</span>], I[<span class="number">1</span>]) + <span class="built_in">dot</span>(G[i][<span class="number">2</span>], I[<span class="number">2</span>]);</span><br><span class="line">cnv[i] = dp3 * dp3; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">vec4</span> orig = <span class="built_in">texture2D</span>( tDiffuse, vUv);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = orig * passthru + <span class="type">vec4</span>(<span class="number">0.5</span> * <span class="built_in">sqrt</span>(cnv[<span class="number">0</span>]*cnv[<span class="number">0</span>]+cnv[<span class="number">1</span>]*cnv[<span class="number">1</span>])) * amount;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="Fibonacci采样"><a href="#Fibonacci采样" class="headerlink" title="Fibonacci采样"></a>Fibonacci采样</h2><p>通常我们会使用 4 个或者 8 个矩形边缘上的采样来进行扩张 / 收缩 / 模糊的效果</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> r;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="comment">// 里面四个</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    phi += PI * <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi)) * r;</span><br><span class="line">    result += <span class="built_in">texture2D</span>(basetex, uv + <span class="keyword">offset</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外面四个</span></span><br><span class="line">r *= <span class="built_in">sqrt</span>(<span class="number">2.0</span>);</span><br><span class="line">phi += PI * <span class="number">0.25</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    phi += PI * <span class="number">0.5</span>;</span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi)) * r;</span><br><span class="line">    result += <span class="built_in">texture2D</span>(basetex, uv + <span class="keyword">offset</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过使用这种方法生成的 pattern 对水平或者垂直的边缘不是很友好。间隔稍微大一点就能看到明显的artifact，步长一大很容易出现这种一条条的情况.</p><p>fibonacci采样最初是用于生成在空间中【均匀】分布的点的方法，在该平面上生成个采样点的公式</p><p>这里使用了黄金分割比的一个奇妙的性质，来让球面上的点分布更加均匀</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> r;</span><br><span class="line"><span class="type">float</span> rad = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">float</span> i = <span class="number">0.0</span>; i &lt; SAMPLE_CNT; i += <span class="number">1.0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rad = <span class="built_in">sqrt</span>((i + <span class="number">0.5</span>) / SAMPLE_CNT); <span class="comment">// 简单地加个小 offset 保证不会每次都采样到原点</span></span><br><span class="line">    phi += GOLDEN_ANGLE; <span class="comment">// 预计算的 $1 / \phi$</span></span><br><span class="line">    <span class="type">vec2</span> <span class="keyword">offset</span> = <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi)) * r * rad;</span><br><span class="line">    result += <span class="built_in">texture2D</span>(basetex, uv + <span class="keyword">offset</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="加入噪声"><a href="#加入噪声" class="headerlink" title="加入噪声"></a>加入噪声</h2><p>为了降低迭代次数，引入噪声来做到一个给均匀采样的效果，这种技术将走样现象转化为噪声，从而减少视觉上的怪异感。在实现上这边偷了个懒。由于计算中采样位置的值是逐次累加的，通过对它的初始值进行随机扰动就可以保证在采样的概率密度不变的情况下做出扰动了（其实就相当于转了一下采样的圆盘）。</p><p>如果让噪声动起来这样人眼就更不能发现锯齿了，但是又有一个问题是噪声太闪了。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">phi += someRandomNumberGenerator(time, uv);</span><br></pre></td></tr></table></figure><h2 id="Temporal-Denoising"><a href="#Temporal-Denoising" class="headerlink" title="Temporal Denoising"></a>Temporal Denoising</h2><p>从时间维度入手，引入上一帧的信息，可以解决噪声每帧都在变（太闪了）的问题。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> <span class="type">float</span> tfactor; <span class="comment">// 上式中的 $\alpha$</span></span><br><span class="line"><span class="type">vec4</span> lastcol = <span class="built_in">texture2D</span>(lasttex, uv);</span><br><span class="line"><span class="type">vec4</span> currcol = <span class="built_in">texture2D</span>(currtex, uv);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="built_in">mix</span>(currcol, lastcol, tfactor);</span><br></pre></td></tr></table></figure><h2 id="Joint-Bilateral-Filtering"><a href="#Joint-Bilateral-Filtering" class="headerlink" title="Joint Bilateral Filtering"></a>Joint Bilateral Filtering</h2><p>隆重介绍联合双向滤波。这一方法最开始被用于进行可以保留边缘的模糊效果，多见于对实时光线追踪进行降噪的过程中。GAMES202课程的最后一个作业实现了这样的一个算法，它利用GBuffer中的多项信息对图像进行滤波。</p><p>最基础的一种滤波方法是以颜色差异判断当前物体是否在移动。当前像素的色差超过某一阈值时就认为当前位置在运动，此时可以抛弃旧的采样以避免残影的问题。但只用这一种作为滤波手段的效果极差，很容易就会弄出更多的残影来，因此一般推荐这个滤波手段要加入更多还在使用的其它东西（比如遮罩）一同作用。</p><p>其实就是双边滤波，滤波时不止考虑远近这一维度的信息，还考虑前一帧和当前帧颜色数值的差值，如果大于阈值就直接舍弃上一帧的信息。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filtering</span></span><br><span class="line"><span class="type">vec3</span> diff = <span class="built_in">abs</span>(currcol.rgb - lastcol.rgb);</span><br><span class="line"><span class="type">float</span> diffmax = <span class="built_in">max</span>(<span class="built_in">max</span>(diff.r, diff.g), diff.b);</span><br><span class="line"><span class="type">float</span> colorfactor = <span class="number">1.0</span> - <span class="built_in">smoothstep</span>(<span class="built_in">max</span>(<span class="number">0.0</span>, thres - softthres), thres, diffmax);</span><br></pre></td></tr></table></figure><h2 id="拖尾效果"><a href="#拖尾效果" class="headerlink" title="拖尾效果"></a>拖尾效果</h2><p>Temporal还能用来实现拖尾，鬼影等效果</p><p>基本思想就是对一个运动的物体，把它前一帧的图像和当前帧的图像混合，并且根据时间因素设置透明度，比如拖尾10帧，当前帧是1，前一帧是0.9，再前一帧是0.8，这样10帧后透明度就是0了，就实现了拖尾效果。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// draw current circle</span></span><br><span class="line"><span class="type">vec2</span> dpos = (uv - center) * canvasSize;</span><br><span class="line"><span class="type">float</span> dist = <span class="built_in">sqrt</span>(<span class="built_in">dot</span>(dpos, dpos));</span><br><span class="line"><span class="type">float</span> vcurr = dist &lt; radius ? <span class="number">1.0</span> : <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// distrub uv</span></span><br><span class="line"><span class="type">float</span> time = t * <span class="number">0.1</span>;</span><br><span class="line"><span class="type">vec2</span> uv_disturb = mirroredUV(uv + time);</span><br><span class="line">uv_disturb = uv + (<span class="built_in">texture2D</span>(noise, uv_disturb).xy * <span class="number">2.0</span> - <span class="number">1.0</span>) * disturbAmp / canvasSize + speed + <span class="type">vec2</span>(<span class="number">0.0008</span>, <span class="number">0.0004</span>);</span><br><span class="line">uv_disturb = mirroredUV(uv_disturb);</span><br><span class="line"></span><br><span class="line"><span class="comment">// spread last</span></span><br><span class="line"><span class="type">float</span> vlast = <span class="built_in">texture2D</span>(last, uv_disturb).x;</span><br><span class="line"><span class="type">float</span> phi = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">  phi += PI * <span class="number">0.5</span>;</span><br><span class="line">  <span class="type">vec2</span> duv = spread * <span class="type">vec2</span>(<span class="built_in">sin</span>(phi), <span class="built_in">cos</span>(phi));</span><br><span class="line">  vlast = <span class="built_in">max</span>(vlast, <span class="built_in">texture2D</span>(last, uv_disturb + duv).x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mix and return</span></span><br><span class="line"><span class="type">float</span> v = <span class="built_in">max</span>(<span class="built_in">max</span>(<span class="number">0.0</span>, vlast - dval), vcurr);</span><br><span class="line"><span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(v), <span class="number">1.0</span>);</span><br></pre></td></tr></table></figure><h2 id="时间上的身体描边效果"><a href="#时间上的身体描边效果" class="headerlink" title="时间上的身体描边效果"></a>时间上的身体描边效果</h2><p>找到前5帧的缓存，每一帧的fbo给一个颜色，再混合，就实现了几层彩色的描边效果</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">varying</span> <span class="type">vec2</span> uv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="type">float</span> pi = <span class="number">3.1415927</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> blend_normal(<span class="type">vec4</span> overlay, <span class="type">vec4</span> base)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> overlay + base*(<span class="number">1.0</span> - overlay.r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> getColor(<span class="type">sampler2D</span> img, <span class="type">vec2</span> coord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(coord.x &lt; <span class="number">0.</span> || coord.x &gt; <span class="number">1.</span> || coord.y &lt; <span class="number">0.</span> || coord.y &gt; <span class="number">1.</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">vec4</span>(<span class="number">0.</span>); <span class="comment">//注意此处为透明而不是黑色！</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">texture2D</span>(img, coord);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line">  <span class="type">float</span> time = uTime;</span><br><span class="line">  <span class="type">vec4</span> bg_Image0 = getColor(bgImage0,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image1 = getColor(bgImage1,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image2 = getColor(bgImage2,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image3 = getColor(bgImage3,uv);</span><br><span class="line">  <span class="type">vec4</span> bg_Image4 = getColor(bgImage4,uv);</span><br><span class="line"></span><br><span class="line">  <span class="type">vec4</span> yan_Image = getColor(y_Image,uv);</span><br><span class="line"></span><br><span class="line">  <span class="type">vec4</span> mattingColor = <span class="built_in">mix</span>(<span class="type">vec4</span>(<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>,<span class="number">0.</span>),yan_Image,bg_Image4.r);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//第三层绿色拖影</span></span><br><span class="line">  <span class="type">vec4</span> color = <span class="built_in">mix</span>(yan_Image,greenCode * <span class="number">1.0</span>,bg_Image2.a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第二层黄色拖影</span></span><br><span class="line">  color = <span class="built_in">mix</span>(color,yellowCode * <span class="number">1.0</span>,bg_Image1.a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//第一层粉色拖影</span></span><br><span class="line">  color = <span class="built_in">mix</span>(color,pinkCode * <span class="number">1.0</span>,bg_Image0.a);</span><br><span class="line"></span><br><span class="line">  color = <span class="built_in">mix</span>(color,mattingColor,mattingColor.a);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">gl_FragColor</span> = color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;快手实习总结&quot;&gt;&lt;a href=&quot;#快手实习总结&quot; class=&quot;headerlink&quot; title=&quot;快手实习总结&quot;&gt;&lt;/a&gt;快手实习总结&lt;/h1&gt;&lt;h2 id=&quot;零散知识&quot;&gt;&lt;a href=&quot;#零散知识&quot; class=&quot;headerlink&quot; title=&quot;零</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="shader" scheme="http://icecorn.github.io/tags/shader/"/>
    
    <category term="openGL" scheme="http://icecorn.github.io/tags/openGL/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（一）|链表，树，递归，回溯</title>
    <link href="http://icecorn.github.io/2022/05/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%A0%91%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%9B%9E%E6%BA%AF/"/>
    <id>http://icecorn.github.io/2022/05/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%A0%91%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%9B%9E%E6%BA%AF/</id>
    <published>2022-05-25T09:25:10.000Z</published>
    <updated>2022-06-29T15:58:10.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法题系列（一）"><a href="#算法题系列（一）" class="headerlink" title="算法题系列（一）"></a>算法题系列（一）</h1><p>主要掌握知识点，滑动窗口，双指针，动态规划，字符串，数组，二叉树，并查集，单调栈，DFS，BFS等；其中字符串操作(子串)，数组(二维数组遍历)是重点。二维数组要记住leetcode上俄罗斯套娃信封问题，里面有个排序思想能解决二维数组的很多问题，比如堆积木，快递问题，小朋友身高体重问题，主要多刷题，总结刷题思路和模板</p><h2 id="常见算法题型"><a href="#常见算法题型" class="headerlink" title="常见算法题型"></a>常见算法题型</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>一个问题的解可以分解为几个子问题的解</li><li>子问题求解思路和原问题一致</li><li>存在基线/终止条件</li></ul><p>Lc21题：合并两个有序链表<br>Lc83题：删除链表重复元素</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong>链表判断是否有环</strong></p><p>方法：双指针，遍历，哈希<br>Lc141题：环形链表<br>Lc206题：反转链表<br>Lc234题：回文链表</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>一篇解决：<br><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/">https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/</a></p><p><strong>解题模板</strong><br>下面给出二叉树对称性递归的解题模板<br><strong>1、递归结束条件：特殊情况的判断</strong><br>如果是单树问题，一般来说只要进行以下判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;left) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br><span class="line"><span class="keyword">if</span>(!root-&gt;right) <span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>/递归函数;</span><br></pre></td></tr></table></figure><p>如果是双树问题(根节点分别为p,q)，一般来说进行以下判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p &amp;&amp; !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span>(!p || !q)<span class="keyword">return</span> <span class="literal">true</span>/<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析</p><p><strong>2、返回值</strong><br>通常对称性递归的返回值是多个条件的复合判断语句<br>可能是以下几种条件判断的组合：<br>节点非空的判断<br>节点值比较判断<br>(单树)调用根节点左右子树的递归函数进行递归判断<br>(双树)调用两棵树的左右子树的递归函数进行判断</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>比较，匹配，解析<br>重点题：回文字符串<br>思路就是以每个字符为中心，像左右发散判断是否回文（分一个字符中心，和两个字符中心）</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p><strong>DFS:</strong><br>应用：暴力搜索（其实就是枚举），检测环路<br>dfs可以搜索到所有的解，根据题意应用一些剪枝的策略<br><strong>解题步骤：</strong></p><ul><li>找到搜索的下一个状态（往哪搜索）</li><li>考虑搜索跳出的条件</li><li>设置搜索状态（标记已经搜索过了）</li><li>考虑剪枝情况优化搜索</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220625130916.png"></p><p>经典题目：迷宫路径，宝石最大价值（暴力+剪枝）</p><p><strong>BFS：</strong></p><p>应用：bfs主要用来算最短路径，找一个“值”，火烧法，通过queue来实现</p><p>经典题：二叉树层序遍历，每层的最大值，在while循环里获取当前queue的size，for循环size次<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220625131519.png"></p><p><strong>回溯法：</strong></p><p>一篇解决：<br><a href="https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/">https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/</a></p><p>回溯和dfs的区别是，dfs是无脑往下一个状态搜，回溯是搜索达到结束条件后，撤销这一步的选择，然后再继续搜，通常带有一些“状态东西“，比如一个vector之类的（想一下麻将胡牌问题）</p><p><strong>回溯应用：一般用在要查找所有解，要维护一个和搜索过程无关的状态集合</strong></p><p><strong>解题步骤：</strong></p><ul><li>画出递归树，找到状态变量（回溯函数的参数）</li><li>根据题意，确立结束条件</li><li>找准选择列表（与函数参数相关）</li><li>判断剪枝</li><li>做出选择</li><li>递归调用</li><li>撤销选择</li></ul><p><strong>题型：</strong></p><ul><li><p>子集，组合</p><p>核心在于设置一个标志位int start，从而选定下一步可选集合</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//sort(candidates.begin(),candidates.end());</span></span><br><span class="line">        <span class="built_in">backtrace</span>(candidates,<span class="number">0</span>,target);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第一步</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">backtrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt; candidates,<span class="type">int</span> start,<span class="type">int</span> target)</span> </span>&#123;      <span class="comment">//第二步</span></span><br><span class="line">        <span class="keyword">if</span>(target==<span class="number">0</span>)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三步</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&lt;<span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">//第四步</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);<span class="comment">//第五步</span></span><br><span class="line">            <span class="built_in">backtrace</span>(candidates,i,target-candidates[i]);<span class="comment">//第六步</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();<span class="comment">//第七步</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>全排列Lc47</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(n,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backTrace</span>(nums,visited,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; visited,<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="comment">//这里可以直接path.size()==nums.size(),不用传pos</span></span><br><span class="line">        <span class="keyword">if</span>(pos==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                <span class="comment">//这个!visited[i-1]没想到，必须前一个也能选才要剪枝</span></span><br><span class="line">                <span class="comment">//注意是i&gt;0,其实不用传pos</span></span><br><span class="line">                <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]&amp;&amp;!visited[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">backTrace</span>(nums,visited,pos+<span class="number">1</span>);</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>搜索</p></li></ul><hr><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><h3 id="是否是数字，字母"><a href="#是否是数字，字母" class="headerlink" title="是否是数字，字母"></a>是否是数字，字母</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="built_in">isdigit</span>(a); <span class="comment">//校验字符是不是十进制数</span></span><br><span class="line"><span class="built_in">isalpha</span>(a); <span class="comment">//校验字符是不是英文字母</span></span><br></pre></td></tr></table></figure><h3 id="n进制字符串转换成10进制"><a href="#n进制字符串转换成10进制" class="headerlink" title="n进制字符串转换成10进制"></a><strong>n进制字符串转换成10进制</strong></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">stoi</span>(字符串，起始位置，n进制);</span><br><span class="line">示例：</span><br><span class="line"><span class="built_in">stoi</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">//直接一个参数也行 结果123</span></span><br><span class="line"><span class="built_in">stoi</span>(str,<span class="number">0</span>,<span class="number">2</span>);<span class="comment">//将str从位置0到末尾转化为10进制</span></span><br></pre></td></tr></table></figure><h3 id="字符串转换成整数"><a href="#字符串转换成整数" class="headerlink" title="字符串转换成整数"></a>字符串转换成整数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;       <span class="comment">//str-&gt;int</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="title">atol</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;<span class="comment">//str-&gt;long</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">atoll</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;<span class="comment">//str-&gt;long long</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">atoq</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *nptr)</span></span>;<span class="comment">//str-&gt; long long</span></span><br><span class="line">示例：</span><br><span class="line">ii=<span class="built_in">atoi</span>(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;ii=%d\n&quot;</span>,ii);</span><br></pre></td></tr></table></figure><h3 id="string转C风格字符串"><a href="#string转C风格字符串" class="headerlink" title="string转C风格字符串"></a>string转C风格字符串</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">c_str</span>();</span><br><span class="line">string s = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s.<span class="built_in">c_str</span>()); <span class="comment">//输出 &quot;Hello World!&quot;</span></span><br><span class="line"></span><br><span class="line">C风格转string可以直接赋值</span><br><span class="line"><span class="type">char</span>* chstr;</span><br><span class="line"><span class="type">char</span> arstr[];</span><br><span class="line">string str = chstr;</span><br><span class="line">string str = arstr;</span><br></pre></td></tr></table></figure><h3 id="字符串常用操作"><a href="#字符串常用操作" class="headerlink" title="字符串常用操作"></a>字符串常用操作</h3><p><strong>拼接</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+号拼接</span><br><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot; world&quot;</span>;</span><br><span class="line">str1 += str2; <span class="comment">// str1 = &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">函数拼接</span><br><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">append</span>(<span class="string">&quot; world&quot;</span>); <span class="comment">//str1 = &quot;hello world&quot;</span></span><br><span class="line"></span><br><span class="line">string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str2.<span class="built_in">append</span>(<span class="string">&quot; world&quot;</span>,<span class="number">3</span>);  <span class="comment">//str1 = &quot;hello wo&quot;,参数3代表只要前3个</span></span><br><span class="line"></span><br><span class="line">string str3 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str3.<span class="built_in">append</span>(<span class="string">&quot; w orld&quot;</span>,<span class="number">2</span>,<span class="number">3</span>);  <span class="comment">//str1 = &quot;hello or&quot;,参数2代表从下标2开始,参数3代表要3个字符</span></span><br></pre></td></tr></table></figure><p><strong>查找子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abcdefdef&quot;</span>;</span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;def&quot;</span>);  <span class="comment">//结果是3，从左往右找</span></span><br><span class="line">str1.<span class="built_in">rfind</span>(<span class="string">&quot;def&quot;</span>); <span class="comment">//结果是6，从右往左找</span></span><br><span class="line">str1.<span class="built_in">find</span>(<span class="string">&quot;hhh&quot;</span>);  <span class="comment">//结果为-1，没有这个子串结果就是-1</span></span><br></pre></td></tr></table></figure><p><strong>替换</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;abcdssw&quot;</span>;</span><br><span class="line">str1.<span class="built_in">replace</span>(<span class="number">0</span>,<span class="number">2</span>,<span class="string">&quot;1111&quot;</span>); <span class="comment">//代表主串从0的位置开始，两个字符被替换掉；此处的结果为1111cdssw</span></span><br></pre></td></tr></table></figure><p><strong>比较</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">compare</span>(str2);  <span class="comment">//结果为0代表相等，否则为不相等</span></span><br><span class="line"></span><br><span class="line">string str1 = <span class="string">&quot;helpo&quot;</span>;</span><br><span class="line">string str2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">compare</span>(str2);  <span class="comment">//结果不为0，为p-l,两个字符的ASCII值求差</span></span><br></pre></td></tr></table></figure><p><strong>插入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str1.<span class="built_in">insert</span>(<span class="number">1</span>,<span class="string">&quot;111&quot;</span>); <span class="comment">//在1的位置插入,结果为&quot;h111ello&quot;</span></span><br></pre></td></tr></table></figure><p><strong>获取子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">str1.<span class="built_in">substr</span>(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//从下标为1的位置截取长度为3的子串</span></span><br><span class="line"><span class="comment">//结果为ell</span></span><br><span class="line">str1.<span class="built_in">substr</span>(<span class="number">1</span>) <span class="comment">//返回的就是下标1到最后的子串</span></span><br></pre></td></tr></table></figure><p><strong>删除子串</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">str1.<span class="built_in">erase</span>(<span class="number">1</span>,<span class="number">3</span>); <span class="comment">//从下标为1的位置起，删除长度为3的子串</span></span><br><span class="line"><span class="comment">//结果为&quot;ho world&quot;</span></span><br></pre></td></tr></table></figure><h3 id="求和函数"><a href="#求和函数" class="headerlink" title="求和函数"></a>求和函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>); <span class="comment">//最后的参数是初始值，一般为0</span></span><br></pre></td></tr></table></figure><hr><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pair的使用</span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p = <span class="built_in">makepair</span>(i,j);</span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(i,j)</span></span>;</span><br><span class="line">pair-&gt;first;   pair-&gt;second;</span><br><span class="line"></span><br><span class="line"><span class="comment">//矩阵构造  注意右边是vector&lt;int&gt; 不要忘记泛型</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; mat = <span class="built_in">vector</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//写递归时注意，前边return true，要在上一级的递归函数中用上</span></span><br><span class="line"><span class="built_in">backtrace</span>()&#123;</span><br><span class="line">    <span class="keyword">if</span>(xxx) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(backtrace)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><p>cin&gt;&gt;    一次处理一行</p><p>思路是重新生成字符串，双指针处理，i指针遍历字符串，j指针跟着遍历但找到符合条件要删除的就j–，然后s[j++] = s[i]组成新的字符串，最后返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            s[j++]=s[i];   <span class="comment">//j还没用</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">3</span>&amp;&amp;s[j<span class="number">-1</span>]==s[j<span class="number">-2</span>]&amp;&amp;s[j<span class="number">-2</span>]==s[j<span class="number">-3</span>]) </span><br><span class="line">                j--;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=<span class="number">4</span>&amp;&amp;s[j<span class="number">-1</span>]==s[j<span class="number">-2</span>]&amp;&amp;s[j<span class="number">-3</span>]==s[j<span class="number">-4</span>]) </span><br><span class="line">                j--;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>()+j,s.<span class="built_in">end</span>());</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="贪心问题"><a href="#贪心问题" class="headerlink" title="贪心问题"></a>贪心问题</h2><h3 id="n个建筑藏3个人"><a href="#n个建筑藏3个人" class="headerlink" title="n个建筑藏3个人"></a>n个建筑藏3个人</h3><p>且最大距离不超过d，处理有序数组的题目</p><p>思路：</p><ul><li>遍历数组，找出每一次可选元素，双指针i j，v[i]-v[j]&lt;=d筛选</li><li>贪心处理，组合问题，假定每一次i的值都被选，那么count=前边的数中选2个人</li></ul><hr><h2 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h2><h3 id="麻将问题"><a href="#麻将问题" class="headerlink" title="麻将问题"></a>麻将问题</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">(<span class="number">720</span>)<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">card</span><span class="params">(<span class="number">9</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查剩余的牌能否组成n个顺子或刻子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">hasTrible</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;card.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="comment">//因为仍是从1开始查验，因此若检查到其牌数&gt;=3，则必定是刻子</span></span><br><span class="line">        <span class="keyword">if</span>(card[i]&gt;<span class="number">2</span>)&#123;   </span><br><span class="line">            card[i] -= <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">hasTrible</span>(n<span class="number">-1</span>))&#123;   <span class="comment">//检查余下的牌能否组成n-1个顺子或刻子</span></span><br><span class="line">                card[i] += <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            card[i] += <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则只能是顺子</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;card.<span class="built_in">size</span>()<span class="number">-2</span> &amp;&amp; card[i]&gt;<span class="number">0</span> &amp;&amp; card[i+<span class="number">1</span>]&gt;<span class="number">0</span> &amp;&amp; card[i+<span class="number">2</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                card[i]--;</span><br><span class="line">                card[i+<span class="number">1</span>]--;</span><br><span class="line">                card[i+<span class="number">2</span>]--;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">hasTrible</span>(n<span class="number">-1</span>))&#123;</span><br><span class="line">                    card[i]++;</span><br><span class="line">                    card[i+<span class="number">1</span>]++;</span><br><span class="line">                    card[i+<span class="number">2</span>]++;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                card[i]++;</span><br><span class="line">                card[i+<span class="number">1</span>]++;</span><br><span class="line">                card[i+<span class="number">2</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查14张牌能否和牌</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isWin</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)&#123;  <span class="comment">//依次把1~9作为雀头拿出来，检查剩下的12张牌能否顺或刻子</span></span><br><span class="line">        <span class="keyword">if</span>(card[i]&lt;<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        card[i] -= <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">hasTrible</span>(<span class="number">4</span>))&#123;    </span><br><span class="line">            card[i] += <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        card[i] += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">13</span>; ++i)&#123;</span><br><span class="line">        cin &gt;&gt; tmp;</span><br><span class="line">        card[tmp<span class="number">-1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">9</span>; ++i)&#123;  <span class="comment">//1~9依次添加，检查是否可以和牌</span></span><br><span class="line">        <span class="keyword">if</span>(card[i]&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        card[i]++;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isWin</span>())           <span class="comment">//如果添加的这张牌可以和牌，则将其加入输出结果</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);</span><br><span class="line">        card[i]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(res.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;res.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        cout &lt;&lt; res[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;算法题系列（一）&quot;&gt;&lt;a href=&quot;#算法题系列（一）&quot; class=&quot;headerlink&quot; title=&quot;算法题系列（一）&quot;&gt;&lt;/a&gt;算法题系列（一）&lt;/h1&gt;&lt;p&gt;主要掌握知识点，滑动窗口，双指针，动态规划，字符串，数组，二叉树，并查集，单调栈，DFS，B</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第十四章-多线程编程</title>
    <link href="http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-15T09:25:10.000Z</published>
    <updated>2022-06-29T15:43:07.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>创建和调度线程无需内核干预, 速度很快.<br>不占用额外的内核资源, 对系统影响较小<br>但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>优缺点正好与上一个相反</li><li>双层调度<br>结合了前两个的优点<br>不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br><span class="line">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class="line">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class="line">执行后不会返回到调用者, 而且永远不会失败</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span></span></span><br><span class="line"><span class="function">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span></span><br><span class="line"><span class="function">成功时返回0, 失败返回错误码</span></span><br><span class="line"><span class="function">等待其他线程结束</span></span><br><span class="line"><span class="function">thread 线程标识符</span></span><br><span class="line"><span class="function">retval 目标线程的退出返回信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">错误码如下</span></span><br><span class="line"><span class="function">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span></span><br><span class="line"><span class="function">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span></span><br><span class="line"><span class="function">`ESRCH`目标线程不存在</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br><span class="line"><span class="function">异常终止一个线程, 即为取消线程</span></span><br><span class="line"><span class="function">成功返回0, 失败返回错误码</span></span><br></pre></td></tr></table></figure><p><strong>线程属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class="line"><span class="comment">// 启动线程取消</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcancelstart</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span>* oldstate)</span></span></span><br><span class="line"><span class="function">第一个参数</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到</span></span><br><span class="line"><span class="function">这个线程允许被取消</span></span><br><span class="line"><span class="function">第二个参数 返回之前设定的状态</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置线程取消类型</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span>* oldtype)</span></span></span><br><span class="line"><span class="function">第一个参数</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数</span></span><br><span class="line"><span class="function">最好使用pthread_testcancel函数设置取消点</span></span><br><span class="line"><span class="function">设置取消类型<span class="params">(如何取消)</span></span></span><br><span class="line"><span class="function">第二个参数</span></span><br><span class="line"><span class="function">原来的取消类型</span></span><br></pre></td></tr></table></figure><p><strong>设置脱离线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化线程属性对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁线程属性对象, 直到再次初始化前都不能用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 参数取值</span></span></span><br><span class="line"><span class="function"><span class="comment">// -PTHREAD_CREATE_JOINABLE 线程可回收</span></span></span><br><span class="line"><span class="function"><span class="comment">// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 可以直接设置为脱离线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure><h2 id="线程同步机制的使用场景"><a href="#线程同步机制的使用场景" class="headerlink" title="线程同步机制的使用场景"></a>线程同步机制的使用场景</h2><p>POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值<br>两份计数值容易出错</p><p>互斥锁-对临界资源的独占式访问</p><p>条件变量-等待某个条件满足<br>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</p><p>读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写</p><p>自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景</p><h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join()</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="comment">// 用于初始化一个未命名的信号量.</span></span><br><span class="line"><span class="comment">// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享</span></span><br><span class="line"><span class="comment">// value指定参数的初始值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁信号量, 释放其占用的系统资源</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destory</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 原子操作将信号量的值 +1</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure><p>初始化已经存在的信号量会导致无法预期的结果</p><p>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</p><p>例子如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kNumberMax = <span class="number">10</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">number</span><span class="params">(kNumberMax)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kThreadNum = <span class="number">10</span>;</span><br><span class="line"><span class="type">sem_t</span> sems[kThreadNum];</span><br><span class="line"><span class="type">pthread_t</span> threads[kThreadNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kPrintTime = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">t</span><span class="params">(<span class="type">void</span> *no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start_sub = *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(no);</span><br><span class="line">    <span class="type">int</span> sub =start_sub;</span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++time &lt;= kPrintTime)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 锁住本线程 释放下一个线程</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sems[start_sub]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number[sub]);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sems[(start_sub + <span class="number">1</span>) % kThreadNum]);</span><br><span class="line"><span class="comment">// 计算下一次要打印的下标</span></span><br><span class="line">        sub = (sub + kThreadNum) % kNumberMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">iota</span>(number.<span class="built_in">begin</span>(), number.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sems[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; kThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sems[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, t, &amp;number[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 等待最后一个线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(threads[kThreadNum - <span class="number">1</span>], <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kThreadNum个进程依次打印<code>[0, kNumberMax)</code><br>每个进程打印kPrintTime次<br>最后一个进程打印完后主线程才能结束</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁目标互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对普通锁加锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>销毁一个已经加锁的互斥锁 会发生不可预期的后果<br>也可使使用宏<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化一个互斥锁<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p><p><strong>互斥锁属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destory</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTHREAD_PROCESS_SHARED 跨进程共享</span></span><br><span class="line"><span class="comment">// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_NORMAL 普通锁 默认类型</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_ERRORCHECK 检错锁</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_RECURSVE 嵌套锁</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_DEFAULT 默认锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>PTHREAD_MUTEX_NORMAL<br>一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平<br>A线程对一个<code>已经加锁</code>的普通锁<code>再次加锁(也是A线程)</code>-同一线程在解锁前再次加锁引发死锁<br>对一个已经<code>被其他线程加锁</code>的普通锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的普通锁–解锁-不可预期后果</p><p>PTHREAD_MUTEX_ERRORCHECK<br>线程对<code>已经加锁</code>的检错锁<code>再次加锁</code>–加锁-加锁操作返回EDEADLK<br>对一个已经<code>被其他线程加锁</code>的检错锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的检错锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_RECURSVE<br>允许一个线程在释放锁前多次加锁 而不发生死锁.<br>如果<code>其他线程</code>要获得这个锁, 则<code>当前锁拥有者</code>必须执行相应次数的解锁操作–加锁<br>对于<code>已经被其他进程</code>加锁的嵌套锁解锁, 或者对<code>已经解锁</code>的再次解锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_DEFAULT<br>这种锁的实现可能为上面三种之一<br>对已经加锁的默认锁再次加锁<br>对被其他线程加锁的默认锁解锁<br>再次解锁已经解锁的默认锁<br>都将会发生不可预料后果</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">t</span><span class="params">(<span class="type">void</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thread[i], <span class="literal">nullptr</span>, t, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> pthread_condattr *cond_attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cont_destory</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播式的唤醒所有等待目标条件变量的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cont_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒一个等待目标条件变量的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待目标条件变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>将各个字段初始化为0</p><p>pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁<br>掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.<br>函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁</p><p>从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值<br>也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,<br>将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">int</span> good = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> produce_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> consume_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Producer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(produce_count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        good++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        produce_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;produce a good\n&quot;</span>);</span><br><span class="line"><span class="comment">// 通知一个线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (consume_count &lt; <span class="number">13</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 传入前需要加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (good &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            good--;</span><br><span class="line">            consume_count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consume a good, reset %d\n&quot;</span>, good);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;good is 0\n&quot;</span>);</span><br><span class="line">            <span class="comment">// wait pthread_cond_signal</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">    <span class="type">pthread_t</span> producer, consumer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer, <span class="literal">nullptr</span>, Consumer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer, <span class="literal">nullptr</span>, Producer, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h2 id="线程同步包装类-多线程环境"><a href="#线程同步包装类-多线程环境" class="headerlink" title="线程同步包装类-多线程环境"></a>线程同步包装类-多线程环境</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;sem_, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;sem_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;sem_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;sem_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;cond_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里我一开始没有想到..</span></span><br><span class="line">            <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond_);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;cond_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件</p><p>多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程<br>子进程只有一个线程-调用fork线程的完美复制</p><p>但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但<code>不是由</code>调用fork线程<br>锁住的, 此时<code>子进程</code>再次对这个互斥锁<code>执行加锁</code>操作将会<code>死锁</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, lock the mutex\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 解锁后 Prepare才能加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个函数在fork创建子进程前被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行</span></span><br><span class="line">    <span class="comment">// 这个函数执行完毕前fork不会创建子进程</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fork创建线程后 返回前 会在子进程和父进程中执行这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Infork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// pthread_atfork(Prepare, Infork, Infork);</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;emmm????\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(id, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process, want to get the lock\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i cann&#x27;t run to here, opps....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait start\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait over\n&quot;</span>); <span class="comment">// 没有打印 因为子进程不会终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $ in child thread, lock the mutex</span></span><br><span class="line"><span class="comment">// $ wait start</span></span><br><span class="line"><span class="comment">// $ child process, want to get the lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $ in child thread, lock the mutex</span></span><br><span class="line"><span class="comment">// $ wait start</span></span><br><span class="line"><span class="comment">// $ child process, want to get the lock</span></span><br><span class="line"><span class="comment">// $ i cann&#x27;t run to here, opps....</span></span><br><span class="line"><span class="comment">// $ wait over</span></span><br></pre></td></tr></table></figure><p>原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_atfork</span> <span class="params">(<span class="type">void</span> (*__prepare) (<span class="type">void</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> (*__parent) (<span class="type">void</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> (*__child) (<span class="type">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>第一个句柄 在fork创建子进程前执行<br>第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行<br>第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十四章-多线程编程&quot;&gt;&lt;a href=&quot;#第十四章-多线程编程&quot; class=&quot;headerlink&quot; title=&quot;第十四章 多线程编程&quot;&gt;&lt;/a&gt;第十四章 多线程编程&lt;/h1&gt;&lt;p&gt;根据运行环境和调度者身份, 线程可以分为两种&lt;br&gt;内核线程&lt;br&gt;运行在内</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    <category term="系统编程" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="多线程" scheme="http://icecorn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第十三章-多进程编程</title>
    <link href="http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-15T09:25:10.000Z</published>
    <updated>2022-06-29T15:41:00.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h1><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明这个是外部函数或外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class="line"><span class="comment">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class="line"><span class="comment">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class="line"><span class="comment">// exec函数是不返回的, 除非出错</span></span><br><span class="line"><span class="comment">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ..., <span class="type">char</span>* <span class="type">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="fork系统调用-进程的创建"><a href="#fork系统调用-进程的创建" class="headerlink" title="fork系统调用-进程的创建"></a>fork系统调用-进程的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class="line"><span class="comment">// 次返回值用于区分是父进程还是子进程</span></span><br><span class="line"><span class="comment">// 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(viod)</span></span>;</span><br></pre></td></tr></table></figure><p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p><ul><li>堆指针</li><li>栈指针</li><li>标志寄存器的值</li><li>子进程代码与父进程完全相同</li><li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li><li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li></ul><p>也存在不同的项目</p><ul><li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li><li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li></ul><p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p><p>The child process is an exact duplicate of the parent process except<br>for the following points:</p><ul><li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p></li><li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p></li><li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p></li><li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p></li><li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p></li><li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p></li><li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p></li><li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p></li></ul><h2 id="处理僵尸进程-进程的管理"><a href="#处理僵尸进程-进程的管理" class="headerlink" title="处理僵尸进程-进程的管理"></a>处理僵尸进程-进程的管理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* stat_loc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class="line"><span class="comment">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class="line"><span class="comment">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class="line"><span class="comment">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class="line"><span class="comment">// 调用失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* stat_loc, <span class="type">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WIFEXITED</span>(stat_val); <span class="comment">// 子进程正常结束, 返回一个非0</span></span><br><span class="line"><span class="built_in">WEXITSTATUS</span>(stat_val); <span class="comment">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class="line"><span class="built_in">WIFSIGNALED</span>(stat_val);<span class="comment">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class="line"><span class="built_in">WTERMSIG</span>(stat_val);<span class="comment">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class="line"><span class="built_in">WIFSTOPPED</span>(stat_val);<span class="comment">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class="line"><span class="built_in">WSTOPSIG</span>(stat_val);<span class="comment">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure><p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p><ul><li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li><li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li></ul><p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p><p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_child</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 善后处理emmmm</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量-进程的锁"><a href="#信号量-进程的锁" class="headerlink" title="信号量-进程的锁"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p><ul><li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li><li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png"></li></ul><p><strong>总结PV使用方法</strong></p><p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0 </code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p><p><strong>创建信号量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semeget 系统调用</span></span><br><span class="line"><span class="comment">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class="line"><span class="comment">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class="line"><span class="comment">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class="line"><span class="comment">// sem_flags指定一组标志, 来控制权限</span></span><br><span class="line"><span class="comment">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class="line"><span class="comment">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class="line"><span class="comment">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_id = <span class="built_in">semget</span>((<span class="type">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl 系统调用</span></span><br><span class="line"><span class="comment">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class="line"><span class="comment">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class="line"><span class="comment">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 竟然需要手动声明...</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>  *array;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seminfo</span>  *__buf;  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">(Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">sem_union.val = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这里可以直接第三个参数传入1(val)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> sem_union&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>与semop信号量关联的一些重要的内核变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semzcnt; <span class="comment">// 等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semncnt<span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="type">pid_t</span> sempid; <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure><p>操作信号量, 实际上就是对上面的内核变量操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class="line"><span class="comment">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class="line"><span class="comment">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf* sem_ops, <span class="type">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op &lt; 0 期望获得信号量</span></span><br><span class="line"><span class="comment">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class="line"><span class="comment">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class="line"><span class="comment">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class="line"><span class="comment">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class="line"><span class="comment">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">P</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>; <span class="comment">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>; <span class="comment">// P</span></span><br><span class="line"><span class="comment">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class="line"><span class="comment">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op &gt; 0 </span></span><br><span class="line"><span class="comment">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class="line"><span class="comment">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">V</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>; <span class="comment">// V</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- sem_op = 0</span></span><br><span class="line"><span class="comment">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class="line"><span class="comment">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class="line"><span class="comment">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class="line"><span class="comment">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class="line"><span class="comment">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>semget成功时返回一个与之关联的内核结构体semid_ds</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span> sem_perm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> sem_nsems; <span class="comment">// 被设置为num_sems</span></span><br><span class="line"><span class="type">time_t</span> sem_otime; <span class="comment">// 被设置为0</span></span><br><span class="line"><span class="type">time_t</span> sem_ctime; <span class="comment">// 被设置为当前的系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来描述权限</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uid_t</span> uid; <span class="comment">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">gid_t</span> gid; <span class="comment">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">uid_t</span> cuid; <span class="comment">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">gid_t</span> cgid; <span class="comment">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">mode_t</span> mode;<span class="comment">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存-进程间通信"><a href="#共享内存-进程间通信" class="headerlink" title="共享内存-进程间通信"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key</span></span><br><span class="line"><span class="comment">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class="line"><span class="comment">// size 内存区域大小 单位字节</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class="line"><span class="comment">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class="line"><span class="comment">// SHM_HUGETLB 系统将使用&quot;大页面&quot;来为共享内存分配空间</span></span><br><span class="line"><span class="comment">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class="line"><span class="comment">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class="line"><span class="comment">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shm_id </span></span><br><span class="line"><span class="comment">// shmget返回的唯一标识</span></span><br><span class="line"><span class="comment">// shm_addr </span></span><br><span class="line"><span class="comment">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class="line"><span class="comment">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class="line"><span class="comment">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class="line"><span class="comment">// SHM_EXEC 有执行权限</span></span><br><span class="line"><span class="comment">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span>* shm_addr, <span class="type">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class="line"><span class="function"><span class="comment">// -shm_nattach +1</span></span></span><br><span class="line"><span class="function"><span class="comment">// -更新 shm_lpid</span></span></span><br><span class="line"><span class="function"><span class="comment">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将共享内存从进程地址空间中分离</span></span><br><span class="line"><span class="comment">// 成功后</span></span><br><span class="line"><span class="comment">// -shm_nattach -1</span></span><br><span class="line"><span class="comment">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_ctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/shmctl.png"></p><hr><p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">shmid_ds</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span> shm_per; <span class="comment">// 权限相关</span></span><br><span class="line"><span class="type">size_t</span> shm_segsz; <span class="comment">// 共享内存大小 单位字节size</span></span><br><span class="line"><span class="type">__time_t</span> shm_atime; <span class="comment">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class="line"><span class="type">__time_t</span> shm_dtime; <span class="comment">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class="line"><span class="type">__time_t</span> shm_ctime; <span class="comment">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class="line"><span class="type">__pid_t</span> shm_cpid; <span class="comment">// 创建者PID</span></span><br><span class="line"><span class="type">__pid_t</span> lpid; <span class="comment">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class="line"><span class="type">shmatt_t</span> shm_nattach <span class="comment">// 关联到此共享内存空间的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>共享内存的POSIX方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shmfd = <span class="built_in">shm_open</span>(<span class="string">&quot;/shm_name&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line"><span class="built_in">ERROR_IF</span>(shmfd == <span class="number">-1</span>, <span class="string">&quot;shm open&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">ftruncate</span>(shmfd, BUFFER_SIZE);</span><br><span class="line"><span class="built_in">ERROR_IF</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line"></span><br><span class="line">share_mem = (<span class="type">char</span>*)<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BUFFER_SIZE,</span><br><span class="line">PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">ERROR_IF</span>(share_mem == MAP_FAILED, <span class="string">&quot;share_mem&quot;</span>);</span><br><span class="line"><span class="built_in">close</span>(shmfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消关联</span></span><br><span class="line"><span class="built_in">munmap</span>((<span class="type">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure><h2 id="进程通信-管道"><a href="#进程通信-管道" class="headerlink" title="进程通信-管道"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p><p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 与semget 相同, 成功返回标识符</span></span><br><span class="line"><span class="comment">// msgflg的设置和作用域setget相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class="line"><span class="comment">// msg_sz 指的是mtext的长度!!!</span></span><br><span class="line"><span class="comment">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class="line">就立即返回 设置errno=EAGIN</span><br><span class="line"></span><br><span class="line">系统自带这个结构体 不过mtext长度是<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">struct</span> msgbuf</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> mtype; <span class="comment">/* 消息类型 正整数*/</span></span><br><span class="line"><span class="type">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* 消息数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class="line"><span class="comment">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class="line"><span class="comment">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class="line"><span class="comment">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class="line"><span class="comment">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> command, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line">IPC_STAT 复制消息队列关联的数据结构</span><br><span class="line">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class="line">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class="line">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class="line"></span><br><span class="line">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class="line">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure><h2 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h2><h2 id="IPC命令-查看进程间通信的全局唯一key"><a href="#IPC命令-查看进程间通信的全局唯一key" class="headerlink" title="IPC命令-查看进程间通信的全局唯一key"></a>IPC命令-查看进程间通信的全局唯一key</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十三章多进程编程&quot;&gt;&lt;a href=&quot;#第十三章多进程编程&quot; class=&quot;headerlink&quot; title=&quot;第十三章多进程编程&quot;&gt;&lt;/a&gt;第十三章多进程编程&lt;/h1&gt;&lt;h2 id=&quot;exec系列系统调用&quot;&gt;&lt;a href=&quot;#exec系列系统调用&quot; cla</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="多进程" scheme="http://icecorn.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器中的一些理解</title>
    <link href="http://icecorn.github.io/2022/05/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/"/>
    <id>http://icecorn.github.io/2022/05/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/</id>
    <published>2022-05-12T09:25:10.000Z</published>
    <updated>2022-06-29T16:00:39.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux服务器的一些理解"><a href="#Linux服务器的一些理解" class="headerlink" title="Linux服务器的一些理解"></a>Linux服务器的一些理解</h1><h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p><a href="https://blog.csdn.net/yushuaigee/article/details/107883964">https://blog.csdn.net/yushuaigee/article/details/107883964</a></p><h2 id="proactor和reactor"><a href="#proactor和reactor" class="headerlink" title="proactor和reactor"></a>proactor和reactor</h2><p>区别就在于谁去处理用户socket到用户缓冲区的数据复制，因为这是一个很费的操作</p><p>reator就是主线程告诉子线程去处理，子线程完成数据复制的操作，因为这个操作很费事件，所以就相当于这个线程被阻塞掉了，假如系统有8个线程，而且都被阻塞掉了，那么epoll事件表里的其他事件就不能第一时间去处理，所以就表现为服务器并发性不高，比如8线程满了，用户再想关掉连接，就没反应</p><p>proactor模式就是主线程告诉<strong>内核线程</strong>去做数据复制的操作，这期间8个子线程都可以各自干别的事，当内核线程复制完了之后，会发送一个信号，唤醒一个休眠的子线程并且告诉它数据在的内存地址，然后子线程就去处理，只需要处理逻辑部分即可</p><p>模拟proactor模式是说用主线程充当内核线程，就是说主线程来处理数据复制的操作，然后再告诉子线程去做逻辑操作</p><p>问题：</p><p>1.复制数据这个费时间的事肯定要有人去办，内核线程去办是怎么处理的呢？</p><p>猜想：应为数据复制的最终速度还是取决于内存和cathe之类的硬件读写速度，各种并发处理只不过是把整个http请求的粒度变小，使得服务器能够再很快的时间内承载更多的连接。</p><p>2.epoll_wait循环是多久一次呢？</p><p>应该是很快的，应为不论是listen和in out事件，主线程实际上只是创建连接，添加请求对列这点事，没有内存数据复制操作，所以会快，当然模拟proactor模式例外，因为他用主线程模拟内核线程</p><p>3.one loop pre thread</p><p>我觉得目的应该是更进一步解放主线程，主线程只处理listenfd建立连接的操作，每个子线程维护一个epoll循环处理每个用户连接的读写操作。好处就是服务器可以并发处理更多的连接请求，猜测这里可能和TCP协议有关系？假如短时间大量请求发生，如果没有及时处理请求，那么TCP协议长时间没收到反馈会断掉之类的？</p><hr><h2 id="并发模式"><a href="#并发模式" class="headerlink" title="并发模式"></a>并发模式</h2><h3 id="半同步半反应堆"><a href="#半同步半反应堆" class="headerlink" title="半同步半反应堆"></a>半同步半反应堆</h3><p>这里的同步和异步指的是一个进程是否一路执行到底，没有中断</p><p>半同步指的是每个线程都直接执行到底</p><p>半反应堆指的是主线程维护一个epoll事件表，循环处理</p><p>要注意的是不要和上边的两种事件处理模式弄混，这里半同步半反应堆同样可以使用proactor事件处理模式</p><h3 id="半同步半异步"><a href="#半同步半异步" class="headerlink" title="半同步半异步"></a>半同步半异步</h3><p>这里不是存粹的半同步半异步，感觉和one thread one loop是一样的，就是每个子线程都维护一个epoll事件表，用它来监听多个http连接的读写事件，这就实现了同一时间一个子线程可以处理多个http连接的读写。<strong>另外一个好处是可以减少线程加锁的开销，因为如果只有主线程一个epoll的话，就是只有一个事件队列，这样不管是主线程加入新的socket还是子线程处理读写socket都要对这个事件队列进行加锁，而one thread one loop就可以避免这种情况</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Linux服务器的一些理解&quot;&gt;&lt;a href=&quot;#Linux服务器的一些理解&quot; class=&quot;headerlink&quot; title=&quot;Linux服务器的一些理解&quot;&gt;&lt;/a&gt;Linux服务器的一些理解&lt;/h1&gt;&lt;h2 id=&quot;文件描述符&quot;&gt;&lt;a href=&quot;#文件描述</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第九章-IO复用</title>
    <link href="http://icecorn.github.io/2022/05/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%B9%9D%E7%AB%A0-IO%E5%A4%8D%E7%94%A8/"/>
    <id>http://icecorn.github.io/2022/05/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%B9%9D%E7%AB%A0-IO%E5%A4%8D%E7%94%A8/</id>
    <published>2022-05-09T09:25:10.000Z</published>
    <updated>2022-06-29T15:36:48.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-I-O复用"><a href="#第九章-I-O复用" class="headerlink" title="第九章 I/O复用"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p><ul><li>客户端程序需要同时处理多个socket 非阻塞connect技术</li><li>客户端程序同时处理用户输入和网络连接 聊天室程序</li><li>TCP服务器要同时处理监听socket和连接socket</li><li>同时处理TCP和UDP请求 - 回射服务器</li><li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li></ul><p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">// nfds - 被监听的文件描述符总数</span></span><br><span class="line"><span class="comment">// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span> <span class="params">(<span class="type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作fd_set的宏</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set* fdset);</span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="comment">// 设置 timeval 超时时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">// 秒</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select</strong></p><p>文件描述符就绪条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt来读取和清除错误</li><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记</li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后</li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p><strong>poll</strong><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png"><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\</span></span><br><span class="line"><span class="comment">// nfds 遍历结合大小 左闭右开</span></span><br><span class="line"><span class="comment">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">short</span> events;  <span class="comment">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class="line"><span class="type">short</span> revents; <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> exit_if(r, ...) \</span></span><br><span class="line"><span class="meta">&#123;   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (r)  \</span></span><br><span class="line"><span class="meta">    &#123;   \</span></span><br><span class="line"><span class="meta">        printf(__VA_ARGS__);    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;errno no: %d, error msg is %s&quot;</span>, errno, strerror(errno));    \</span></span><br><span class="line"><span class="meta">        exit(1);    \</span></span><br><span class="line"><span class="meta">    &#125;   \</span></span><br><span class="line"><span class="meta">&#125;   \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_info</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ip_;</span><br><span class="line">    <span class="type">int</span> port_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> port = <span class="number">8001</span>;</span><br><span class="line">    <span class="type">char</span> ip[] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">htons</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit_if</span>(listenfd &lt; <span class="number">0</span>, <span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">exit_if</span>(ret == <span class="number">-1</span>, <span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit_if</span>(ret == <span class="number">-1</span>, <span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> MAX_CLIENTS = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> polls[MAX_CLIENTS] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">client_info</span> clientsinfo[MAX_CLIENTS] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    polls[<span class="number">3</span>].fd = listenfd;</span><br><span class="line">    polls[<span class="number">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">poll</span>(polls, MAX_CLIENTS + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">exit_if</span>(ret == <span class="number">-1</span>, <span class="string">&quot;poll error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = polls[i].fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class="line">            &#123;</span><br><span class="line">                polls[i].events = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;close fd-%d from %s:%d\n&quot;</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == listenfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                    <span class="type">socklen_t</span> client_addresslen = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> clientfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address,</span><br><span class="line">                            &amp;client_addresslen);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">client_info</span> *clientinfo = &amp;clientsinfo[clientfd];</span><br><span class="line"></span><br><span class="line">                    clientinfo-&gt;ip_ = <span class="built_in">inet_ntoa</span>(client_address.sin_addr);</span><br><span class="line">                    clientinfo-&gt;port_ = <span class="built_in">ntohs</span>(client_address.sin_port);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">exit_if</span>(clientfd &lt; <span class="number">0</span>, <span class="string">&quot;accpet error, from %s:%d\n&quot;</span>, clientinfo-&gt;ip_,</span><br><span class="line">                            clientinfo-&gt;port_);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;accept from %s:%d\n&quot;</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class="line"></span><br><span class="line">                    polls[clientfd].fd = clientfd;</span><br><span class="line">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">                    ret = <span class="built_in">read</span>(fd, buffer, <span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv from %s:%d:\n%s\n&quot;</span>, clientsinfo[fd].ip_,</span><br><span class="line">                               clientsinfo[fd].port_, buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll</strong></p><p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p><ul><li>epoll使用一组函数完成任务</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li><li>epoll无需每次调用都传入文件描述符集或事件集.</li></ul><p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p><p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">poll</span>(fds, MAX_EVENT_NUMBER - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="type">int</span> sockfd = fds[i].fd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENT_NUMBER,  <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">// sockfd 一定就绪 ?????</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p><p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p><p>ET模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of content: 123456789</span><br><span class="line">get 9bytes of content: -12345678</span><br><span class="line">get 9bytes of content: 9-1234567</span><br><span class="line">get 4bytes of content: 89</span><br><span class="line">read later</span><br></pre></td></tr></table></figure><p>LT模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: -12345678</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 9-1234567</span><br><span class="line">event trigger once</span><br><span class="line">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure><p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class="line"><span class="comment">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epfd 为 epoll_create的返回值</span></span><br><span class="line"><span class="comment">// op为操作类型</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class="line"><span class="comment">// fd 为要操作的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">_uint32_t</span> events; <span class="comment">// epoll事件</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据 是一个联合体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr; <span class="comment">// ptr fd 不能同时使用</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxevents监听事件数 必须大于0</span></span><br><span class="line"><span class="comment">// timeout 为-1 表示阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="三种IO复用的比较"><a href="#三种IO复用的比较" class="headerlink" title="三种IO复用的比较"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p><ul><li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li><li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li><li><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png"></li></ul><h2 id="I-O-复用的高级应用-非阻塞connect"><a href="#I-O-复用的高级应用-非阻塞connect" class="headerlink" title="I/O 复用的高级应用, 非阻塞connect"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p><p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-I-O复用&quot;&gt;&lt;a href=&quot;#第九章-I-O复用&quot; class=&quot;headerlink&quot; title=&quot;第九章 I/O复用&quot;&gt;&lt;/a&gt;第九章 I/O复用&lt;/h1&gt;&lt;p&gt;I/O复用使得程序能同时监听多个文件描述符.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端程序需</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第八章-Linux高性能服务器框架</title>
    <link href="http://icecorn.github.io/2022/05/05/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%85%AB%E7%AB%A0-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://icecorn.github.io/2022/05/05/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%85%AB%E7%AB%A0-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</id>
    <published>2022-05-05T09:25:10.000Z</published>
    <updated>2022-06-29T15:34:50.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第八章高性能服务器程序框架"><a href="#第八章高性能服务器程序框架" class="headerlink" title="第八章高性能服务器程序框架"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p><p><strong>优点</strong></p><ul><li>实现起来简单<br><strong>缺点</strong></li><li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li></ul><p>模式图<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233248719.png" alt="image-20220629233248719"></p><p>编写的demo 没有用到fork函数. 后续待完善</p><p><strong>服务器框架 IO模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png"></p><p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p><p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p><p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p><p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p><p><strong>两种高效的事件处理模式和并发模式</strong><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/Reactor%E6%A8%A1%E5%BC%8F.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233354924.png" alt="image-20220629233354924"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233409090.png" alt="image-20220629233409090"></p><p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p><p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p><ul><li>半同步/半异步模式</li><li>领导者/追随者模式</li></ul><p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p><p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233423078.png" alt="image-20220629233423078"></p><p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p><p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png"></p><p>异步线程 - 主线程 - 负责监听所有socket上的事件</p><p><strong>领导者/追随者模式</strong><br>略</p><p><strong>高效编程方法 - 有限状态机</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态独立的有限状态机</span></span><br><span class="line">STATE_MACHINE(Package _pack) &#123;</span><br><span class="line"></span><br><span class="line">PackageType _type = _pack.GetType();</span><br><span class="line"><span class="keyword">switch</span>(_type) &#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">xxxx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">xxxx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态转移的有限状态机</span></span><br><span class="line">STATE_MACHINE() &#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line"><span class="keyword">while</span>(cur_State != type_C) &#123;</span><br><span class="line"></span><br><span class="line">Package _pack = getNewPackage();</span><br><span class="line"><span class="keyword">switch</span>(cur_State) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_state_A(_pack);</span><br><span class="line">cur_State = type_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">xxxx;</span><br><span class="line">cur_State = type_C;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提高服务器性能的其他建议-池-数据复制-上下文切换和锁"><a href="#提高服务器性能的其他建议-池-数据复制-上下文切换和锁" class="headerlink" title="提高服务器性能的其他建议 池 数据复制 上下文切换和锁"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p><p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p><p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第八章高性能服务器程序框架&quot;&gt;&lt;a href=&quot;#第八章高性能服务器程序框架&quot; class=&quot;headerlink&quot; title=&quot;第八章高性能服务器程序框架&quot;&gt;&lt;/a&gt;第八章高性能服务器程序框架&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;服务器模型-CS模型&lt;/strong</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第6-7章-Linux高级IO函数&amp;Linux服务器程序规范</title>
    <link href="http://icecorn.github.io/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC6-7%E7%AB%A0-Linux%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0&amp;Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/"/>
    <id>http://icecorn.github.io/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC6-7%E7%AB%A0-Linux%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0&amp;Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/</id>
    <published>2022-05-03T09:25:10.000Z</published>
    <updated>2022-06-29T15:30:17.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章高级IO函数"><a href="#第六章高级IO函数" class="headerlink" title="第六章高级IO函数"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p><h3 id="创建文件描述符-pipe-dup-dup2-splice-select"><a href="#创建文件描述符-pipe-dup-dup2-splice-select" class="headerlink" title="创建文件描述符 - pipe dup dup2 splice select"></a>创建文件描述符 - pipe dup dup2 splice select</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class="line"><span class="comment">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class="line"><span class="comment">// 失败返回-1 errno</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向管道</span></span><br><span class="line"><span class="comment">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> a[] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        send(fds[<span class="number">1</span>], a, <span class="built_in">strlen</span>(a), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">char</span> b[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">        recv(fds[<span class="number">0</span>], b, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class="line"><span class="comment">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> filefd = open(<span class="string">&quot;/home/lsmg/1.txt&quot;</span>, O_WRONLY);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    dup(filefd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写数据-readv-writev-mmap-munmap"><a href="#读写数据-readv-writev-mmap-munmap" class="headerlink" title="读写数据 - readv writev mmap munmap"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class="line"><span class="comment">// 成功时返回写入\读取的长度 失败返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* <span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* <span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="type">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line"><span class="type">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2020年1月7日16:52:11</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> file = open(<span class="string">&quot;/home/lsmg/1.txt&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">100000</span>;</span><br><span class="line">    iovec temp_iovec&#123;&#125;;</span><br><span class="line">    temp_iovec.iov_base = &amp;temp;</span><br><span class="line">    temp_iovec.iov_len = <span class="keyword">sizeof</span>(temp);</span><br><span class="line">    writev(file, &amp;temp_iovec, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendfile函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="comment">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line">O_RDONLY只读模式</span><br><span class="line">O_WRONLY只写模式</span><br><span class="line">O_RDWR读写模式</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(file_name, flag)</span>;</span><br></pre></td></tr></table></figure><p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span>       st_dev;     <span class="comment">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class="line">    <span class="type">ino_t</span>       st_ino;     <span class="comment">/* inode number -inode节点号*/</span></span><br><span class="line">    <span class="type">mode_t</span>      st_mode;    <span class="comment">/* protection -保护模式?*/</span></span><br><span class="line">    <span class="type">nlink_t</span>     st_nlink;   <span class="comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class="line">    <span class="type">uid_t</span>       st_uid;     <span class="comment">/* user ID of owner -user id*/</span></span><br><span class="line">    <span class="type">gid_t</span>       st_gid;     <span class="comment">/* group ID of owner - group id*/</span></span><br><span class="line">    <span class="type">dev_t</span>       st_rdev;    <span class="comment">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class="line">    <span class="type">off_t</span>       st_size;    <span class="comment">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class="line">    <span class="type">blksize_t</span>   st_blksize; <span class="comment">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class="line">    <span class="type">blkcnt_t</span>    st_blocks;  <span class="comment">/* number of blocks allocated -文件所占块数*/</span></span><br><span class="line">    <span class="type">time_t</span>      st_atime;   <span class="comment">/* time of last access -最近存取时间*/</span></span><br><span class="line">    <span class="type">time_t</span>      st_mtime;   <span class="comment">/* time of last modification -最近修改时间*/</span></span><br><span class="line">    <span class="type">time_t</span>      st_ctime;   <span class="comment">/* time of last status change - */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>身份证</strong>生成函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数需要调用open生成文件描述符</span></span><br><span class="line"><span class="comment">// 下面其他两个为文件全路径</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class="line"><span class="comment">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class="line"><span class="comment">* 删除就可以正常访问</span></span><br><span class="line"><span class="comment">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class="line"><span class="comment">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> <strong>mmap和munmap函数</strong></p><p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class="line"><span class="comment">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class="line"><span class="comment">// flag参数 内存被修改后的行为</span></span><br><span class="line"><span class="comment">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class="line"><span class="comment">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class="line"><span class="comment">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class="line"><span class="comment">// 成功返回区域指针, 失败返回 -1</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> port, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class="line"><span class="comment">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class="line"><span class="comment">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class="line"><span class="comment">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span>* off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span>* off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用splice函数  实现echo服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the parmerters is wrong\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the port is %d the ip is %s\n&quot;</span>, port, ip);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd&#123;&#125;;</span><br><span class="line">    sockaddr_in client_address&#123;&#125;;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span> (clientfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a new connection from %s:%d success\n&quot;</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class="line">        <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        pipe(fds);</span><br><span class="line">        ret = splice(clientfd, nullptr, fds[<span class="number">1</span>], nullptr, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ret = splice(fds[<span class="number">0</span>], nullptr, clientfd, nullptr, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        close(clientfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select 函数</strong><br>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p><p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p><p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="comment">// maxfdp 最大数 FD_SETSIZE</span></span><br><span class="line"><span class="comment">// struct fd_set 一个集合,可以存储多个文件描述符</span></span><br><span class="line"><span class="comment">// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd</span></span><br><span class="line"><span class="comment">// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中</span></span><br><span class="line"><span class="comment">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class="line"><span class="comment">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class="line"><span class="comment">// errorfds 错误</span></span><br><span class="line"><span class="comment">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class="line"><span class="comment">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,<span class="keyword">struct</span> timeval*timeout)</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exit_if(r, ...) \</span></span><br><span class="line"><span class="meta">&#123;   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (r)  \</span></span><br><span class="line"><span class="meta">    &#123;   \</span></span><br><span class="line"><span class="meta">        printf(__VA_ARGS__);    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;errno no: %d, error msg is %s&quot;</span>, errno, strerror(errno));    \</span></span><br><span class="line"><span class="meta">        exit(1);    \</span></span><br><span class="line"><span class="meta">    &#125;   \</span></span><br><span class="line"><span class="meta">&#125;   \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> keyboard_fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    exit_if(keyboard_fd &lt; <span class="number">0</span>, <span class="string">&quot;open keyboard fd error\n&quot;</span>);</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    <span class="type">char</span> recv_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;readfd);</span><br><span class="line">        FD_SET(<span class="number">0</span>, &amp;readfd);</span><br><span class="line"></span><br><span class="line">        timeval timeout &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = select(keyboard_fd + <span class="number">1</span>, &amp;readfd, nullptr, nullptr, &amp;timeout);</span><br><span class="line">        exit_if(ret == <span class="number">-1</span>, <span class="string">&quot;select error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(keyboard_fd, &amp;readfd))</span><br><span class="line">            &#123;</span><br><span class="line">                recv_buffer = <span class="number">0</span>;</span><br><span class="line">                read(keyboard_fd, &amp;recv_buffer, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == recv_buffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;q&#x27;</span> == recv_buffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the input is %c\n&quot;</span>, recv_buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第七章Linux服务器程序规范"><a href="#第七章Linux服务器程序规范" class="headerlink" title="第七章Linux服务器程序规范"></a>第七章Linux服务器程序规范</h2><ul><li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li><li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li><li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li><li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li><li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li><li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="comment">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class="line"><span class="comment">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class="line"><span class="comment">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class="line"><span class="comment">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class="line"><span class="comment">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class="line"><span class="comment">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class="line"><span class="comment">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class="line"><span class="comment">// - 6 LOG_INFO /* 信息*/</span></span><br><span class="line"><span class="comment">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, .....)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ident 位于日志的时间后 通常为名字</span></span><br><span class="line"><span class="comment">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class="line"><span class="comment">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class="line"><span class="comment">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class="line"><span class="comment">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class="line"><span class="comment">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class="line"><span class="comment">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maskpri 一共八位 0000-0000</span></span><br><span class="line"><span class="comment">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class="line"><span class="comment">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class="line"><span class="comment">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class="line"><span class="comment">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭日志功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="用户信息-切换用户"><a href="#用户信息-切换用户" class="headerlink" title="用户信息, 切换用户"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure><p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p><p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p><p><strong>会话</strong><br>一些有关联的进程组将形成一个会话</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六章高级IO函数&quot;&gt;&lt;a href=&quot;#第六章高级IO函数&quot; class=&quot;headerlink&quot; title=&quot;第六章高级IO函数&quot;&gt;&lt;/a&gt;第六章高级IO函数&lt;/h2&gt;&lt;p&gt;Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第五章-Linux网络编程基础API</title>
    <link href="http://icecorn.github.io/2022/04/30/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%94%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/"/>
    <id>http://icecorn.github.io/2022/04/30/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%94%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/</id>
    <published>2022-04-30T09:25:10.000Z</published>
    <updated>2022-06-29T15:27:08.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章Linux网络编程基础API"><a href="#第五章Linux网络编程基础API" class="headerlink" title="第五章Linux网络编程基础API"></a>第五章Linux网络编程基础API</h2><p>socket基础api位于 <code>sys/socket.h</code> 头文件中<br>socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段<br>网络信息api <code>netdb.h</code>头文件中</p><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p><p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>基础连接</strong><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机序和网络字节序转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">htonl</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span></span>; <span class="comment">// host to network long</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostlong)</span></span>; <span class="comment">// host to network short</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">htonl</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址转换函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span>  <span class="title">inet_addr</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* strptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* cp, <span class="keyword">struct</span> in_addr* inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class="line"><span class="comment">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> * src, <span class="type">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>*  src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 命名 监听 socket</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class="line"><span class="comment">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class="line"><span class="comment">// protocol设置为默认的0</span></span><br><span class="line"><span class="comment">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket为socket文件描述符</span></span><br><span class="line"><span class="comment">// my_addr 为地址信息</span></span><br><span class="line"><span class="comment">// addrlen为socket地址长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog表示队列最大的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第三个参数为 地址指定的长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * serv_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数为保存的socket</span></span><br><span class="line"><span class="comment">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即关闭</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第二个参数为可选值 </span></span><br><span class="line"><span class="comment">//SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class="line"><span class="comment">//SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class="line"><span class="comment">//SHUT_RDWR 同时关闭读和写</span></span><br><span class="line"><span class="comment">// 成功返回0 失败为-1 设置errno</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span><br></pre></td></tr></table></figure><p><strong>基础TCP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取sockfd的数据</span></span><br><span class="line"><span class="comment">// buf 指定读缓冲区的位置</span></span><br><span class="line"><span class="comment">// len 指定读缓冲区的大小</span></span><br><span class="line"><span class="comment">// flags 参数较多</span></span><br><span class="line"><span class="comment">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项名</th><th>含义</th><th>可用于发送</th><th>可用于接收</th></tr></thead><tbody><tr><td>MSG_CONFIRM</td><td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTROUTE</td><td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTWAIT</td><td>非阻塞</td><td>Y</td><td>Y</td></tr><tr><td>MSG_MORE</td><td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td><td>Y</td><td>N</td></tr><tr><td>MSG_WAITALL</td><td>读操作一直等待到读取到指定字节后才会返回</td><td>N</td><td>Y</td></tr><tr><td>MSG_PEEK</td><td>看一下内缓存数据, 并不会影响数据</td><td>N</td><td>Y</td></tr><tr><td>MSG_OOB</td><td>发送或接收紧急数据</td><td>Y</td><td>Y</td></tr><tr><td>MSG_NOSIGNAL</td><td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td><td>Y</td><td>N</td></tr></tbody></table><p><strong>基础UDP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class="line"><span class="comment">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, ing flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通用读写函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class="line"><span class="type">void</span>* msg_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">socklen_t</span> msg_namelen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class="line"><span class="comment">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class="line"><span class="comment">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span></span><br><span class="line"><span class="type">int</span> msg_iovlen; <span class="comment">/* 分散内存块的数量*/</span></span><br><span class="line"><span class="type">void</span>* msg_control; <span class="comment">/* 指向辅助数据的起始位置*/</span></span><br><span class="line"><span class="type">socklen_t</span> msg_controllen; <span class="comment">/* 辅助数据的大小*/</span></span><br><span class="line"><span class="type">int</span> msg_flags; <span class="comment">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line"><span class="type">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他Api</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class="line"><span class="comment">// 是的话返回1, 不是返回0</span></span><br><span class="line"><span class="comment">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class="line"><span class="comment">// getpeername 获取远端的信息, 同上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数头文件均相同*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class="line"><span class="comment">// 成功时返回0 失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> <span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> <span class="keyword">restrict</span> option_len)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>SO_REUSEADDR</th><th>重用本地地址</th><th>sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock</th></tr></thead><tbody><tr><td>SO_RCVBUF</td><td>TCP接收缓冲区大小</td><td>最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞</td></tr><tr><td>SO_SNDBUF</td><td>TCP发送缓冲区大小</td><td>最小值为2048字节</td></tr><tr><td>SO_RCVLOWAT</td><td>接收的低水位标记</td><td>默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据</td></tr><tr><td>SO_SNDLOWAT</td><td>发送的高水位标记</td><td>默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据</td></tr><tr><td>SO_LINGER</td><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> l_onoff <span class="comment">/* 开启非0, 关闭为0*/</span></span><br><span class="line"><span class="type">int</span> l_linger; <span class="comment">/* 滞留时间*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class="line"><span class="comment">* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class="line"><span class="comment">* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class="line"><span class="comment">* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/socket%E9%80%89%E9%A1%B9.jpg"></p><p><strong>网络信息API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过主机名查找ip</span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ip获取主机完整信息 </span></span><br><span class="line"><span class="comment">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *h_name;<span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="type">char</span> **h_aliases;<span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="type">int</span> h_addrtype;<span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="type">int</span> h_length;<span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="type">char</span> **h_addr_list;<span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;非法输入\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostptr</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    hostptr = gethostbyname(name);</span><br><span class="line">    <span class="keyword">if</span> (hostptr == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入存在错误 或无法获取\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name of hostptr: %s\n&quot;</span>, hostptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="type">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alias list:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != nullptr; ++pptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AF_INET:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;List of addresses from name server:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != nullptr; ++pptr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\t%s\n&quot;</span>,</span><br><span class="line">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class="keyword">sizeof</span>(inet_addr)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknow address type\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">./run baidu.com</span></span><br><span class="line"><span class="comment">Official name of hostptr: baidu.com</span></span><br><span class="line"><span class="comment">Alias list:</span></span><br><span class="line"><span class="comment">List of addresses from name server:</span></span><br><span class="line"><span class="comment">39.156.69.79</span></span><br><span class="line"><span class="comment">220.181.38.148</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p><p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p><ul><li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li><li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 根据名称获取某个服务的完整信息</span></span><br><span class="line"><span class="keyword">struct</span> servent <span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据端口号获取服务信息</span></span><br><span class="line"><span class="keyword">struct</span> servent <span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span>* s_name; <span class="comment">/* 服务名称*/</span></span><br><span class="line"><span class="type">char</span> ** s_aliases; <span class="comment">/* 服务的别名列表*/</span></span><br><span class="line"><span class="type">int</span> s_port; <span class="comment">/* 端口号*/</span></span><br><span class="line"><span class="type">char</span>* s_proto; <span class="comment">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class="line"><span class="comment">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class="line"><span class="comment">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class="line"><span class="comment">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class="line"><span class="comment">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname, <span class="type">const</span> <span class="type">char</span>* service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> addrinfo</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ai_flags;</span><br><span class="line"><span class="type">int</span> ai_family;</span><br><span class="line"><span class="type">int</span> ai_socktype; <span class="comment">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class="line"><span class="type">int</span> ai_protocol;</span><br><span class="line"><span class="type">socklen_t</span> ai_addrlen;</span><br><span class="line"><span class="type">char</span>* ai_canonname; <span class="comment">/* 主机的别名*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/* 指向socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/* 指向下一个结构体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要手动的释放堆内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo* res)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/7ebedb14d8eedeac.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// host 存储返回的主机名</span></span><br><span class="line"><span class="comment">// serv存储返回的服务名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv</span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/bc7196e9a30d5152.png"></p><p>测试使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet ip port #来连接服务器的此端口</span><br><span class="line">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第五章Linux网络编程基础API&quot;&gt;&lt;a href=&quot;#第五章Linux网络编程基础API&quot; class=&quot;headerlink&quot; title=&quot;第五章Linux网络编程基础API&quot;&gt;&lt;/a&gt;第五章Linux网络编程基础API&lt;/h2&gt;&lt;p&gt;socket基础ap</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第1-3章-计算机网络部分</title>
    <link href="http://icecorn.github.io/2022/04/27/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%AE%A1%E7%BD%91%E9%83%A8%E5%88%86-1-3%E7%AB%A0/"/>
    <id>http://icecorn.github.io/2022/04/27/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%AE%A1%E7%BD%91%E9%83%A8%E5%88%86-1-3%E7%AB%A0/</id>
    <published>2022-04-27T09:25:10.000Z</published>
    <updated>2022-06-29T15:22:52.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h2><h3 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h3><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg"></p><p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li><li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li><li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li><li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li></ul><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h2 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h2><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p><p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png"></p><p>路由机制</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png"></p><p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p><ul><li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li><li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li><li>选择默认路由项, 通常意味着下一跳路由是网关</li></ul><h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p><p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p><p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p><p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p><p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p><p><strong>TCP连接的建立和关闭</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 三次握手</span><br><span class="line"># 客户端发送请求连接 ISN=seq + 0 = 3683340920</span><br><span class="line"># mss 最大数据载量1460</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [S], seq 3683340920, win 64240, </span><br><span class="line">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class="line"></span><br><span class="line"># 同意客户端连接</span><br><span class="line"># ack = 客户端发送 seq + 1</span><br><span class="line"># 同时发送服务端的seq</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class="line">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class="line"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 = 1</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 938535102, win 4106, length 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"># 服务端确认关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [.], ack 2, win 502, length 0</span><br><span class="line"></span><br><span class="line"># 服务端发送关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class="line"></span><br><span class="line"># 客户端确认</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-TCP-IP协议族&quot;&gt;&lt;a href=&quot;#第一章-TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;第一章 TCP/IP协议族&quot;&gt;&lt;/a&gt;第一章 TCP/IP协议族&lt;/h2&gt;&lt;h3 id=&quot;TCP-IP协议族体系结构和主要协议&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第四讲-分配器/new&amp;delete</title>
    <link href="http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    <id>http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/</id>
    <published>2022-04-16T09:25:10.000Z</published>
    <updated>2022-06-29T15:50:29.412Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h3 id="七种分配器"><a href="#七种分配器" class="headerlink" title="七种分配器"></a>七种分配器</h3><ul><li><p><strong>new_allocator</strong></p><p>没做什么事，直接调用malloc/free，包装了一层而已</p></li><li><p><strong>malloc_allocator</strong></p><p>和new_allocator一样</p></li><li><p><strong>array_allocator</strong></p><p>分配一个静态的内存空间，不需要考虑归还的事情，其实就是c++的array</p></li><li><p><strong>debug_allocator</strong></p><p>其实就是每分配一块内存都多加一个M_extra的内存来占一个元素的大小用于debug</p></li><li><p><strong>pool_allocator</strong></p><p>就是第二讲讲的内存池的实现，16个自由链表挂载不同粒度的内存块，缺点是没有动态free,但不能算作内存泄漏，因为那些内存还在分配器的掌控之下</p></li><li><p>bitmap_allocator</p><p>用一个索引以 2 的指数倍数成长的桶子(exponentially increasing power-of-two-sized buckets)的思路。先捋一捋bitmap_allocator实现当中的相关数据结构的概念：</p><p><strong>blocks：</strong>即是进行分配的内存区块，每个block size一般取8bytes，是super-block的一部分；<br><strong>super-blocks：</strong>表示一个__mini_vector所管理的整个内存空间，bitmap_allocator进行管理内存空间扩容/缩减的操作就是通过增加或减少super-blocks的数目来实现的，是 bitmap_allocator 进行内存管理的基本单位；<br>bitmap：记录一个__mini_vector所管理的内存空间所属的64个 blocks 的分配情况(依据增长情况，不一定是64个，也可能是128/256，block数目是2的幂次增长的)，所以为64bit，8bytes(0表示分配出去了，1表示未分配出去；若是全未分配出去则为0x FFFF FFFF FFFF FFFF，若是第一个分配出去则为 0x FFFF FFFF FFFF FFFE(1110)，即bitmap字节序从低位到高位表示的是block序号从63到0)，是super-block的一部分；<br><strong>mini-vector：</strong>该数据结构的实现是为了避免作为容器的分配其还嵌套容器所造成的先有鸡还是先有蛋的困扰，实现过程也即和vector的实现思路相似，见 vector 容器。含有三个成员变量_M_start；(表示所管理的block的起始位置，即block0的内存地址)，_M_finish；(表示第一个可分配的block的内存位置)，_M_end_of_storage;(类似于vector当中的capacity概念)。其作用是对 super-block 进行存储、访问和管理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514202055.png"></p></li><li><p><strong>mt_allocator</strong></p><p>针对多线程的分配器</p></li></ul><hr><h3 id="关于Const"><a href="#关于Const" class="headerlink" title="关于Const"></a>关于Const</h3><p>const放在<strong>成员函数</strong>后，是告诉编译器这个成员函数不改变这个类的data</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514210303.png"></p><p>记住non_const obj可以调用const函数，反过来则不行，如果const和non_const函数都有的话，就各调用各的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514211437.png"></p><p>上图右边两个函数名称一样，只是一个多了const，所以const是算在函数签名里边的。</p><p>举例 string s1 = “abc”; s1[0] = ‘d’;这样就发生了写操作，这里s1实际调用的就是重载[]的非const版本，<strong>同时这里要考虑COW，就是有多个线程同时共有s1的话，要加锁，不要发生重写，脏数据等情况</strong></p><p>const string s2 = “abc”; s2是常量，所以s2[0]访问的就是const版本的重载[]函数，且无需考虑COW</p><hr><h3 id="关于new，delete"><a href="#关于new，delete" class="headerlink" title="关于new，delete"></a>关于new，delete</h3><p><strong>new：</strong></p><p>1.调用operator new(),这个函数是可以重载的，可以实现内存池，这个函数默认就是调用malloc（）分配一块内存</p><p>2.static_cast&lt;T*&gt; 将1中分配的内存强制转型成想new的数据类型</p><p>3.调用new的类的构造函数</p><p><strong>delete：</strong></p><p>1.调用该对象的析构函数，这里要注意的是，如果这个对象没有指针类型的data，那么其实不析构也没啥事，有的话就一定要析构</p><p>2.调用delete释放这块内存，这里实际就是调用free（）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514212527.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h3 id=&quot;七种分配器&quot;&gt;&lt;a href=&quot;#七种分配器&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第三讲-malloc/free</title>
    <link href="http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/"/>
    <id>http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/</id>
    <published>2022-04-11T09:25:10.000Z</published>
    <updated>2022-06-29T15:50:22.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc/free"></a>malloc/free</h2><h3 id="一、VC6内存分配"><a href="#一、VC6内存分配" class="headerlink" title="一、VC6内存分配"></a>一、VC6内存分配</h3><p>下图左边是函数调用栈，最下方是操作系统</p><p><img src="https://i.imgur.com/GSff1Jp.png"></p><p>SBH：VC6 malloc对小区块（1016）的分配有特殊处理。在后续的版本VC10 取消了SBH的实现，全部交给操作系统来做（HeapAlloc()函数，OS对小区快内存的分配也和VC6类似）</p><p>下图是VC10的call stack，红×是相对VC6去掉的，最大区别就是取消了SBH，全部移交OS分配</p><p><img src="https://i.imgur.com/EZG35WQ.png"></p><h4 id="SBH之始"><a href="#SBH之始" class="headerlink" title="SBH之始"></a>SBH之始</h4><p><strong>以下内容核心的目的，就是通过组织一些数据结构和算法来管理1MB的内存的灵活分配和释放（因为超过1MB就不用SBH，直接交给OS管理）</strong></p><p>首先call OS的系统函数HeapCreate（），申请一块4096bits的内存(_crtheap)供后续使用，</p><p>即__cdecl_heap_init()，创建了16个Header</p><p><img src="https://s2.loli.net/2022/05/13/4kxruOeRVKcI3GM.png"></p><p>CRT：C Run Time</p><p>Header里边包括下边这些东西，具体干什么用的下文再说</p><p><img src="https://s2.loli.net/2022/05/13/Cu87lfJpyGnMLFz.png"></p><p>debug模式会多增加一些内存用于跟踪我们使用的内存，这就是VS debug模式能显示堆栈中变量及地址的原因</p><p><strong>ioinit（）</strong>函数是首次分配内存的函数，而且必定是256个字节（16进制为100）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513215753.png"></p><p>接着往下调用到**_heap_alloc_dbg()<strong>,这个函数的参数是下图中的blocksize= debug模式需要的内存（下图上方灰色部分）+ 上下两个“无人区”（下图深绿部分，一个4字节）+ 实际内存大小（下图浅绿部分，256字节）</strong>补充一点：上下无人区实际也属于debug模式的信息，release模式就没有了**</p><p><strong>无人区</strong>起到一个栏杆的作用，从而调试器可以检测出内存越界行为</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513223103.png"></p><p>pBlockHeaderNext;pBlockHeaderPrev这两个指针的作用就是将SBH分配的所有的内存区块全部串联起来，从而来管理</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513230245.png"></p><p>接下来调用**_heap_alloc_base()**这个函数就是在加完debug这些内存之后，判断有没有超过1016个字节，没超过就SBH，超过了就OS分配</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513230944.png"></p><p>接下来调用**__sbh_alloc_block()**,这个函数作用：</p><p>下图add 8 bytes就是加入了上下cookies，然后进行对齐操作，将这个带着上下cookies的内存块上调为16 bytes对齐</p><p>这些整个的大小是0X130，但是cookies里却存的是00000131，这里是用了个trick，因为内存块是16位对齐的，那么最后一位必然是0，所以这里cookies那里就用结尾存0或1来表示这个内存块的状态（使用，释放）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513231905.png"></p><p><strong>以上这些内容都是在计算所需内存大小，还没有实际分配内存，自然更谈不上初始化内容</strong></p><p>下面将进入实际分配内存的环节：</p><p>之前讲过有16个Header，它们每个控制1MB的内存（通过win API申请的Virtual melloc（））</p><p>下图就是将它们控制的region是怎么玩的，细节是一个header的一个group维护了64个指针（双向链表）来控制这1MB，这些指针消耗大概16K</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220513233203018.png" alt="image-20220513233203018"></p><p>32个group分1MB，一个32K，再分成8分，一份4K称为一个page，看到这里恍然大悟，和OS连上了，这个就是OS里的分页，目的就是最大程度的里用零散的小内存</p><p>所以这里实际上就看出来SBH就是类似上一讲的内存池那样挖出一块大内存1MB然后手动画好格子32group * 8page，并且搞一堆指针形成链表让他们能找到，然后就可以分配管理了</p><p><strong>另外，这个header控制的1MB实际上只是逻辑上的地址空间，因为win系统的虚拟内存机制，前边也说了它是用Virtual malloc申请的，这里联想以下OS里的虚内存机制就可以了。所以这里不是直接再物理空间上挖1MB，而是最小只用分配1page 4k就可以了，为什么呢？这里联想下虚内存和硬盘的交互，恰恰就是按page的粒度来进行换入换出的！</strong></p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220513234229182.png" alt="image-20220513234229182"></p><p>上图中一个group的64根指针实际上就像第二讲的allocator内存池一样，第一个用来挂在8字节，第二个16字节，这样一直到最后一个指针是挂载1KB及1KB以上的</p><p> 下面是实际切的情况：</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514002537699.png" alt="image-20220514002537699"></p><p>VC6的内存管理分配情况：</p><p>其实就和内存池的分配差不多，把一个group用64个指针管理，按照所需分配的内存大小选择挂载在哪个指针下边，每一次分配从下往上长</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514102213.png"></p><p>收回内存，就是把这块内存挂载到对应的链表上（例下图是35号链表），然后把group的标志数组对应的35号位子置为1，表示这个底下有闲置的内存可以分配</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514103905946.png" alt="image-20220514103905946"></p><p>下一次再分配内存，算出要挂载在25号指针，但是它的group标志位是0，那么就往后找比它大的最近的指针标志位为1的，这里是35号链表，所以这次分配的内存实际上就是在上一次回收的35号内存上切一刀再分配给当前申请内存的程序。这里相比第二讲allocate简陋的内存池，就有了一个很大的好处，可以将这一个group32K的内存的压榨的很满。</p><p><strong>区块合并</strong></p><p>一个区块要被free的情况，在直接挂载到group对应的指针下之前，可以先看这个区块的上下区块是不是也是free的状态，如果是，那么可以将它们合并成一个大区块（上下cookies的最后一位是0表示是free状态的区块，可以合并，<strong>这也是上下cookies的作用之一</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514155941.png"></p><p><strong>Free（p）挂载内存到指针上</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514160556.png"></p><p>确定哪一个Header-&gt;确定哪一个group-&gt;最后确定是64个指针中的哪一个</p><p>至于怎么找，就用指针的地址减去头的地址就行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SBH实际上就是将内存分成不同的粒度大小，16个Header每个管理1MB，1MB又分成了32个group每个32K，32K用分成8个page每个4K，<strong>这实际上就是OS内存的段页式管理，目的就是为了最大化合理利用内存碎片，从最大的内存一层一层找到最后内存所在的page就是句柄？</strong></p><p><strong>全回收判断</strong></p><p>因为是链表的结构，所以不容易判断内存是否全部回收完毕，所以设置了一个cntEntires参数每次melloc就+1，free就-1，如果为0就表示全回收啦（就是最后8个page全部挂在最后一个链表上，因为最后一个链表指针控制1KB以上的字节）</p><p>另外这里有个buffer机制，就是有个defer指针，当有第一个全回收的group时先不回收（还给OS），出现第二个全回收的group再把第一个回收掉，这样就减少了像OS申请虚拟内存的次数（当没有第二个group时，又有进程申请内存，这时直接分配defer指针下全回收的group就行）</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514162140680.png" alt="image-20220514162140680"></p><p>allocator内存池的设计其实只是为了减少cookies内存的占用，而不是减少malloc的调用次数，因为malloc其实很快</p><p>在下图中各层级的调用栈中，确实存在一些冗余，但因为过于庞大且不是一拨开发人员所以没办法，但VC因为是微软自家的，所以在VC10就取消了SBH的设计，将小区块内存也一并交给下层OS来管理了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514163554.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h2 id=&quot;malloc-free&quot;&gt;&lt;a href=&quot;#malloc-free&quot; class=&quot;head</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第二讲-std_allocator-内存池</title>
    <link href="http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/"/>
    <id>http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/</id>
    <published>2022-04-08T09:25:10.000Z</published>
    <updated>2022-06-29T15:50:03.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h2 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h2><h3 id="一、malloc-内部原理"><a href="#一、malloc-内部原理" class="headerlink" title="一、malloc()内部原理"></a>一、malloc()内部原理</h3><h4 id="1、VC6-0-malloc"><a href="#1、VC6-0-malloc" class="headerlink" title="1、VC6.0 malloc"></a>1、VC6.0 malloc</h4><p><img src="https://i.imgur.com/gQUae6j.png"></p><p>从上图可见，VC6中的malloc()函数分配的内存里面除了我们需要申请的内存空间外还有cookie，debug信息和pad，其中cookie是我们不需要的，如果大量调用malloc的话cookie总和会增多，这回造成较大的浪费。</p><p><img src="https://i.imgur.com/cmEOkpQ.png"></p><p>从上面可以看出，VC6.0的allocate()函数只是对malloc的二次封装，并没有做什么很特殊的操作，它是以类型字节长度为单位分配内存的，上图就分配了512个int类型空间。</p><h4 id="2、BC5-malloc"><a href="#2、BC5-malloc" class="headerlink" title="2、BC5 malloc"></a>2、BC5 malloc</h4><p><img src="https://i.imgur.com/ob9hMFD.png"></p><p>BC5的allocate()函数和VC6.0本质一样。</p><h4 id="3、G2-9-malloc"><a href="#3、G2-9-malloc" class="headerlink" title="3、G2.9 malloc"></a>3、G2.9 malloc</h4><p><img src="https://i.imgur.com/e2MZ9ZG.png"></p><p>GCC 2.9版本的allocator如上图所示，但是在实际中该部分却没有被包含使用，从下图容器使用的Alloc可以看到，实际的分配器是使用了一个叫alloc的类，该类分配内存是以字节为单位的，而不是以对象为单位。下图右边灰色部分分配的是512字节，而不是512个对象。</p><p><img src="https://i.imgur.com/FVlBA20.png"></p><h4 id="4、-pool-alloc"><a href="#4、-pool-alloc" class="headerlink" title="4、__pool_alloc"></a>4、__pool_alloc</h4><p>在GCC 4.9版本，2.9版本的allocate不属于正式使用的那个版本，而是变成了__pool_alloc：</p><p><img src="https://i.imgur.com/K7XxqvN.png"></p><p><img src="https://i.imgur.com/6MTLUB7.png"></p><p>从上面两张图可以对比看出，2.9版本的allocate和4.9版本的__pool_alloc做的事是一样的，只是修改了变量名和一些细小操作而已。</p><p><img src="https://i.imgur.com/AHgQElz.png"></p><p><img src="https://i.imgur.com/BVIH5XG.png"></p><p>测试的代码如所示：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt; #include &lt;ext\pool_allocator.h&gt;using namespace std;template&lt;typename Alloc&gt; void cookie_test(Alloc alloc, size_t n)                                                                                &#123;    typename Alloc::value_type *p1, *p2, *p3;        //需有 typename       p1 = alloc.allocate(n);         //allocate() and deallocate() 是 non-static, 需以 object 呼叫之.       p2 = alloc.allocate(n);             p3 = alloc.allocate(n);        cout &lt;&lt; &quot;p1= &quot; &lt;&lt; p1 &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;p2= &quot; &lt;&lt; p2 &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;p3= &quot; &lt;&lt; p3 &lt;&lt; &#39;\n&#39;;                alloc.deallocate(p1,sizeof(typename Alloc::value_type));     //需有 typename       alloc.deallocate(p2,sizeof(typename Alloc::value_type));      //有些 allocator 對於 2nd argument 的值無所謂            alloc.deallocate(p3,sizeof(typename Alloc::value_type));     &#125;int main(void)&#123;    cout &lt;&lt; sizeof(__gnu_cxx::__pool_alloc&lt;double&gt;) &lt;&lt; endl;    vector&lt;int, __gnu_cxx::__pool_alloc&lt;double&gt; &gt; vecPool;    cookie_test(__gnu_cxx::__pool_alloc&lt;double&gt;(), 1);        cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;        cout &lt;&lt; sizeof(std::allocator&lt;double&gt;) &lt;&lt; endl;    vector&lt;int, std::allocator&lt;double&gt; &gt; vecPool2;    cookie_test(std::allocator&lt;double&gt;(), 1);        return 0;&#125;</code></pre><p>测试环境是Dev C++5.1.1版本，GCC 4.9，测试结果如下：</p><p><img src="https://i.imgur.com/n7pUFXm.png"></p><p>从上面的测试结果可以看出，如果使用了__pool_alloc的话，连续两块内存之间的距离是8，而一个double类型变量的大小也是8个字节，说明这连续几块内存之间是不带cookie的（即使这几块内存在物理上也是不连续的）。如果使用std的allocator，那么相邻两块内存之间距离为18个字节，每块内存带有一个4字节的头和4字节的尾。</p><h3 id="二、std-alloc"><a href="#二、std-alloc" class="headerlink" title="二、std::alloc"></a>二、std::alloc</h3><h4 id="1、std-alloc运作模式"><a href="#1、std-alloc运作模式" class="headerlink" title="1、std:alloc运作模式"></a>1、std:alloc运作模式</h4><p><img src="https://i.imgur.com/lzcpFvY.png"></p><p>std::alloc使用一个16个元素的数组来管理内存链表，而我们上一章只是用了一条链表。数组不同的元素管理不同的区块管理，例如#3号元素负责管理32bytes为一小块的链表。</p><p>假设现在用户需要32字节的内存，std::allloc先申请一块区间，为32<em>20</em>2大小，用一条链表管理，然后让数组的#3元素管理这条链表。接着讲该以32为一个单元的链表的一个单元（32字节）分给用户。为什么是32<em>20</em>2？<br>前面32<em>20空间是分配给用户的，但是后面的32</em>20空间是预留的，如果这时用户需要一个64字节的空间，那么剩下的32<em>20空间将变成64</em>10，然后将其中64字节分配给用户，而不用再一次地构建链表和申请空间。</p><p>但是也有上限。如果该链表组维护的链表最大的一个小块为128byte，但是用户申请内存块超过了128byte，那么std::alloc将调用malloc给用户分配空间，然后该块将带上cookie头和尾。</p><p><img src="https://i.imgur.com/8MNTpki.png"></p><p>在真正的商业级的内存分配器中，一般都会使用嵌入式指针，将每一个小块的前四个字节用作指针连接下一块可用的内存块。</p><h4 id="2、std-alloc运行一瞥"><a href="#2、std-alloc运行一瞥" class="headerlink" title="2、std::alloc运行一瞥"></a>2、std::alloc运行一瞥</h4><p><img src="https://i.imgur.com/lGNyqvP.png"></p><p><img src="https://i.imgur.com/G4h5VE1.png"></p><p><img src="https://i.imgur.com/oEh5eUL.png"></p><p><img src="https://i.imgur.com/gjy2DCM.png"></p><p><img src="https://i.imgur.com/Ik5j4AB.png"></p><p><img src="https://i.imgur.com/0EbenSF.png"></p><p><img src="https://i.imgur.com/KiVVXm0.png"></p><p><img src="https://i.imgur.com/KzfwDdr.png"></p><p><img src="https://i.imgur.com/Vb9WrUI.png"></p><p><img src="https://i.imgur.com/iYdhtkB.png"></p><p><img src="https://i.imgur.com/NTqyfwF.png"></p><p><img src="https://i.imgur.com/kGj86gM.png"></p><p><img src="https://i.imgur.com/2udQslV.png"></p><p><img src="https://i.imgur.com/jfBEG5f.png"></p><h4 id="3、std-alloc源码剖析"><a href="#3、std-alloc源码剖析" class="headerlink" title="3、std::alloc源码剖析"></a>3、std::alloc源码剖析</h4><p>侯杰老师的ppt上总结的很好，在看这部分内容时需要结合老师的ppt，为了方便分析，这里结合老师的课程，使用“倒叙”的方式，先介绍中间的几张ppt，然后跳回前面，顺序和原版ppt不一样。</p><p>原版ppt的1-3张介绍的是GCC 2.9的std::alloc的第一级分配器，这里先从第二级开始分析，然后再到第一级。</p><p><img src="https://i.imgur.com/SCvJ2A6.png"></p><p>该分配器为__default_alloc_template，一开始默认使用的分配器，在该类中定义了ROUND_UP函数，用来将申请内存数量做16字节对齐。定义了union free_list_link，在后面会介绍它的作用，在上一章中我们构建的一个小的分配器中也定义了该联合体，作用类似，该联合体可以使用struct代替。free_list是一个有16个obj*元素的数组，在前面讲过，GCC 2.9的分配器用一个16字节数组管理16条链表，free_list便是该管理数组。refill和chunk_alloc在后面再介绍。start_free和end_free分别指向该内存池的头和尾。</p><p><img src="https://i.imgur.com/ofe7YUv.png"></p><p>首先看allocate函数，在函数的一开始便定义了:</p><pre><code>obj* volatile *my_free_list;</code></pre><p>结合上图右侧的链表图和上上一张图片内容，my_free_list指向的是free_list中16个元素中的任何一个，*my_free_list则取出free_list某元素中的值，该值指向一条分配内存的链表。所以my_free_list要定义为二级指针。</p><p>result则保存分配给用户的一块内存的地址。</p><p>首先：</p><pre><code>if (n &gt; (size_t)__MAX_BYTES) &#123;    return(malloc_alloc::allocate(n));&#125;</code></pre><p>检查用户申请内存块大小，如果大于__MAX_BYTES（128）那么将调用malloc_alloc::allocate()，这便是第一级分配器，这在后面分析。现在假设用户申请内存小于128字节，那么将根据用户申请内存大小分配对应的内存，由于内存池使用free_list链表管理的，每个free_list链表元素管理不同的内存块大小，这在前面介绍过了。于是有：</p><pre><code>my_free_list = free_list + FREELIST_INDEX(n);</code></pre><p>定位到该内存块的位置，这时my_free_list指向的是管理该内存块的空间的地址，使用*my_free_list便可以取到该内存块的地址：</p><pre><code>result = *my_free_list;</code></pre><p>然后判断result是否为空：</p><pre><code>if (result == 0) &#123;    void* r = refill(ROUND_UP(n));    return r;&#125;</code></pre><p>如果为空，说明系统内存不够用了，将使用refill()函数分配内存，这部分在后面会介绍。</p><p>如果情况正常，那么将该链表中下一个可以使用的空间设置为当前分配给用户空间指向的下一个、在逻辑上连续的空间，最后将result返回给用户：</p><pre><code>*my_free_list = result-&gt;free_list_link;return (result);</code></pre><p>下面的这张图很形象地演示了内存分配的过程：</p><p><img src="https://i.imgur.com/zXMf35J.png"></p><p>接下来分析释放内存。</p><pre><code>  static void deallocate(void *p, size_t n)  //p may not be 0  &#123;    obj* q = (obj*)p;    obj* volatile *my_free_list;   //obj** my_free_list;    if (n &gt; (size_t) __MAX_BYTES) &#123;        malloc_alloc::deallocate(p, n);        return;    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    q-&gt;free_list_link = *my_free_list;    *my_free_list = q;  &#125;</code></pre><p>释放内存的代码也不难理解，找到需要释放内存的那块空间的地址，然后将当前可分配给用户的空间地址设置为需要释放的该内存空间，一开始指向的可分配的内存空间地址赋值给需要释放空间地址的逻辑连续的下一个内存地址。感觉十分拗口，图和代码更能体现这一过程：</p><p><img src="https://i.imgur.com/ubYKWxM.png"></p><p>上面说到，不论是分配内存还是释放内存，则有：</p><pre><code>if (n &gt; (size_t)__MAX_BYTES) &#123;    return(malloc_alloc::allocate(n));&#125;</code></pre><p>和：</p><pre><code>if (n &gt; (size_t) __MAX_BYTES) &#123;    malloc_alloc::deallocate(p, n);    return;&#125;</code></pre><p>也就是将内存分配与释放操作放到第一级allocator中：</p><p><img src="https://i.imgur.com/Mf5qVqE.png"></p><p>从上图中可以看到，第一级分配器叫做：</p><pre><code>class __malloc_alloc_template</code></pre><p>其实有：</p><pre><code>typedef __malloc_alloc_template&lt;0&gt;  malloc_alloc;</code></pre><p>这在后面会介绍。</p><p>分配器的allocate函数如下：</p><pre><code>  static void* allocate(size_t n)  &#123;    void *result = malloc(n);   //直接使用 malloc()    if (0 == result) result = oom_malloc(n);    return result;  &#125;</code></pre><p>直接调用malloc函数分配内存，如果分配失败则调用oom_malloc函数。</p><p>同样地，reallocate也是如此：</p><pre><code>  static void* reallocate(void *p, size_t /* old_sz */, size_t new_sz)  &#123;    void * result = realloc(p, new_sz); //直接使用 realloc()    if (0 == result) result = oom_realloc(p, new_sz);    return result;  &#125;</code></pre><p>如果重新要求内存失败，则调用oom_realloc函数，这两个函数在后续会介绍。</p><p>deallocate操作则直接释放内存：</p><pre><code>static void deallocate(void *p, size_t /* n */)&#123;    free(p);                    //直接使用 free()&#125;</code></pre><p>set_malloc_handler是个函数指针，里面传入一个void (*f)()类型函数：</p><pre><code>  static void (*set_malloc_handler(void (*f)()))()  &#123; //類似 C++ 的 set_new_handler().    void (*old)() = __malloc_alloc_oom_handler;    __malloc_alloc_oom_handler = f;    return(old);  &#125;</code></pre><p>该函数设置的是内存分配不够情况下的错误处理函数，这个需要交给用户来管理，首先保存先前的处理函数，然后再将新的处理函数f赋值给__malloc_alloc_oom_handler，然后返回旧的错误处理函数，这也在下一张图片中会介绍：</p><p><img src="https://i.imgur.com/tWjkErU.png"></p><p>可以看到oom_malloc函数内部做的事：</p><pre><code>template &lt;int inst&gt;void* __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123;  void (*my_malloc_handler)();  void* result;  for (;;) &#123;    //不斷嘗試釋放、配置、再釋放、再配置…    my_malloc_handler = __malloc_alloc_oom_handler;    if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;    (*my_malloc_handler)();    //呼叫處理常式，企圖釋放記憶體    result = malloc(n);        //再次嘗試配置記憶體    if (result) return(result);  &#125;&#125;</code></pre><p>该函数不断调用__malloc_alloc_oom_handler和malloc函数，直到内存分配成功才返回。oom_realloc也是如此：</p><pre><code>template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)&#123;  void (*my_malloc_handler)();  void* result;  for (;;) &#123;    //不斷嘗試釋放、配置、再釋放、再配置…    my_malloc_handler = __malloc_alloc_oom_handler;    if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;    (*my_malloc_handler)();    //呼叫處理常式，企圖釋放記憶體。    result = realloc(p, n);    //再次嘗試配置記憶體。    if (result) return(result);  &#125;&#125;</code></pre><p><img src="https://i.imgur.com/hK3r07F.png"></p><p>到这里，分配器只剩下refill函数没有分析了，下面将重点讨论该函数。不过在讨论refill函数之前有必要分析chunk_alloc函数：</p><p><img src="https://i.imgur.com/ICXnj4c.png"></p><p><img src="https://i.imgur.com/p9EfgAj.png"></p><p>该函数声明如下：</p><pre><code>template &lt;bool threads, int inst&gt;char*__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, int&amp; nobjs)</code></pre><p>函数一开始计算了一些需要的值：</p><pre><code>char* result;size_t total_bytes = size * nobjs;size_t bytes_left = end_free - start_free;</code></pre><p>result指向分配给用户的内存，total_bytes为需要分配的内存块的大小，bytes_left则是当前内存池中剩余的空间大小。</p><p>然后：</p><pre><code>if (bytes_left &gt;= total_bytes) &#123;  result = start_free;  start_free += total_bytes;  return(result);&#125;</code></pre><p>判断如果内存池剩余的内存大小多余需要分配的内存块大小，那么将内存池的首地址start_free直接赋值给result，然后将start_free指针下移total_bytes距离，将当下的result~start_free之间的空间返回给用户。</p><p>当然，如果bytes_left比total_bytes小，但是却比size大：</p><pre><code>else if (bytes_left &gt;= size) &#123;      nobjs = bytes_left / size;      total_bytes = size * nobjs;      result = start_free;      start_free += total_bytes;      return(result);  &#125;</code></pre><p>这意味着不能直接分配size * nobjs大小内存给用户，那么可以先看看内存池当下的空间能分配多少个size大小的块给用户，然后将该块分配给用户，start_free指针移动total_bytes长度。</p><pre><code>  size_t bytes_to_get =             2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);  // Try to make use of the left-over piece.  if (bytes_left &gt; 0) &#123;      obj* volatile *my_free_list =             free_list + FREELIST_INDEX(bytes_left);      ((obj*)start_free)-&gt;free_list_link = *my_free_list;      *my_free_list = (obj*)start_free;  &#125;</code></pre><p>这部分查看内存池里面还有没有多余的内存，如果有，就充分利用。然后就是不断地获取内存块，将这些内存块不断切割用链表连接起来，递归这些过程：</p><pre><code>  start_free = (char*)malloc(bytes_to_get);  if (0 == start_free) &#123;      int i;      obj* volatile *my_free_list, *p;      //Try to make do with what we have. That can&#39;t      //hurt. We do not try smaller requests, since that tends      //to result in disaster on multi-process machines.      for (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;          my_free_list = free_list + FREELIST_INDEX(i);          p = *my_free_list;          if (0 != p) &#123;              *my_free_list = p -&gt; free_list_link;              start_free = (char*)p;              end_free = start_free + i;              return(chunk_alloc(size, nobjs));              //Any leftover piece will eventually make it to the              //right free list.          &#125;      &#125;      end_free = 0;       //In case of exception.      start_free = (char*)malloc_alloc::allocate(bytes_to_get);      //This should either throw an exception or      //remedy the situation. Thus we assume it      //succeeded.  &#125;  heap_size += bytes_to_get;  end_free = start_free + bytes_to_get;  return(chunk_alloc(size, nobjs));</code></pre><p><img src="https://i.imgur.com/j26x3xi.png"></p><p><img src="https://i.imgur.com/t4Gz1D7.png"></p><p><img src="https://i.imgur.com/QhuRqGz.png"></p><p><img src="https://i.imgur.com/eL1hcds.png"></p><p><img src="https://i.imgur.com/cUVMnHp.png"></p><p><img src="https://i.imgur.com/VcXK94y.png"></p><p><img src="https://i.imgur.com/zvx7Zmx.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h2 id=&quot;std-allocator&quot;&gt;&lt;a href=&quot;#std-allocator&quot; class=&quot;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="内存池" scheme="http://icecorn.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
</feed>
