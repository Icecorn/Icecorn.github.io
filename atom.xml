<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-06-29T15:09:23.175Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++内存管理机制|第四讲-分配器/new&amp;delete</title>
    <link href="http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    <id>http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/</id>
    <published>2022-04-16T09:25:10.000Z</published>
    <updated>2022-06-29T15:09:23.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h3 id="七种分配器"><a href="#七种分配器" class="headerlink" title="七种分配器"></a>七种分配器</h3><ul><li><p><strong>new_allocator</strong></p><p>没做什么事，直接调用malloc/free，包装了一层而已</p></li><li><p><strong>malloc_allocator</strong></p><p>和new_allocator一样</p></li><li><p><strong>array_allocator</strong></p><p>分配一个静态的内存空间，不需要考虑归还的事情，其实就是c++的array</p></li><li><p><strong>debug_allocator</strong></p><p>其实就是每分配一块内存都多加一个M_extra的内存来占一个元素的大小用于debug</p></li><li><p><strong>pool_allocator</strong></p><p>就是第二讲讲的内存池的实现，16个自由链表挂载不同粒度的内存块，缺点是没有动态free,但不能算作内存泄漏，因为那些内存还在分配器的掌控之下</p></li><li><p>bitmap_allocator</p><p>用一个索引以 2 的指数倍数成长的桶子(exponentially increasing power-of-two-sized buckets)的思路。先捋一捋bitmap_allocator实现当中的相关数据结构的概念：</p><p><strong>blocks：</strong>即是进行分配的内存区块，每个block size一般取8bytes，是super-block的一部分；<br><strong>super-blocks：</strong>表示一个__mini_vector所管理的整个内存空间，bitmap_allocator进行管理内存空间扩容/缩减的操作就是通过增加或减少super-blocks的数目来实现的，是 bitmap_allocator 进行内存管理的基本单位；<br>bitmap：记录一个__mini_vector所管理的内存空间所属的64个 blocks 的分配情况(依据增长情况，不一定是64个，也可能是128/256，block数目是2的幂次增长的)，所以为64bit，8bytes(0表示分配出去了，1表示未分配出去；若是全未分配出去则为0x FFFF FFFF FFFF FFFF，若是第一个分配出去则为 0x FFFF FFFF FFFF FFFE(1110)，即bitmap字节序从低位到高位表示的是block序号从63到0)，是super-block的一部分；<br><strong>mini-vector：</strong>该数据结构的实现是为了避免作为容器的分配其还嵌套容器所造成的先有鸡还是先有蛋的困扰，实现过程也即和vector的实现思路相似，见 vector 容器。含有三个成员变量_M_start；(表示所管理的block的起始位置，即block0的内存地址)，_M_finish；(表示第一个可分配的block的内存位置)，_M_end_of_storage;(类似于vector当中的capacity概念)。其作用是对 super-block 进行存储、访问和管理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514202055.png"></p></li><li><p><strong>mt_allocator</strong></p><p>针对多线程的分配器</p></li></ul><hr><h3 id="关于Const"><a href="#关于Const" class="headerlink" title="关于Const"></a>关于Const</h3><p>const放在<strong>成员函数</strong>后，是告诉编译器这个成员函数不改变这个类的data</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514210303.png"></p><p>记住non_const obj可以调用const函数，反过来则不行，如果const和non_const函数都有的话，就各调用各的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514211437.png"></p><p>上图右边两个函数名称一样，只是一个多了const，所以const是算在函数签名里边的。</p><p>举例 string s1 = “abc”; s1[0] = ‘d’;这样就发生了写操作，这里s1实际调用的就是重载[]的非const版本，<strong>同时这里要考虑COW，就是有多个线程同时共有s1的话，要加锁，不要发生重写，脏数据等情况</strong></p><p>const string s2 = “abc”; s2是常量，所以s2[0]访问的就是const版本的重载[]函数，且无需考虑COW</p><hr><h3 id="关于new，delete"><a href="#关于new，delete" class="headerlink" title="关于new，delete"></a>关于new，delete</h3><p><strong>new：</strong></p><p>1.调用operator new(),这个函数是可以重载的，可以实现内存池，这个函数默认就是调用malloc（）分配一块内存</p><p>2.static_cast&lt;T*&gt; 将1中分配的内存强制转型成想new的数据类型</p><p>3.调用new的类的构造函数</p><p><strong>delete：</strong></p><p>1.调用该对象的析构函数，这里要注意的是，如果这个对象没有指针类型的data，那么其实不析构也没啥事，有的话就一定要析构</p><p>2.调用delete释放这块内存，这里实际就是调用free（）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514212527.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h3 id=&quot;七种分配器&quot;&gt;&lt;a href=&quot;#七种分配器&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第三讲-malloc/free</title>
    <link href="http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/"/>
    <id>http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/</id>
    <published>2022-04-11T09:25:10.000Z</published>
    <updated>2022-06-29T15:08:22.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc/free"></a>malloc/free</h2><h3 id="一、VC6内存分配"><a href="#一、VC6内存分配" class="headerlink" title="一、VC6内存分配"></a>一、VC6内存分配</h3><p>下图左边是函数调用栈，最下方是操作系统</p><p><img src="https://i.imgur.com/GSff1Jp.png"></p><p>SBH：VC6 malloc对小区块（1016）的分配有特殊处理。在后续的版本VC10 取消了SBH的实现，全部交给操作系统来做（HeapAlloc()函数，OS对小区快内存的分配也和VC6类似）</p><p>下图是VC10的call stack，红×是相对VC6去掉的，最大区别就是取消了SBH，全部移交OS分配</p><p><img src="https://i.imgur.com/EZG35WQ.png"></p><h4 id="SBH之始"><a href="#SBH之始" class="headerlink" title="SBH之始"></a>SBH之始</h4><p><strong>以下内容核心的目的，就是通过组织一些数据结构和算法来管理1MB的内存的灵活分配和释放（因为超过1MB就不用SBH，直接交给OS管理）</strong></p><p>首先call OS的系统函数HeapCreate（），申请一块4096bits的内存(_crtheap)供后续使用，</p><p>即__cdecl_heap_init()，创建了16个Header</p><p><img src="https://s2.loli.net/2022/05/13/4kxruOeRVKcI3GM.png"></p><p>CRT：C Run Time</p><p>Header里边包括下边这些东西，具体干什么用的下文再说</p><p><img src="https://s2.loli.net/2022/05/13/Cu87lfJpyGnMLFz.png"></p><p>debug模式会多增加一些内存用于跟踪我们使用的内存，这就是VS debug模式能显示堆栈中变量及地址的原因</p><p><strong>ioinit（）</strong>函数是首次分配内存的函数，而且必定是256个字节（16进制为100）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513215753.png"></p><p>接着往下调用到**_heap_alloc_dbg()<strong>,这个函数的参数是下图中的blocksize= debug模式需要的内存（下图上方灰色部分）+ 上下两个“无人区”（下图深绿部分，一个4字节）+ 实际内存大小（下图浅绿部分，256字节）</strong>补充一点：上下无人区实际也属于debug模式的信息，release模式就没有了**</p><p><strong>无人区</strong>起到一个栏杆的作用，从而调试器可以检测出内存越界行为</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513223103.png"></p><p>pBlockHeaderNext;pBlockHeaderPrev这两个指针的作用就是将SBH分配的所有的内存区块全部串联起来，从而来管理</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513230245.png"></p><p>接下来调用**_heap_alloc_base()**这个函数就是在加完debug这些内存之后，判断有没有超过1016个字节，没超过就SBH，超过了就OS分配</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513230944.png"></p><p>接下来调用**__sbh_alloc_block()**,这个函数作用：</p><p>下图add 8 bytes就是加入了上下cookies，然后进行对齐操作，将这个带着上下cookies的内存块上调为16 bytes对齐</p><p>这些整个的大小是0X130，但是cookies里却存的是00000131，这里是用了个trick，因为内存块是16位对齐的，那么最后一位必然是0，所以这里cookies那里就用结尾存0或1来表示这个内存块的状态（使用，释放）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513231905.png"></p><p><strong>以上这些内容都是在计算所需内存大小，还没有实际分配内存，自然更谈不上初始化内容</strong></p><p>下面将进入实际分配内存的环节：</p><p>之前讲过有16个Header，它们每个控制1MB的内存（通过win API申请的Virtual melloc（））</p><p>下图就是将它们控制的region是怎么玩的，细节是一个header的一个group维护了64个指针（双向链表）来控制这1MB，这些指针消耗大概16K</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220513233203018.png" alt="image-20220513233203018"></p><p>32个group分1MB，一个32K，再分成8分，一份4K称为一个page，看到这里恍然大悟，和OS连上了，这个就是OS里的分页，目的就是最大程度的里用零散的小内存</p><p>所以这里实际上就看出来SBH就是类似上一讲的内存池那样挖出一块大内存1MB然后手动画好格子32group * 8page，并且搞一堆指针形成链表让他们能找到，然后就可以分配管理了</p><p><strong>另外，这个header控制的1MB实际上只是逻辑上的地址空间，因为win系统的虚拟内存机制，前边也说了它是用Virtual malloc申请的，这里联想以下OS里的虚内存机制就可以了。所以这里不是直接再物理空间上挖1MB，而是最小只用分配1page 4k就可以了，为什么呢？这里联想下虚内存和硬盘的交互，恰恰就是按page的粒度来进行换入换出的！</strong></p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220513234229182.png" alt="image-20220513234229182"></p><p>上图中一个group的64根指针实际上就像第二讲的allocator内存池一样，第一个用来挂在8字节，第二个16字节，这样一直到最后一个指针是挂载1KB及1KB以上的</p><p> 下面是实际切的情况：</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514002537699.png" alt="image-20220514002537699"></p><p>VC6的内存管理分配情况：</p><p>其实就和内存池的分配差不多，把一个group用64个指针管理，按照所需分配的内存大小选择挂载在哪个指针下边，每一次分配从下往上长</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514102213.png"></p><p>收回内存，就是把这块内存挂载到对应的链表上（例下图是35号链表），然后把group的标志数组对应的35号位子置为1，表示这个底下有闲置的内存可以分配</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514103905946.png" alt="image-20220514103905946"></p><p>下一次再分配内存，算出要挂载在25号指针，但是它的group标志位是0，那么就往后找比它大的最近的指针标志位为1的，这里是35号链表，所以这次分配的内存实际上就是在上一次回收的35号内存上切一刀再分配给当前申请内存的程序。这里相比第二讲allocate简陋的内存池，就有了一个很大的好处，可以将这一个group32K的内存的压榨的很满。</p><p><strong>区块合并</strong></p><p>一个区块要被free的情况，在直接挂载到group对应的指针下之前，可以先看这个区块的上下区块是不是也是free的状态，如果是，那么可以将它们合并成一个大区块（上下cookies的最后一位是0表示是free状态的区块，可以合并，<strong>这也是上下cookies的作用之一</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514155941.png"></p><p><strong>Free（p）挂载内存到指针上</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514160556.png"></p><p>确定哪一个Header-&gt;确定哪一个group-&gt;最后确定是64个指针中的哪一个</p><p>至于怎么找，就用指针的地址减去头的地址就行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SBH实际上就是将内存分成不同的粒度大小，16个Header每个管理1MB，1MB又分成了32个group每个32K，32K用分成8个page每个4K，<strong>这实际上就是OS内存的段页式管理，目的就是为了最大化合理利用内存碎片，从最大的内存一层一层找到最后内存所在的page就是句柄？</strong></p><p><strong>全回收判断</strong></p><p>因为是链表的结构，所以不容易判断内存是否全部回收完毕，所以设置了一个cntEntires参数每次melloc就+1，free就-1，如果为0就表示全回收啦（就是最后8个page全部挂在最后一个链表上，因为最后一个链表指针控制1KB以上的字节）</p><p>另外这里有个buffer机制，就是有个defer指针，当有第一个全回收的group时先不回收（还给OS），出现第二个全回收的group再把第一个回收掉，这样就减少了像OS申请虚拟内存的次数（当没有第二个group时，又有进程申请内存，这时直接分配defer指针下全回收的group就行）</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514162140680.png" alt="image-20220514162140680"></p><p>allocator内存池的设计其实只是为了减少cookies内存的占用，而不是减少malloc的调用次数，因为malloc其实很快</p><p>在下图中各层级的调用栈中，确实存在一些冗余，但因为过于庞大且不是一拨开发人员所以没办法，但VC因为是微软自家的，所以在VC10就取消了SBH的设计，将小区块内存也一并交给下层OS来管理了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514163554.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h2 id=&quot;malloc-free&quot;&gt;&lt;a href=&quot;#malloc-free&quot; class=&quot;head</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第二讲-std_allocator-内存池</title>
    <link href="http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/"/>
    <id>http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/</id>
    <published>2022-04-08T09:25:10.000Z</published>
    <updated>2022-06-29T15:07:32.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h2 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h2><h3 id="一、malloc-内部原理"><a href="#一、malloc-内部原理" class="headerlink" title="一、malloc()内部原理"></a>一、malloc()内部原理</h3><h4 id="1、VC6-0-malloc"><a href="#1、VC6-0-malloc" class="headerlink" title="1、VC6.0 malloc"></a>1、VC6.0 malloc</h4><p><img src="https://i.imgur.com/gQUae6j.png"></p><p>从上图可见，VC6中的malloc()函数分配的内存里面除了我们需要申请的内存空间外还有cookie，debug信息和pad，其中cookie是我们不需要的，如果大量调用malloc的话cookie总和会增多，这回造成较大的浪费。</p><p><img src="https://i.imgur.com/cmEOkpQ.png"></p><p>从上面可以看出，VC6.0的allocate()函数只是对malloc的二次封装，并没有做什么很特殊的操作，它是以类型字节长度为单位分配内存的，上图就分配了512个int类型空间。</p><h4 id="2、BC5-malloc"><a href="#2、BC5-malloc" class="headerlink" title="2、BC5 malloc"></a>2、BC5 malloc</h4><p><img src="https://i.imgur.com/ob9hMFD.png"></p><p>BC5的allocate()函数和VC6.0本质一样。</p><h4 id="3、G2-9-malloc"><a href="#3、G2-9-malloc" class="headerlink" title="3、G2.9 malloc"></a>3、G2.9 malloc</h4><p><img src="https://i.imgur.com/e2MZ9ZG.png"></p><p>GCC 2.9版本的allocator如上图所示，但是在实际中该部分却没有被包含使用，从下图容器使用的Alloc可以看到，实际的分配器是使用了一个叫alloc的类，该类分配内存是以字节为单位的，而不是以对象为单位。下图右边灰色部分分配的是512字节，而不是512个对象。</p><p><img src="https://i.imgur.com/FVlBA20.png"></p><h4 id="4、-pool-alloc"><a href="#4、-pool-alloc" class="headerlink" title="4、__pool_alloc"></a>4、__pool_alloc</h4><p>在GCC 4.9版本，2.9版本的allocate不属于正式使用的那个版本，而是变成了__pool_alloc：</p><p><img src="https://i.imgur.com/K7XxqvN.png"></p><p><img src="https://i.imgur.com/6MTLUB7.png"></p><p>从上面两张图可以对比看出，2.9版本的allocate和4.9版本的__pool_alloc做的事是一样的，只是修改了变量名和一些细小操作而已。</p><p><img src="https://i.imgur.com/AHgQElz.png"></p><p><img src="https://i.imgur.com/BVIH5XG.png"></p><p>测试的代码如所示：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt; #include &lt;ext\pool_allocator.h&gt;using namespace std;template&lt;typename Alloc&gt; void cookie_test(Alloc alloc, size_t n)                                                                                &#123;    typename Alloc::value_type *p1, *p2, *p3;        //需有 typename       p1 = alloc.allocate(n);         //allocate() and deallocate() 是 non-static, 需以 object 呼叫之.       p2 = alloc.allocate(n);             p3 = alloc.allocate(n);        cout &lt;&lt; &quot;p1= &quot; &lt;&lt; p1 &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;p2= &quot; &lt;&lt; p2 &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;p3= &quot; &lt;&lt; p3 &lt;&lt; &#39;\n&#39;;                alloc.deallocate(p1,sizeof(typename Alloc::value_type));     //需有 typename       alloc.deallocate(p2,sizeof(typename Alloc::value_type));      //有些 allocator 對於 2nd argument 的值無所謂            alloc.deallocate(p3,sizeof(typename Alloc::value_type));     &#125;int main(void)&#123;    cout &lt;&lt; sizeof(__gnu_cxx::__pool_alloc&lt;double&gt;) &lt;&lt; endl;    vector&lt;int, __gnu_cxx::__pool_alloc&lt;double&gt; &gt; vecPool;    cookie_test(__gnu_cxx::__pool_alloc&lt;double&gt;(), 1);        cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;        cout &lt;&lt; sizeof(std::allocator&lt;double&gt;) &lt;&lt; endl;    vector&lt;int, std::allocator&lt;double&gt; &gt; vecPool2;    cookie_test(std::allocator&lt;double&gt;(), 1);        return 0;&#125;</code></pre><p>测试环境是Dev C++5.1.1版本，GCC 4.9，测试结果如下：</p><p><img src="https://i.imgur.com/n7pUFXm.png"></p><p>从上面的测试结果可以看出，如果使用了__pool_alloc的话，连续两块内存之间的距离是8，而一个double类型变量的大小也是8个字节，说明这连续几块内存之间是不带cookie的（即使这几块内存在物理上也是不连续的）。如果使用std的allocator，那么相邻两块内存之间距离为18个字节，每块内存带有一个4字节的头和4字节的尾。</p><h3 id="二、std-alloc"><a href="#二、std-alloc" class="headerlink" title="二、std::alloc"></a>二、std::alloc</h3><h4 id="1、std-alloc运作模式"><a href="#1、std-alloc运作模式" class="headerlink" title="1、std:alloc运作模式"></a>1、std:alloc运作模式</h4><p><img src="https://i.imgur.com/lzcpFvY.png"></p><p>std::alloc使用一个16个元素的数组来管理内存链表，而我们上一章只是用了一条链表。数组不同的元素管理不同的区块管理，例如#3号元素负责管理32bytes为一小块的链表。</p><p>假设现在用户需要32字节的内存，std::allloc先申请一块区间，为32<em>20</em>2大小，用一条链表管理，然后让数组的#3元素管理这条链表。接着讲该以32为一个单元的链表的一个单元（32字节）分给用户。为什么是32<em>20</em>2？<br>前面32<em>20空间是分配给用户的，但是后面的32</em>20空间是预留的，如果这时用户需要一个64字节的空间，那么剩下的32<em>20空间将变成64</em>10，然后将其中64字节分配给用户，而不用再一次地构建链表和申请空间。</p><p>但是也有上限。如果该链表组维护的链表最大的一个小块为128byte，但是用户申请内存块超过了128byte，那么std::alloc将调用malloc给用户分配空间，然后该块将带上cookie头和尾。</p><p><img src="https://i.imgur.com/8MNTpki.png"></p><p>在真正的商业级的内存分配器中，一般都会使用嵌入式指针，将每一个小块的前四个字节用作指针连接下一块可用的内存块。</p><h4 id="2、std-alloc运行一瞥"><a href="#2、std-alloc运行一瞥" class="headerlink" title="2、std::alloc运行一瞥"></a>2、std::alloc运行一瞥</h4><p><img src="https://i.imgur.com/lGNyqvP.png"></p><p><img src="https://i.imgur.com/G4h5VE1.png"></p><p><img src="https://i.imgur.com/oEh5eUL.png"></p><p><img src="https://i.imgur.com/gjy2DCM.png"></p><p><img src="https://i.imgur.com/Ik5j4AB.png"></p><p><img src="https://i.imgur.com/0EbenSF.png"></p><p><img src="https://i.imgur.com/KiVVXm0.png"></p><p><img src="https://i.imgur.com/KzfwDdr.png"></p><p><img src="https://i.imgur.com/Vb9WrUI.png"></p><p><img src="https://i.imgur.com/iYdhtkB.png"></p><p><img src="https://i.imgur.com/NTqyfwF.png"></p><p><img src="https://i.imgur.com/kGj86gM.png"></p><p><img src="https://i.imgur.com/2udQslV.png"></p><p><img src="https://i.imgur.com/jfBEG5f.png"></p><h4 id="3、std-alloc源码剖析"><a href="#3、std-alloc源码剖析" class="headerlink" title="3、std::alloc源码剖析"></a>3、std::alloc源码剖析</h4><p>侯杰老师的ppt上总结的很好，在看这部分内容时需要结合老师的ppt，为了方便分析，这里结合老师的课程，使用“倒叙”的方式，先介绍中间的几张ppt，然后跳回前面，顺序和原版ppt不一样。</p><p>原版ppt的1-3张介绍的是GCC 2.9的std::alloc的第一级分配器，这里先从第二级开始分析，然后再到第一级。</p><p><img src="https://i.imgur.com/SCvJ2A6.png"></p><p>该分配器为__default_alloc_template，一开始默认使用的分配器，在该类中定义了ROUND_UP函数，用来将申请内存数量做16字节对齐。定义了union free_list_link，在后面会介绍它的作用，在上一章中我们构建的一个小的分配器中也定义了该联合体，作用类似，该联合体可以使用struct代替。free_list是一个有16个obj*元素的数组，在前面讲过，GCC 2.9的分配器用一个16字节数组管理16条链表，free_list便是该管理数组。refill和chunk_alloc在后面再介绍。start_free和end_free分别指向该内存池的头和尾。</p><p><img src="https://i.imgur.com/ofe7YUv.png"></p><p>首先看allocate函数，在函数的一开始便定义了:</p><pre><code>obj* volatile *my_free_list;</code></pre><p>结合上图右侧的链表图和上上一张图片内容，my_free_list指向的是free_list中16个元素中的任何一个，*my_free_list则取出free_list某元素中的值，该值指向一条分配内存的链表。所以my_free_list要定义为二级指针。</p><p>result则保存分配给用户的一块内存的地址。</p><p>首先：</p><pre><code>if (n &gt; (size_t)__MAX_BYTES) &#123;    return(malloc_alloc::allocate(n));&#125;</code></pre><p>检查用户申请内存块大小，如果大于__MAX_BYTES（128）那么将调用malloc_alloc::allocate()，这便是第一级分配器，这在后面分析。现在假设用户申请内存小于128字节，那么将根据用户申请内存大小分配对应的内存，由于内存池使用free_list链表管理的，每个free_list链表元素管理不同的内存块大小，这在前面介绍过了。于是有：</p><pre><code>my_free_list = free_list + FREELIST_INDEX(n);</code></pre><p>定位到该内存块的位置，这时my_free_list指向的是管理该内存块的空间的地址，使用*my_free_list便可以取到该内存块的地址：</p><pre><code>result = *my_free_list;</code></pre><p>然后判断result是否为空：</p><pre><code>if (result == 0) &#123;    void* r = refill(ROUND_UP(n));    return r;&#125;</code></pre><p>如果为空，说明系统内存不够用了，将使用refill()函数分配内存，这部分在后面会介绍。</p><p>如果情况正常，那么将该链表中下一个可以使用的空间设置为当前分配给用户空间指向的下一个、在逻辑上连续的空间，最后将result返回给用户：</p><pre><code>*my_free_list = result-&gt;free_list_link;return (result);</code></pre><p>下面的这张图很形象地演示了内存分配的过程：</p><p><img src="https://i.imgur.com/zXMf35J.png"></p><p>接下来分析释放内存。</p><pre><code>  static void deallocate(void *p, size_t n)  //p may not be 0  &#123;    obj* q = (obj*)p;    obj* volatile *my_free_list;   //obj** my_free_list;    if (n &gt; (size_t) __MAX_BYTES) &#123;        malloc_alloc::deallocate(p, n);        return;    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    q-&gt;free_list_link = *my_free_list;    *my_free_list = q;  &#125;</code></pre><p>释放内存的代码也不难理解，找到需要释放内存的那块空间的地址，然后将当前可分配给用户的空间地址设置为需要释放的该内存空间，一开始指向的可分配的内存空间地址赋值给需要释放空间地址的逻辑连续的下一个内存地址。感觉十分拗口，图和代码更能体现这一过程：</p><p><img src="https://i.imgur.com/ubYKWxM.png"></p><p>上面说到，不论是分配内存还是释放内存，则有：</p><pre><code>if (n &gt; (size_t)__MAX_BYTES) &#123;    return(malloc_alloc::allocate(n));&#125;</code></pre><p>和：</p><pre><code>if (n &gt; (size_t) __MAX_BYTES) &#123;    malloc_alloc::deallocate(p, n);    return;&#125;</code></pre><p>也就是将内存分配与释放操作放到第一级allocator中：</p><p><img src="https://i.imgur.com/Mf5qVqE.png"></p><p>从上图中可以看到，第一级分配器叫做：</p><pre><code>class __malloc_alloc_template</code></pre><p>其实有：</p><pre><code>typedef __malloc_alloc_template&lt;0&gt;  malloc_alloc;</code></pre><p>这在后面会介绍。</p><p>分配器的allocate函数如下：</p><pre><code>  static void* allocate(size_t n)  &#123;    void *result = malloc(n);   //直接使用 malloc()    if (0 == result) result = oom_malloc(n);    return result;  &#125;</code></pre><p>直接调用malloc函数分配内存，如果分配失败则调用oom_malloc函数。</p><p>同样地，reallocate也是如此：</p><pre><code>  static void* reallocate(void *p, size_t /* old_sz */, size_t new_sz)  &#123;    void * result = realloc(p, new_sz); //直接使用 realloc()    if (0 == result) result = oom_realloc(p, new_sz);    return result;  &#125;</code></pre><p>如果重新要求内存失败，则调用oom_realloc函数，这两个函数在后续会介绍。</p><p>deallocate操作则直接释放内存：</p><pre><code>static void deallocate(void *p, size_t /* n */)&#123;    free(p);                    //直接使用 free()&#125;</code></pre><p>set_malloc_handler是个函数指针，里面传入一个void (*f)()类型函数：</p><pre><code>  static void (*set_malloc_handler(void (*f)()))()  &#123; //類似 C++ 的 set_new_handler().    void (*old)() = __malloc_alloc_oom_handler;    __malloc_alloc_oom_handler = f;    return(old);  &#125;</code></pre><p>该函数设置的是内存分配不够情况下的错误处理函数，这个需要交给用户来管理，首先保存先前的处理函数，然后再将新的处理函数f赋值给__malloc_alloc_oom_handler，然后返回旧的错误处理函数，这也在下一张图片中会介绍：</p><p><img src="https://i.imgur.com/tWjkErU.png"></p><p>可以看到oom_malloc函数内部做的事：</p><pre><code>template &lt;int inst&gt;void* __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123;  void (*my_malloc_handler)();  void* result;  for (;;) &#123;    //不斷嘗試釋放、配置、再釋放、再配置…    my_malloc_handler = __malloc_alloc_oom_handler;    if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;    (*my_malloc_handler)();    //呼叫處理常式，企圖釋放記憶體    result = malloc(n);        //再次嘗試配置記憶體    if (result) return(result);  &#125;&#125;</code></pre><p>该函数不断调用__malloc_alloc_oom_handler和malloc函数，直到内存分配成功才返回。oom_realloc也是如此：</p><pre><code>template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)&#123;  void (*my_malloc_handler)();  void* result;  for (;;) &#123;    //不斷嘗試釋放、配置、再釋放、再配置…    my_malloc_handler = __malloc_alloc_oom_handler;    if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;    (*my_malloc_handler)();    //呼叫處理常式，企圖釋放記憶體。    result = realloc(p, n);    //再次嘗試配置記憶體。    if (result) return(result);  &#125;&#125;</code></pre><p><img src="https://i.imgur.com/hK3r07F.png"></p><p>到这里，分配器只剩下refill函数没有分析了，下面将重点讨论该函数。不过在讨论refill函数之前有必要分析chunk_alloc函数：</p><p><img src="https://i.imgur.com/ICXnj4c.png"></p><p><img src="https://i.imgur.com/p9EfgAj.png"></p><p>该函数声明如下：</p><pre><code>template &lt;bool threads, int inst&gt;char*__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, int&amp; nobjs)</code></pre><p>函数一开始计算了一些需要的值：</p><pre><code>char* result;size_t total_bytes = size * nobjs;size_t bytes_left = end_free - start_free;</code></pre><p>result指向分配给用户的内存，total_bytes为需要分配的内存块的大小，bytes_left则是当前内存池中剩余的空间大小。</p><p>然后：</p><pre><code>if (bytes_left &gt;= total_bytes) &#123;  result = start_free;  start_free += total_bytes;  return(result);&#125;</code></pre><p>判断如果内存池剩余的内存大小多余需要分配的内存块大小，那么将内存池的首地址start_free直接赋值给result，然后将start_free指针下移total_bytes距离，将当下的result~start_free之间的空间返回给用户。</p><p>当然，如果bytes_left比total_bytes小，但是却比size大：</p><pre><code>else if (bytes_left &gt;= size) &#123;      nobjs = bytes_left / size;      total_bytes = size * nobjs;      result = start_free;      start_free += total_bytes;      return(result);  &#125;</code></pre><p>这意味着不能直接分配size * nobjs大小内存给用户，那么可以先看看内存池当下的空间能分配多少个size大小的块给用户，然后将该块分配给用户，start_free指针移动total_bytes长度。</p><pre><code>  size_t bytes_to_get =             2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);  // Try to make use of the left-over piece.  if (bytes_left &gt; 0) &#123;      obj* volatile *my_free_list =             free_list + FREELIST_INDEX(bytes_left);      ((obj*)start_free)-&gt;free_list_link = *my_free_list;      *my_free_list = (obj*)start_free;  &#125;</code></pre><p>这部分查看内存池里面还有没有多余的内存，如果有，就充分利用。然后就是不断地获取内存块，将这些内存块不断切割用链表连接起来，递归这些过程：</p><pre><code>  start_free = (char*)malloc(bytes_to_get);  if (0 == start_free) &#123;      int i;      obj* volatile *my_free_list, *p;      //Try to make do with what we have. That can&#39;t      //hurt. We do not try smaller requests, since that tends      //to result in disaster on multi-process machines.      for (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;          my_free_list = free_list + FREELIST_INDEX(i);          p = *my_free_list;          if (0 != p) &#123;              *my_free_list = p -&gt; free_list_link;              start_free = (char*)p;              end_free = start_free + i;              return(chunk_alloc(size, nobjs));              //Any leftover piece will eventually make it to the              //right free list.          &#125;      &#125;      end_free = 0;       //In case of exception.      start_free = (char*)malloc_alloc::allocate(bytes_to_get);      //This should either throw an exception or      //remedy the situation. Thus we assume it      //succeeded.  &#125;  heap_size += bytes_to_get;  end_free = start_free + bytes_to_get;  return(chunk_alloc(size, nobjs));</code></pre><p><img src="https://i.imgur.com/j26x3xi.png"></p><p><img src="https://i.imgur.com/t4Gz1D7.png"></p><p><img src="https://i.imgur.com/QhuRqGz.png"></p><p><img src="https://i.imgur.com/eL1hcds.png"></p><p><img src="https://i.imgur.com/cUVMnHp.png"></p><p><img src="https://i.imgur.com/VcXK94y.png"></p><p><img src="https://i.imgur.com/zvx7Zmx.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h2 id=&quot;std-allocator&quot;&gt;&lt;a href=&quot;#std-allocator&quot; class=&quot;</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="内存池" scheme="http://icecorn.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第一讲-primitives</title>
    <link href="http://icecorn.github.io/2022/04/05/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%AE%B2primitives/"/>
    <id>http://icecorn.github.io/2022/04/05/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%AE%B2primitives/</id>
    <published>2022-04-05T09:25:10.000Z</published>
    <updated>2022-06-29T15:06:13.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h3 id="一、四种内存分配和释放方法"><a href="#一、四种内存分配和释放方法" class="headerlink" title="一、四种内存分配和释放方法"></a>一、四种内存分配和释放方法</h3><p><img src="https://i.imgur.com/AREog97.png"></p><p>在编程时可以通过上图的几种方法直接或间接地操作内存。下面将介绍四种C++内存操作方法：</p><p><img src="https://i.imgur.com/8F62Mf8.png"></p><p>通常可以使用malloc和new来分配内存，当然也可以使用::operator new()和分配器allocator来操作内存，下面将具体介绍这些函数的使用方法。对于不同的编译器，其allocate函数的接口也有所不同：</p><p><img src="https://i.imgur.com/lljUGp1.png"></p><p>对于GNU C，不同版本又有所不同：</p><p><img src="https://i.imgur.com/xkUvBlJ.png"></p><p>这张图中的__gnu_cxx::__pool_alloc<T>().allocate()对应于上张图中的allocator<T>().allocate()。</p><p>通过malloc和new分配内存、通过free和delete释放内存是十分常用的，通过::operator new操作内存比较少见，allocator分配器操作内存在STL源码中使用较多，对于不同的编译环境使用也有所不同。下面这个例子是基与VS2013环境做测试的:</p><pre><code>#include &lt;iostream&gt;#include &lt;complex&gt;#include &lt;memory&gt;                 //std::allocator  //#include &lt;ext\pool_allocator.h&gt;     //GCC使用，欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; using namespace std;namespace jj01&#123;    void test_primitives()    &#123;        cout &lt;&lt; &quot;\ntest_primitives().......... \n&quot;;        void* p1 = malloc(512);    //512 bytes        free(p1);        complex&lt;int&gt;* p2 = new complex&lt;int&gt;; //one object        delete p2;        void* p3 = ::operator new(512); //512 bytes        ::operator delete(p3);        //以下使用 C++ 標準庫提供的 allocators。        //其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。#ifdef _MSC_VER        //以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.        int* p4 = allocator&lt;int&gt;().allocate(3, (int*)0);        p4[0] = 666;        p4[1] = 999;        p4[2] = 888;        cout &lt;&lt; &quot;p4[0] = &quot; &lt;&lt; p4[0] &lt;&lt; endl;        cout &lt;&lt; &quot;p4[1] = &quot; &lt;&lt; p4[1] &lt;&lt; endl;        cout &lt;&lt; &quot;p4[2] = &quot; &lt;&lt; p4[2] &lt;&lt; endl;        allocator&lt;int&gt;().deallocate(p4, 3);#endif#ifdef __BORLANDC__        //以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.        int* p4 = allocator&lt;int&gt;().allocate(5);        allocator&lt;int&gt;().deallocate(p4, 5);#endif#ifdef __GNUC__        //以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.        //void* p4 = alloc::allocate(512);         //alloc::deallocate(p4,512);           //以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.            void* p4 = allocator&lt;int&gt;().allocate(7);        allocator&lt;int&gt;().deallocate((int*)p4, 7);        //以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.            void* p5 = __gnu_cxx::__pool_alloc&lt;int&gt;().allocate(9);        __gnu_cxx::__pool_alloc&lt;int&gt;().deallocate((int*)p5, 9);#endif    &#125;&#125; //namespaceint main(void)&#123;    jj01::test_primitives();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/wFWZoad.png"></p><p>可见 int* p4 = allocator<int>().allocate(3, (int*)0) 操作成功申请了三个int的空间。</p><h3 id="二、基本构件之-new-delete-expression"><a href="#二、基本构件之-new-delete-expression" class="headerlink" title="二、基本构件之 new/delete expression"></a>二、基本构件之 new/delete expression</h3><h4 id="1、内存申请"><a href="#1、内存申请" class="headerlink" title="1、内存申请"></a>1、内存申请</h4><p><img src="https://i.imgur.com/SU7545t.png"></p><p>上面这张图揭示了new操作背后编译器做的事：</p><ul><li>1、第一步通过operator new()操作分配一个目标类型的内存大小，这里是Complex的大小；</li><li>2、第二步通过static_cast将得到的内存块强制转换为目标类型指针，这里是Complex*</li><li>3、第三版调用目标类型的构造方法，但是需要注意的是，直接通过pc-&gt;Complex::Complex(1, 2)这样的方法调用构造函数只有编译器可以做，用户这样做将产生错误。</li></ul><p>值得注意的是，operator new()操作的内部是调用了malloc()函数。</p><h4 id="2、内存释放"><a href="#2、内存释放" class="headerlink" title="2、内存释放"></a>2、内存释放</h4><p><img src="https://i.imgur.com/FS9k7Lw.png"></p><p>同样地，delete操作第一步也是调用了对象的析构函数，然后再通过operator delete()函数释放内存，本质上也是调用了free函数。</p><h4 id="3、模拟编译器直接调用构造和析构函数"><a href="#3、模拟编译器直接调用构造和析构函数" class="headerlink" title="3、模拟编译器直接调用构造和析构函数"></a>3、模拟编译器直接调用构造和析构函数</h4><p>下面的代码测试环节为VS2013：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;//#include &lt;memory&gt;                 //std::allocator  using namespace std;namespace jj02&#123;    class A    &#123;    public:        int id;        A() : id(0)      &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        A(int i) : id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        ~A()             &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;    &#125;;    void test_call_ctor_directly()    &#123;        cout &lt;&lt; &quot;\ntest_call_ctor_directly().......... \n&quot;;        string* pstr = new string;        cout &lt;&lt; &quot;str= &quot; &lt;&lt; *pstr &lt;&lt; endl;        //! pstr-&gt;string::string(&quot;jjhou&quot;);          //[Error] &#39;class std::basic_string&lt;char&gt;&#39; has no member named &#39;string&#39;        //! pstr-&gt;~string();    //crash -- 其語法語意都是正確的, crash 只因為上一行被 remark 起來嘛.          cout &lt;&lt; &quot;str= &quot; &lt;&lt; *pstr &lt;&lt; endl;</code></pre><p>​<br>​            //————<br>​<br>            A* pA = new A(1);             //ctor. this=000307A8 id=1<br>            cout &lt;&lt; pA-&gt;id &lt;&lt; endl;       //1<br>            pA-&gt;A::A(3);<br>            cout &lt;&lt; pA-&gt;id &lt;&lt; endl;<br>            //!    pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3<br>            //in GCC : [Error] cannot call constructor ‘jj02::A::A’ directly</p><pre><code>        A::A(5);        //!    A::A(5);                      //in VC6 : ctor. this=0013FF60 id=5        //         dtor. this=0013FF60              //in GCC : [Error] cannot call constructor &#39;jj02::A::A&#39; directly        //         [Note] for a function-style cast, remove the redundant &#39;::A&#39;        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;       //in VC6 : 3        //in GCC : 1              delete pA;                    //dtor. this=000307A8         //simulate new        void* p = ::operator new(sizeof(A));        cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; endl;     //p=000307A8        pA = static_cast&lt;A*&gt;(p);        pA-&gt;A::A(2);        //!    pA-&gt;A::A(2);                //in VC6 : ctor. this=000307A8 id=2        //in GCC : [Error] cannot call constructor &#39;jj02::A::A&#39; directly              cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     //in VC6 : 2        //in GCC : 0              //simulate delete        pA-&gt;~A();                    //dtor. this=000307A8         ::operator delete(pA);        //free()    &#125;&#125; //namespaceint main(void)&#123;    jj02::test_call_ctor_directly();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/pFUmLy0.png"></p><p>VS下可以直接通过内存空间调用构造函数，但侯杰测试在GNU C下无法通过，具体的内容可见代码注解和打印效果。</p><h3 id="三、Array-new"><a href="#三、Array-new" class="headerlink" title="三、Array new"></a>三、Array new</h3><p><img src="https://i.imgur.com/aWEq4Ve.png"></p><p><strong>上图主要展示的是关于new array内存分配的大致情况。当new一个数组对象时（例如 new Complex[3]），编译器将分配一块内存，这块内存首部是关于对象内存分配的一些标记，然后下面会分配三个连续的对象内存，在使用delete释放内存时需要使用delete[]。如果不使用delete[]，只是使用delete只会将分配的三块内存空间释放，但不会调用对象的析构函数，如果对象内部还使用了new指向其他空间，如果指向的该空间里的对象的析构函数没有意义，那么不会造成问题，如果有意义，那么由于该部分对象析构函数不会调用，那么将会导致内存泄漏。图中new string[3]便是一个例子，虽然str[0]、str[1]、str[2]被析构了，但只是调用了str[0]的析构函数，其他对象的析构函数不被调用，这里就会出问题。</strong></p><p>下面将演示数组对象创建与析构过程：</p><p><img src="https://i.imgur.com/7FwNSzm.png"></p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;        //placement newusing namespace std;namespace jj03&#123;    class A    &#123;    public:        int id;        A() : id(0)      &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        A(int i) : id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        ~A()             &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;    &#125;;    void test_array_new_and_placement_new()    &#123;        cout &lt;&lt; &quot;\ntest_placement_new().......... \n&quot;;        size_t size = 3;        &#123;            //case 1            //模擬 memory pool 的作法, array new + placement new. 崩潰             A* buf = (A*)(new char[sizeof(A)*size]);            A* tmp = buf;            cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            for (int i = 0; i &lt; size; ++i)                new (tmp++) A(i);              //3次 调用ctor             cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            //!    delete [] buf;        //crash. why?            //因為這其實是個 char array，看到 delete [] buf; 編譯器會企圖喚起多次 A::~A.             // 但 array memory layout 中找不到與 array 元素個數 (本例 3) 相關的信息,             // -- 整個格局都錯亂 (從我對 VC 的認識而言)，於是崩潰。             delete buf;         //dtor just one time, ~[0]                cout &lt;&lt; &quot;\n\n&quot;;        &#125;        &#123;            //case 2            //回頭測試單純的 array new            A* buf = new A[size];  //default ctor 3 次. [0]先於[1]先於[2])            //A必須有 default ctor, 否則 [Error] no matching function for call to &#39;jj02::A::A()&#39;            A* tmp = buf;            cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            for (int i = 0; i &lt; size; ++i)                new (tmp++) A(i);          //3次 ctor             cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            delete[] buf;    //dtor three times (次序逆反, [2]先於[1]先於[0])            &#125;        &#123;            //case 3                //掌握崩潰原因, 再次模擬 memory pool作法, array new + placement new.                 //不, 不做了, 因為 memory pool 只是供應 memory, 它並不管 construction,             //也不管 destruction. 它只負責回收 memory.             //所以它是以 void* 或 char* 取得 memory, 釋放 (刪除)的也是 void* or char*.              //不像本例 case 1 釋放 (刪除) 的是 A*.             //            //事實上 memory pool 形式如 jj04::test         &#125;    &#125;&#125; //namespaceint main(void)&#123;    jj03::test_array_new_and_placement_new();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/kcoXFR6.png"></p><p>构造函数调用顺序是按照构建对象顺序来执行的，但是析构函数执行却相反。值得注意的是，在调用了delete的大括号代码段中，数组有三个元素，但最后只调用了第一个对象的析构函数。</p><p>接下来将更具体地展示new array对象的内存分配情况：</p><p><img src="https://i.imgur.com/mQAjijM.png"></p><p>如果使用new分配十个内存的int，内存空间如上图所示，首先内存块会有一个头和尾，黄色部分为debug信息，灰色部分才是真正使用到的内存，蓝色部分的12bytes是为了让该内存块以16字节对齐。在这个例子中delete pi和delete[] pi效果是一样的，因为int没有析构函数。但是下面的例子就不一样了：</p><p><img src="https://i.imgur.com/RCX6Hfm.png"></p><p>上图通过new申请三个Demo空间大小，内存块使用了96byte，这里是这样计算得到的:黄色部分调试信息32 + 4 = 36byte；黄色部分下面的“3”用于标记实际分配给对象内存个数，这里是三个所以里面内容为3，消耗4byte；Demo内有三个int类型成员变量，一个Demo消耗内存3 * 4 = 12byte，由于有三个Demo，所以消耗了12 * 3 = 36byte空间；到目前为止消耗36 + 4 + 36 = 76byte，加上头尾cookie一共8byte一共消耗84byte，由于需要16位对齐，所以填充蓝色部分为12byte，一共消耗了84 + 12 = 96byte。这里释放内存时需要加上delete[]，上面分配内存中有个标记“3”，所以编译器将释放三个Demo对象空间，如果不加就会报错。</p><h3 id="四、placement-new"><a href="#四、placement-new" class="headerlink" title="四、placement new"></a>四、placement new</h3><p><img src="https://i.imgur.com/aWyButl.png"></p><h3 id="五、重载"><a href="#五、重载" class="headerlink" title="五、重载"></a>五、重载</h3><h4 id="1、C-内存分配的途径"><a href="#1、C-内存分配的途径" class="headerlink" title="1、C++内存分配的途径"></a>1、C++内存分配的途径</h4><p><img src="https://i.imgur.com/xAguah0.png"></p><p>如果是正常情况下，调用new之后走的是第二条路线，如果在类中重载了operator new()，那么走的是第一条路线，但最后还是要调用到系统的::operator new()函数，这在后续的例子中会体现。</p><p><img src="https://i.imgur.com/XkgjnI1.png"></p><p>对于GNU C，背后使用的allocate()函数最后也是调用了系统的::operator new()函数。</p><h4 id="2、重载new-和-delete"><a href="#2、重载new-和-delete" class="headerlink" title="2、重载new 和 delete"></a>2、重载new 和 delete</h4><p><img src="https://i.imgur.com/2o83TNy.png"></p><p>上面这张图演示了如何重载系统的::operator new()函数，该方法最后也是模拟了系统的做法，效果和系统的方法一样，但一般不推荐重载::operator new()函数，因为它对全局有影响，如果使用不当将造成很大的问题。</p><p><img src="https://i.imgur.com/KMrjz7s.png"></p><p>如果是在类中重载operator new()方法，那么该方法有N多种形式，但必须保证函数参数列表第一个参数是size_t类型变量；对于operator delete()，第一个参数必须是void* 类型，第二个size_t是可选项，可以去掉。</p><p><img src="https://i.imgur.com/sZrLSr8.png"></p><p>对于operator new[]和operator delete[]函数的重载，和前面类似。</p><p><img src="https://i.imgur.com/S2yG6Um.png"></p><p><img src="https://i.imgur.com/6D7odtt.png"></p><p><img src="https://i.imgur.com/KjGXpFs.png"></p><p><img src="https://i.imgur.com/GPW5wRa.png"></p><p><img src="https://i.imgur.com/0ZoNJdM.png"></p><p><img src="https://i.imgur.com/VgcPaVf.png"></p><p><img src="https://i.imgur.com/PcPsPWd.png"></p><h4 id="3、测试案例"><a href="#3、测试案例" class="headerlink" title="3、测试案例"></a>3、测试案例</h4><p>测试一：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;namespace jj06&#123;    class Foo    &#123;    public:        int _id;        long _data;        string _str;    public:        static void* operator new(size_t size);        static void  operator delete(void* deadObject, size_t size);        static void* operator new[](size_t size);        static void  operator delete[](void* deadObject, size_t size);        Foo() : _id(0)      &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125;        Foo(int i) : _id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125;        //virtual         ~Foo()              &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125;        //不加 virtual dtor, sizeof = 12, new Foo[5] =&gt; operator new[]() 的 size 參數是 64,         //加了 virtual dtor, sizeof = 16, new Foo[5] =&gt; operator new[]() 的 size 參數是 84,         //上述二例，多出來的 4 可能就是個 size_t 欄位用來放置 array size.     &#125;;    void* Foo::operator new(size_t size)    &#123;        Foo* p = (Foo*)malloc(size);        cout &lt;&lt; &quot;Foo::operator new(), size=&quot; &lt;&lt; size &lt;&lt; &quot;\t  return: &quot; &lt;&lt; p &lt;&lt; endl;        return p;    &#125;    void Foo::operator delete(void* pdead, size_t size)    &#123;        cout &lt;&lt; &quot;Foo::operator delete(), pdead= &quot; &lt;&lt; pdead &lt;&lt; &quot;  size= &quot; &lt;&lt; size &lt;&lt; endl;        free(pdead);    &#125;    void* Foo::operator new[](size_t size)    &#123;        Foo* p = (Foo*)malloc(size);  //crash, 問題可能出在這兒         cout &lt;&lt; &quot;Foo::operator new[](), size=&quot; &lt;&lt; size &lt;&lt; &quot;\t  return: &quot; &lt;&lt; p &lt;&lt; endl;        return p;    &#125;    void Foo::operator delete[](void* pdead, size_t size)    &#123;        cout &lt;&lt; &quot;Foo::operator delete[](), pdead= &quot; &lt;&lt; pdead &lt;&lt; &quot;  size= &quot; &lt;&lt; size &lt;&lt; endl;        free(pdead);    &#125;    //-------------        void test_overload_operator_new_and_array_new()    &#123;        cout &lt;&lt; &quot;\ntest_overload_operator_new_and_array_new().......... \n&quot;;        cout &lt;&lt; &quot;sizeof(Foo)= &quot; &lt;&lt; sizeof(Foo) &lt;&lt; endl;        &#123;            Foo* p = new Foo(7);            delete p;            Foo* pArray = new Foo[5];    //無法給 array elements 以 initializer             delete[] pArray;        &#125;        &#123;            cout &lt;&lt; &quot;testing global expression ::new and ::new[] \n&quot;;            // 這會繞過 overloaded new(), delete(), new[](), delete[]()             // 但當然 ctor, dtor 都會被正常呼叫.              Foo* p = ::new Foo(7);            ::delete p;            Foo* pArray = ::new Foo[5];            ::delete[] pArray;        &#125;    &#125;&#125; //namespaceint main(void)&#123;    jj06::test_overload_operator_new_and_array_new();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/c6l7tRe.png"></p><p>测试二：</p><pre><code>#include &lt;vector&gt;  //for test#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;namespace jj07&#123;    class Bad &#123; &#125;;    class Foo    &#123;    public:        Foo() &#123; cout &lt;&lt; &quot;Foo::Foo()&quot; &lt;&lt; endl; &#125;        Foo(int) &#123;            cout &lt;&lt; &quot;Foo::Foo(int)&quot; &lt;&lt; endl;            // throw Bad();          &#125;        //(1) 這個就是一般的 operator new() 的重載         void* operator new(size_t size)&#123;            cout &lt;&lt; &quot;operator new(size_t size), size= &quot; &lt;&lt; size &lt;&lt; endl;            return malloc(size);        &#125;        //(2) 這個就是標準庫已經提供的 placement new() 的重載 (形式)        //    (所以我也模擬 standard placement new 的動作, just return ptr)         void* operator new(size_t size, void* start)&#123;            cout &lt;&lt; &quot;operator new(size_t size, void* start), size= &quot; &lt;&lt; size &lt;&lt; &quot;  start= &quot; &lt;&lt; start &lt;&lt; endl;            return start;        &#125;        //(3) 這個才是嶄新的 placement new         void* operator new(size_t size, long extra)&#123;            cout &lt;&lt; &quot;operator new(size_t size, long extra)  &quot; &lt;&lt; size &lt;&lt; &#39; &#39; &lt;&lt; extra &lt;&lt; endl;            return malloc(size + extra);        &#125;        //(4) 這又是一個 placement new         void* operator new(size_t size, long extra, char init)&#123;            cout &lt;&lt; &quot;operator new(size_t size, long extra, char init)  &quot; &lt;&lt; size &lt;&lt; &#39; &#39; &lt;&lt; extra &lt;&lt; &#39; &#39; &lt;&lt; init &lt;&lt; endl;            return malloc(size + extra);        &#125;        //(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new)         //!      void* operator new(long extra, char init) &#123; //[Error] &#39;operator new&#39; takes type &#39;size_t&#39; (&#39;unsigned int&#39;) as first parameter [-fpermissive]        //!          cout &lt;&lt; &quot;op-new(long,char)&quot; &lt;&lt; endl;        //!        return malloc(extra);        //!      &#125;             //以下是搭配上述 placement new 的各個 called placement delete.         //當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起.         //應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory.          //(1) 這個就是一般的 operator delete() 的重載         void operator delete(void*, size_t)        &#123;            cout &lt;&lt; &quot;operator delete(void*,size_t)  &quot; &lt;&lt; endl;        &#125;        //(2) 這是對應上述的 (2)          void operator delete(void*, void*)        &#123;            cout &lt;&lt; &quot;operator delete(void*,void*)  &quot; &lt;&lt; endl;        &#125;        //(3) 這是對應上述的 (3)          void operator delete(void*, long)        &#123;            cout &lt;&lt; &quot;operator delete(void*,long)  &quot; &lt;&lt; endl;        &#125;        //(4) 這是對應上述的 (4)          //如果沒有一一對應, 也不會有任何編譯報錯         void operator delete(void*, long, char)        &#123;            cout &lt;&lt; &quot;operator delete(void*,long,char)  &quot; &lt;&lt; endl;        &#125;    private:        int m_i;    &#125;;</code></pre><p>​<br>​        //————-<br>​        void test_overload_placement_new()<br>​        {<br>​            cout &lt;&lt; “\n\n\ntest_overload_placement_new()………. \n”;<br>​<br>            Foo start;  //Foo::Foo</p><pre><code>        Foo* p1 = new Foo;           //op-new(size_t)        Foo* p2 = new (&amp;start) Foo;  //op-new(size_t,void*)        Foo* p3 = new (100) Foo;     //op-new(size_t,long)        Foo* p4 = new (100, &#39;a&#39;) Foo; //op-new(size_t,long,char)        Foo* p5 = new (100) Foo(1);     //op-new(size_t,long)  op-del(void*,long)        Foo* p6 = new (100, &#39;a&#39;) Foo(1); //        Foo* p7 = new (&amp;start) Foo(1);  //        Foo* p8 = new Foo(1);           //        //VC6 warning C4291: &#39;void *__cdecl Foo::operator new(unsigned int)&#39;        //no matching operator delete found; memory will not be freed if        //initialization throws an exception    &#125;&#125; //namespace    int main(void)&#123;    jj07::test_overload_placement_new();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/J7nEVmm.png"></p><h3 id="五、pre-class-allocator"><a href="#五、pre-class-allocator" class="headerlink" title="五、pre-class allocator"></a>五、pre-class allocator</h3><p><img src="https://i.imgur.com/o1landO.png"></p><p><img src="https://i.imgur.com/XeVjepx.png"></p><p>案例如下：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;using namespace std;namespace jj04&#123;    //ref. C++Primer 3/e, p.765    //per-class allocator     class Screen &#123;    public:        Screen(int x) : i(x) &#123; &#125;;        int get() &#123; return i; &#125;        void* operator new(size_t);        void  operator delete(void*, size_t);    //(2)        //! void  operator delete(void*);            //(1) 二擇一. 若(1)(2)並存,會有很奇怪的報錯 (摸不著頭緒)     private:        Screen* next;        static Screen* freeStore;        static const int screenChunk;    private:        int i;    &#125;;    Screen* Screen::freeStore = 0;    const int Screen::screenChunk = 24;    void* Screen::operator new(size_t size)    &#123;        Screen *p;        if (!freeStore) &#123;            //linked list 是空的，所以攫取一大塊 memory            //以下呼叫的是 global operator new            size_t chunk = screenChunk * size;            freeStore = p =                reinterpret_cast&lt;Screen*&gt;(new char[chunk]);            //將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來            for (; p != &amp;freeStore[screenChunk - 1]; ++p)                p-&gt;next = p + 1;            p-&gt;next = 0;        &#125;        p = freeStore;        freeStore = freeStore-&gt;next;        return p;    &#125;</code></pre><p>​<br>​        //! void Screen::operator delete(void *p)        //(1)<br>​        void Screen::operator delete(void *p, size_t)    //(2)二擇一<br>​        {<br>​            //將 deleted object 收回插入 free list 前端<br>​            (static_cast&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>​            freeStore = static_cast&lt;Screen*&gt;(p);<br>​        }<br>​<br>        //————-<br>        void test_per_class_allocator_1()<br>        {<br>            cout &lt;&lt; “\ntest_per_class_allocator_1()………. \n”;</p><pre><code>        cout &lt;&lt; sizeof(Screen) &lt;&lt; endl;        //8            size_t const N = 100;        Screen* p[N];        for (int i = 0; i&lt; N; ++i)            p[i] = new Screen(i);        //輸出前 10 個 pointers, 用以比較其間隔         for (int i = 0; i&lt; 10; ++i)            cout &lt;&lt; p[i] &lt;&lt; endl;        for (int i = 0; i&lt; N; ++i)            delete p[i];    &#125;&#125; //namespaceint main(void)&#123;    jj04::test_per_class_allocator_1();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/AAD8dur.png"></p><p>每个对象以8byte对齐。内存池本质上是分配了一大块内存，然后将该内存分割为多个小块通过链表拼接起来，所以物理上不一定连续但是逻辑上是连续的。</p><p><img src="https://i.imgur.com/Va92P0d.png"></p><p><img src="https://i.imgur.com/DEjg6FL.png"></p><p>案例如下：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;using namespace std;namespace jj05&#123;    //ref. Effective C++ 2e, item10    //per-class allocator     class Airplane &#123;   //支援 customized memory management    private:        struct AirplaneRep &#123;            unsigned long miles;            char type;        &#125;;    private:        union &#123;            AirplaneRep rep;  //此針對 used object            Airplane* next;   //此針對 free list        &#125;;    public:        unsigned long getMiles() &#123; return rep.miles; &#125;        char getType() &#123; return rep.type; &#125;        void set(unsigned long m, char t)        &#123;            rep.miles = m;            rep.type = t;        &#125;    public:        static void* operator new(size_t size);        static void  operator delete(void* deadObject, size_t size);    private:        static const int BLOCK_SIZE;        static Airplane* headOfFreeList;    &#125;;    Airplane* Airplane::headOfFreeList;    const int Airplane::BLOCK_SIZE = 512;    void* Airplane::operator new(size_t size)    &#123;        //如果大小錯誤，轉交給 ::operator new()        if (size != sizeof(Airplane))        return ::operator new(size);        Airplane* p = headOfFreeList;        //如果 p 有效，就把list頭部移往下一個元素        if (p)            headOfFreeList = p-&gt;next;        else &#123;            //free list 已空。配置一塊夠大記憶體，            //令足夠容納 BLOCK_SIZE 個 Airplanes            Airplane* newBlock = static_cast&lt;Airplane*&gt;                (::operator new(BLOCK_SIZE * sizeof(Airplane)));            //組成一個新的 free list：將小區塊串在一起，但跳過             //#0 元素，因為要將它傳回給呼叫者。            for (int i = 1; i &lt; BLOCK_SIZE - 1; ++i)                newBlock[i].next = &amp;newBlock[i + 1];            newBlock[BLOCK_SIZE - 1].next = 0; //以null結束            // 將 p 設至頭部，將 headOfFreeList 設至            // 下一個可被運用的小區塊。            p = newBlock;            headOfFreeList = &amp;newBlock[1];        &#125;        return p;    &#125;    // operator delete 接獲一塊記憶體。    // 如果它的大小正確，就把它加到 free list 的前端    void Airplane::operator delete(void* deadObject,        size_t size)    &#123;        if (deadObject == 0) return;        if (size != sizeof(Airplane)) &#123;            ::operator delete(deadObject);            return;        &#125;        Airplane *carcass =            static_cast&lt;Airplane*&gt;(deadObject);        carcass-&gt;next = headOfFreeList;        headOfFreeList = carcass;    &#125;    //-------------    void test_per_class_allocator_2()    &#123;        cout &lt;&lt; &quot;\ntest_per_class_allocator_2().......... \n&quot;;        cout &lt;&lt; sizeof(Airplane) &lt;&lt; endl;    //8        size_t const N = 100;        Airplane* p[N];        for (int i = 0; i&lt; N; ++i)            p[i] = new Airplane;</code></pre><p>​<br>​            //隨機測試 object 正常否<br>​            p[1]-&gt;set(1000, ‘A’);<br>​            p[5]-&gt;set(2000, ‘B’);<br>​            p[9]-&gt;set(500000, ‘C’);<br>​            cout &lt;&lt; p[1] &lt;&lt; ‘ ‘ &lt;&lt; p[1]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[1]-&gt;getMiles() &lt;&lt; endl;<br>​            cout &lt;&lt; p[5] &lt;&lt; ‘ ‘ &lt;&lt; p[5]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[5]-&gt;getMiles() &lt;&lt; endl;<br>​            cout &lt;&lt; p[9] &lt;&lt; ‘ ‘ &lt;&lt; p[9]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[9]-&gt;getMiles() &lt;&lt; endl;<br>​<br>            //輸出前 10 個 pointers, 用以比較其間隔<br>            for (int i = 0; i&lt; 10; ++i)<br>                cout &lt;&lt; p[i] &lt;&lt; endl;</p><pre><code>        for (int i = 0; i&lt; N; ++i)            delete p[i];    &#125;&#125; //namespaceint main(void)&#123;    jj05::test_per_class_allocator_2();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/fM1lMiv.png"></p><p>这种做法有几点比较有意思，首先是使用了union保存链表元素的next指针，这样整体上可以节省空间；其次是delete函数，它并没有直接将目标元素删除，而是将它当作下一个可分配的内存空间，也就是说如果delete某元素，那么该元素占有的内存空间不会被free掉，而是在下一次调用new时分配给新的对象。</p><h3 id="六、static-allocator"><a href="#六、static-allocator" class="headerlink" title="六、static allocator"></a>六、static allocator</h3><p><img src="https://i.imgur.com/9dojXlJ.png"></p><p><img src="https://i.imgur.com/OrZw2Ik.png"></p><p><img src="https://i.imgur.com/akWdqgr.png"></p><p>代码如下：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;complex&gt;using namespace std;namespace jj09&#123;    class allocator    &#123;    private:        struct obj &#123;            struct obj* next;  //embedded pointer        &#125;;    public:        void* allocate(size_t);        void  deallocate(void*, size_t);        void  check();    private:        obj* freeStore = nullptr;        const int CHUNK = 5; //小一點方便觀察     &#125;;    void* allocator::allocate(size_t size)    &#123;        obj* p;        if (!freeStore) &#123;            //linked list 是空的，所以攫取一大塊 memory            size_t chunk = CHUNK * size;            freeStore = p = (obj*)malloc(chunk);            //cout &lt;&lt; &quot;empty. malloc: &quot; &lt;&lt; chunk &lt;&lt; &quot;  &quot; &lt;&lt; p &lt;&lt; endl;            //將分配得來的一大塊當做 linked list 般小塊小塊串接起來            for (int i = 0; i &lt; (CHUNK - 1); ++i)    &#123;  //沒寫很漂亮, 不是重點無所謂.                  p-&gt;next = (obj*)((char*)p + size);                p = p-&gt;next;            &#125;            p-&gt;next = nullptr;  //last               &#125;        p = freeStore;        freeStore = freeStore-&gt;next;        //cout &lt;&lt; &quot;p= &quot; &lt;&lt; p &lt;&lt; &quot;  freeStore= &quot; &lt;&lt; freeStore &lt;&lt; endl;        return p;    &#125;    void allocator::deallocate(void* p, size_t)    &#123;        //將 deleted object 收回插入 free list 前端        ((obj*)p)-&gt;next = freeStore;        freeStore = (obj*)p;    &#125;    void allocator::check()    &#123;        obj* p = freeStore;        int count = 0;        while (p) &#123;            cout &lt;&lt; p &lt;&lt; endl;            p = p-&gt;next;            count++;        &#125;        cout &lt;&lt; count &lt;&lt; endl;    &#125;    //--------------    class Foo &#123;    public:        long L;        string str;        static allocator myAlloc;    public:        Foo(long l) : L(l) &#123;  &#125;        static void* operator new(size_t size)        &#123; return myAlloc.allocate(size); &#125;        static void  operator delete(void* pdead, size_t size)        &#123;            return myAlloc.deallocate(pdead, size);        &#125;    &#125;;    allocator Foo::myAlloc;</code></pre><p>​<br>​        class Goo {<br>​        public:<br>​            complex<double> c;<br>​            string str;<br>​            static allocator myAlloc;<br>​        public:<br>​            Goo(const complex<double>&amp; x) : c(x) {  }<br>​            static void* operator new(size_t size)<br>​            { return myAlloc.allocate(size); }<br>​            static void  operator delete(void* pdead, size_t size)<br>​            {<br>​                return myAlloc.deallocate(pdead, size);<br>​            }<br>​        };<br>​        allocator Goo::myAlloc;<br>​<br>        //————-<br>        void test_static_allocator_3()<br>        {<br>            cout &lt;&lt; “\n\n\ntest_static_allocator()………. \n”;</p><pre><code>        &#123;            Foo* p[100];            cout &lt;&lt; &quot;sizeof(Foo)= &quot; &lt;&lt; sizeof(Foo) &lt;&lt; endl;            for (int i = 0; i&lt;23; ++i) &#123;    //23,任意數, 隨意看看結果                 p[i] = new Foo(i);                cout &lt;&lt; p[i] &lt;&lt; &#39; &#39; &lt;&lt; p[i]-&gt;L &lt;&lt; endl;            &#125;            //Foo::myAlloc.check();            for (int i = 0; i&lt;23; ++i) &#123;                delete p[i];            &#125;            //Foo::myAlloc.check();        &#125;        &#123;            Goo* p[100];            cout &lt;&lt; &quot;sizeof(Goo)= &quot; &lt;&lt; sizeof(Goo) &lt;&lt; endl;            for (int i = 0; i&lt;17; ++i) &#123;    //17,任意數, 隨意看看結果                 p[i] = new Goo(complex&lt;double&gt;(i, i));                cout &lt;&lt; p[i] &lt;&lt; &#39; &#39; &lt;&lt; p[i]-&gt;c &lt;&lt; endl;            &#125;            //Goo::myAlloc.check();            for (int i = 0; i&lt;17; ++i) &#123;                delete p[i];            &#125;            //Goo::myAlloc.check();            &#125;    &#125;&#125; //namespace    int main(void)&#123;    jj09::test_static_allocator_3();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/czxP8JH.png"></p><p>之前的几个版本都是在类的内部重载了operator new()和operator delete()函数，这些版本都将分配内存的工作放在这些函数中，但现在的这个版本将这些分配内存的操作放在了allocator类中，这就渐渐接近了标准库的方法。从上面的代码中可以看到，两个类Foo和Goo中operator new()和operator delete()函数等很多部分代码类似，于是可以使用宏来将这些高度相似的代码提取出来，简化类的内部结构，但最后达到的结果是一样的：</p><p><img src="https://i.imgur.com/baXE2RO.png"></p><p><img src="https://i.imgur.com/nog6qAD.png"></p><h3 id="七、global-allocator"><a href="#七、global-allocator" class="headerlink" title="七、global allocator"></a>七、global allocator</h3><p>上面我们自己定义的分配器使用了一条链表来管理内存的，但标准库却用了多条链表来管理，这在后续会详细介绍：</p><p><img src="https://i.imgur.com/0M5X6lY.png"></p><h3 id="八、new-handler"><a href="#八、new-handler" class="headerlink" title="八、new handler"></a>八、new handler</h3><p><img src="https://i.imgur.com/TJ9GqFz.png"></p><p>如果用户调用new申请一块内存，如果由于系统原因或者申请内存过大导致申请失败，这时将抛出异常，在一些老的编译器中可能会直接返回0，可以参考上图右边代码，当无法分配内存时，operator new()函数内部将调用_calnewh()函数，这个函数通过左边的typedef传入，看程序员是否能自己写一个handler处理函数来处理该问题。一般有两个选择，让更多的Memory可用或者直接abort()或exit()。下面是测试的一个结果：</p><p><img src="https://i.imgur.com/JfazkE0.png"></p><p>该部分中自定义了处理函数noMoreMemory()并通过set_new_handler来注册该处理函数，在BCB4编译器中会调用到自定义的noMoreMemory()函数，但在右边的dev c++中却没有调用，这个还要看平台。</p><h3 id="九、-default和-delete"><a href="#九、-default和-delete" class="headerlink" title="九、=default和=delete"></a>九、=default和=delete</h3><p><img src="https://i.imgur.com/WUtaH2m.png"></p><p><img src="https://i.imgur.com/2lxEgBI.png"></p><p>更加详细的内容可以参考下面这篇文章:</p><blockquote><p><a href="https://blog.csdn.net/u012333003/article/details/25299939">https://blog.csdn.net/u012333003/article/details/25299939</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h3 id=&quot;一、四种内存分配和释放方法&quot;&gt;&lt;a href=&quot;#一、四种内存分配和释放方法&quot; class=&quot;</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Games-101|光线追踪部分</title>
    <link href="http://icecorn.github.io/2022/03/25/Games-101/Games101-%E5%85%89%E8%BF%BD%E9%83%A8%E5%88%86/"/>
    <id>http://icecorn.github.io/2022/03/25/Games-101/Games101-%E5%85%89%E8%BF%BD%E9%83%A8%E5%88%86/</id>
    <published>2022-03-25T09:25:10.000Z</published>
    <updated>2022-06-29T14:59:01.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Games101-光追部分"><a href="#Games101-光追部分" class="headerlink" title="Games101 光追部分"></a>Games101 光追部分</h1><h2 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h2><p>光栅化是局部光照模型，无法体现出全局光照的效果（比如软阴影，全局光照，glossy reflection)</p><p>所以出现了光线追踪技术，但是光追相比光栅化很慢</p><p>从每个像素射出一根光线，打到好多物体，这里可以很方便的得到深度信息</p><p> <img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618131619.png"></p><p>有了焦点，将焦点和光源连接，如果没有遮挡就着色，如果有遮挡说明这个位置在这个光源形成的阴影里</p><h2 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h2><p>递归处理的光追</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618132157.png"></p><p>模拟光的折射和反射，然后将下图中的红色框住的点分别进行着色，然后在进行加权最后作为该像素的颜色，当然还要考虑阴影信息，判断某一个点是否要进入加权。这里我们可以控制反射/折射的次数</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618132444.png"></p><h3 id="光线和物体求交点"><a href="#光线和物体求交点" class="headerlink" title="光线和物体求交点"></a>光线和物体求交点</h3><p>Ray-Surface Intersection</p><p>定义射线，有点O和方向d来表示</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133112.png"></p><h4 id="隐式表面"><a href="#隐式表面" class="headerlink" title="隐式表面"></a>隐式表面</h4><p>求光线和球的交点</p><p>交点P既在射线上又在球上，只有t未知，联立求解</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133254.png"></p><p>t必须是正的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133453.png"></p><p>针对复杂的隐式表达的曲面，都可以用这种方法求解，数值计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133837.png"></p><h4 id="显示表面"><a href="#显示表面" class="headerlink" title="显示表面"></a>显示表面</h4><p>光线和三角网格求交点，遍历每个三角面片求角点（必然为0或1个交点）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618134027.png"></p><p>先求光线和三角面片所在平面的角点，在判断交点是否在三角形内</p><p><strong>平面可以用一个点+平面法向来定义</strong></p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220618134411190.png" alt="image-20220618134411190"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618134447.png"></p><p>另一种直接算交点的方法</p><p>直接用重心坐标进行联立等式求解</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618134757.png"></p><h4 id="加速求交点"><a href="#加速求交点" class="headerlink" title="加速求交点"></a>加速求交点</h4><p>光线和每个面片都算一遍求交太慢了，需要进行加速</p><h2 id="利用包围盒和空间、物体划分方法加速光追"><a href="#利用包围盒和空间、物体划分方法加速光追" class="headerlink" title="利用包围盒和空间、物体划分方法加速光追"></a>利用包围盒和空间、物体划分方法加速光追</h2><h3 id="轴对齐包围盒"><a href="#轴对齐包围盒" class="headerlink" title="轴对齐包围盒"></a>轴对齐包围盒</h3><p>Axis-Aligned Bounding Box</p><p>思想就是将模型包围起来，如果一个光线和包围盒都没有交点，那么它一定和模型没有交点，这样只用考虑6个面就好了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618135528.png"></p><p>判断光线和盒子是否相交</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618140144.png"></p><p>求三组tmin和tmax的交集得出tenter和texit</p><p>当且仅当下方红框，光线和包围盒有交点</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618142323.png"></p><p>另外要说的一点是这个盒子其实都是和着色空间轴平行的盒子，这样方便计算</p><hr><h3 id="空间划分算法"><a href="#空间划分算法" class="headerlink" title="空间划分算法"></a>空间划分算法</h3><p>利用AABB包围盒的空间划分加速算法</p><h4 id="均匀空间划分"><a href="#均匀空间划分" class="headerlink" title="均匀空间划分"></a>均匀空间划分</h4><p>Uniform Spatial Partitions(Grids)</p><p>对每个物体求一个包围盒，在与三角形面求交之前先对包围盒求交，这样不是已经可以达到不错加速效果了吗？作者认为可以考虑这样两个极端情况：</p><p><strong>1 整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升</strong></p><p><strong>2 整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限</strong></p><p>基于以上两点考虑，AABB并不应只局限于以<strong>物体模型</strong>为单位，可以更加精细的考虑到以<strong>三角面</strong>为单位。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。 <strong>因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！</strong> (以下的划分形成的AABB更是一种general的概念，可能不会严格包围物体，读者不必纠结)</p><p>那么接下来就从最简单的划分方法，均匀空间划分开始介绍。 第一步对所要考虑的场景找一个包围盒：</p><ul><li>找包围盒</li><li>画网格</li><li>在每个格子上存储物体模型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618144723.png"></p><p>紧接着，根据光线的方向与判断出所有相交的方格(这一步可以利用bresenham算法，就是如何光栅化一条线)，倘若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交。</p><p>光线和格子求交点是非常快的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618144949.png"></p><p>以上就是均匀空间划分的全部过程了，简单来说就是将空间划分为多个均匀的小的AABB，再根据光线方向找出相交grid(这一步并不需要判断所有方格，正如上文提示，可以用brenham类似的方法来做)，再判断grid中是否存储了模型信息，若有则进一步求交。（这种划分方法假设了找出相交方格要比直接判断与物体求交相对容易，因此划分方格数的多少也是性能的关键，方格太少，没有加速效果，方格太多，判断与方格的求交可能会拖累效率）</p><p>因此这种方法最适合的场景就是空间中均匀布满了三角形面，如果说场景较为空旷，物体较小且分离得比较开，那么均匀分割的效果就会很差了，因为会有很多无效的方格与光线的求交过程。</p><h4 id="KD-Tree空间划分"><a href="#KD-Tree空间划分" class="headerlink" title="KD-Tree空间划分"></a>KD-Tree空间划分</h4><p>几种空间划分算法：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618153918.png"></p><p>第一种Oct-Tree，也就是八叉树，每次将空间分为8个相等的部分，再递归的对子空间进行划分，因为图中是2维例子，所以只划分了4部分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。</p><p>第二种KD-Tree，也是本小节将要主要介绍的方法，其每次将空间划分为两部分，且划分依次沿着x-axis，y-axis，z-axis，即如图中所示，第一次横着将2维空间分为上下，第二次再竖着将上下两个子空间分别划分为左右部分，依次递归划分，终止条件与八叉树类似，细节问题之后按具体例子详解。</p><p>第三种BSP-Tree，其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。</p><p>接下来从一个例子具体介绍KD-Tree 第一步将空间分为两部分</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618192037.png"></p><p>第二步对左右两个子空间换个方向再分为两部分(这里只画出了有半部分，其实左边也是一样)</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618192135.png"></p><p>如此递归的划分下去，且在划分过程当中遵循这样几点：</p><p><strong>1 依次沿着x-axis,y-axis,z-axis划分，使得空间被划分的更加平衡</strong></p><p><strong>2 划分的位置由空间中三角面的分布决定，具体细节不展开</strong></p><p><strong>3 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间</strong></p><p><strong>4 当划分空间太小或是子空间内只有少量三角形则停止划分</strong></p><p>当KD-Tree建立完成之后，如何进行光线与物体求交判断呢？过程如下： 第一步判断光线是否与最外层的包围盒相交</p><p><img src="https://pic2.zhimg.com/80/v2-e5a612ef01ef5fd4b0f4e7b45f721009_720w.jpg" alt="img"></p><p>如果相交进一步判断是否与对应的两个子空间相交</p><p><img src="https://pic4.zhimg.com/80/v2-2f840d662f0d7b5dd95aadab4c4d08fb_720w.jpg" alt="img"></p><p>注意！因图中做了简化，最大包围盒的左半边并没继续进行划分(实际上应该要划分的)，所以左半部分对应的1号空间是叶子节点，如果光线与之相交，进一步判断与存储与叶子节点的物体信息求交。左半边判断完之后，接着判断右半部分</p><p><img src="https://pic4.zhimg.com/80/v2-0ccfa5171938411f65203465d41ea353_720w.jpg" alt="img"></p><p>同样如果对于有半部分存在相交情况，则对于右半部分的所有子空间，递归的执行这个步骤即可</p><p><img src="https://pic3.zhimg.com/80/v2-63048362e98117dfa53ace2a6810cffe_720w.jpg" alt="img"></p><p>更加具体的过程不再展开。</p><p><strong>优点：</strong> 利用KD-Tree的结构来构建AABB的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，在原始的纯粹的AABB之上更进一步提升了加速效率。</p><p><strong>缺点：</strong> </p><ul><li>缺点是判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单</li><li>其次同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面</li></ul><p>综上所述，我们详细介绍了利用AABB的均匀划分方法，KD-Tree划分方法，也简略提及了Oct-Tree以及BSP-Tree。但其实这些技术在业界之中以及逐渐不再被多使用，但依然有很多借鉴参考价值，在下面一节会介绍一种现在被广泛使用的加速光线追踪的方法，即Bounding Volume Hierarchy。</p><h4 id="BVH划分-对物体的划分"><a href="#BVH划分-对物体的划分" class="headerlink" title="BVH划分(对物体的划分)"></a>BVH划分(对物体的划分)</h4><p>Bounding Volume Hierarchy</p><p>BVH与前几种方法最显著的区别  就是，<strong>不再以空间作为划分依据，而是从对象的角度考虑，即三角形面</strong>，过程如下： 第一步同样找出场景的整体包围盒作为根节点</p><p><img src="https://pic2.zhimg.com/80/v2-70193926724bf8bc2a5bae00bbd7ddb1_720w.jpg" alt="img"></p><p>第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒</p><p><img src="https://pic1.zhimg.com/80/v2-bca572b39a57a86697aa9f35c35c6240_720w.jpg" alt="img"></p><p>注意到这里，<strong>包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内，而这也就解决了KD-Tree的缺点！</strong> 接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤</p><p><img src="https://pic4.zhimg.com/80/v2-ab08eb6c85843a732f78828644f02117_720w.jpg" alt="img"></p><p>最终可以建立出如上图的所示的树形结构，同样为了画图方便，只进行了左半部分的划分，右半部分其实同理。</p><p>tips：</p><ol><li>每次划分一般选择最长的那一轴划分，假设是x轴，那么划分点选择所有三角面的重心坐标在x坐标上的中位数进行划分（快排思想二分，O(n）)，如此便能保证划分的三角形左右两边三角形数量尽可能差不多，<strong>当然也就使得树形结构建立的更加平衡，深度更小，平均搜索次数更少，提高了效率</strong>，这些都是数据结构的知识，相信大家掌握的都不错，就不多赘述了。</li><li>与KD-Tree一样，中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少 （e.g. 5个）</li></ol><p>最后给出这样一个BVH加速结构遍历节点的伪代码参考：</p><p><img src="https://pic4.zhimg.com/80/v2-d626a6bf35f46e6372c8bb3cb246d84b_720w.jpg" alt="img"></p><hr><h2 id="基于物理渲染的基础知识"><a href="#基于物理渲染的基础知识" class="headerlink" title="基于物理渲染的基础知识"></a>基于物理渲染的基础知识</h2><p>首先要说明的是通过上文的处理我们获得了交点，并且简单的使用blinn-Phong模型加权平均来着色，这显然是不准确的，而PBR就是在如何正确处理着色的方法。</p><h3 id="为什么需要辐射度量学？"><a href="#为什么需要辐射度量学？" class="headerlink" title="为什么需要辐射度量学？"></a>为什么需要辐射度量学？</h3><p>首先，想一想到目前为止我们对光线亮度的定义是什么？只是简单的用3维(R,G,B)向量来描述，但却没有任何的单位，如果想要一个完全正确的模型，这显然是不应该的，必须用合适的物理量来描述光线！</p><p>其次，考虑在前两篇文章中提到的whited-style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下：</p><p><strong>1 whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色</strong></p><p><strong>2 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的</strong></p><p>而就以上的各种缺点而言，所有的问题都能在辐射度量学之中得到完美解决！</p><h3 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h3><p>辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><p>几个基本概念：</p><ul><li> <strong>辐射能量(Radiant energy)</strong></li><li> <strong>辐射通量(Radiant flux)</strong></li><li><strong>辐射强度(Radiant intensity)</strong></li><li><strong>irradiance</strong></li><li><strong>radiance</strong></li></ul><h4 id="辐射能量和辐射通量"><a href="#辐射能量和辐射通量" class="headerlink" title="辐射能量和辐射通量"></a>辐射能量和辐射通量</h4><p>Radiant energy定义： </p><p><img src="https://pic1.zhimg.com/v2-af57b246bdaf1e68e219ad003ededa68_b.jpg" alt="img"></p><p> 所谓辐射能量其实非常直观，就是辐射出来的电磁能量，单位为焦耳。可以用物理当中的做功的大小来进行类比。</p><p>接下来是Radiant flux(power)： </p><p><img src="https://pic2.zhimg.com/v2-e66e744741aacbb2f311c3b8cfa5284d_b.png" alt="img"></p><p> 所谓辐射通量或者说辐射功率，其实就是在辐射能量的基础之上除以时间，也就是单位时间的能量。同样也可以用物理当中的功率来进行类比。<strong>在光学中能量的单位通常用lumen流明</strong></p><p>(tips: 具体来说一般偏向用radiant flux来衡量光线的亮度，因为我们更关心的是单位时间的效果，事实上也是这么做的，想想在说白炽灯泡的时候也是说60W亮度，80W亮度)</p><h4 id="辐射强度"><a href="#辐射强度" class="headerlink" title="辐射强度"></a>辐射强度</h4><p>在进行具体的数学定义之前，先借助如下一张图建立对剩下3个概念的一些直观的理解： </p><p><img src="https://pic1.zhimg.com/v2-039fbcb784ca5531560b50b69a9cca68_b.jpg" alt="img"></p><ul><li><p><strong>Radiant itensity其实就是指从一个光源出发某一方向上的亮度</strong></p></li><li><p><strong>Irradiance指某一微小平面所接受到的光线亮度</strong></p></li><li><p><strong>radiance衡量的是一条传播光线所具有的亮度(不受传播方向影响而改变)</strong></p></li></ul><p>（这里的亮度也可以理解为radiant flux(power)。）</p><p>好了，接下来首先看Radiant intensity的数学定义： </p><p><img src="https://pic1.zhimg.com/v2-ff2e020aa81d545c785a4dc0d558bca8_b.jpg" alt="img"></p><p> Radiant intensity一句话来说就是从光源发出的<strong>每单位立体角上的功率</strong>，关于辐射功率的定义在上文已经解释，这里唯一还不知道的就是立体角(solid angle)了。</p><p>solid angle其实就是对应二维空间中圆的弧度在三维空间中球上的拓展。 首先看在二维计算弧度公式如下： </p><p><img src="https://pic1.zhimg.com/v2-cfbc6ba4ed667f7586b946364f73b27c_b.jpg" alt="img"></p><p> 即 <img src="https://www.zhihu.com/equation?tex=%5Ctheta+=+%5Cfrac%7Bl%7D%7Br%7D" alt="[公式]">(至于为什么这么算，中学知识这里就不展开了。)</p><p>那么对应在三维上的球的弧度(立体角)，只需进行一个简单的扩展如下： </p><p><img src="https://pic2.zhimg.com/v2-c181f1010783556ce6fb8d1755ba8185_b.jpg" alt="img"></p><p> 即立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为<img src="https://www.zhihu.com/equation?tex=4%5Cpi" alt="[公式]">。</p><p>那么对于Radiant intensity的定义当中，微分立体角<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">计算如下： </p><p><img src="https://pic2.zhimg.com/v2-08bd4e7fe0adbef6e11f8dc77f344001_b.jpg" alt="img"></p><p> 首先确定空间中一个方向(通过<img src="https://www.zhihu.com/equation?tex=%5Ctheta,%5Cphi" alt="[公式]">)，在这两个角度上分别增加一个微分值，则可以计算出如图中所示的对应到球上的投影面积。其中<img src="https://www.zhihu.com/equation?tex=rd%5Ctheta" alt="[公式]">就是微分面积元的高，<img src="https://www.zhihu.com/equation?tex=rsin%5Ctheta+d%5Cphi" alt="[公式]">是微分面积元的宽，二者相乘，自然就是面积了，再根据立体角的定义除以 <img src="https://www.zhihu.com/equation?tex=r%5E2" alt="[公式]"> 即可得到微分立体角了。</p><p>在此还可以验证下，对<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">在整个球上积分：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5COmega+&=%5Cint_%7BS%5E%7B2%7D%7D+%5Cmathrm%7Bd%7D+%5Comega+%5C%5C+&=%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+%5Cint_%7B0%7D%5E%7B%5Cpi%7D+%5Csin+%5Ctheta+%5Cmathrm%7Bd%7D+%5Ctheta+%5Cmathrm%7Bd%7D+%5Cphi+%5C%5C+&=4+%5Cpi+%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>与之前所讲的球的立体角为<img src="https://www.zhihu.com/equation?tex=4%5Cpi" alt="[公式]">一致。</p><p><strong>tips：</strong></p><p>注意在计算微分立体角之前，我们其实选定了空间当中的一个方向（由<img src="https://www.zhihu.com/equation?tex=%5Ctheta,%5Cphi" alt="[公式]">所确定），称这个方向为<img src="https://www.zhihu.com/equation?tex=%5Comega" alt="[公式]">，然后才在此基础之上分别对<img src="https://www.zhihu.com/equation?tex=%5Ctheta,%5Cphi" alt="[公式]">增加<img src="https://www.zhihu.com/equation?tex=d%5Ctheta,d%5Cphi" alt="[公式]">经计算得到最终的<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">，因此Radiant intensity的物理含义此时就很清楚了，为光源向某一方向所发射出的单位立体角的功率，简而言之就是光源在某个方向上的亮度如何！</p><p>最后举一个对各向同性点光源计算Radiant intensity的例子： </p><p><img src="https://pic3.zhimg.com/v2-ee0c1e7d905b47a0de73f60238b29f2e_b.jpg" alt="img"></p><p> 因为各项同性点光源所有方向上的亮度都与方向无关，因此立体角可以直接积分出来为<img src="https://www.zhihu.com/equation?tex=4%5Cpi" alt="[公式]">，最终计算得<img src="https://www.zhihu.com/equation?tex=I+=+%5Cfrac%7B%5CPhi%7D%7B4%5Cpi%7D" alt="[公式]">。 (如果不是各项同性的话这里的<img src="https://www.zhihu.com/equation?tex=I(%5Comega)" alt="[公式]">应该为一个关于<img src="https://www.zhihu.com/equation?tex=%5Comega" alt="[公式]">方向的的函数)</p><p><strong>以上就已经详细介绍完了关于Radiant intensity的定义，接下来给出irradiance的相关定义</strong></p><h4 id="irradiance"><a href="#irradiance" class="headerlink" title="irradiance"></a>irradiance</h4><p><img src="https://pic3.zhimg.com/v2-594c083ca0df39a60bd1021a0449d93a_b.jpg" alt="img"></p><p> 同样用一句话来说，irradiance是指每单位<strong>照射</strong>面积所接收到的power，单位如图中所示。 借助于irradiance，可以很轻松的解释在Blinn-Phong所提到的Lambert’s Law,即光线亮度在计算时需要乘上一个<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">，如下图所示： </p><p><img src="https://pic1.zhimg.com/v2-783a8236548da199f5f463bec1067314_b.jpg" alt="img"></p><p> 当光线垂直照射平面时，如上图左边所示，<strong>照射</strong>到平面上的面积与光线本身的“宽度一致”。但当光线斜着照射到平面时，此时的<strong>照射</strong>面积就不再是光线本身的“宽度”了，具体来说此时的照射面积<img src="https://www.zhihu.com/equation?tex=A_2+=+A/cos%5Ctheta" alt="[公式]">。</p><p>那么针对右边情况的irradiance的计算就应该为：</p><p><img src="https://www.zhihu.com/equation?tex=E2+=+%5CPhi/A_2=%5CPhi+cos%5Ctheta/A" alt="[公式]">，相对于<img src="https://www.zhihu.com/equation?tex=E1=%5CPhi/A" alt="[公式]">多了一个<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">。</p><p>而这其实也就解释了Lambert’s Law要乘以一个<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">的原因了。</p><p>此外，回想一下也是在Blinn-Phong模型所提到的光线越远会越加衰减： </p><p><img src="https://pic3.zhimg.com/v2-1b60efad48a95bee425e70b4ee638fa6_b.jpg" alt="img"></p><p> 该现象也完全可以用irradiance解释，因为光的功率始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的面积值也就越大，irradiance也就越小。</p><h4 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h4><p>最后，我们终于来到了最后一条概念了，这条概念也是所有辐射度量学的概念当中最为重要的一个，那么首先直接就来看他的数学定义是怎么样的： </p><p><img src="https://pic2.zhimg.com/v2-2abc66f02abec7c085ed78e41033015d_b.jpg" alt="img"></p><p> 用一句话概述的话，所谓radiance就是指<strong>每单位立体角，每单位垂直面积的功率</strong>，直观来看的话，很像是Intensity和irradiance的结合。<strong>它同时指定了光的方向与照射到的表面所接受到的亮度</strong>。</p><p>但这里有一个细微的区别，在irradiance中定义的<strong>每单位照射面积</strong>，而在radiance当中，为了更好的使其成为描述一条光线传播中的亮度，且在传播过程当中大小不随方向改变，所以在定义中关于接收面积的部分是<strong>每单位垂直面积</strong>，而这一点的不同也正解释了图中式子分母上的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">，具体可以观察如下图： </p><p><img src="https://pic4.zhimg.com/v2-f4069d6992189e1bd74eb8d4af371dbb_b.jpg" alt="img"></p><p> 即图中的<img src="https://www.zhihu.com/equation?tex=dA" alt="[公式]">是irradiance中定义所对应的，而<img src="https://www.zhihu.com/equation?tex=%7Bd%7D+A%5E%7B%5Cperp%7D" alt="[公式]">才是radiance中所定义的面积。二者之间的关系为<img src="https://www.zhihu.com/equation?tex=%7Bd%7D+A%5E%7B%5Cperp%7D+=+dAcos%5Ctheta" alt="[公式]">。</p><p>(以上各项定义确实比较绕，我在闫老师的讲解上又去借鉴了PBR书中的定义，对这些概念加以了自己的解释，希望能对大家有帮助！)</p><p>好了，在理解了radiance和irradiance的定义之后，再讨论讨论它们之间的关系，通过二者的定义式子，不难得出如下结果：</p><p><img src="https://www.zhihu.com/equation?tex=L(%5Cmathrm%7Bp%7D,+%5Comega)=%5Cfrac%7B%5Cmathrm%7Bd%7D+E(%5Cmathrm%7Bp%7D)%7D%7B%5Cmathrm%7Bd%7D+%5Comega+%5Ccos+%5Ctheta%7D+%5C%5C" alt="[公式]"></p><p>进一步推导得到： </p><p><img src="https://pic4.zhimg.com/v2-91a45fb046a362b5c6c4b767b231354b_b.jpg" alt="img"></p><p> 观察一下积分后的式子，<img src="https://www.zhihu.com/equation?tex=E(p)" alt="[公式]">就是点p的irradiance，其物理含义是上文所提到过的点p上<strong>每单位照射面积的功率</strong>，而<img src="https://www.zhihu.com/equation?tex=L_i(p,%5Comega)" alt="[公式]">指入射光<strong>每立体角，每垂直面积的功率</strong>，因此积分式子右边的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">解释了面积上定义的差异，而对<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">积分，则是相当于对所有不同角度的入射光线做一个求和，那么该积分式子的物理含义便是，一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到。</p><h3 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数(BRDF)"></a>双向反射分布函数(BRDF)</h3><p>Bidirectional Scattering Distribution Function</p><p>通过上述所有辐射度量学各种概念的定义之后，我们可以从这样一个角度理解光线的反射，如下图所示： </p><p><img src="https://pic2.zhimg.com/v2-4b994e259e57655f1145a51b3832ac75_b.jpg" alt="img"></p><p><strong>一个点(微分面积元)在接受到一定方向上的亮度(</strong><img src="https://www.zhihu.com/equation?tex=dE(%5Comega_i)" alt="[公式]"><strong>)之后，再向不同方向把能量辐射出去(</strong><img src="https://www.zhihu.com/equation?tex=dL_r(%5Comega_r)" alt="[公式]"><strong>)</strong></p><p>从直观的理解来说，不同物体表面材质自然会把一定方向上的入射亮度(<img src="https://www.zhihu.com/equation?tex=dE(%5Comega_i))" alt="[公式]">反射到不同的方向的光线上(<img src="https://www.zhihu.com/equation?tex=dL_r(%5Comega_r)" alt="[公式]">)， <strong>如理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有。如理想粗糙表面会把入射光线均匀的反射到所有方向。因此所谓BRDF就是描述这样一个从不同方向入射之后，反射光线分布情况的函数</strong>，定义如下： </p><p><img src="https://pic4.zhimg.com/v2-690f3e96bd2730eeda4255a21c9e330f_b.jpg" alt="img"></p><p> 上图中下方的式子即为BRDF，它接收两个参数，入射光方向<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">,反射光方向<img src="https://www.zhihu.com/equation?tex=%5Comega_r" alt="[公式]">，函数值为反射光的radiance与入射光的iiradiance的比值。(从某个方向接受到的光能有多少反射到另外一个方向)</p><p>借助BRDF，可以定义出<strong>反射方程</strong>如下： </p><p><img src="https://pic2.zhimg.com/v2-ac12ff2871a3666a07b1d91b8820d4d9_b.jpg" alt="img"></p><p> 即摄像机所接受到的<img src="https://www.zhihu.com/equation?tex=%5Comega_r" alt="[公式]">方向上的反射光，是由所有不同方向上入射光线的irradiance贡献得到的(即图中式子的<img src="https://www.zhihu.com/equation?tex=L_%7Bi%7D%5Cleft(%5Cmathrm%7Bp%7D,+%5Comega_%7Bi%7D%5Cright)+%5Ccos+%5Ctheta_%7Bi%7D+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D" alt="[公式]">)，而不同方向入射光线的irradiance对反射方向<img src="https://www.zhihu.com/equation?tex=%5Comega_r" alt="[公式]">的贡献程度则由物体表面材质决定，所以乘上了一个BRDF函数。</p><p>到这里，通过辐射度量学，以及BRDF最终得到的反射方程正是一个<strong>完全正确的光线传播模型了</strong>，解决了在第一章提到的现有模型的所有缺点！（渲染方程只是在反射方程的基础之上加了一个自发光项，关于渲染方程会在下一章仔细去了解)。</p><p>在进入到渲染方程之前，再仔细观察一下反射方程： </p><p><img src="https://pic3.zhimg.com/v2-713d854abe8bcc32710b7292563326a6_b.jpg" alt="img"></p><p> 不难发现正如上图中所说的，入射光线的radiance不仅仅是光源所引起的，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p(即间接光照)，同时其他物体上的反射光线的radiance依然也是由直接光照和间接光照构成，因此这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程。所以说想要解这样一个方程还是比较难的。</p><p>接下来，在最后一章我们会引入渲染方程，并对渲染方程做一些直观上的物理解释，对于反射方程或者说是渲染方程的具体求解，留在下一篇文章里面去说。</p><h3 id="渲染方程及其物理含义解释"><a href="#渲染方程及其物理含义解释" class="headerlink" title="渲染方程及其物理含义解释"></a>渲染方程及其物理含义解释</h3><p>正如在上一节中提到的，渲染方程知识在反射方程的基础之上添加了一个自发光项(Emission term)，从而使得反射方程更加的general：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=L_%7Be%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)+%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>其中<img src="https://www.zhihu.com/equation?tex=L_e(p,%5Comega_o)" alt="[公式]">为自发光项，反射方程中的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">用，<img src="https://www.zhihu.com/equation?tex=n%5Ccdot%5Comega_i" alt="[公式]">代替。 (tips：所有光线方向均指向外)</p><p>接下来从一个点光源和单个物体的场景开始理解渲染方程： </p><p><img src="https://pic2.zhimg.com/v2-80d5e7a9cb7533eaa48ea76f658a56c1_b.jpg" alt="img"></p><p> (点光源对一个点来说自然只有一个方向有入射光，所以这里没有了积分)</p><p>多个点光源一个物体的情况： </p><p><img src="https://pic1.zhimg.com/v2-6bf8c6b5bee54674648d8805a34c133c_b.jpg" alt="img"></p><p> 将这些所有的点光源的贡献全部求和即可，那么如果点光源变成了面光源呢？如下图所示： </p><p><img src="https://pic2.zhimg.com/v2-20ef57e7db1040edd7de6797b0df91bd_b.jpg" alt="img"></p><p> 其实面光源就相当于无穷多个点光源的集合，只需要对 面光源所在的立体角范围进行积分，并且能够确定不同立体角方向的面光源的入射光radiance即可。</p><p>那么更进一步的，再在场景当中加入其它物体，使得物体之间发生光线交互之后是什么情况呢： </p><p><img src="https://pic1.zhimg.com/v2-aa6ee1c6af3ac2c8f7dadfdf4920d9c4_b.jpg" alt="img"></p><p> 如上图所示，可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。</p><p>观察一下图中的渲染方程可以发现除了两个radiance，其它所有项都是知道的，可以将上式进一步写成如下图下方所示的式子： </p><p><img src="https://pic4.zhimg.com/v2-995a0c3a7f373a80ceaa9c9fff9de5f7_b.jpg" alt="img"></p><p> 其中各项与原渲染方程中一一对应，(这里其实是有数学严格推导的，不过我们只是为了接下来构建直观的物理解释，对于这些推导不必在意，默认成立即可)，再接着，可以把该式子离散化写为线性代数的形式： </p><p><img src="https://pic4.zhimg.com/v2-cf43f163f31001283275a91ecb22f493_b.jpg" alt="img"></p><p> 呼，经过两步我们不是很清楚但其实是正确的数学推导之后，得到了这样一个式子：</p><p><img src="https://www.zhihu.com/equation?tex=L=E+KL+%5C%5C" alt="[公式]"></p><p>其中L其实就是想要求得的反射光，E是自发光其实就是光源的发光项，K可以理解为对光线进行反射的一种算子操作(因为它由BRDF化来的)。那么利用线性代数的知识很容易就可以推导出L的结果如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+L+&=E+K+L+%5C%5C+IL-K+L+&=E+%5C%5C+(I-K)+L+&=E+%5C%5C+L+&=(I-K)%5E%7B-1%7D+E+%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>其中<img src="https://www.zhihu.com/equation?tex=I" alt="[公式]">为单位矩阵，再接着对<img src="https://www.zhihu.com/equation?tex=(I-K)%5E%7B-1%7D" alt="[公式]">使用广义二项式定理得到：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+L=%5Cleft(I+K+K%5E%7B2%7D+K%5E%7B3%7D+%5Cldots%5Cright)+E+%5C%5C+L=E+K+E+K%5E%7B2%7D+E+K%5E%7B3%7D+E+%5Cldots+.+%5Cend%7Barray%7D%5C%5C" alt="[公式]"></p><p>仔细观察这个式子，注意E是光源所发出的光，K为反射算子，这样一个式子的物理含义如下图所示： </p><p><img src="https://pic2.zhimg.com/v2-91eedfd2bb5d78841807410df577d921_b.jpg" alt="img"></p><p> E为光源发出的光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果，对于全局光照来说，还考虑了<img src="https://www.zhihu.com/equation?tex=K%5E2E" alt="[公式]">，即一次弹射的间接照明，<img src="https://www.zhihu.com/equation?tex=K%5E3E" alt="[公式]">就是两次弹射的间接照明，依次类推。</p><p>这样来看整个结果是不是就很清晰了，就是光源发光加上直接光照与多次间接光照的结果！而这一切都是从渲染方程推导而来的，因此这也正是渲染方程的物理意义！</p><p>最后以几张基于物理渲染的图片作为本篇文章的结束 一次反射直接光照： </p><p><img src="https://pic2.zhimg.com/v2-e089c847c76885d7fd2d16dacd6926dd_b.jpg" alt="img"></p><p> 两次反射，考虑到一次弹射的间接光照： </p><p><img src="https://pic3.zhimg.com/v2-8d29adb7ef636cee958d858dd4f19dae_b.jpg" alt="img"></p><p> 3次反射，考虑到两次弹射的间接光照： </p><p><img src="https://pic3.zhimg.com/v2-63e675a1a7ea4bc637c4412393008b96_b.jpg" alt="img"></p><p> (考虑次数越多越接近真实图片效果,趋近收敛)</p><p>以上就是所有的关于PBR的一些相关基础知识了，我们从辐射度量学入手，掌握了正确衡量光线属性的方法，由此定义出了BRDF，来表示物体的材质，即它对于光线的反射能量分布，最后结合辐射度量学与BRDF得到渲染方程，一个个真正完全正确的光线传播模型！</p><hr><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>概率密度函数值为1</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618222319.png"></p><hr><h3 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h3><p>蒙特卡洛积分求解渲染方程</p><p>我们通过对辐射度量学当中一系列概念的定义，引入了渲染方程，一个正确的光线传播模型，但并没有去涉及如何解出该渲染方程，或者说如何通过该渲染方程计算出屏幕上每一个坐标的像素值。</p><h4 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h4><p>Monte Carlo Integration</p><p>首先让我们先搞懂蒙特卡洛路径追踪的这个“蒙特卡洛”的前缀到底指什么。</p><p><strong>蒙特卡洛积分的目的：</strong> <strong>其实就是用一种数值方法求解定积分</strong>，当一个积分很难通过解析的方式得到答案的时候可以通过蒙特卡洛的方式近似得到积分结果，如下图所示： </p><p><img src="https://pic4.zhimg.com/v2-49dba6285defd950f23247805bdc46ab_b.jpg" alt="img"></p><p> 显然对于这样一个函数，很难去用一个数学式子去表示，因此无法用一般解析的方法直接求得积分值，而这时候就可以采用蒙特卡洛的思想了。</p><p><strong>蒙特卡洛积分的原理及做法：</strong> 对函数值进行多次采样求均值作为积分值的近似</p><p>该做法十分容易理解，想象一下如果对上图这个函数值进行<strong>均匀采样</strong>的话，其实就相当于将整个积分面积切成了许许多多个长方形，然后将这些小长方形的面积全部加起来。没错，该做法其实就与黎曼积分的想法几乎一致。但蒙特卡洛积分更加的general，因为它可以指定一个分布来对被积分的值进行采样，定义如下： </p><p><img src="https://pic4.zhimg.com/v2-89678cd612b45b024bed2789acf275f3_b.jpg" alt="img"></p><p> 如图所示，我们希望求出一个函数<img src="https://www.zhihu.com/equation?tex=f(x)" alt="[公式]">在积分域<img src="https://www.zhihu.com/equation?tex=%5Ba,b%5D" alt="[公式]">上的积分值，选定一个采样的分布<img src="https://www.zhihu.com/equation?tex=p(x)" alt="[公式]">，通过对该分布来进行多次的函数值采样，最后估计的值如图中最下方式子所示。</p><p>这里对该式子进行一个简单的推导。相信大家都知道，求均值的做法其实也是对期望的逼近，因此：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7BN%7D+%5Csum_%7Bi=1%7D%5E%7BN%7D+%5Cfrac%7Bf%5Cleft(X_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(X_%7Bi%7D%5Cright)%7D+%5Capprox+%5Cmathbb%7BE%7D_%7Bx%5Csim+p(x)%7D(%5Cfrac%7Bf%5Cleft(x%5Cright)%7D%7Bp%5Cleft(x%5Cright)%7D)+%5C%5C" alt="[公式]"></p><p>那么对于这样一个服从某一分布的期望的计算套公式直接计算得：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cmathbb%7BE%7D_%7BX_i%5Csim+p(x)%7D(%5Cfrac%7Bf%5Cleft(X_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(X_%7Bi%7D%5Cright)%7D)+&=%5Cint_%7Ba%7D%5E%7Bb%7D+%5Cfrac%7Bf(x)%7D%7Bp(x)%7Dp(x)d+x%5C%5C+&=%5Cint_%7Ba%7D%5E%7Bb%7D+f(x)d+x%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>通过以上推导即可明白蒙特卡洛的近似正是对积分值的一个无偏估计。</p><p>但在本文中为了方便，所有的采样都使用均匀采样，因此很容易推出： </p><p><img src="https://pic4.zhimg.com/v2-cdfc9bd57ff05fe32ad48e29fe507c97_b.jpg" alt="img"></p><p> 因此，<strong>蒙特卡洛在此来说就是一个帮助求得困难积分值的方法</strong>。</p><h4 id="蒙特卡洛路径追踪"><a href="#蒙特卡洛路径追踪" class="headerlink" title="蒙特卡洛路径追踪"></a>蒙特卡洛路径追踪</h4><p>Monte Carlo Path Tracing</p><p>回顾一下上篇文章中所得到的渲染方程：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=L_%7Be%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)+%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>要想解出以上方程的解主要有两个难点：</p><ol><li>积分的计算</li><li>递归形式</li></ol><p>而解决这些难点自然就要利用上节中所提到的蒙特卡洛积分方法了。</p><p>在进入具体计算之前，对渲染方程做出一点小修改，即舍弃一下自发光项(因为除了光源其他物体不会发光), 以方便进行计算推导：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>从具体例子出发，首先仅仅考虑直接光照： </p><p><img src="https://pic2.zhimg.com/v2-26f8046689feafff2d84e8422e4575a1_b.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>再次观察该修改过之后的方程其实就只是一个单纯的积分计算了，其物理含义为着色点p到摄像机或人眼的Radiance值。</p><p>回想第一章所提的，对于一个困难积分只要选定一个被积分变量的采样分布即可通过蒙特卡洛的方法得到积分结果的近似值，而此时的被积分值为<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">，选定<img src="https://www.zhihu.com/equation?tex=%5Comega_i+%5Csim+p(%5Comega_i)" alt="[公式]">，不难得出积分近似结果如下：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)+%5Capprox+%5Cfrac%7B1%7D%7BN%7D+%5Csum_%7Bi=1%7D%5E%7BN%7D+%5Cfrac%7BL_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(%5Comega_%7Bi%7D%5Cright)%7D+%5C%5C" alt="[公式]"></p><p>正如一开始所说，先单独考虑直接光照，因此只有当采样的方向<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">击中光源的时候，光源才会对该着色点有贡献，计算伪代码如下： </p><p><img src="https://pic2.zhimg.com/v2-b47375a846c2c970fe94fa8407d64eed_b.jpg" alt="img"></p><p> 显而易见的，单独仅仅考虑直接光照自然是不够的，还需要间接光照，即当采样的<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">方向碰撞到了别的物体，如下图所示： </p><p><img src="https://pic3.zhimg.com/v2-2bf4ed87211fa8756bd2982e7f7b51e6_b.jpg" alt="img"></p><p> 此时采样的光线碰撞到了另一个物体的Q点，那么该条路径对着色点P的贡献是多少呢？自然是在点Q的直接光照再乘上反射到该方向上的百分比了！显然这是一个类似光线追踪的递归过程，不同在于该方法通过对光线方向的采样从而找出一条条可行的路径，这也正是为什么叫路径追踪的原因，伪代码如下： </p><p><img src="https://pic2.zhimg.com/v2-cfa9e75a770b298b95eaa592b4726611_b.jpg" alt="img"></p><p>至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但该方法至此有一个非常致命的缺陷： </p><p><img src="https://pic1.zhimg.com/v2-3ac15235ec0e981aaae4e632005644d4_b.jpg" alt="img"></p><p> 我们通过每次对光线方向的采样从而解出方程，假设每次采样100条，那么从人眼出发的第一次采样就是100条，在进行第二次反射之后就是10000条，依次类推，反射越多次光线数量便会爆炸增长，计算量会无法负担，那么如何才能使得光线数量不爆炸增长呢？<strong>唯有每次只采样一个方向！N=1</strong> </p><p><img src="https://pic2.zhimg.com/v2-4166c72edb9154d759c4f02340c2cf15_b.jpg" alt="img"></p><p> 每次如果只采样一个方向那么所带来的问题也是显而易见的，积分计算的结果会非常的noisy，虽然蒙特卡洛积分是无偏估计，但样本越少显然偏差越大。但该问题很好解决，如果每次只去寻找一条路径结果不好，那么重复多次寻找到多条路径，将多条路径的结果求得平均即可！如下图所示： </p><p><img src="https://pic1.zhimg.com/v2-271216ad202de93f81a88736feca7920_b.jpg" alt="img"></p><p> 改良之后的Path Tracing伪代码如下： </p><p><img src="https://pic2.zhimg.com/v2-0b1bd71c9b0646340f63a1380903f371_b.jpg" alt="img"></p><p> 通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。</p><p>那么现在所有的问题都解决了吗？还没有！因为shade函数的递归没有出口，永远不会停下。 但这里并不没有采用类似光线追踪当中设定反射深度显示的给出递归出口的方法，而是非常精妙的采用了**俄罗斯轮盘赌(Russian Roulette)**。 </p><p><img src="https://pic3.zhimg.com/v2-0a56506e94dd87a4261c4db18c4df26e_b.jpg" alt="img"></p><p> 给你一把左轮，两发子弹，你不知道哪一发会真正的射出子弹，因此拿这把左轮射自己，你有4/6的概率活下来，这就是俄罗斯轮盘赌的概念。</p><p>将其应用在路径追踪当中，首先设定一个概率<img src="https://www.zhihu.com/equation?tex=P" alt="[公式]">, 有P的概率光线会继续递归并设置返回值为<img src="https://www.zhihu.com/equation?tex=L_o+/P" alt="[公式]">，有<img src="https://www.zhihu.com/equation?tex=1-P" alt="[公式]">的概率光线停止递归，并返回0。这样巧妙的设定之下光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为Radiance的期望不变，证明如下：</p><p><img src="https://www.zhihu.com/equation?tex=E=P%5E%7B%5Cstar%7D(L+o+/+P)+(1-P)%5E%7B%5Cstar%7D+0=L_%7B0%7D+%5C%5C" alt="[公式]"></p><p>shade函数的伪代码变更如下，使得可以停止递归了： </p><p><img src="https://pic3.zhimg.com/v2-b89455bc8933ef9eed64d92f0690a4e6_b.jpg" alt="img"></p><p> 至此，我们的路径追踪算法已经完成大半，只差最后一个小问题！现在的路径追踪效率非常的低下，如图所示： </p><p><img src="https://pic3.zhimg.com/v2-00d6036dae14d6bdc5cf819f8149cee6_b.jpg" alt="img"></p><p> 在每次计算直接光照的时候，通过均匀采样任选一个方向，但很少会的光线可以hit光源，尤其当光源较小的时候，这种现象越明显，大量采样的光线都被浪费了。</p><p>因此在计算直接光照的时候改进为<strong>直接对光源进行采样！</strong>这样所有采样的光线都一定会击中光源(如果中间没有别的物体)，没有光线再会被浪费了。假设光源的面积为A，那么对光源进行采样的 <img src="https://www.zhihu.com/equation?tex=pdf+=+1/A" alt="[公式]"> (因为<img src="https://www.zhihu.com/equation?tex=%5Cint+%5Coperatorname%7Bpdf%7D+d+A=1" alt="[公式]">)，但原始的渲染方程：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>很明显是对光线方向<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">进行积分的，如果想要对光源进行采样的并依然使用蒙题卡洛的方法，那么一定要将其修改为对光源面积 dA的积分，换言之就是需要找到dA与d<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">的关系即可。如下图所示： </p><p><img src="https://pic4.zhimg.com/v2-e2c132bd2bbd66f2781c26ce5990d94b_b.jpg" alt="img"></p><p> 关系式中的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta%5E%7B%5Cprime%7D" alt="[公式]">是为了计算出光源上微分面积元正对半球的面积，之后再按照立体角的定义<img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Bd%7D+%5Comega=%5Cfrac%7B%5Cmathrm%7Bd%7D+A%7D%7Br%5E%7B2%7D%7D" alt="[公式]">，除以着色点x与光源采样点x’距离的平方即可。于是根据图中二者的关系可将渲染方程改写如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+L_%7Bo%7D%5Cleft(x,+%5Comega_%7Bo%7D%5Cright)+&=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(x,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(x,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)+%5Ccos+%5Ctheta+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C+&=%5Cint_%7BA%7D+L_%7Bi%7D%5Cleft(x,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(x,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)+%5Cfrac%7B%5Ccos+%5Ctheta+%5Ccos+%5Ctheta%5E%7B%5Cprime%7D%7D%7B%5Cleft%5C%7Cx%5E%7B%5Cprime%7D-x%5Cright%5C%7C%5E%7B2%7D%7D+%5Cmathrm%7Bd%7D+A+%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>这样便成功从<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">积分转到了对光源面积A的积分，就可以利用蒙特卡洛的方法对光源进行采样从而计算直接光照的积分值了，对于间接光照，依然采用先前的方法进行光线方向的均匀采样。最终伪代码如下，分直接光照和间接光照两部分计算： </p><p><img src="https://pic4.zhimg.com/v2-3fb23eece40f6f50e4a9be56dddbb363_b.jpg" alt="img"></p><p>tips:计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可，如图所示: </p><p><img src="https://pic1.zhimg.com/v2-7c17994605220a196d57e8e6cecdbb2c_b.jpg" alt="img"></p><p>最后以一张闫老师课程的path tracing作业的截图作为结束！ </p><p><img src="https://pic4.zhimg.com/v2-dd78fa7aa518b8427a1d8e737e3f0f0f_b.jpg" alt="img"></p><h4 id="遗留问题探索"><a href="#遗留问题探索" class="headerlink" title="遗留问题探索"></a>遗留问题探索</h4><ul><li>怎样去在半球面上去采样呢？采样方法？</li><li>PDF函数的选取，目前用的最简单的均匀PDF，怎么选最合理的，重要性采样原理</li><li>随机数的生成 low discrepancy sequences</li><li>将半球采样和光源采样结合起来 multiple imp sampling 混合采样</li><li>像素平均加权问题</li><li>radiance和颜色的映射，gamma矫正 HDR 颜色空间</li></ul><hr><h3 id="材质和外观"><a href="#材质和外观" class="headerlink" title="材质和外观"></a>材质和外观</h3><p>Materials and Appearances</p><p>以前只有Blinn Phong的时候，通过非物理的方式模拟出各种材质。Material == BRDF 决定光如何被反射</p><h4 id="漫反射、镜面反射、折射材质"><a href="#漫反射、镜面反射、折射材质" class="headerlink" title="漫反射、镜面反射、折射材质"></a>漫反射、镜面反射、折射材质</h4><ul><li><strong>Diffuse / Lambertian Material (BRDF) 漫反射材质</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220619133822.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220619134005.png"></p><ul><li><p><strong>Glossy material (BRDF)</strong></p><p>有一些镜面效果，但不是完全镜面的材质</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Games101-光追部分&quot;&gt;&lt;a href=&quot;#Games101-光追部分&quot; class=&quot;headerlink&quot; title=&quot;Games101 光追部分&quot;&gt;&lt;/a&gt;Games101 光追部分&lt;/h1&gt;&lt;h2 id=&quot;Ray-Tracing&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Rasterizer" scheme="http://icecorn.github.io/tags/Rasterizer/"/>
    
    <category term="Games-101" scheme="http://icecorn.github.io/tags/Games-101/"/>
    
  </entry>
  
  <entry>
    <title>Games-101|光栅化渲染部分</title>
    <link href="http://icecorn.github.io/2022/03/18/Games-101/Games101-%E5%85%89%E6%A0%85%E5%8C%96%E9%83%A8%E5%88%86/"/>
    <id>http://icecorn.github.io/2022/03/18/Games-101/Games101-%E5%85%89%E6%A0%85%E5%8C%96%E9%83%A8%E5%88%86/</id>
    <published>2022-03-18T09:25:10.000Z</published>
    <updated>2022-06-29T14:59:15.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Game-101"><a href="#Game-101" class="headerlink" title="Game-101"></a>Game-101</h1><h2 id="二-向量与线性代数"><a href="#二-向量与线性代数" class="headerlink" title="二 向量与线性代数"></a>二 向量与线性代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>vector表示的向量，包括向量的长度，方向，单位向量等。</p><p>向量加法（平行四边形，三角形法则），用笛卡尔坐标系直接坐标相加</p><p><strong>向量点乘：</strong></p><p>a*b = |a||b|cosθ，得到的是一个数</p><p>作用：</p><ul><li>算向量的夹角</li><li>算b向量在a向量上的投影</li><li>衡量两个方向是不是接近的</li><li>分解一个向量（到两个垂直方向上）</li><li>通过点成&gt;0或&lt;0判断方向性</li></ul><p><strong>向量叉乘：</strong></p><p>|axb| = |a||b|sinθ</p><p>axb = -bxa</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629224913916.png" alt="image-20220629224913916"></p><p>作用：</p><ul><li>算法向量的方向</li><li>判断左右</li><li>判断内外（经典问题，判断点在三角形内外）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/2.png" alt="2"></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵乘法是没有<strong>交换律</strong>的，AB！=BA</p><p>有<strong>结合律</strong>和<strong>分配律</strong></p><p>矩阵求<strong>逆矩阵</strong>，求<strong>转置</strong></p><p>向量的乘积写成矩阵形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/3.png" alt="3"></p><h2 id="三-变换（二维和三维）"><a href="#三-变换（二维和三维）" class="headerlink" title="三 变换（二维和三维）"></a>三 变换（二维和三维）</h2><h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629224946363.png" alt="image-20220629224946363"></p><h3 id="反转变换"><a href="#反转变换" class="headerlink" title="反转变换"></a>反转变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/5.png" alt="5"></p><h3 id="切变换（Shear）"><a href="#切变换（Shear）" class="headerlink" title="切变换（Shear）"></a>切变换（Shear）</h3><p>找到对应关系，这里其实相当于在x方向上进行一个线性插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629224959521.png" alt="image-20220629224959521"></p><h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>旋转方向默认逆时针</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225022067.png" alt="image-20220629225022067"></p><p>旋转-sinθ</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225045408.png" alt="image-20220629225045408"></p><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8.png" alt="8"></p><h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><p>需要线性变化+常数项</p><p><strong>平移变换不属于线性变换</strong></p><p><strong>将平移变换转变成矩阵乘法：</strong></p><p>通过给二维点和向量增加一个维度从而实现（齐次坐标）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225058336.png" alt="image-20220629225058336"></p><p>点+点表示的是这两个点的中点</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/10.png" alt="10"></p><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11.png" alt="11"></p><p>总结：通过齐次坐标实现仿射变换，它们的任何变换操作都可以变成左乘一个变换矩阵来表示</p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/12.png" alt="12"></p><p>实现上就是左乘M矩阵的逆矩阵</p><h3 id="变换的合成与分解"><a href="#变换的合成与分解" class="headerlink" title="变换的合成与分解"></a>变换的合成与分解</h3><p>通过左乘很多矩阵实现变换的合成，同时也可以左乘逆矩阵实现变换的分解</p><h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><p>类比二维的，多加一为，用4x4的矩阵表示各种变换矩阵</p><p>对于三维的旋转有很多种方法：</p><p>比如欧拉角和四元数</p><hr><h2 id="四-变换（MVP变换，模型，视图，投影）"><a href="#四-变换（MVP变换，模型，视图，投影）" class="headerlink" title="四 变换（MVP变换，模型，视图，投影）"></a>四 变换（MVP变换，模型，视图，投影）</h2><p>以拍照来类比：</p><p>Model：人拍pose</p><p>View：确定相机的位置，和镜头朝向等等</p><p>Projection：按下快门，把三维场景投影到照片上</p><h3 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h3><p>首先要固定相机在（0，0，0）的位置上，并且看下-Z方向，向上方向（想想摄像机上有一根草，相机歪着的话，草也是歪着的，这就是向上方向）为Y方向因为这样之后好处理。</p><p>那么在移动过程中，就是先移动相机的位置，然后所有的物体都做同样的变换，保持相对变换就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14.png" alt="14"></p><p>先平移，在旋转</p><p>因为要把任意的（x,y,z）旋转到（1，0，0）不好写，所以可以先求逆变换，然后因为旋转矩阵是正交矩阵，它的转置就是它的逆，所以之后再转置就可以得到正常的旋转变化了。</p><p>这样的操作（平移+旋转）就叫视图变换</p><hr><h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><p>3D to 2D的变化方式，分为正交投影和透视投影</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>并不会近大远小</p><p>简单方法：</p><ul><li>设置相机（0，0，0），-Z，向上Y</li><li>丢掉Z坐标</li><li>变换到【-1，1】的平方这块矩形上</li></ul><p>常规方法（图形学上）：</p><p>先把物体中心平移到【-1，1】的立方这个小正方体上，在进行缩放变换</p><ul><li>平移中心</li><li>缩放到单位正方体</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225134866.png" alt="image-20220629225134866"></p><p>写成数学形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/17.png" alt="17"></p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>会有近大远小的特性，符合人眼，用途广泛</p><p>实现方法：</p><p>分成两步：</p><ul><li>将中间和远平面的所有点都“挤压”到单位平面上</li><li>再做正交投影</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/18.png" alt="18"></p><p>由相似三角形，可以得到被挤压后的位置应该在哪里</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225151670.png" alt="image-20220629225151670"></p><p>由此可以反推出来变换矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20.png" alt="20"></p><p>根据近平面点和远平面中点的不变性，用待定系数法，推出M矩阵的第三行</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/21.png" alt="21"></p><hr><h2 id="五-光栅化（三角形的离散化）"><a href="#五-光栅化（三角形的离散化）" class="headerlink" title="五  光栅化（三角形的离散化）"></a>五  光栅化（三角形的离散化）</h2><p>将【-1，1】的单位立方体，呈现到屏幕上，屏幕是由像素组成的比如1980*1080</p><p><strong>视口变换：</strong></p><ul><li>先把中心平移到屏幕的中心</li><li>进行M变换</li></ul><p>整个过程我们先不考虑Z轴的问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/22.png" alt="22"></p><h3 id="三角网格的优势"><a href="#三角网格的优势" class="headerlink" title="三角网格的优势"></a>三角网格的优势</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225209123.png" alt="image-20220629225209123"></p><p><strong>怎样判断一个像素是在三角形内部还是外部？</strong></p><p>三个向量叉乘同号</p><h3 id="采样光栅化（Sampling）"><a href="#采样光栅化（Sampling）" class="headerlink" title="采样光栅化（Sampling）"></a>采样光栅化（Sampling）</h3><p>采样其实就是把函数离散化的过程</p><p>例子：</p><p>首先写一个函数 inside（tri，x，y）；表示点是否在三角形内，然后遍历像素把每个像素的值写入结果image【x】【y】中</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/24.png" alt="24"></p><p>判断点是否在三角形内很重要，有时间写一下代码</p><p><strong>优化：</strong></p><p>为了避免每个三角形离散都要遍历所有像素，可以进行优化</p><ul><li>包围盒，找到min_x,min_y,max_x,max_y这样就可以确定包围盒</li><li>一行一行遍历里边的像素（适合窄的三角形）</li></ul><h2 id="六-光栅化（深度测试与抗锯齿）"><a href="#六-光栅化（深度测试与抗锯齿）" class="headerlink" title="六 光栅化（深度测试与抗锯齿）"></a>六 光栅化（深度测试与抗锯齿）</h2><h3 id="反走样-MSAA（抗锯齿）"><a href="#反走样-MSAA（抗锯齿）" class="headerlink" title="反走样-MSAA（抗锯齿）"></a>反走样-MSAA（抗锯齿）</h3><p><strong>需要先做模糊（卷积）再采样</strong></p><p>具体的原因是根据信号与系统中时域和频域的知识，简单理解去掉高频信息可以使得采样更接近（想象一下颜色都相近情况下，采样的间隔当然可以变小，换句话说同样的采样间隔，颜色相近，频率更低的函数采样起来肯定更准确）</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>通过一个卷积核对单位像素周围的一圈像素（一环领域）平均算值，从而实现模糊的效果</p><h3 id="超采样MSAA"><a href="#超采样MSAA" class="headerlink" title="超采样MSAA"></a>超采样MSAA</h3><p>将每个像素点分割成4个或16个或更多个小单元，判断一个像素中有几个单元在三角形内，然后计算比例，通过这种方式实现模糊操作</p><p><strong>注意这里的采样方式不是规规整整的4个格子，是其他有效的采样方式，比如斐波那契采样之类的，而且有一些相邻的采样点还会被相邻像素复用</strong></p><h3 id="快速近似抗锯齿-FXAA"><a href="#快速近似抗锯齿-FXAA" class="headerlink" title="快速近似抗锯齿-FXAA"></a>快速近似抗锯齿-FXAA</h3><p>得到有锯齿的图，找到锯齿的边界，换成没有锯齿的图</p><h3 id="Temporal-AA-TAA"><a href="#Temporal-AA-TAA" class="headerlink" title="Temporal AA-TAA"></a>Temporal AA-TAA</h3><p>复用上一帧的抗锯齿效果，这一帧再进行处理</p><hr><h3 id="可见性（遮挡）"><a href="#可见性（遮挡）" class="headerlink" title="可见性（遮挡）"></a>可见性（遮挡）</h3><p>要把很多物体放在屏幕上，如何呈现的问题</p><h4 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h4><p>从远到近，一个一个画，后画的遮挡前边画的</p><h4 id="深度缓存（Z-Buffer）"><a href="#深度缓存（Z-Buffer）" class="headerlink" title="深度缓存（Z-Buffer）"></a>深度缓存（Z-Buffer）</h4><p>从像素考虑，像素永远保存里屏幕最近的元素</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/25.png" alt="25"></p><p>同时要维护两张图，一张是最后的结果图，一张是深度图</p><p>对每一个三角形（物体），遍历它的采样（像素），如果它的深度比深度图中的小，那就要更新结果图和深度图，否则什么都不做</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/26.png" alt="26"></p><hr><h2 id="七-九-着色（光照与基本着色模型）"><a href="#七-九-着色（光照与基本着色模型）" class="headerlink" title="七-九  着色（光照与基本着色模型）"></a>七-九  着色（光照与基本着色模型）</h2><h3 id="布林-冯模型"><a href="#布林-冯模型" class="headerlink" title="布林-冯模型"></a>布林-冯模型</h3><p>就是在一种光源下，一个着色点如何着色的问题</p><p>全反射（高光）</p><p>漫反射</p><p>环境光照（间接光照）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/27.png" alt="27"></p><p>着色点，光源方向，观察方向等一些参数的设置</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/28.png" alt="28"></p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>考虑光是离散的，根据光照射到着色点，着色点接收到光的能量来计算漫反射的实际光照</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225230444.png" alt="image-20220629225230444"></p><p>n点乘l，计算夹角的cos值</p><p><strong>漫反射和观测角度没关系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/30.png" alt="30"></p><hr><h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h3><p>镜面反射，和观测方向有关</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/31.png" alt="31"></p><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/32.png" alt="32"></p><h3 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3><p>按照粒度不同可分为，按照面着色（flat shading)，按照点着色(Gouraud shading)，按照像素着色(phong shading)</p><p>Gouraud shading:渲染点，求出每个点法向，然后算出点的颜色，三角形内部点颜色插值得到</p><p>phong shading:像素渲染，每个像素插值法向，然后逐像素着色</p><p><strong>算点的法向量：是点周围的面的法向量加权平均</strong></p><hr><h3 id="实时渲染管线"><a href="#实时渲染管线" class="headerlink" title="实时渲染管线"></a>实时渲染管线</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/33.png" alt="33"></p><ul><li>顶点的投影 MVP变换</li><li>光栅化，包括Z-buffer操作</li><li>着色，可分为顶点着色，或者像素着色</li></ul><p><strong>Shader 程序</strong></p><p>shader是在硬件中实现的，可以定义顶点着色或者像素着色</p><p>不用写for循环，一个shader写好可以应用在所有像素或者顶点上</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/34.png" alt="34"></p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>纹理贴图，uv映射</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/35.png" alt="35"></p><h3 id="三角形内属性插值"><a href="#三角形内属性插值" class="headerlink" title="三角形内属性插值"></a>三角形内属性插值</h3><p>通过重心坐标实现插值</p><p><strong>重点：重心坐标在投影下是会变的，也就是说，我们要插值三维属性（比如说深度，法向）就必须在世界空间（投影前的三维空间）下进行插值。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225248914.png" alt="image-20220629225248914"></p><p>点在三角形要保证三个参数非负</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/37.png" alt="37"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/38.png" alt="38"></p><p>纹理就是漫反射系数</p><h4 id="纹理太小"><a href="#纹理太小" class="headerlink" title="纹理太小"></a>纹理太小</h4><p>纹理太小，可以使用双线性插值，双三次插值等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225303891.png" alt="image-20220629225303891"></p><h4 id="纹理太大"><a href="#纹理太大" class="headerlink" title="纹理太大"></a>纹理太大</h4><p>纹理太大会引起摩尔纹等走样问题</p><p>解决方法：</p><p><strong>Mipmap</strong></p><p><strong>三线性插值</strong></p><p>mipmap做近似的正方形的范围查询</p><p>其实就是一张图生成一系列分辨率不同的图</p><p>这里有个问题是远处的点采样小分辨率的图，会覆盖很多像素，那么就会做模糊，可能会引起远处全糊的情况，可以使用<strong>各向异性过滤</strong>的方法解决</p><h3 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h3><p>通过凹凸贴图在<strong>切线空间</strong>重新计算扰动后的法向量，能够达到视觉上的trick</p><hr><h2 id="十-几何（基本表示方法）"><a href="#十-几何（基本表示方法）" class="headerlink" title="十 几何（基本表示方法）"></a>十 几何（基本表示方法）</h2><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p>几何有很多表示方法，大体分为隐式表示和显示表示</p><p>隐式表示就是通过一系列的函数来描述几何体，比如一个球</p><p>水平集，分形等</p><p><strong>优点：表示起来比较容易，一个公式描述一个形状，并且判断点在几何体内外很容易</strong></p><p><strong>缺点：难以描述复杂模型</strong></p><h3 id="曲线和曲面"><a href="#曲线和曲面" class="headerlink" title="曲线和曲面"></a>曲线和曲面</h3><p><strong>贝塞尔曲线</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225316434.png" alt="image-20220629225316434"></p><p>B样条，曲面表示等等</p><h3 id="网格处理"><a href="#网格处理" class="headerlink" title="网格处理"></a>网格处理</h3><p><strong>网格简化，网格正规化，网格细分</strong></p><h4 id="Loop-细分（加密）"><a href="#Loop-细分（加密）" class="headerlink" title="Loop 细分（加密）"></a>Loop 细分（加密）</h4><p>只能用在三角形网格</p><ul><li>先递归分解，每个面片分成几个小面片</li><li>调整点的位置（光滑处理）</li></ul><h4 id="Catmull-Clark-细分"><a href="#Catmull-Clark-细分" class="headerlink" title="Catmull-Clark 细分"></a>Catmull-Clark 细分</h4><p>通过增加非四边形面的奇异点，来使网格都变成四边形面</p><p>然后再光滑处理</p><h3 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h3><p>只能处理点光源</p><p>核心思想是一个点既能被相机看到也能被光源看到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Game-101&quot;&gt;&lt;a href=&quot;#Game-101&quot; class=&quot;headerlink&quot; title=&quot;Game-101&quot;&gt;&lt;/a&gt;Game-101&lt;/h1&gt;&lt;h2 id=&quot;二-向量与线性代数&quot;&gt;&lt;a href=&quot;#二-向量与线性代数&quot; class=&quot;he</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Rasterizer" scheme="http://icecorn.github.io/tags/Rasterizer/"/>
    
    <category term="Games-101" scheme="http://icecorn.github.io/tags/Games-101/"/>
    
  </entry>
  
  <entry>
    <title>操作系统思维导图</title>
    <link href="http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-16T11:37:26.000Z</published>
    <updated>2022-06-29T14:18:13.925Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="http://icecorn.github.io/file/os.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>线程是os能调度的最小单位，它包含在进程中，是进程的实际运作单位，但是它不拥有资源（实际上就是为了将进程拥有资源和接受os调度这两个事分开才有的线程，同时一个进程可拥有多个线程，可以是进程并发的处理任务）</li></ul><h3 id="有什么？"><a href="#有什么？" class="headerlink" title="有什么？"></a>有什么？</h3><ul><li>一个线程执行状态（运行，就绪等）</li><li>线程上下文，一个独立的程序计数器（记录下一条指令地址）</li><li>用于局部变量的一些静态存储空间（栈空间）要注意这个栈空间是私有的</li><li>与进程内其他线程共享的内存和资源的访问权限</li></ul><h3 id="好处？"><a href="#好处？" class="headerlink" title="好处？"></a>好处？</h3><ul><li>使cpu的调度时间片粒度更小，运行一个进程时，可以分成更小的时间片给进程的各个线程</li><li>线程间切换时间要小于进程间切换</li><li>提高了不同执行程序通信的效率，因为进程内的线程共享内存，直接改就行，而不用内核接入切换进程再通信来完成</li></ul><h3 id="两种线程"><a href="#两种线程" class="headerlink" title="两种线程"></a>两种线程</h3><ul><li><p>用户态线程</p><ul><li>这种线程对os来说是未知的，切换线程不需要状态切换，但一个进程同时只能运行一个线程。一个线程阻塞，进程就阻塞。</li></ul></li><li><p>内核态线程</p><ul><li>这种线程实际上就是mini进程，线程切换和进程一样会触发中断进行状态切换。当然它们也就可以再多个处理器上真正的并行执行。</li></ul></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>一个能分配给处理器执行的程序实体</li></ul><h3 id="有什么？-1"><a href="#有什么？-1" class="headerlink" title="有什么？"></a>有什么？</h3><ul><li>1.程序代码</li><li>2.数据集（系统资源）</li><li>3.进程控制块</li></ul><h3 id="进程控制块（由os创建和管理）"><a href="#进程控制块（由os创建和管理）" class="headerlink" title="进程控制块（由os创建和管理）"></a>进程控制块（由os创建和管理）</h3><ul><li>标识符：进程唯一标识符</li><li>状态：执行状态</li><li>优先级：相对其他进程的优先顺序</li><li>程序计数器：程序中即将执行的下一条指令地址</li><li>内存指针：相关代码和数据集以及和其他进程共享内存块的指针</li><li>上下文：执行时处理器寄存器中的数据</li><li>IO信息：IO请求，使用的文件列表等</li><li>记账信息：包括处理器时间总和，时钟数总和等</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>运行态：进程执行中，单核的话只有一个进程为运行态</li><li>就绪态：准备好了，有机会就执行</li><li>阻塞态：在某事发生前不能执行，如IO完成</li><li>新建态：刚创建的进程，通常进程控制块建好了，但没有加载到内存中</li><li>退出态：释放了的进程</li><li>挂起态：不属于上述5个标准的状态，挂起态是把阻塞长的进程换到磁盘中，把能直接执行的进程换到内存中，避免让cpu闲下来</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li><p>中断</p><ul><li>时钟中断：就是时间片到点了</li><li>IO中断：要等打印机了==</li><li>内存失效：要使用到虚存了，要从磁盘里调</li></ul></li><li><p>陷阱：处理一个错误或异常条件</p></li><li><p>系统调用：调用操作系统函数</p></li><li><p>以上三种发生了，处理器都会执行一次模式切换（用户态转到内核态），将控制权交给os例程，os处理完，可以恢复被中断的进程或切换到其他进程</p></li></ul><h2 id="如何控制资源？通过维护一些表。"><a href="#如何控制资源？通过维护一些表。" class="headerlink" title="如何控制资源？通过维护一些表。"></a>如何控制资源？通过维护一些表。</h2><h3 id="内存表"><a href="#内存表" class="headerlink" title="内存表"></a>内存表</h3><ul><li>页表</li><li>段表</li></ul><h3 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h3><ul><li>主进程表：包含每个进程的表项（至少包含一个指向进程映像的指针）</li><li>进程映像：包括程序，数据，栈，属性</li><li>进程可以一部分存在内存，一部分放在外存，这些信息都要存在进程表里。一切目的都是让cpu能够找到而已</li></ul><h3 id="IO表"><a href="#IO表" class="headerlink" title="IO表"></a>IO表</h3><h3 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h3><h2 id="并发性：互斥和同步"><a href="#并发性：互斥和同步" class="headerlink" title="并发性：互斥和同步"></a>并发性：互斥和同步</h2><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul><li><p>通过编程语言来实现</p><ul><li>信号量机制（实际的实现还是硬件或软件方法）</li><li>消息机制</li><li>管程</li><li>生产者/消费者问题</li><li>读/写者问题</li></ul></li><li><p>硬件实现</p><ul><li>中断禁用（临界区禁用中断）</li><li>专用的机器指令</li></ul></li><li><p>软件实现</p><ul><li>通过进程来实现</li></ul></li></ul><h2 id="并发性：死锁和饥饿"><a href="#并发性：死锁和饥饿" class="headerlink" title="并发性：死锁和饥饿"></a>并发性：死锁和饥饿</h2><h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><ul><li><p>产生死锁的3个必要非充分条件</p><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li></ul></li><li><p>充分条件：循环等待（是上边3个必要条件导致的结果）</p></li></ul><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><ul><li>可重用资源（IO，内存等等）</li><li>可消耗资源（中断，IO缓冲区消息等）</li></ul><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul><li><p>预防</p><ul><li><p>一次性请求所有资源</p><ul><li>缺点：</li></ul></li></ul></li></ul><p>1.因阻塞导致占有这么多资源都不能用，别的进程也不能用<br>2.事先不知道需要哪些资源</p><pre><code>- 抢占    - 缺点：</code></pre><p>1.要求两个进程优先级不同<br>2.资源状态要容易保存和恢复</p><pre><code>- 资源排序    - 缺点：</code></pre><p>1.和一次性请求所有资源一样，会拒绝资源访问，浪费资源可使用的时间</p><ul><li><p>避免</p><ul><li>操作以便发现至少一条安全路径</li></ul></li></ul><p>1.若一个进程请求会导致死锁，则不启动该进程<br>2.若一个进程增加资源请求会导致死锁，则不允许这一资源分配</p><pre><code>    - 资源分配拒绝策略</code></pre><p>（银行家算法）</p><pre><code>        - 优点：</code></pre><p>无需死锁预防中的抢占和回滚进程<br>            - 限制：<br>1.必须事先声明每个进程请求的最大资源<br>2.所讨论的进程必须是无关的，即它们的执行顺序没有任何同步要求的限制<br>3.分配的资源数量必须是固定的<br>4.在占有资源时，进程不能退出</p><ul><li><p>检测</p><ul><li><p>周期性检测死锁的存在</p></li><li><p>恢复</p><ul><li>1.取消所有死锁进程（os最常用方法）</li></ul></li></ul></li></ul><p>2.每个死锁进程回滚，并重启所有进程<br>3.连续取消死锁进程直到不再存在死锁<br>4.连续抢占资源直到不在存在死锁</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>重定位</li><li>保护</li><li>共享</li><li>逻辑组织</li><li>物理组织</li></ul><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><ul><li><p>固定分区</p></li><li><p>动态分区</p></li><li><p>伙伴系统</p></li><li><p>分页</p><ul><li>进程分成页<br>内存分成页框（大小相等）<br>每一页很小，windows是4kb<br>进程可以拥有不连续的很多页，通过维护一个页表来找到它们</li></ul></li><li><p>分段</p><ul><li><p>进程和内存被分成很多段<br>段的大小可以不相等</p><ul><li>特点：<br>可以由程序员控制，一般将每个段定义一组逻辑信息，然后映射到内存中去。而分页是定死的，程序员控制不了</li></ul></li></ul></li><li><p>分段和分页区别</p><ul><li><p>1.页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</p></li><li><p>2.页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</p></li><li><p>3.分页的作业地址空间是一维的.分段的地址空间是二维的.</p><ul><li>意思是分页的话，给个虚拟地址就能找到物理地址（因为页是一样大的，可以算出来），而分段的话，需要给段号和虚拟地址才能算出来物理地址，因为段是不定长的嘛</li></ul></li></ul></li><li><p>段页式</p><ul><li>首先将进程按逻辑分成段<br>再将每段分成页<br>查找需要段号，页号，偏移量</li></ul></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>好处：</li></ul><p>1.可以使有限的内存存放更多进程<br>2.可以使程序比整个内存都大，比如某些游戏<br>3.不需要程序的所有页或段都在内存之中</p><h3 id="操作系统处理"><a href="#操作系统处理" class="headerlink" title="操作系统处理"></a>操作系统处理</h3><ul><li><p>为了防止缺页中断太过频繁，os有很多算法来进行内存调度</p><ul><li><p>读取策略：<br>进程页可以在请求时读取，或预先分页，按簇一次读取多页</p></li><li><p>放置策略：<br>对纯分段系统，读取的段必须匹配内存的空间</p></li><li><p>置换策略：<br>内存装满后，必须决定置换哪些页</p></li><li><p>驻留集管理：<br>换入特定进程时，os决定给他分配多少内存，既可以静态分配，也可以动态地变化</p></li><li><p>清除策略：<br>修改过的进程页可在置换时写出，或使用预约式清楚策略，按簇一次写出多页</p></li><li><p>加载控制：<br>主要关注任何给定时刻驻留在内存中的进程数量</p></li></ul></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h3><ul><li><p>处理器调度类型</p><ul><li>长程调度：<br>决定哪些进程可以进入系统中处理（读入内存）</li><li>中程调度：<br>是交换功能的一部分，就是决定进程的一部分读入内存或换出到磁盘</li><li>短程调度：<br>真正决定当前cpu处理哪个进程（运行态）的调度</li></ul></li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><ul><li><p>粒度</p></li><li><p>进程调度</p></li><li><p>线程调度</p><ul><li><p>负载分配</p><ul><li>先来先服务</li><li>最少线程数优先</li><li>可抢占的最少线程数优先</li></ul></li><li><p>组调度</p></li><li><p>专用处理器分配</p></li><li><p>动态调度</p></li></ul></li><li><p>多核线程调度</p></li></ul><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p>进程优先级</p></li><li><p>决策模式：抢占/非抢占</p></li><li><p>调度策略</p><ul><li>先来先服务</li><li>轮转</li><li>最短进程优先</li><li>最短剩余时间</li><li>最高响应比优先</li><li>反馈法</li><li>公平共享调度（进程组）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;http://icecorn.github.io/file/os.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;




&lt;h1</summary>
      
    
    
    
    <category term="操作系统" scheme="http://icecorn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://icecorn.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="思维导图" scheme="http://icecorn.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|专题-四种类型转换的使用</title>
    <link href="http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-03-10T12:25:30.000Z</published>
    <updated>2022-06-29T13:24:31.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专题-四种类型转换的使用"><a href="#专题-四种类型转换的使用" class="headerlink" title="专题 -四种类型转换的使用"></a>专题 -四种类型转换的使用</h2><h3 id="运行时类型识别（Run-Time-Type-Identification）"><a href="#运行时类型识别（Run-Time-Type-Identification）" class="headerlink" title="运行时类型识别（Run-Time Type Identification）"></a>运行时类型识别（Run-Time Type Identification）</h3><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p><ul><li><code>typeid</code>运算符，用于返回表达式的类型。</li><li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</li></ul><p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p><h3 id="dynamic-cast运算符（The-dynamic-cast-Operator）"><a href="#dynamic-cast运算符（The-dynamic-cast-Operator）" class="headerlink" title="dynamic_cast运算符（The dynamic_cast Operator）"></a>dynamic_cast运算符（The dynamic_cast Operator）</h3><p><code>dynamic_cast</code>运算符的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure><p>其中<em>type</em>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<em>e</em>必须是一个有效指针；在第二种形式中，<em>e</em>必须是一个左值；在第三种形式中，<em>e</em>不能是左值。在所有形式中，<em>e</em>的类型必须符合以下条件之一：</p><ul><li><em>e</em>是<em>type</em>的公有派生类。</li><li><em>e</em>是<em>type</em>的公有基类。</li><li><em>e</em>和<em>type</em>类型相同。</li></ul><p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p><ul><li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use the Derived object to which dp points</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   <span class="comment">// bp points at a Base object</span></span><br><span class="line">    <span class="comment">// use the Base object to which bp points</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<em>typeinfo</em>中）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br><span class="line">        <span class="comment">// use the Derived object to which b referred</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_cast)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle the fact that the cast failed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p><p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p><hr><h3 id="四种强制类型转换"><a href="#四种强制类型转换" class="headerlink" title="四种强制类型转换"></a>四种强制类型转换</h3><p><strong>强制类型转换解决的问题：</strong></p><p>强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成<a href="http://c.biancheng.net/c/80/">指针</a>，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p><p><strong>1) 没有从形式上体现转换功能和风险的不同。</strong></p><p>例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。</p><p><strong>2) 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</strong></p><p><strong>3) 难以在程序中寻找到底什么地方进行了强制类型转换。</strong></p><p>强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。</p><p>如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。</p><p>而用 C++ 的方式，则只需要查找**<code>_cast</code>**字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找<code>reinterpret_cast</code>字符串。</p><p>C++ 强制类型转换运算符的用法如下：</p><p>*<em>强制类型转换运算符 &lt;**要转换到的类型**&gt; (*<em>待转换的表达式*</em>)</em>*</p><p>例如：</p><p>double d = static_cast <double> (3<em>5); //将 3</em>5 的值转换成实数</p><hr><p><strong>下面分别介绍四种强制类型转换运算符。</strong></p><h4 id="const-cast-常量转换"><a href="#const-cast-常量转换" class="headerlink" title="const_cast 常量转换"></a>const_cast 常量转换</h4><p>const_cast 运算符仅用于进行<strong>去除 const 属性的转换</strong>，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。</p><p>将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Inception&quot;</span>;</span><br><span class="line">string&amp; p = <span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);</span><br><span class="line">string* ps = <span class="keyword">const_cast</span> &lt;string*&gt; (&amp;s);  <span class="comment">// &amp;s 的类型是 const string*</span></span><br></pre></td></tr></table></figure><p>const int* p; //p可变,p指向的内容不可变<br>int const* p; //p可变,p指向的内容不可变<br>int* const p; //p不可变,p指向的内容可变</p><p>const修饰函数返回值表示返回值不可改变,多用于返回指针的情形<br>volatile可理解为编译器警告指示字<br>volatile用于告诉编译器必须每次去内存中取变量值<br>volatile主要修饰可能被多个线程访问的变量<br>volatile也可以修饰可能被未知因数更改的变量</p><p>1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；<br>2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；<br>3、const_cast一般用于修改指针。如const char *p形式；</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211182748443.png" alt="image-20211211182748443"></p><p>未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 <em>c_val , use_val , ptr_val</em> 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的<em>c_val</em> 会被改变.也有可能编译器对这类行为直接 <em>error</em> 或 <em>warning</em>.</p><h4 id="static-cast-静态类型转换"><a href="#static-cast-静态类型转换" class="headerlink" title="static_cast 静态类型转换"></a><strong>static_cast 静态类型转换</strong></h4><p>1、static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。<br>2、用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。<br>3、用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。                               4、static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)                                5、在c++ primer 中说道：c++ 的任何的隐式转换都是使用 <em>static_cast</em> 来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">char</span>*() &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;New Dragon Inn&quot;</span>;</span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (<span class="number">3.14</span>);  <span class="comment">// n 的值变为 3</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (a);  <span class="comment">//调用 a.operator int，n 的值变为 1</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (a);  <span class="comment">//调用 a.operator char*，p 的值变为 NULL</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (p);  <span class="comment">//编译错误，static_cast不能将指针转换成整型</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (n);  <span class="comment">//编译错误，static_cast 不能将整型转换成指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dynamic-cast-动态类型转换"><a href="#dynamic-cast-动态类型转换" class="headerlink" title="dynamic_cast 动态类型转换"></a>dynamic_cast 动态类型转换</h4><p>用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p><p>dynamic_cast 是通过“<strong>运行时类型检查</strong>”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;  <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived* pd;</span><br><span class="line">    pd = <span class="keyword">reinterpret_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe reinterpret_cast&quot;</span> &lt;&lt; endl; <span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast1&quot;</span> &lt;&lt; endl;  <span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;d);  <span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//此处 pd 不会为 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast2&quot;</span> &lt;&lt; endl;  <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>unsafe dynamic_cast1</p><p>第 20 行，通过判断 pd 的值是否为 NULL，就能知道第 19 行进行的转换是否是安全的。第 23 行同理。</p><p>如果上面的程序中出现了下面的语句：</p><p>Derived &amp; r = dynamic_cast &lt;Derived &amp;&gt; (b);</p><p>那该如何判断该转换是否安全呢？不存在空引用，因此不能通过返回值来判断转换是否安全。C++ 的解决办法是：dynamic_cast 在进行引用的强制转换时，如果发现转换不安全，就会拋出一个异常，通过处理异常，就能发现不安全的转换。</p><hr><p><em>dynamic_cast</em>强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211183405628.png" alt="image-20211211183405628"></p><p>对于<em>从子类到基类的指针转换</em> ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果，</p><p>而<em>从基类到子类的转换</em> , dynamic_cast 在转换时也没有报错,但是输出给 <em>base2sub</em> 是一个 <em>nullptr</em> ,说明dynami_cast 在程序运行时对类型转换对<em>“运行期类型信息”（Runtime type information，RTTI）</em>进行了检查. </p><p>这个检查主要来自<em>虚函数(virtual function)</em> 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。*因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数</p><h4 id="reinterpret-cast-重新解释（类型的比特位）"><a href="#reinterpret-cast-重新解释（类型的比特位）" class="headerlink" title="reinterpret_cast 重新解释（类型的比特位）"></a><strong>reinterpret_cast 重新解释（类型的比特位）</strong></h4><p>reinterpret_cast 用于进行各种不同类型的<strong>指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换</strong>。转换时，执行的是<strong>逐个比特复制</strong>的操作。</p><p>这种转换提供了很强的灵活性，但<strong>转换的安全性只能由程序员的细心来保证了</strong>。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">i</span>(n),<span class="built_in">j</span>(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> &amp;r = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a（即a的首地址）</span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; endl;  <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt; (&amp;n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;  <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="type">int</span>,<span class="type">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="built_in">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>200, 100<br>400<br>5678abcd</p><p>第 19 行的代码不安全，<strong>因为在编译器看来，pa-&gt;j 的存放位置就是 n 后面的 4 个字节</strong>。 本条语句会向这 4 个字节中写入 500。**但这 4 个字节不知道是用来存放什么的（*<em>因为i和j不一定连续存储*<em>），贸然向其中写入可能会导致程序错误甚至崩溃。</em></em></p><p>上面程序中的各种转换都没有实际意义，只是为了演示 reinteipret_cast 的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。</p><p><strong>reinterpret_cast体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。</strong></p><p>提供下IBM C++ 对 reinterpret_cast 推荐使用的地方<br>A pointer to any integral type large enough to hold it （指针转向足够大的整数类型）<br>A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针）<br>A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针）<br>A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针）<br>A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专题-四种类型转换的使用&quot;&gt;&lt;a href=&quot;#专题-四种类型转换的使用&quot; class=&quot;headerlink&quot; title=&quot;专题 -四种类型转换的使用&quot;&gt;&lt;/a&gt;专题 -四种类型转换的使用&lt;/h2&gt;&lt;h3 id=&quot;运行时类型识别（Run-Time-Type-I</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十五章-面向对象程序设计</title>
    <link href="http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-03-10T12:25:30.000Z</published>
    <updated>2022-06-29T13:21:19.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</p><p>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</p><p><strong>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</strong></p><p>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;         <span class="comment">// object of base type</span></span><br><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line">Quote *p = &amp;item;   <span class="comment">// p points to a Quote object</span></span><br><span class="line">p = &amp;bulk;          <span class="comment">// p points to the Quote part of bulk</span></span><br><span class="line">Quote &amp;r = bulk;    <span class="comment">// r bound to the Quote part of bulk</span></span><br></pre></td></tr></table></figure><p>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, </span><br><span class="line">            std::<span class="type">size_t</span> qty, <span class="type">double</span> disc) :</span><br><span class="line">    <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br></pre></td></tr></table></figure><p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p><p><strong>派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。</strong></p><p>派生类可以访问基类的公有成员和受保护成员。</p><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</p><p>已经完整定义的类才能被用作基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> D1 &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p><em>Base</em>是<em>D1</em>的直接基类（direct base），是<em>D2</em>的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。</p><p>C++11中，在类名后面添加<code>final</code>关键字可以禁止其他类继承它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span> &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// NoDerived can&#x27;t be a base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* */</span> &#125;;</span><br><span class="line"><span class="comment">// Last is final; we cannot inherit from Last</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Last</span> <span class="keyword">final</span> : Base &#123; <span class="comment">/* */</span> &#125;;  <span class="comment">// Last can&#x27;t be a base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> : NoDerived &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// error: NoDerived is final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad2</span> : Last &#123; <span class="comment">/* */</span> &#125;;        <span class="comment">// error: Last is final</span></span><br></pre></td></tr></table></figure><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</p><p>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</p><p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p><p>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;   <span class="comment">// error: can&#x27;t convert base to derived</span></span><br><span class="line">Bulk_quote&amp; bulkRef = base;  <span class="comment">// error: can&#x27;t convert base to derived</span></span><br></pre></td></tr></table></figure><p>如果在基类中含有一个或多个虚函数，可以使用<code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。</p><p>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作。</p><p>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</p><p>派生类到基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;   <span class="comment">// uses the Quote::Quote(const Quote&amp;) constructor</span></span><br><span class="line">item = bulk;        <span class="comment">// calls Quote::operator=(const Quote&amp;)</span></span><br></pre></td></tr></table></figure><p>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</p><h3 id="虚函数（Virtual-Functions）"><a href="#虚函数（Virtual-Functions）" class="headerlink" title="虚函数（Virtual Functions）"></a>虚函数（Virtual Functions）</h3><p>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</p><p>在派生类中覆盖某个虚函数时，可以再次使用<code>virtual</code>关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</p><p>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p><p>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</p><p>C++11允许派生类使用<code>override</code>关键字显式地注明虚函数。如果<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。<code>override</code>位于函数参数列表之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;    <span class="comment">// ok: f1 matches f1 in the base</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;      <span class="comment">// error: B has no f2(int) function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: f3 not virtual</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: B doesn&#x27;t have a function named f4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与禁止类继承类似，函数也可以通过添加<code>final</code>关键字来禁止覆盖操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;   <span class="comment">// subsequent classes can&#x27;t override f1(int)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>final</code>和<code>override</code>关键字出现在形参列表（包括任何<code>const</code>或引用修饰符）以及尾置返回类型之后。</p><p><strong>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</strong></p><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</p><p>使用作用域运算符<code>::</code>可以强制执行虚函数的某个版本，不进行动态绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calls the version from the base class regardless of the dynamic type of baseP</span></span><br><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</p><p>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</p><hr><h3 id="抽象基类（Abstract-Base-Classes）"><a href="#抽象基类（Abstract-Base-Classes）" class="headerlink" title="抽象基类（Abstract Base Classes）"></a>抽象基类（Abstract Base Classes）</h3><p>在类内部虚函数声明语句的分号前添加<code>=0</code>可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</p><p>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</p><p><strong>不能创建抽象基类的对象。</strong></p><p>派生类构造函数只初始化它的直接基类。</p><p>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</p><hr><h3 id="关于多继承和虚继承"><a href="#关于多继承和虚继承" class="headerlink" title="关于多继承和虚继承"></a>关于多继承和虚继承</h3><p>多继承很简单就是一个子类可以继承多个父类，且对于一个子类对象，它里面其实包含每个父类的对象各一个，那么怎么协调好变量和函数的继承关系，理解记忆就好了，关键是不产生冲突</p><p>虚继承是为了解决菱形继承出现的，因为如果不是菱形继承，一个子类对象就会有两个一样的爷爷类的对象，这是不对的，而有了虚继承，就是让一个子对象只拥有一个爷爷类对象，不会产生冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十五章-面向对象程序设计&quot;&gt;&lt;a href=&quot;#第十五章-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;第十五章 面向对象程序设计&quot;&gt;&lt;/a&gt;第十五章 面向对象程序设计&lt;/h2&gt;&lt;h3 id=&quot;基类和派生类&quot;&gt;&lt;a href=&quot;#基类和</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十四章 重载运算与类型转换</title>
    <link href="http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-03-08T12:25:30.000Z</published>
    <updated>2022-06-29T13:33:20.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="headerlink" title="第14章 重载运算与类型转换"></a>第14章 重载运算与类型转换</h1><h2 id="基本概念（Basic-Concepts）"><a href="#基本概念（Basic-Concepts）" class="headerlink" title="基本概念（Basic Concepts）"></a>基本概念（Basic Concepts）</h2><p>重载的运算符是具有特殊名字的函数，它们的名字由关键字<code>operator</code>和其后要定义的运算符号组成。</p><p>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p><p>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的<code>this</code>指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</p><p>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</p><p>只能重载大多数已有的运算符，无权声明新的运算符号。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-1.png" alt="14-1"></p><p>重载运算符的优先级和结合律与对应的内置运算符一致。</p><p>可以像调用普通函数一样直接调用运算符函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent calls to a nonmember operator function</span></span><br><span class="line">data1 + data2;              <span class="comment">// normal expression</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);    <span class="comment">// equivalent function call</span></span><br><span class="line">data1 += data2;             <span class="comment">// expression-based &#x27;&#x27;call&#x27;&#x27;</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);    <span class="comment">// equivalent call to a member operator function</span></span><br></pre></td></tr></table></figure><p>通常情况下，不应该重载逗号<code>,</code>、取地址<code>&amp;</code>、逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符。</p><p>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</p><p>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</p><p>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;     <span class="comment">// ok: we can add a const char* to a string</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s;    <span class="comment">// would be an error if + were a member of string</span></span><br></pre></td></tr></table></figure><p>如何选择将运算符定义为成员函数还是普通函数：</p><ul><li>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>和成员访问箭头<code>-&gt;</code>运算符必须是成员函数。</li><li>复合赋值运算符一般是成员函数，但并非必须。</li><li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li><li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li></ul><h2 id="输入和输出运算符（Input-and-Output-Operators）"><a href="#输入和输出运算符（Input-and-Output-Operators）" class="headerlink" title="输入和输出运算符（Input and Output Operators）"></a>输入和输出运算符（Input and Output Operators）</h2><h3 id="重载输出运算符-lt-lt-（Overloading-the-Output-Operator-lt-lt-）"><a href="#重载输出运算符-lt-lt-（Overloading-the-Output-Operator-lt-lt-）" class="headerlink" title="重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）"></a>重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）</h3><p>通常情况下，输出运算符的第一个形参是<code>ostream</code>类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的<code>ostream</code>形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出运算符应该尽量减少格式化操作。</p><p>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</p><h3 id="重载输入运算符-gt-gt-（Overloading-the-Input-Operator-gt-gt-）"><a href="#重载输入运算符-gt-gt-（Overloading-the-Input-Operator-gt-gt-）" class="headerlink" title="重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）"></a>重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）</h3><p>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> price;   <span class="comment">// no need to initialize; we&#x27;ll read into price before we use it</span></span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span> (is)    <span class="comment">// check that the inputs succeeded</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item = <span class="built_in">Sales_data</span>();    <span class="comment">// input failed: give the object the default state</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入运算符必须处理输入失败的情况，而输出运算符不需要。</p><p>以下情况可能导致读取操作失败：</p><ul><li>读取了错误类型的数据。</li><li>读取操作到达文件末尾。</li><li>遇到输入流的其他错误。</li></ul><p>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</p><p>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置<code>failbit</code>状态。<code>eofbit</code>、<code>badbit</code>等错误最好由IO标准库自己标示。</p><h2 id="算术和关系运算符（Arithmetic-and-Relational-Operators）"><a href="#算术和关系运算符（Arithmetic-and-Relational-Operators）" class="headerlink" title="算术和关系运算符（Arithmetic and Relational Operators）"></a>算术和关系运算符（Arithmetic and Relational Operators）</h2><p>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</p><p>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的<code>const</code>类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs;   <span class="comment">// copy data members from lhs into sum</span></span><br><span class="line">    sum += rhs;     <span class="comment">// add rhs into sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。</p><h3 id="相等运算符（Equality-Operators）"><a href="#相等运算符（Equality-Operators）" class="headerlink" title="相等运算符（Equality Operators）"></a>相等运算符（Equality Operators）</h3><p>相等运算符设计准则：</p><ul><li><p>如果类在逻辑上有相等性的含义，则应该定义<code>operator==</code>而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</p></li><li><p>通常情况下，<code>operator==</code>应该具有传递性。</p></li><li><p>如果类定义了<code>operator==</code>，则也应该定义<code>operator!=</code>。</p></li><li><p><code>operator==</code>和<code>operator!=</code>中的一个应该把具体工作委托给另一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">        lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">        lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="关系运算符（Relational-Operators）"><a href="#关系运算符（Relational-Operators）" class="headerlink" title="关系运算符（Relational Operators）"></a>关系运算符（Relational Operators）</h3><p>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较实用。</p><p>关系运算符设计准则：</p><ul><li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li><li>如果类定义了<code>operator==</code>，则关系运算符的定义应该与<code>operator==</code>保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li><li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义<code>operator&lt;</code>。</li></ul><h2 id="赋值运算符（Assignment-Operators）"><a href="#赋值运算符（Assignment-Operators）" class="headerlink" title="赋值运算符（Assignment Operators）"></a>赋值运算符（Assignment Operators）</h2><p>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// alloc_n_copy allocates space and copies elements from the given range</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();     <span class="comment">// destroy the elements in this object and free the space</span></span><br><span class="line">    elements = data.first;      <span class="comment">// update data members to point to the new</span></span><br><span class="line">    space</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member binary operator: left-hand operand is bound to the implicit this pointer</span></span><br><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标运算符（Subscript-Operator）"><a href="#下标运算符（Subscript-Operator）" class="headerlink" title="下标运算符（Subscript Operator）"></a>下标运算符（Subscript Operator）</h2><p>下标运算符必须定义为成员函数。</p><p>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *elements;  <span class="comment">// pointer to the first element in the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递增和递减运算符（Increment-and-Decrement-Operators）"><a href="#递增和递减运算符（Increment-and-Decrement-Operators）" class="headerlink" title="递增和递减运算符（Increment and Decrement Operators）"></a>递增和递减运算符（Increment and Decrement Operators）</h2><p>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</p><p>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix: return a reference to the incremented/decremented object</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++curr;     <span class="comment">// advance the current state</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置递增或递减运算符接受一个额外的（不被使用）<code>int</code>类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// increment and decrement</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();    <span class="comment">// prefix operators</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>);  <span class="comment">// postfix operators</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的<code>const</code>类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;    <span class="comment">// save the current value</span></span><br><span class="line">    ++*<span class="keyword">this</span>;      <span class="comment">// advance one element; prefix ++ checks the increment</span></span><br><span class="line">    <span class="keyword">return</span> ret;   <span class="comment">// return the saved state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;   <span class="comment">// p points to the vector inside a1</span></span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);    <span class="comment">// call postfix operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();     <span class="comment">// call prefix operator++</span></span><br></pre></td></tr></table></figure><h2 id="成员访问运算符（Member-Access-Operators）"><a href="#成员访问运算符（Member-Access-Operators）" class="headerlink" title="成员访问运算符（Member Access Operators）"></a>成员访问运算符（Member Access Operators）</h2><p>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</p><p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];   <span class="comment">// (*p) is the vector to which this object points</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;   <span class="comment">// delegate the real work to the dereference operator</span></span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于形如<code>point-&gt;mem</code>的表达式来说，<em>point</em>必须是指向类对象的指针或者是一个重载了<code>operator-&gt;</code>的类的对象。<em>point</em>类型不同，<code>point-&gt;mem</code>的含义也不同。</p><ul><li>如果<em>point</em>是指针，则调用内置箭头运算符，表达式等价于<code>(*point).mem</code>。</li><li>如果<em>point</em>是重载了<code>operator-&gt;</code>的类的对象，则使用<code>point.operator-&gt;()</code>的结果来获取<em>mem</em>，表达式等价于<code>(point.operator-&gt;())-&gt;mem</code>。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li></ul><h2 id="函数调用运算符（Function-Call-Operator）"><a href="#函数调用运算符（Function-Call-Operator）" class="headerlink" title="函数调用运算符（Function-Call Operator）"></a>函数调用运算符（Function-Call Operator）</h2><p>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">        <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;   <span class="comment">// stream on which to write</span></span><br><span class="line">    <span class="type">char</span> sep;      <span class="comment">// character to print after each output</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer;  <span class="comment">// uses the defaults; prints to cout</span></span><br><span class="line"><span class="built_in">printer</span>(s);     <span class="comment">// prints s followed by a space on cout</span></span><br></pre></td></tr></table></figure><p>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="lambda是函数对象（Lambdas-Are-Function-Objects）"><a href="#lambda是函数对象（Lambdas-Are-Function-Objects）" class="headerlink" title="lambda是函数对象（Lambdas Are Function Objects）"></a>lambda是函数对象（Lambdas Are Function Objects）</h3><p>编写一个<code>lambda</code>后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort words by size, but maintain alphabetical order for words of the same size</span></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// acts like an unnamed object of a class that would look something like</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>默认不能改变它捕获的变量。因此在默认情况下，由<code>lambda</code>产生的类中的函数调用运算符是一个<code>const</code>成员函数。如果<code>lambda</code>被声明为可变的，则调用运算符就不再是<code>const</code>函数了。</p><p><code>lambda</code>通过引用捕获变量时，由程序负责确保<code>lambda</code>执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在<code>lambda</code>产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到<code>lambda</code>中，此时<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to the first element whose size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [sz](<span class="type">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// would generate a class that looks something like</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(<span class="type">size_t</span> n): <span class="built_in">sz</span>(n) &#123; &#125;   <span class="comment">// parameter for each captured variable</span></span><br><span class="line">    <span class="comment">// call operator with the same return type, parameters, and body as the lambda</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> sz;   <span class="comment">// a data member for each variable captured by value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数则通常要视捕获的变量类型而定。</p><h3 id="标准库定义的函数对象（Library-Defined-Function-Objects）"><a href="#标准库定义的函数对象（Library-Defined-Function-Objects）" class="headerlink" title="标准库定义的函数对象（Library-Defined Function Objects）"></a>标准库定义的函数对象（Library-Defined Function Objects）</h3><p>标准库在头文件<em>functional</em>中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-2.png" alt="14-2"></p><p>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string *&gt; nameTable;    <span class="comment">// vector of pointers</span></span><br><span class="line"><span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(),</span><br><span class="line">        [](string *a, string *b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="comment">// ok: library guarantees that less on pointer types is well defined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure><h3 id="可调用对象与function（Callable-Objects-and-function）"><a href="#可调用对象与function（Callable-Objects-and-function）" class="headerlink" title="可调用对象与function（Callable Objects and function）"></a>可调用对象与function（Callable Objects and function）</h3><p>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p><p>标准库<code>function</code>类型是一个模板，定义在头文件<em>functional</em>中，用来表示对象的调用形式。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-3.png" alt="14-3"></p><p>创建一个具体的<code>function</code>类型时必须提供其所表示的对象的调用形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ordinary function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// function-object class</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator, <span class="type">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;      <span class="comment">// function pointer</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = <span class="built_in">div</span>();    <span class="comment">// object of a function-object class</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;;  <span class="comment">// lambda</span></span><br><span class="line">                                   </span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 6</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 8</span></span><br></pre></td></tr></table></figure><p>不能直接将重载函数的名字存入<code>function</code>类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用<code>lambda</code>或者存储函数指针而非函数名字。</p><p>C++11新标准库中的<code>function</code>类与旧版本中的<code>unary_function</code>和<code>binary_function</code>没有关系，后两个类已经被<code>bind</code>函数代替。</p><h2 id="重载、类型转换与运算符（Overloading，Conversions，and-Operators）"><a href="#重载、类型转换与运算符（Overloading，Conversions，and-Operators）" class="headerlink" title="重载、类型转换与运算符（Overloading，Conversions，and Operators）"></a>重载、类型转换与运算符（Overloading，Conversions，and Operators）</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。</p><h3 id="类型转换运算符（Conversion-Operators）"><a href="#类型转换运算符（Conversion-Operators）" class="headerlink" title="类型转换运算符（Conversion Operators）"></a>类型转换运算符（Conversion Operators）</h3><p>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>类型转换运算符可以面向除了<code>void</code>以外的任意类型（该类型要能作为函数的返回类型）进行定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the double argument is converted to int using the built-in conversion</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;     <span class="comment">// calls the SmallInt(int) constructor</span></span><br><span class="line"><span class="comment">// the SmallInt conversion operator converts si to int;</span></span><br><span class="line">si + <span class="number">3.14</span>;     <span class="comment">// that int is converted to double using the built-in conversion</span></span><br></pre></td></tr></table></figure><p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p><p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// the compiler won&#x27;t automatically apply this conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;    <span class="comment">// ok: the SmallInt constructor is not explicit</span></span><br><span class="line">si + <span class="number">3</span>;     <span class="comment">// error: implicit is conversion required, but operator int is explicit</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si) + <span class="number">3</span>;    <span class="comment">// ok: explicitly request the conversion</span></span><br></pre></td></tr></table></figure><p>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</p><ul><li><code>if</code>、<code>while</code>、<code>do-while</code>语句的条件部分。</li><li><code>for</code>语句头的条件表达式。</li><li>条件运算符<code>? :</code>的条件表达式。</li><li>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</li></ul><p>类类型向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般被定义为显式的。</p><h3 id="避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）"><a href="#避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）" class="headerlink" title="避免有二义性的类型转换（Avoiding Ambiguous Conversions）"></a>避免有二义性的类型转换（Avoiding Ambiguous Conversions）</h3><p>在两种情况下可能产生多重转换路径：</p><ul><li><p><em>A</em>类定义了一个接受<em>B</em>类对象的转换构造函数，同时<em>B</em>类定义了一个转换目标是<em>A</em>类的类型转换运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usually a bad idea to have mutual conversions between two class types</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp;); <span class="comment">// converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// also converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);    <span class="comment">// error ambiguous: f(B::operator A())</span></span><br><span class="line">               <span class="comment">// or f(A::A(const B&amp;))</span></span><br></pre></td></tr></table></figure></li><li><p>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);     <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);      <span class="comment">// conversions from arithmetic types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// conversions to arithmetic types</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);    <span class="comment">// error ambiguous: f(A::operator int())</span></span><br><span class="line">          <span class="comment">// or f(A::operator double())</span></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;   <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span></span><br></pre></td></tr></table></figure></li></ul><p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());    <span class="comment">// ok: use B&#x27;s conversion operator</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));     <span class="comment">// ok: use A&#x27;s constructor</span></span><br></pre></td></tr></table></figure><p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</p><p>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</p><p>如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。</p><p>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="comment">// error ambiguous: two different user-defined conversions could be used</span></span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>);    <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span></span><br></pre></td></tr></table></figure><h3 id="函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）"><a href="#函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）" class="headerlink" title="函数匹配与重载运算符（Function Matching and Overloaded Operators）"></a>函数匹配与重载运算符（Function Matching and Overloaded Operators）</h3><p>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="type">const</span> SmallInt&amp;, <span class="type">const</span> SmallInt&amp;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> = <span class="number">0</span>);    <span class="comment">// conversion from int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;    <span class="comment">// conversion to int</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;    <span class="comment">// uses overloaded operator+</span></span><br><span class="line"><span class="type">int</span> i = s3 + <span class="number">0</span>;    <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure><p>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第14章-重载运算与类型转换&quot;&gt;&lt;a href=&quot;#第14章-重载运算与类型转换&quot; class=&quot;headerlink&quot; title=&quot;第14章 重载运算与类型转换&quot;&gt;&lt;/a&gt;第14章 重载运算与类型转换&lt;/h1&gt;&lt;h2 id=&quot;基本概念（Basic-Concep</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十三章-拷贝控制</title>
    <link href="http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</id>
    <published>2022-03-07T12:25:30.000Z</published>
    <updated>2022-06-29T13:17:34.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h2><p>主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。</p><p><strong>关于拷贝不在赘述，主要要记得当一个类里有指针类型时，要注意深拷贝和浅拷贝的问题，比如Myclass b = a；就是如果是浅拷贝的话，b中拷贝过来的指针和a中原来的指针指向的是同一块位置，那么就要考虑要析构b的时候，a对象是否还再用，如果还在用就不能析构指针指向这块内存，防止出现a对象这个指针指向未定义的情况发生。如果是深拷贝的话，就是说a对象和b对象的指针指向的东西也不是在一块内存上，所以可以正常析构。具体要深拷贝还是浅拷贝还是要看业务类型来实现处理。</strong></p><h4 id="对象移动（Moving-Objects）"><a href="#对象移动（Moving-Objects）" class="headerlink" title="对象移动（Moving Objects）"></a>对象移动（Moving Objects）</h4><p>某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。</p><p>在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p><p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。IO类和<code>unique_ptr</code>类可以移动但不能拷贝。</p><h4 id="右值引用（Rvalue-Reference）"><a href="#右值引用（Rvalue-Reference）" class="headerlink" title="右值引用（Rvalue Reference）"></a>右值引用（Rvalue Reference）</h4><p>为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过<code>&amp;&amp;</code>来获得右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;         <span class="comment">// ok: r refers to i</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;       <span class="comment">// error: cannot bind an rvalue reference to an</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;   <span class="comment">// error: i * 42 is an rvalue</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>;    <span class="comment">// ok: we can bind a reference to const to an rvalue</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;        <span class="comment">// ok: bind rr2 to the result of the multiplication</span></span><br></pre></td></tr></table></figure><p>右值引用只能绑定到<strong>即将被销毁，并且没有其他用户的临时对象</strong>上。使用右值引用的代码可以自由地接管所引用对象的资源。</p><p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     <span class="comment">// ok: literals are rvalues</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">// error: the expression rr1 is an lvalue!</span></span><br></pre></td></tr></table></figure><p>调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件<em>utility</em>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure><p>调用<code>move</code>函数的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p><hr><h4 id="移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）"><a href="#移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）" class="headerlink" title="移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）"></a>移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）</h4><p>移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。</p><p>除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。</p><p>在函数的形参列表后面添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常。</p><p>对于构造函数，<code>noexcept</code>位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定<code>noexcept</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// move constructor</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/* member initializers */</span></span><br><span class="line">&#123; <span class="comment">/* constructor body */</span> &#125;</span><br></pre></td></tr></table></figure><p>标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。</p><p>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p><p>在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// direct test for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();     <span class="comment">// free existing elements</span></span><br><span class="line">        elements = rhs.elements;    <span class="comment">// take over resources from rhs</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// leave rhs in a destructible state</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当一个类没有定义任何拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the compiler will synthesize the move operations for X and hasX</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;   <span class="comment">// built-in types can be moved</span></span><br><span class="line">    std::string s;   <span class="comment">// string defines its own move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span></span><br><span class="line">&#123;</span><br><span class="line">    X mem; <span class="comment">// X has synthesized move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);         <span class="comment">// uses the synthesized move constructor</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);   <span class="comment">// uses the synthesized move constructor</span></span><br></pre></td></tr></table></figure><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。</p><p>如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用<code>move</code>函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// other members, but Foo does not define a move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;   <span class="comment">// copy constructor; x is an lvalue</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>;    <span class="comment">// copy constructor, because there is no move constructor</span></span><br></pre></td></tr></table></figure><p>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assignment operator is both the move- and copy-assignment operator</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hp = hp2;   <span class="comment">// hp2 is an lvalue; copy constructor used to copy hp2</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);    <span class="comment">// move constructor moves hp2</span></span><br></pre></td></tr></table></figure><p>建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p><p>移动赋值运算符可以直接检查自赋值情况。</p><p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。</p><p>调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p><p>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用<code>move</code>操作。</p><h4 id="右值引用和成员函数（Rvalue-References-and-Member-Functions）"><a href="#右值引用和成员函数（Rvalue-References-and-Member-Functions）" class="headerlink" title="右值引用和成员函数（Rvalue References and Member Functions）"></a>右值引用和成员函数（Rvalue References and Member Functions）</h4><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>参数，另一个版本接受一个<code>T&amp;&amp;</code>参数（<em>T</em>为类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;   <span class="comment">// copy: binds to any kind of X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// move: binds only to modifiable rvalues of type X</span></span><br></pre></td></tr></table></figure><p>有时可以对右值赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">s1 + s2 = <span class="string">&quot;wow!&quot;</span>;</span><br></pre></td></tr></table></figure><p>在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即<code>this</code>指向的对象）必须是一个左值。</p><p>在非<code>static</code>成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定<code>this</code>的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示<code>this</code>可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &amp;; <span class="comment">// may assign only to modifiable lvalues</span></span><br><span class="line">    <span class="comment">// other members of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;rhs) &amp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do whatever is needed to assign rhs to this object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个非<code>static</code>成员函数可以同时使用<code>const</code>和引用限定符，此时引用限定符跟在<code>const</code>限定符之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="type">const</span></span>;      <span class="comment">// error: const qualifier must come first</span></span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// ok: const qualifier comes first</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用限定符也可以区分成员函数的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;        <span class="comment">// may run on modifiable rvalues</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// may run on any kind of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>();   <span class="comment">// retVal() is an rvalue, calls Foo::sorted() &amp;&amp;</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>();   <span class="comment">// retFoo() is an lvalue, calls Foo::sorted() const &amp;</span></span><br></pre></td></tr></table></figure><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// error: must have reference qualifier</span></span><br><span class="line">    <span class="comment">// Comp is type alias for the function type</span></span><br><span class="line">    <span class="comment">// that can be used to compare int values</span></span><br><span class="line">    <span class="keyword">using</span> Comp = <span class="built_in">bool</span>(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span></span>;  <span class="comment">// ok: different parameter list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>理解move</strong></p><p>这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。</p><p><strong>注意：使用move不会释放源对象，所以一定要确保源对象不会再使用了，才能用move</strong></p><p>详细帖子：</p><p><a href="https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c+++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c%2B%2B+%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十三章-拷贝控制&quot;&gt;&lt;a href=&quot;#第十三章-拷贝控制&quot; class=&quot;headerlink&quot; title=&quot;第十三章 拷贝控制&quot;&gt;&lt;/a&gt;第十三章 拷贝控制&lt;/h2&gt;&lt;p&gt;主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十二章 动态内存</title>
    <link href="http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</id>
    <published>2022-03-05T12:25:30.000Z</published>
    <updated>2022-06-29T13:22:36.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h2><p>程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。</p><h3 id="动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）"><a href="#动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）" class="headerlink" title="动态内存与智能指针（Dynamic Memory and Smart Pointers）"></a>动态内存与智能指针（Dynamic Memory and Smart Pointers）</h3><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p><p>新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<em>memory</em>中。</p><h4 id="shared-ptr类（The-shared-ptr-Class）"><a href="#shared-ptr类（The-shared-ptr-Class）" class="headerlink" title="shared_ptr类（The shared_ptr Class）"></a>shared_ptr类（The shared_ptr Class）</h4><p>智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;      <span class="comment">// shared_ptr that can point at a string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;   <span class="comment">// shared_ptr that can point at a list of ints</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211518263.png" alt="image-20220629211518263"></p><p><code>shared_ptr</code>独有的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211141442645.png" alt="image-20211211141442645"></p><p><code>make_shared</code>函数（定义在头文件<em>memory</em>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr that points to an int with value 42</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 points to a string with value 9999999999</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// p5 points to an int that is value initialized</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// object to which p points has one user</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  <span class="comment">// p and q point to the same object</span></span><br><span class="line">            <span class="comment">// object to which p and q point has two users</span></span><br></pre></td></tr></table></figure><p>每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// int to which r points has one user</span></span><br><span class="line">r = q;  <span class="comment">// assign to r, making it point to a different address</span></span><br><span class="line">        <span class="comment">// increase the use count for the object to which q points</span></span><br><span class="line">        <span class="comment">// reduce the use count of the object to which r had pointed</span></span><br><span class="line">        <span class="comment">// the object r had pointed to has no users; that object is automatically freed</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数会销毁对象并释放空间。</p><p>如果将<code>shared_ptr</code>存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用<code>erase</code>删除不再需要的元素。</p><p>程序使用动态内存通常出于以下三种原因之一：</p><ul><li>不确定需要使用多少对象。</li><li>不确定所需对象的准确类型。</li><li>需要在多个对象间共享数据。</li></ul><h4 id="shared-ptr和new结合使用（Using-shared-ptrs-with-new）"><a href="#shared-ptr和new结合使用（Using-shared-ptrs-with-new）" class="headerlink" title="shared_ptr和new结合使用（Using shared_ptrs with new）"></a>shared_ptr和new结合使用（Using shared_ptrs with new）</h4><p>可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">// error: must use direct initialization</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;     <span class="comment">// ok: uses direct initialization</span></span><br></pre></td></tr></table></figure><p>默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211535799.png" alt="image-20220629211535799"></p><p>不要混合使用内置指针和智能指针。当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr is created and initialized when process is called</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use ptr</span></span><br><span class="line">&#125;   <span class="comment">// ptr goes out of scope and is destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">// dangerous: x is a plain pointer, not a smart pointer</span></span><br><span class="line"><span class="built_in">process</span>(x);     <span class="comment">// error: cannot convert int* to shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));    <span class="comment">// legal, but the memory will be deleted!</span></span><br><span class="line"><span class="type">int</span> j = *x;     <span class="comment">// undefined: x is a dangling pointer!</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;   <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="built_in">process</span>(p);     <span class="comment">// copying p increments its count; in process the reference count is 2</span></span><br><span class="line"><span class="type">int</span> i = *p;     <span class="comment">// ok: reference count is 1</span></span><br></pre></td></tr></table></figure><p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p><p>不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();   <span class="comment">// ok: but don&#x27;t use q in any way that might delete its pointer</span></span><br><span class="line">&#123;   <span class="comment">// new block</span></span><br><span class="line">    <span class="comment">// undefined: two independent shared_ptrs point to the same memory</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(q);</span><br><span class="line">&#125; <span class="comment">// block ends, q is destroyed, and the memory to which q points is freed</span></span><br><span class="line"><span class="type">int</span> foo = *p;   <span class="comment">// undefined; the memory to which p points was freed</span></span><br></pre></td></tr></table></figure><p>可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));   <span class="comment">// we aren&#x27;t alone; allocate a new copy</span></span><br><span class="line">*p += newVal;   <span class="comment">// now that we know we&#x27;re the only pointer, okay to change this object</span></span><br></pre></td></tr></table></figure><h4 id="智能指针和异常（Smart-Pointers-and-Exceptions）"><a href="#智能指针和异常（Smart-Pointers-and-Exceptions）" class="headerlink" title="智能指针和异常（Smart Pointers and Exceptions）"></a>智能指针和异常（Smart Pointers and Exceptions）</h4><p>如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ip = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);    <span class="comment">// dynamically allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">    <span class="keyword">delete</span> ip;     <span class="comment">// free the memory before exiting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">&#125; <span class="comment">// shared_ptr freed automatically when the function ends</span></span><br></pre></td></tr></table></figure><p>默认情况下<code>shared_ptr</code>假定其指向动态内存，使用<code>delete</code>释放对象。创建<code>shared_ptr</code>时可以传递一个（可选）指向删除函数的指针参数，用来代替<code>delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;    <span class="comment">// represents what we are connecting to</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;     <span class="comment">// information needed to use the connection</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;   <span class="comment">// open the connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;    <span class="comment">// close the given connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other parameters */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// use the connection</span></span><br><span class="line">    <span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针规范：</p><ul><li>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</li><li>不释放<code>get</code>返回的指针。</li><li>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</li><li>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</li><li>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</li></ul><hr><h4 id="深度理解智能指针"><a href="#深度理解智能指针" class="headerlink" title="深度理解智能指针"></a>深度理解智能指针</h4><p><strong>1.智能指针的作用</strong></p><p>​    C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><p>理解智能指针需要从下面三个层次：</p><ol><li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同，在Java里面下列代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">　　<span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>   你当然知道，这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a;</span><br><span class="line">Animal b = a;</span><br></pre></td></tr></table></figure><p>   这里却是就是生成了两个对象。</p><p>2.智能指针的实质</p><p>   前面已经说过了，<strong>智能指针是一个类对象（类似迭代器，其实也是用类对象来模拟指针的作用）</strong>，这样在被调函数执行完，程序过期时，对象将会被删除（对象的名字保存在栈变量中），这样不仅对象会被删除，它指向的内存也会被删除的。</p><p>智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、auto_ptr</p><p>建议：</p><p>​      1-每种指针都有不同的使用范围，unique_ptr指针优于其它两种类型，除非对象需要共享时用shared_ptr。</p><p>​      2- 建议– 如果你没有打算在多个线程之间来共享资源的话，那么就请使用unique_ptr。</p><p>​      3 -建议- 使用make_shared而不是裸指针来初始化共享指针。</p><p>​      4 -建议 – 在设计类的时候，当不需要资源的所有权，而且你不想指定这个对象的生命周期时，可以考虑使用weak_ptr代替shared_ptr。</p><p>使用智能指针的时候，只需要将new出的地址值赋值给这种对象，也就是将new出的地址作为实参！</p><p><strong>总结：智能指针其实就是类对象，来模拟指针的效果，从而实现更安全的管理内存的操作，实现了自动释放内存等功能。<br>智能指针分类，最简单实用的是unique_ptr,如果要多个指针指向同一个对象的话，要使用shared_ptr，同时因为多个指针<br>操作一个对象，一定会带来多线程那种读写脏数据的问题，这时候就要加锁，而这里加锁的方式就是通过使用weak_ptr的<br>lock()函数来进行的。而对于shared_ptr的数据结构，其实就是里边有一个count计数的类，并且重载了&gt;和*以及=等操作，<br>并且根据实际需要实现维护count和释放内存的操作。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十二章-动态内存&quot;&gt;&lt;a href=&quot;#第十二章-动态内存&quot; class=&quot;headerlink&quot; title=&quot;第十二章 动态内存&quot;&gt;&lt;/a&gt;第十二章 动态内存&lt;/h2&gt;&lt;p&gt;程序用堆（heap）来存储动态分配（dynamically allocate）的对象</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十一章-关联容器</title>
    <link href="http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2022-03-02T12:25:30.000Z</published>
    <updated>2022-06-29T13:11:59.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><p>关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是<code>map</code>和<code>set</code>。</p><ul><li><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</li><li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</li></ul><p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p><ul><li>是<code>map</code>还是<code>set</code>类型。</li><li>是否允许保存重复的关键字。</li><li>是否按顺序保存元素。</li></ul><p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-1.png" alt="11-1"></p><p><code>map</code>和<code>multimap</code>类型定义在头文件<em>map</em>中；<code>set</code>和<code>multiset</code>类型定义在头文件<em>set</em>中；无序容器定义在头文件<em>unordered_map</em>和<em>unordered_set</em>中。</p><h2 id="使用关联容器（Using-an-Associative-Container）"><a href="#使用关联容器（Using-an-Associative-Container）" class="headerlink" title="使用关联容器（Using an Associative Container）"></a>使用关联容器（Using an Associative Container）</h2><p><code>map</code>类型通常被称为关联数组（associative array）。</p><p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count the number of times each word occurs in the input</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;     <span class="comment">// empty map from string to size_t</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];     <span class="comment">// fetch and increment the counter for word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)    <span class="comment">// for each element in the map</span></span><br><span class="line">    <span class="comment">// print the results</span></span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p><h2 id="关联容器概述（Overview-of-the-Associative-Containers）"><a href="#关联容器概述（Overview-of-the-Associative-Containers）" class="headerlink" title="关联容器概述（Overview of the Associative Containers）"></a>关联容器概述（Overview of the Associative Containers）</h2><h3 id="定义关联容器（Defining-an-Associative-Container）"><a href="#定义关联容器（Defining-an-Associative-Container）" class="headerlink" title="定义关联容器（Defining an Associative Container）"></a>定义关联容器（Defining an Associative Container）</h3><p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p><p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;   <span class="comment">// empty</span></span><br><span class="line"><span class="comment">// list initialization</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// three elements; authors maps last name to first</span></span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p><h3 id="关键字类型的要求（Requirements-on-Key-Type）"><a href="#关键字类型的要求（Requirements-on-Key-Type）" class="headerlink" title="关键字类型的要求（Requirements on Key Type）"></a>关键字类型的要求（Requirements on Key Type）</h3><p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p><p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bookstore can have several transactions with the same ISBN</span></span><br><span class="line"><span class="comment">// elements in bookstore will be in ISBN order</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pair类型（The-pair-Type）"><a href="#pair类型（The-pair-Type）" class="headerlink" title="pair类型（The pair Type）"></a>pair类型（The pair Type）</h3><p><code>pair</code>定义在头文件<em>utility</em>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// holds two strings</span></span><br><span class="line">pair&lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">// holds a string and an size_t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; line;   <span class="comment">// holds string and vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p><p><code>pair</code>支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-2.png" alt="11-2"></p><p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="comment">// list initialize</span></span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// explicitly constructed return value</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联容器操作（Operations-on-Associative-Containers）"><a href="#关联容器操作（Operations-on-Associative-Containers）" class="headerlink" title="关联容器操作（Operations on Associative Containers）"></a>关联容器操作（Operations on Associative Containers）</h2><p>关联容器定义了类型别名来表示容器关键字和值的类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-3.png" alt="11-3"></p><p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是关键字-值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure><h3 id="关联容器迭代器（Associative-Container-Iterators）"><a href="#关联容器迭代器（Associative-Container-Iterators）" class="headerlink" title="关联容器迭代器（Associative Container Iterators）"></a>关联容器迭代器（Associative Container Iterators）</h3><p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to an element in word_count</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// *map_it is a reference to a pair&lt;const string, size_t&gt; object</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;first;          <span class="comment">// prints the key for this element</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; map_it-&gt;second;  <span class="comment">// prints the value of the element</span></span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;      <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second;               <span class="comment">// ok: we can change the value through an iterator</span></span><br></pre></td></tr></table></figure><p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error: keys in a set are read-only</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok: can read the key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p><p>通常不对关联容器使用泛型算法。</p><h3 id="添加元素（Adding-Elements）"><a href="#添加元素（Adding-Elements）" class="headerlink" title="添加元素（Adding Elements）"></a>添加元素（Adding Elements）</h3><p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p><p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// four ways to add word to word_count</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>关联容器的<code>insert</code>操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211132789.png" alt="image-20220629211132789"></p><p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p><ul><li>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</li><li>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</li></ul><h3 id="删除元素（Erasing-Elements）"><a href="#删除元素（Erasing-Elements）" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>关联容器的删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-5.png" alt="11-5"></p><p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p><h3 id="map的下标操作（Subscripting-a-map）"><a href="#map的下标操作（Subscripting-a-map）" class="headerlink" title="map的下标操作（Subscripting a map）"></a>map的下标操作（Subscripting a map）</h3><p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p><p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p><p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p><h3 id="访问元素（Accessing-Elements）"><a href="#访问元素（Accessing-Elements）" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><p>关联容器的查找操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-7.png" alt="11-7"></p><p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">// adds the first element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// ok: adds the second element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;      <span class="comment">// author we&#x27;ll look for</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_item);  <span class="comment">// number of elements</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);      <span class="comment">// first entry for this author</span></span><br><span class="line"><span class="comment">// loop through the number of entries there are for this author</span></span><br><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;   <span class="comment">// print each title</span></span><br><span class="line">    ++iter;      <span class="comment">// advance to the next title</span></span><br><span class="line">    --entries;   <span class="comment">// keep track of how many we&#x27;ve printed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// beg and end denote the range of elements for this author</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;    <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p><p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// pos holds iterators that denote the range of elements for this key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure><h2 id="无序容器（The-Unordered-Containers）"><a href="#无序容器（The-Unordered-Containers）" class="headerlink" title="无序容器（The Unordered Containers）"></a>无序容器（The Unordered Containers）</h2><p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p><p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p><p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p><p>无序容器管理操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-8.png" alt="11-8"></p><p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第11章-关联容器&quot;&gt;&lt;a href=&quot;#第11章-关联容器&quot; class=&quot;headerlink&quot; title=&quot;第11章 关联容器&quot;&gt;&lt;/a&gt;第11章 关联容器&lt;/h1&gt;&lt;p&gt;关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第九章-顺序容器</title>
    <link href="http://icecorn.github.io/2022/02/28/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://icecorn.github.io/2022/02/28/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-02-28T12:25:30.000Z</published>
    <updated>2022-06-29T13:08:35.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h1><h2 id="顺序容器概述（Overview-of-the-Sequential-Containers）"><a href="#顺序容器概述（Overview-of-the-Sequential-Containers）" class="headerlink" title="顺序容器概述（Overview of the Sequential Containers）"></a>顺序容器概述（Overview of the Sequential Containers）</h2><p>顺序容器类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-1.png" alt="9-1"></p><table><thead><tr><th align="center">类型</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center"><code>vector</code></td><td align="center">可变大小数组。支持快速随机访问。在尾部之外的位置插入/删除元素可能很慢</td></tr><tr><td align="center"><code>deque</code></td><td align="center">双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td></tr><tr><td align="center"><code>list</code></td><td align="center">双向链表。只支持双向顺序访问。在任何位置插入/删除速度都很快</td></tr><tr><td align="center"><code>forward_list</code></td><td align="center">单向链表。只支持单向顺序访问。在任何位置插入/删除速度都很快</td></tr><tr><td align="center"><code>array</code></td><td align="center">固定大小数组。支持快速随机访问。不能添加/删除元素</td></tr><tr><td align="center"><code>string</code></td><td align="center">类似<code>vector</code>，但用于保存字符。支持快速随机访问。在尾部插入/删除速度很快</td></tr></tbody></table><p><code>forward_list</code>和<code>array</code>是C++11新增类型。与内置数组相比，<code>array</code>更安全易用。<code>forward_list</code>没有<code>size</code>操作。</p><p>容器选择原则：</p><ul><li>除非有合适的理由选择其他容器，否则应该使用<code>vector</code>。</li><li>如果程序有很多小的元素，且空间的额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code>。</li><li>如果程序要求随机访问容器元素，则应该使用<code>vector</code>或<code>deque</code>。</li><li>如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用<code>deque</code>。</li><li>如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则：<ul><li>先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向<code>vector</code>追加数据，再调用标准库的<code>sort</code>函数重排元素，从而避免在中间位置添加元素。</li><li>如果必须在中间位置插入元素，可以在输入阶段使用<code>list</code>。输入完成后将<code>list</code>中的内容拷贝到<code>vector</code>中。</li></ul></li><li>不确定应该使用哪种容器时，可以先只使用<code>vector</code>和<code>list</code>的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择<code>vector</code>或<code>list</code>都很方便。</li></ul><h2 id="容器库概览（Container-Library-Overview）"><a href="#容器库概览（Container-Library-Overview）" class="headerlink" title="容器库概览（Container Library Overview）"></a>容器库概览（Container Library Overview）</h2><p>每个容器都定义在一个头文件中，文件名与类型名相同。容器均为模板类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-2.png" alt="9-2"></p><h3 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h3><p><code>forward_list</code>类型不支持递减运算符<code>--</code>。</p><p>一个迭代器范围（iterator range）由一对迭代器表示。这两个迭代器通常被称为<code>begin</code>和<code>end</code>，分别指向同一个容器中的元素或尾后地址。<code>end</code>迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为<code>[begin，end）</code>。迭代器<code>begin</code>和<code>end</code>必须指向相同的容器，<code>end</code>可以与<code>begin</code>指向相同的位置，但不能指向<code>begin</code>之前的位置（由程序员确保）。</p><p>假定<code>begin</code>和<code>end</code>构成一个合法的迭代器范围，则：</p><ul><li>如果<code>begin</code>等于<code>end</code>，则范围为空。</li><li>如果<code>begin</code>不等于<code>end</code>，则范围内至少包含一个元素，且<code>begin</code>指向该范围内的第一个元素。</li><li>可以递增<code>begin</code>若干次，令<code>begin</code>等于<code>end</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != end)</span><br><span class="line">&#123;</span><br><span class="line">    *begin = val;   <span class="comment">// ok: range isn&#x27;t empty so begin denotes an element</span></span><br><span class="line">    ++begin;    <span class="comment">// advance the iterator to get the next element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器类型成员（Container-Type-Members）"><a href="#容器类型成员（Container-Type-Members）" class="headerlink" title="容器类型成员（Container Type Members）"></a>容器类型成员（Container Type Members）</h3><p>通过类型别名，可以在不了解容器元素类型的情况下使用元素。如果需要元素类型，可以使用容器的<code>value_type</code>。如果需要元素类型的引用，可以使用<code>reference</code>或<code>const_reference</code>。</p><h3 id="begin和end成员（begin-and-end-Members）"><a href="#begin和end成员（begin-and-end-Members）" class="headerlink" title="begin和end成员（begin and end Members）"></a>begin和end成员（begin and end Members）</h3><p><code>begin</code>和<code>end</code>操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。</p><p><code>begin</code>和<code>end</code>操作有多个版本：带<code>r</code>的版本返回反向迭代器。以<code>c</code>开头的版本（C++11新增）返回<code>const</code>迭代器。不以<code>c</code>开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对<code>const</code>对象调用时，返回<code>const</code>迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();    <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>();   <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();   <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>();  <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure><p>当<code>auto</code>与<code>begin</code>或<code>end</code>结合使用时，返回的迭代器类型依赖于容器类型。但调用以<code>c</code>开头的版本仍然可以获得<code>const</code>迭代器，与容器是否是常量无关。</p><p>当程序不需要写操作时，应该使用<code>cbegin</code>和<code>cend</code>。</p><h3 id="容器定义和初始化（Defining-and-Initializing-a-Container）"><a href="#容器定义和初始化（Defining-and-Initializing-a-Container）" class="headerlink" title="容器定义和初始化（Defining and Initializing a Container）"></a>容器定义和初始化（Defining and Initializing a Container）</h3><p>容器定义和初始化方式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-3.png" alt="9-3"></p><p>将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。</p><p>传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;        <span class="comment">// ok: types match</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;    <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(articles)</span></span>;     <span class="comment">// error: element types must match</span></span><br><span class="line"><span class="comment">// ok: converts const char* elements to string</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br></pre></td></tr></table></figure><p>C++11允许对容器进行列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>定义和使用<code>array</code>类型时，需要同时指定元素类型和容器大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 42&gt;      <span class="comment">// type is: array that holds 42 ints</span></span><br><span class="line">array&lt;string, 10&gt;   <span class="comment">// type is: array that holds 10 strings</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;::size_type i;   <span class="comment">// array type includes element type and size</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt;::size_type j;       <span class="comment">// error: array&lt;int&gt; is not a type</span></span><br></pre></td></tr></table></figure><p>对<code>array</code>进行列表初始化时，初始值的数量不能大于<code>array</code>的大小。如果初始值的数量小于<code>array</code>的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。</p><p>可以对<code>array</code>进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。</p><h3 id="赋值和swap（Assignment-and-swap）"><a href="#赋值和swap（Assignment-and-swap）" class="headerlink" title="赋值和swap（Assignment and swap）"></a>赋值和swap（Assignment and swap）</h3><p>容器赋值操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210627262.png" alt="image-20220629210627262"></p><p>赋值运算符两侧的运算对象必须类型相同。<code>assign</code>允许用不同但相容的类型赋值，或者用容器的子序列赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;   <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="comment">// ok: can convert from const char*to string</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br></pre></td></tr></table></figure><p>由于其旧元素被替换，因此传递给<code>assign</code>的迭代器不能指向调用<code>assign</code>的容器本身。</p><p><code>swap</code>交换两个相同类型容器的内容。除<code>array</code>外，<code>swap</code>不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此可以保证快速完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// vector with ten elements</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;   <span class="comment">// vector with 24 elements</span></span><br><span class="line"><span class="built_in">swap</span>(svec1, svec2);</span><br></pre></td></tr></table></figure><p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而<code>swap</code>操作交换容器内容，不会导致迭代器、引用和指针失效（<code>array</code>和<code>string</code>除外）。</p><p>对于<code>array</code>，<code>swap</code>会真正交换它们的元素。因此在<code>swap</code>操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 3&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换后的值，即4、5、6</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他容器类型（除<code>string</code>），指针、引用和迭代器在<code>swap</code>操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换前的值，即1、2、3</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>array</code>不支持<code>assign</code>，也不允许用花括号列表进行赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;;    <span class="comment">// elements all have value 0</span></span><br><span class="line">a1 = a2;    <span class="comment">// replaces elements in a1</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;;   <span class="comment">// error: cannot assign to an array from a braced list</span></span><br></pre></td></tr></table></figure><p>新标准库同时提供了成员和非成员函数版本的<code>swap</code>。非成员版本的<code>swap</code>在泛型编程中非常重要，建议统一使用非成员版本的<code>swap</code>。</p><h3 id="容器大小操作（Container-Size-Operations）"><a href="#容器大小操作（Container-Size-Operations）" class="headerlink" title="容器大小操作（Container Size Operations）"></a>容器大小操作（Container Size Operations）</h3><p><code>size</code>成员返回容器中元素的数量；<code>empty</code>当<code>size</code>为0时返回<code>true</code>，否则返回<code>false</code>；<code>max_size</code>返回一个大于或等于该类型容器所能容纳的最大元素数量的值。<code>forward_list</code>支持<code>max_size</code>和<code>empty</code>，但不支持<code>size</code>。</p><h3 id="关系运算符（Relational-Operators）"><a href="#关系运算符（Relational-Operators）" class="headerlink" title="关系运算符（Relational Operators）"></a>关系运算符（Relational Operators）</h3><p>每个容器类型都支持相等运算符（<code>==</code>、<code>!=</code>）。除无序关联容器外，其他容器都支持关系运算符（<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。关系运算符两侧的容器类型和保存元素类型都必须相同。</p><p>两个容器的比较实际上是元素的逐对比较，其工作方式与<code>string</code>的关系运算符类似：</p><ul><li>如果两个容器大小相同且所有元素对应相等，则这两个容器相等。</li><li>如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li><li>如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">v1 &lt; v2     <span class="comment">// true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]</span></span><br><span class="line">v1 &lt; v3     <span class="comment">// false; all elements are equal, but v3 has fewer of them;</span></span><br><span class="line">v1 == v4    <span class="comment">// true; each element is equal and v1 and v4 have the same size()</span></span><br><span class="line">v1 == v2    <span class="comment">// false; v2 has fewer elements than v1</span></span><br></pre></td></tr></table></figure><p>容器的相等运算符实际上是使用元素的<code>==</code>运算符实现的，而其他关系运算符则是使用元素的<code>&lt;</code>运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。</p><h2 id="顺序容器操作（Sequential-Container-Operations）"><a href="#顺序容器操作（Sequential-Container-Operations）" class="headerlink" title="顺序容器操作（Sequential Container Operations）"></a>顺序容器操作（Sequential Container Operations）</h2><h3 id="向顺序容器添加元素（Adding-Elements-to-a-Sequential-Container）"><a href="#向顺序容器添加元素（Adding-Elements-to-a-Sequential-Container）" class="headerlink" title="向顺序容器添加元素（Adding Elements to a Sequential Container）"></a>向顺序容器添加元素（Adding Elements to a Sequential Container）</h3><p>除<code>array</code>外，所有标准库容器都提供灵活的内存管理，在运行时可以动态添加或删除元素。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-5.png" alt="9-5"></p><p><code>push_back</code>将一个元素追加到容器尾部，<code>push_front</code>将元素插入容器头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from standard input, putting each word onto the end of container</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    container.<span class="built_in">push_back</span>(word);</span><br></pre></td></tr></table></figure><p><code>insert</code>将元素插入到迭代器指定的位置之前。一些不支持<code>push_front</code>的容器可以使用<code>insert</code>将元素插入开始位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;string&gt; slist;</span><br><span class="line"><span class="comment">// equivalent to calling slist.push_front(&quot;Hello!&quot;);</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="comment">// no push_front on vector but we can insert before begin()</span></span><br><span class="line"><span class="comment">// warning: inserting anywhere but at the end of a vector might be slow</span></span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure><p>将元素插入到<code>vector</code>、<code>deque</code>或<code>string</code>的任何位置都是合法的，但可能会很耗时。</p><p>在新标准库中，接受元素个数或范围的<code>insert</code>版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回<code>void</code>。如果范围为空，不插入任何元素，<code>insert</code>会返回第一个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; <span class="number">1</span>st;</span><br><span class="line"><span class="keyword">auto</span> iter = <span class="number">1</span>st.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    iter = <span class="number">1</span>st.<span class="built_in">insert</span>(iter, word);  <span class="comment">// same as calling push_front</span></span><br></pre></td></tr></table></figure><p>新标准库增加了三个直接构造而不是拷贝元素的操作：<code>emplace_front</code>、<code>emplace_back</code>和<code>emplace</code>，其分别对应<code>push_front</code>、<code>push_back</code>和<code>insert</code>。当调用<code>push</code>或<code>insert</code>时，元素对象被拷贝到容器中。而调用<code>emplace</code>时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a Sales_data object at the end of c</span></span><br><span class="line"><span class="comment">// uses the three-argument Sales_data constructor</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// error: there is no version of push_back that takes three arguments</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// ok: we create a temporary Sales_data object to pass to push_back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure><p>传递给<code>emplace</code>的参数必须与元素类型的构造函数相匹配。</p><p><code>forward_list</code>有特殊版本的<code>insert</code>和<code>emplace</code>操作，且不支持<code>push_back</code>和<code>emplace_back</code>。<code>vector</code>和<code>string</code>不支持<code>push_front</code>和<code>emplace_front</code>。</p><h3 id="访问元素（Accessing-Elements）"><a href="#访问元素（Accessing-Elements）" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><p>每个顺序容器都有一个<code>front</code>成员函数，而除了<code>forward_list</code>之外的顺序容器还有一个<code>back</code>成员函数。这两个操作分别返回首元素和尾元素的引用。</p><p>在调用<code>front</code>和<code>back</code>之前，要确保容器非空。</p><p>顺序容器的元素访问操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210649908.png" alt="image-20220629210649908"></p><p>在容器中访问元素的成员函数都返回引用类型。如果容器是<code>const</code>对象，则返回<code>const</code>引用，否则返回普通引用。</p><p>可以快速随机访问的容器（<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code>）都提供下标运算符。保证下标有效是程序员的责任。如果希望确保下标合法，可以使用<code>at</code>成员函数。<code>at</code>类似下标运算，但如果下标越界，<code>at</code>会抛出<code>out_of_range</code>异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;  <span class="comment">// empty vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];      <span class="comment">// run-time error: there are no elements in svec!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);   <span class="comment">// throws an out_of_range exception</span></span><br></pre></td></tr></table></figure><h3 id="删除元素（Erasing-Elements）"><a href="#删除元素（Erasing-Elements）" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>顺序容器的元素删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-7.png" alt="9-7"></p><p>删除<code>deque</code>中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除<code>vector</code>或<code>string</code>的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。</p><p>删除元素前，程序员必须确保目标元素存在。</p><p><code>pop_front</code>和<code>pop_back</code>函数分别删除首元素和尾元素。<code>vector</code>和<code>string</code>类型不支持<code>pop_front</code>，<code>forward_list</code>类型不支持<code>pop_back</code>。</p><p><code>erase</code>函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的<code>erase</code>都返回指向删除元素（最后一个）之后位置的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete the range of elements between two iterators</span></span><br><span class="line"><span class="comment">// returns an iterator to the element just after the last removed element</span></span><br><span class="line">elem1 = slist.<span class="built_in">erase</span>(elem1, elem2);  <span class="comment">// after the call elem1 == elem2</span></span><br></pre></td></tr></table></figure><p><code>clear</code>函数删除容器内的所有元素。</p><h3 id="特殊的forward-list操作（Specialized-forward-list-Operations）"><a href="#特殊的forward-list操作（Specialized-forward-list-Operations）" class="headerlink" title="特殊的forward_list操作（Specialized forward_list Operations）"></a>特殊的forward_list操作（Specialized forward_list Operations）</h3><p>在<code>forward_list</code>中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-8.png" alt="9-8"></p><p><code>forward_list</code>的插入和删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-9.png" alt="9-9"></p><h3 id="改变容器大小（Resizing-a-Container）"><a href="#改变容器大小（Resizing-a-Container）" class="headerlink" title="改变容器大小（Resizing a Container）"></a>改变容器大小（Resizing a Container）</h3><p>顺序容器的大小操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210707236.png" alt="image-20220629210707236"></p><p><code>resize</code>函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且<code>resize</code>向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。</p><h3 id="容器操作可能使迭代器失效（Container-Operations-May-Invalidate-Iterators）"><a href="#容器操作可能使迭代器失效（Container-Operations-May-Invalidate-Iterators）" class="headerlink" title="容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）"></a>容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）</h3><p>向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。</p><ul><li>向容器中添加元素后：<ul><li>如果容器是<code>vector</code>或<code>string</code>类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。</li><li>如果容器是<code>deque</code>类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。</li><li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器的迭代器、指针和引用仍然有效。</li></ul></li><li>从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效：<ul><li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器其他位置的迭代器、指针和引用仍然有效。</li><li>如果容器是<code>deque</code>类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。</li><li>如果容器是<code>vector</code>或<code>string</code>类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。</li></ul></li></ul><p>必须保证在每次改变容器后都正确地重新定位迭代器。</p><p>不要保存<code>end</code>函数返回的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// safer: recalculate end on each trip whenever the loop adds/erases elements</span></span><br><span class="line"><span class="keyword">while</span> (begin != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do some processing</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin because we want to insert after this element</span></span><br><span class="line">    begin = v.<span class="built_in">insert</span>(begin, <span class="number">42</span>);    <span class="comment">// insert the new value</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin past the element we just added</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector对象是如何增长的（How-a-vector-Grows）"><a href="#vector对象是如何增长的（How-a-vector-Grows）" class="headerlink" title="vector对象是如何增长的（How a vector Grows）"></a>vector对象是如何增长的（How a vector Grows）</h2><p><code>vector</code>和<code>string</code>的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多新元素。</p><p>容器大小管理操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210726965.png" alt="image-20220629210726965"></p><p><code>capacity</code>函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。<code>reserve</code>函数告知容器应该准备保存多少元素，它并不改变容器中元素的数量，仅影响容器预先分配的内存空间大小。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-12.png" alt="9-12"></p><p>只有当需要的内存空间超过当前容量时，<code>reserve</code>才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，<code>reserve</code>并不会退回内存空间。因此在调用<code>reserve</code>之后，<code>capacity</code>会大于或等于传递给<code>reserve</code>的参数。</p><p>在C++11中可以使用<code>shrink_to_fit</code>函数来要求<code>deque</code>、<code>vector</code>和<code>string</code>退回不需要的内存空间（并不保证退回）。</p><h2 id="额外的string操作（Additional-string-Operations）"><a href="#额外的string操作（Additional-string-Operations）" class="headerlink" title="额外的string操作（Additional string Operations）"></a>额外的string操作（Additional string Operations）</h2><h3 id="构造string的其他方法（Other-Ways-to-Construct-strings）"><a href="#构造string的其他方法（Other-Ways-to-Construct-strings）" class="headerlink" title="构造string的其他方法（Other Ways to Construct strings）"></a>构造string的其他方法（Other Ways to Construct strings）</h3><p>构造<code>string</code>的其他方法：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-13.png" alt="9-13"></p><p>从另一个<code>string</code>对象拷贝字符构造<code>string</code>时，如果提供的拷贝开始位置（可选）大于给定<code>string</code>的大小，则构造函数会抛出<code>out_of_range</code>异常。</p><p>子字符串操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-14.png" alt="9-14"></p><p>如果传递给<code>substr</code>函数的开始位置超过<code>string</code>的大小，则函数会抛出<code>out_of_range</code>异常。</p><h3 id="改变string的其他方法（Other-Ways-to-Change-a-string）"><a href="#改变string的其他方法（Other-Ways-to-Change-a-string）" class="headerlink" title="改变string的其他方法（Other Ways to Change a string）"></a>改变string的其他方法（Other Ways to Change a string）</h3><p>修改<code>string</code>的操作：</p><p><code>append</code>函数是在<code>string</code>末尾进行插入操作的简写形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>, s2 </span>= s;     <span class="comment">// initialize s and s2 to &quot;C++ Primer&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2</span></span><br></pre></td></tr></table></figure><p><code>replace</code>函数是调用<code>erase</code>和<code>insert</code>函数的简写形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">11</span>, <span class="number">3</span>);         <span class="comment">// s == &quot;C++ Primer Ed.&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;5th&quot;</span>);    <span class="comment">// s == &quot;C++ Primer 5th Ed.&quot;</span></span><br><span class="line"><span class="comment">// starting at position 11, erase three characters and then insert &quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&quot;5th&quot;</span>);   <span class="comment">// equivalent: s == s2</span></span><br></pre></td></tr></table></figure><h3 id="string搜索操作（string-Search-Operations）"><a href="#string搜索操作（string-Search-Operations）" class="headerlink" title="string搜索操作（string Search Operations）"></a>string搜索操作（string Search Operations）</h3><p><code>string</code>的每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配位置的下标。如果搜索失败，则返回一个名为<code>string::npos</code>的<code>static</code>成员。标准库将<code>npos</code>定义为<code>const string::size_type</code>类型，并初始化为-1。</p><p>不建议用<code>int</code>或其他带符号类型来保存<code>string</code>搜索函数的返回值。</p><p><code>string</code>搜索操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-16.png" alt="9-16"></p><h3 id="compare函数（The-compare-Functions）"><a href="#compare函数（The-compare-Functions）" class="headerlink" title="compare函数（The compare Functions）"></a>compare函数（The compare Functions）</h3><p><code>string</code>类型提供了一组<code>compare</code>函数进行字符串比较操作，类似C标准库的<code>strcmp</code>函数。</p><p><code>compare</code>函数的几种参数形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210808871.png" alt="image-20220629210808871"></p><h3 id="数值转换（Numeric-Conversions）"><a href="#数值转换（Numeric-Conversions）" class="headerlink" title="数值转换（Numeric Conversions）"></a>数值转换（Numeric Conversions）</h3><p>C++11增加了<code>string</code>和数值之间的转换函数：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-18.png" alt="9-18"></p><p>进行数值转换时，<code>string</code>参数的第一个非空白字符必须是符号（<code>+</code>或<code>-</code>）或数字。它可以以<code>0x</code>或<code>0X</code>开头来表示十六进制数。对于转换目标是浮点值的函数，<code>string</code>参数也可以以小数点开头，并可以包含<code>e</code>或<code>E</code>来表示指数部分。</p><p>如果给定的<code>string</code>不能转换为一个数值，则转换函数会抛出<code>invalid_argument</code>异常。如果转换得到的数值无法用任何类型表示，则抛出<code>out_of_range</code>异常。</p><h2 id="容器适配器（Container-Adaptors）"><a href="#容器适配器（Container-Adaptors）" class="headerlink" title="容器适配器（Container Adaptors）"></a>容器适配器（Container Adaptors）</h2><p>标准库定义了<code>stack</code>、<code>queue</code>和<code>priority_queue</code>三种容器适配器。容器适配器可以改变已有容器的工作机制。</p><p>所有容器适配器都支持的操作和类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-19.png" alt="9-19"></p><p>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是基于<code>vector</code>实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on top of vector</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure><p>所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在<code>array</code>上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用<code>forward_list</code>构造适配器。</p><p>栈适配器<code>stack</code>定义在头文件<em>stack</em>中，其支持的操作如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210825536.png" alt="image-20220629210825536"></p><p>队列适配器<code>queue</code>和<code>priority_queue</code>定义在头文件<em>queue</em>中，其支持的操作如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-21.png" alt="9-21"></p><p><code>queue</code>使用先进先出（first-in，first-out，FIFO）的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第9章-顺序容器&quot;&gt;&lt;a href=&quot;#第9章-顺序容器&quot; class=&quot;headerlink&quot; title=&quot;第9章 顺序容器&quot;&gt;&lt;/a&gt;第9章 顺序容器&lt;/h1&gt;&lt;h2 id=&quot;顺序容器概述（Overview-of-the-Sequential-Contain</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第八章-IO库</title>
    <link href="http://icecorn.github.io/2022/02/26/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-IO%E5%BA%93/"/>
    <id>http://icecorn.github.io/2022/02/26/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-IO%E5%BA%93/</id>
    <published>2022-02-26T12:25:30.000Z</published>
    <updated>2022-06-29T13:04:00.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-IO库"><a href="#第8章-IO库" class="headerlink" title="第8章 IO库"></a>第8章 IO库</h1><p>部分IO库设施：</p><ul><li><code>istream</code>：输入流类型，提供输入操作。</li><li><code>ostream</code>：输出流类型，提供输出操作。</li><li><code>cin</code>：<code>istream</code>对象，从标准输入读取数据。</li><li><code>cout</code>：<code>ostream</code>对象，向标准输出写入数据。</li><li><code>cerr</code>：<code>ostream</code>对象，向标准错误写入数据。</li><li><code>&gt;&gt;</code>运算符：从<code>istream</code>对象读取输入数据。</li><li><code>&lt;&lt;</code>运算符：向<code>ostream</code>对象写入输出数据。</li><li><code>getline</code>函数：从<code>istream</code>对象读取一行数据，写入<code>string</code>对象。</li></ul><h2 id="IO类（The-IO-Classes）"><a href="#IO类（The-IO-Classes）" class="headerlink" title="IO类（The IO Classes）"></a>IO类（The IO Classes）</h2><p>头文件<em>iostream</em>定义了用于读写流的基本类型，<em>fstream</em>定义了读写命名文件的类型，<em>sstream</em>定义了读写内存中<code>string</code>对象的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210314294.png" alt="image-20220629210314294"></p><p>宽字符版本的IO类型和函数的名字以<code>w</code>开始，如<code>wcin</code>、<code>wcout</code>和<code>wcerr</code>分别对应<code>cin</code>、<code>cout</code>和<code>cerr</code>。它们与其对应的普通<code>char</code>版本都定义在同一个头文件中，如头文件<em>fstream</em>定义了<code>ifstream</code>和<code>wifstream</code>类型。</p><p>可以将派生类的对象当作其基类的对象使用。</p><h3 id="IO象无拷贝或赋值（No-Copy-or-Assign-for-IO-Objects）"><a href="#IO象无拷贝或赋值（No-Copy-or-Assign-for-IO-Objects）" class="headerlink" title="IO象无拷贝或赋值（No Copy or Assign for IO Objects）"></a>IO象无拷贝或赋值（No Copy or Assign for IO Objects）</h3><p>不能拷贝或对IO对象赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;    <span class="comment">// error: cannot assign stream objects</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">// error: can&#x27;t initialize the ofstream parameter</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">// error: cannot copy stream objects</span></span><br></pre></td></tr></table></figure><p>由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</p><h3 id="条件状态（Condition-States）"><a href="#条件状态（Condition-States）" class="headerlink" title="条件状态（Condition States）"></a>条件状态（Condition States）</h3><p>IO库条件状态：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8-2.png" alt="8-2"></p><p><code>badbit</code>表示系统级错误，如不可恢复的读写错误。通常情况下，一旦<code>badbit</code>被置位，流就无法继续使用了。在发生可恢复错误后，<code>failbit</code>会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，<code>eofbit</code>和<code>failbit</code>都会被置位。如果流未发生错误，则<code>goodbit</code>的值为0。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任何一个被置位，检测流状态的条件都会失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok: read operation successful...</span></span><br></pre></td></tr></table></figure><p><code>good</code>函数在所有错误均未置位时返回<code>true</code>。而<code>bad</code>、<code>fail</code>和<code>eof</code>函数在对应错误位被置位时返回<code>true</code>。此外，在<code>badbit</code>被置位时，<code>fail</code>函数也会返回<code>true</code>。因此应该使用<code>good</code>或<code>fail</code>函数确定流的总体状态，<code>eof</code>和<code>bad</code>只能检测特定错误。</p><p>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，表示流的当前状态。<code>setstate</code>成员用于将指定条件置位（叠加原始流状态）。<code>clear</code>成员的无参版本清除所有错误标志；含参版本接受一个<code>iostate</code>值，用于设置流的新状态（覆盖原始流状态）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remember the current state of cin</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();     <span class="comment">// remember the current state of cin</span></span><br><span class="line">cin.<span class="built_in">clear</span>();    <span class="comment">// make cin valid</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);     <span class="comment">// use cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);    <span class="comment">// now reset cin to its old state</span></span><br></pre></td></tr></table></figure><h3 id="管理输出缓冲（Managing-the-Output-Buffer）"><a href="#管理输出缓冲（Managing-the-Output-Buffer）" class="headerlink" title="管理输出缓冲（Managing the Output Buffer）"></a>管理输出缓冲（Managing the Output Buffer）</h3><p>每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多：</p><ul><li>程序正常结束。</li><li>缓冲区已满。</li><li>使用操纵符（如<code>endl</code>）显式刷新缓冲区。</li><li>在每个输出操作之后，可以用<code>unitbuf</code>操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li><li>一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此，读<code>cin</code>或写<code>cerr</code>都会刷新<code>cout</code>的缓冲区。</li></ul><p><code>flush</code>操纵符刷新缓冲区，但不输出任何额外字符。<code>ends</code>向缓冲区插入一个空字符，然后刷新缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;   <span class="comment">// writes hi and a newline, then flushes the buffer</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush;  <span class="comment">// writes hi, then flushes the buffer; adds no data</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends;   <span class="comment">// writes hi and a null, then flushes the buffer</span></span><br></pre></td></tr></table></figure><p>如果想在每次输出操作后都刷新缓冲区，可以使用<code>unitbuf</code>操纵符。它令流在接下来的每次写操作后都进行一次<code>flush</code>操作。而<code>nounitbuf</code>操纵符则使流恢复使用正常的缓冲区刷新机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;    <span class="comment">// all writes will be flushed immediately</span></span><br><span class="line"><span class="comment">// any output is flushed immediately, no buffering</span></span><br><span class="line">cout &lt;&lt; nounitbuf;  <span class="comment">// returns to normal buffering</span></span><br></pre></td></tr></table></figure><p>如果程序异常终止，输出缓冲区不会被刷新。</p><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将<code>cout</code>和<code>cin</code>关联在一起，因此下面的语句会导致<code>cout</code>的缓冲区被刷新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ival;</span><br></pre></td></tr></table></figure><p>交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。</p><p>使用<code>tie</code>函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。<code>tie</code>的第二个版本接受一个指向<code>ostream</code>的指针，将本对象关联到此<code>ostream</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout);     <span class="comment">// illustration only: the library ties cin and cout for us</span></span><br><span class="line"><span class="comment">// old_tie points to the stream (if any) currently tied to cin</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); <span class="comment">// cin is no longer tied</span></span><br><span class="line"><span class="comment">// ties cin and cerr; not a good idea because cin should be tied to cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);     <span class="comment">// reading cin flushes cerr, not cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);   <span class="comment">// reestablish normal tie between cin and cout</span></span><br></pre></td></tr></table></figure><p>每个流同时最多关联一个流，但多个流可以同时关联同一个<code>ostream</code>。向<code>tie</code>传递空指针可以解开流的关联。</p><h2 id="文件输入输出（File-Input-and-Output）"><a href="#文件输入输出（File-Input-and-Output）" class="headerlink" title="文件输入输出（File Input and Output）"></a>文件输入输出（File Input and Output）</h2><p>头文件<em>fstream</em>定义了三个类型来支持文件IO：<code>ifstream</code>从给定文件读取数据，<code>ofstream</code>向指定文件写入数据，<code>fstream</code>可以同时读写指定文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210334141.png" alt="image-20220629210334141"></p><h3 id="使用文件流对象（Using-File-Stream-Objects）"><a href="#使用文件流对象（Using-File-Stream-Objects）" class="headerlink" title="使用文件流对象（Using File Stream Objects）"></a>使用文件流对象（Using File Stream Objects）</h3><p>每个文件流类型都定义了<code>open</code>函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。</p><p>创建文件流对象时，如果提供了文件名（可选），<code>open</code>会被自动调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;   <span class="comment">// construct an ifstream and open the given file</span></span><br><span class="line">ofstream out;   <span class="comment">// output file stream that is not associated with any file</span></span><br></pre></td></tr></table></figure><p>在C++11中，文件流对象的文件名可以是<code>string</code>对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。</p><p>在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受<code>iostream</code>类型引用或指针参数的函数，可以用对应的<code>fstream</code>类型来调用。</p><p>可以先定义空文件流对象，再调用<code>open</code>函数将其与指定文件关联。如果<code>open</code>调用失败，<code>failbit</code>会被置位。</p><p>对一个已经打开的文件流调用<code>open</code>会失败，并导致<code>failbit</code>被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用<code>close</code>关闭当前文件，再调用<code>clear</code>重置流的条件状态（<code>close</code>不会重置流的条件状态）。</p><p>当<code>fstream</code>对象被销毁时，<code>close</code>会自动被调用。</p><h3 id="文件模式（File-Modes）"><a href="#文件模式（File-Modes）" class="headerlink" title="文件模式（File Modes）"></a>文件模式（File Modes）</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8-4.png" alt="8-4"></p><ul><li>只能对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式。</li><li>只能对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式。</li><li>只有当<code>out</code>被设定时才能设定<code>trunc</code>模式。</li><li>只要<code>trunc</code>没被设定，就能设定<code>app</code>模式。在<code>app</code>模式下，即使没有设定<code>out</code>模式，文件也是以输出方式打开。</li><li>默认情况下，即使没有设定<code>trunc</code>，以<code>out</code>模式打开的文件也会被截断。如果想保留以<code>out</code>模式打开的文件内容，就必须同时设定<code>app</code>模式，这会将数据追加写到文件末尾；或者同时设定<code>in</code>模式，即同时进行读写操作。</li><li><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。</li><li>与<code>ifstream</code>对象关联的文件默认以<code>in</code>模式打开，与<code>ofstream</code>对象关联的文件默认以<code>out</code>模式打开，与<code>fstream</code>对象关联的文件默认以<code>in</code>和<code>out</code>模式打开。</li></ul><p>默认情况下，打开<code>ofstream</code>对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定<code>app</code>或<code>in</code>模式。</p><p>流对象每次打开文件时都可以改变其文件模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;   <span class="comment">// no file mode is set</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;scratchpad&quot;</span>);    <span class="comment">// mode implicitly out and trunc</span></span><br><span class="line">out.<span class="built_in">close</span>();    <span class="comment">// close out so we can use it for a different file</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;precious&quot;</span>, ofstream::app);   <span class="comment">// mode is out and app</span></span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h2 id="string流（string-Streams）"><a href="#string流（string-Streams）" class="headerlink" title="string流（string Streams）"></a>string流（string Streams）</h2><p>头文件<em>sstream</em>定义了三个类型来支持内存IO：<code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入数据，<code>stringstream</code>可以同时读写<code>string</code>的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8-5.png" alt="8-5"></p><h3 id="使用istringstream（Using-an-istringstream）"><a href="#使用istringstream（Using-an-istringstream）" class="headerlink" title="使用istringstream（Using an istringstream）"></a>使用istringstream（Using an istringstream）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// members are public by default</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string line, word;   <span class="comment">// will hold a line and word from input, respectively</span></span><br><span class="line">vector&lt;PersonInfo&gt; people;    <span class="comment">// will hold all the records from the input</span></span><br><span class="line"><span class="comment">// read the input a line at a time until cin hits end-of-file (or another error)</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    PersonInfo info;    <span class="comment">// create an object to hold this record&#x27;s data</span></span><br><span class="line">    <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;    <span class="comment">// bind record to the line we just read</span></span><br><span class="line">    record &gt;&gt; info.name;    <span class="comment">// read the name</span></span><br><span class="line">    <span class="keyword">while</span> (record &gt;&gt; word)  <span class="comment">// read the phone numbers</span></span><br><span class="line">        info.phones.<span class="built_in">push_back</span>(word);   <span class="comment">// and store them</span></span><br><span class="line">    people.<span class="built_in">push_back</span>(info);    <span class="comment">// append this record to people</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ostringstream（Using-ostringstreams）"><a href="#使用ostringstream（Using-ostringstreams）" class="headerlink" title="使用ostringstream（Using ostringstreams）"></a>使用ostringstream（Using ostringstreams）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">&#123; <span class="comment">// for each entry in people</span></span><br><span class="line">    ostringstream formatted, badNums;   <span class="comment">// objects created on each loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)</span><br><span class="line">    &#123; <span class="comment">// for each number</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(nums))</span><br><span class="line">        &#123;</span><br><span class="line">            badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nums;  <span class="comment">// string in badNums</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// &#x27;&#x27;writes&#x27;&#x27; to formatted&#x27;s string</span></span><br><span class="line">            formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; format(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())   <span class="comment">// there were no bad numbers</span></span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span>  <span class="comment">// print the name</span></span><br><span class="line">            &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;   <span class="comment">// and reformatted numbers</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// otherwise, print the name and bad numbers</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name</span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid number(s) &quot;</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第8章-IO库&quot;&gt;&lt;a href=&quot;#第8章-IO库&quot; class=&quot;headerlink&quot; title=&quot;第8章 IO库&quot;&gt;&lt;/a&gt;第8章 IO库&lt;/h1&gt;&lt;p&gt;部分IO库设施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;istream&lt;/code&gt;：输入流类型，提</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第七章-类</title>
    <link href="http://icecorn.github.io/2022/02/24/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"/>
    <id>http://icecorn.github.io/2022/02/24/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/</id>
    <published>2022-02-24T12:25:30.000Z</published>
    <updated>2022-06-29T12:58:17.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。 </p><p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p><p>C++允许在成员函数的参数列表后面添加关键字<code>const</code>，表示<code>this</code>是一个指向常量的指针。使用关键字<code>const</code>的成员函数被称作常量成员函数（const member function）。</p><p>下边这种就是错误的：因为上边声明了isbn（）是一个const的成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pseudo-code illustration of how the implicit this pointer is used</span></span><br><span class="line"><span class="comment">// this code is illegal: we may not explicitly define the this pointer ourselves</span></span><br><span class="line"><span class="comment">// note that this is a pointer to const because isbn is a const member</span></span><br><span class="line"><span class="function">std::string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data *<span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p><p><strong>总结：因为this默认指向非常量的成员函数，所以常量对象不能调用非常量的函数，常量对象只能调用常量的成员函数（后边加const的，这时用this的话，this是一个常量指针）。另外const成员函数的声明和定义后边必须都有const</strong></p><hr><h3 id="防止隐式构造函数转换"><a href="#防止隐式构造函数转换" class="headerlink" title="防止隐式构造函数转换"></a>防止隐式构造函数转换</h3><p>在要求隐式转换的程序上下文中，可以通过将构造函数声明为<code>explicit</code>的加以阻止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>: bookNo(s) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>explicit</code>关键字只对接受一个实参的构造函数有效。</p><p>只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不能重复。</p><p>执行拷贝初始化时（使用<code>=</code>）会发生隐式转换，所以<code>explicit</code>构造函数只能用于直接初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// ok: direct initialization</span></span><br><span class="line"><span class="comment">// error: cannot use the copy form of initialization with an explicit constructor</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></table></figure><p>可以使用<code>explicit</code>构造函数显式地强制转换类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: the argument is an explicitly constructed Sales_data object</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">// ok: static_cast can use an explicit constructor</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure><hr><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>使用关键字<code>static</code>可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为<code>const</code>的，也不能在静态成员函数内使用<code>this</code>指针。</p><p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>(); <span class="comment">// access a static member using the scope operator</span></span><br><span class="line"></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// equivalent ways to call the static member rate function</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>(); <span class="comment">// through an Account object or reference</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">// through a pointer to an Account object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类外部定义静态成员时，不能重复<code>static</code>关键字，其只能用于类内部的声明语句。</p><p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define and initialize a static class member</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure><p>建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。</p><p>尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>。初始值必须是常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;  <span class="comment">// period is a constant</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态数据成员的类型可以是它所属的类类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Bar mem1;   <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2;    <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3;   <span class="comment">// error: data members must have complete type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用静态成员作为函数的默认实参。</p><hr><h3 id="static关键字详解"><a href="#static关键字详解" class="headerlink" title="static关键字详解"></a>static关键字详解</h3><p>从程序的存储上来看：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211112444578.png" alt="image-20211211112444578"></p><ol><li>正文段<br>CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是经常环境指针环境表环境字符串执行的程序(如文本编辑程序、C编译程序、s h e l l等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令。</li><li>初始化数据段<br>通常将此段称为数据段，它包含了程序中需赋初值的变量。初始化的全局变量和静态变量存放在这里。例如，C程序中任何函数之外的说明：int maxcount = 99; 使此变量以初值存放在初始化数据段中。<br>a.初始化的全局变量<br>b.初始化的静态变量</li><li>非初始化数据段<br>通常将此段称为bss段，这一名称来源于早期汇编程序的一个操作符，意思是“block started by symbol（由符号开始的块）”，未初始化的全局变量和静态变量存放在这里。在程序开始执行之前，内核将此段初始化为0。函数外的说明：long sum[1000] ; 使此变量存放在非初始化数据段中。<br>a.未初始化的全局变量<br>b.未初始化的静态变量</li><li>堆<br>需要由程序员分配释放管理，若程序员不释放，程序结束时可能由OS回收。通常在堆中进行动态存储分配。<br>如程序中的malloc, calloc, realloc等函数都从这里面分配。堆是从下向上分配的。</li><li>栈<br>由编译器自动分配释放管理。局部变量及每次函数调用时返回地址、以及调用者的环境信息（例如某些机器寄存器）都存放在栈中。新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C函数可以递归调用。递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响另一个函数调用实例中的变量。<br>a.局部变量<br>b.函数调用时返回地址<br>c.调用者的环境信息（例如某些机器寄存器）</li></ol><h4 id="c-中static用法："><a href="#c-中static用法：" class="headerlink" title="c++中static用法："></a>c++中static用法：</h4><p><strong>1、static 数据成员</strong></p><p>在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> a,b,c;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> Sum; <span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Myclass::Sum=<span class="number">0</span>; <span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"><span class="comment">//static int Myclass::Sum = 0; //注意加static， 是错误的</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> M.<span class="built_in">GetSum</span>(); <span class="comment">// cout 6</span></span><br><span class="line"></span><br><span class="line"> <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> N.<span class="built_in">GetSum</span>(); <span class="comment">// cout 21</span></span><br><span class="line"> M.<span class="built_in">GetSum</span>(); <span class="comment">// cout 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，static数据成员有以下特点：<br>(1). 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。</p><p>(2). 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。</p><p>在上例中，语句 int Myclass::Sum = 0; 是定义静态数据成员；</p><p>(3). 静态数据成员和普通数据成员一样遵从public, protected, private 访问规则；除了定义，定义不要管访问规则。</p><p>(4). 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</p><p>(5). 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</span></span><br><span class="line"><span class="type">int</span> Myclass::Sum=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>(6). 类的静态数据成员有两种 访问形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//＜类对象名＞.＜静态数据成员名＞</span></span><br><span class="line">M.Sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//＜类类型名＞::＜静态数据成员名＞</span></span><br><span class="line">Myclass::Sum = <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>但是上面这个例子是不行的，因为他是private的变量，如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；</p><p>(7). 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；</p><p>(8). 同全局变量相比，使用静态数据成员有两个优势：<br>a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；<br>b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</p><p><strong>2、static 成员函数</strong><br>  static 成员函数，它为类的全部对象服务而不是为某一个类的具体对象服务。普通的成员函数一般都隐含了一个this指针，但静态成员函数由于不是与任何的对象相联系，因此<strong>它不具有this指针</strong>。从这个意义上讲，<strong>它无法访问属于类对象的no-static数据成员，也无法访问no-static成员函数，它只能调用其余的静态成员函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c);</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetSum</span><span class="params">()</span></span>; /声明静态成员函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> a,b,c;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> Sum; <span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Myclass::Sum = <span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> Sum+=a+b+c; <span class="comment">//非静态成员函数可以访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void Myclass::GetSum()&#123;...&#125; //加上static是错误的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> <span class="comment">//静态成员函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl; <span class="comment">//静态函数是能访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> M.<span class="built_in">GetSum</span>();</span><br><span class="line"></span><br><span class="line"> <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> N.<span class="built_in">GetSum</span>();</span><br><span class="line"></span><br><span class="line"> Myclass::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于静态成员函数，可以总结为以下几点：</p><p>(1). 在类体外，静态函数的定义前不能加关键字static；</p><p>(2). static成员之间可以相互访问，包括static成员函数访问static数据成员和访问static成员函数；</p><p>(3). 非静态成员函数可以任意地访问静态成员函数和静态数据成员；</p><p>(4). 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的；</p><p>(5). 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</p><p>(6). 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)或直接用类名调用静态成员函数</p><p>M.GetSum();<br>Myclass::GetSum();调用类的静态成员函数。<br><strong>但是，一样 要遵从 public，protected，private 访问规则 。</strong></p><hr><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><h4 id="1-栈简介"><a href="#1-栈简介" class="headerlink" title="1.栈简介"></a>1.栈简介</h4><p>栈由操作系统自动分配释放 ，用于<strong>存放函数的参数值、局部变量等</strong>，其操作方式类似于数据结构中的栈。参考如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> b;<span class="comment">//栈</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//栈</span></span><br><span class="line"><span class="type">char</span> *p2;<span class="comment">//栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如上面代码中变量 s 的地址小于变量 b 的地址，p2 地址小于 s 的地址。<strong>栈中存储的数据的生命周期随着函数的执行完成而结束。</strong></p><h4 id="2-堆简介"><a href="#2-堆简介" class="headerlink" title="2. 堆简介"></a>2. 堆简介</h4><p>堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。参考如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// C 中用 malloc() 函数申请</span></span><br><span class="line"><span class="type">char</span>* p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">cout&lt;&lt;(<span class="type">int</span>*)p1&lt;&lt;endl;<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 free() 函数释放</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// C++ 中用 new 运算符申请</span></span><br><span class="line"><span class="type">char</span>* p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>*)p2 &lt;&lt; endl;<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 delete 运算符释放</span></span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 p1 所指的 10 字节的内存空间与 p2 所指的 10 字节内存空间都是存在于堆。堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，<strong>后申请的内存空间并不一定在先申请的内存空间的后面</strong>，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。<strong>堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。</strong></p><p>关于堆上内存空间的分配过程，首先应该知道<strong>操作系统有一个记录空闲内存地址的链表</strong>，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。**另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。(这就是为什么stl中pool_allocator更好的原因，可以节省一些存放分配大小的首地址的开销)**由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。</p><p>1.3 堆与栈区别<br>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p><p>（2）空间大小不同。<strong>每个进程拥有的栈大小要远远小于堆大小。</strong>理论上，进程可申请的堆大小为<strong>虚拟内存</strong>大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p><p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p><p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloc()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。</p><p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p><p>（6）存放内容不同。栈存放的内容，<strong>函数返回地址、相关参数、局部变量和寄存器内容等。</strong>当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p><p>从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p><p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第七章-类&quot;&gt;&lt;a href=&quot;#第七章-类&quot; class=&quot;headerlink&quot; title=&quot;第七章 类&quot;&gt;&lt;/a&gt;第七章 类&lt;/h2&gt;&lt;h3 id=&quot;成员函数&quot;&gt;&lt;a href=&quot;#成员函数&quot; class=&quot;headerlink&quot; title=&quot;成员函数&quot;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第六章-函数</title>
    <link href="http://icecorn.github.io/2022/02/23/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
    <id>http://icecorn.github.io/2022/02/23/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/</id>
    <published>2022-02-23T12:25:30.000Z</published>
    <updated>2022-06-29T12:56:42.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h2><h4 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h4><p>使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。</p><p>除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。</p><p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p><p>一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。</p><hr><h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h4><p>当形参有顶层<code>const</code>时，传递给它常量对象或非常量对象都是可以的。</p><p>可以使用非常量对象初始化一个底层<code>const</code>形参，但是反过来不行。</p><p>把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。</p><p><strong>所以，“不变”的参数一定要记得加上const</strong></p><hr><h4 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h4><p>因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each function has a single parameter of type const int*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;    <span class="comment">// shows the intent that the function takes an array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// dimension for documentation purposes (at best)</span></span><br></pre></td></tr></table></figure><p>因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。</p><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。</p><p>以数组作为形参的函数必须确保使用数组时不会越界。</p><p>如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。</p><p>形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。</p><p>将多维数组传递给函数时，数组第二维（以及后面所有维度）的大小是数组类型的一部分，不能省略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span> &amp;arr[<span class="number">10</span>])     <span class="comment">// error: declares arr as an array of references</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">// ok: arr is a reference to an array of ten ints</span></span><br></pre></td></tr></table></figure><hr><h4 id="关于函数返回引用"><a href="#关于函数返回引用" class="headerlink" title="关于函数返回引用"></a>关于函数返回引用</h4><p><strong>调用一个返回引用的函数会得到左值，其他返回类型得到右值。</strong></p><ul><li><p>如果返回的是引用的话，是可以当作左值来使用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> error=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">0</span>&amp;&amp;n&lt;=<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">return</span> value[n];<span class="comment">//返回的引用所绑定的变量一定是全局变量，不能是函数中定义的局部变量 </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>)=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">4</span>)=<span class="number">12</span>;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">4</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++函数返回的步骤是：<br>1、一般情况下计算结果保存在某个局部变量内，上面的程序，结果保存在变量 result 内。<br>2、return result 的时候，result 的值会“复制” 到一个临时变量中，假设变量名为 temp，即执行 temp = result，然后，函数生命周期结束。<br>3、最后， 主程序把 temp 变量的值“复制”到目标变量中，例如：x4 = temp。</p><p>这里面有两次“复制”过程，因此需要构造temp和目标变量。有些编译器会自动优化，甚至只需要构造一次 result 就解决问题了。这样虽然效率提高了很多，但是这样的源代码却不合适，因为换成其他的编译器可能效率就低下来了。</p></li></ul><p><strong>引用作为函数的返回值</strong></p><ol><li>引用作为函数的返回值时，<strong>必须在定义函数时在函数名前将&amp;</strong></li><li>用引用作函数的返回值的<strong>最大的好处是在内存中不产生返回值的副本</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来源：RUNOOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">float</span> temp;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">fn1</span><span class="params">(<span class="type">float</span> r)</span></span>&#123;</span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">fn2</span><span class="params">(<span class="type">float</span> r)</span></span>&#123; <span class="comment">//&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span></span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> a=<span class="built_in">fn1</span>(<span class="number">5.0</span>); <span class="comment">//case 1：返回值</span></span><br><span class="line">    <span class="comment">//float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type &#x27;float&amp;&#x27; from an rvalue of type &#x27;float&#x27;</span></span><br><span class="line">                           <span class="comment">//（有些编译器可以成功编译该语句，但会给出一个warning） </span></span><br><span class="line">    <span class="type">float</span> c=<span class="built_in">fn2</span>(<span class="number">5.0</span>);<span class="comment">//case 3：返回引用</span></span><br><span class="line">    <span class="type">float</span> &amp;d=<span class="built_in">fn2</span>(<span class="number">5.0</span>);<span class="comment">//case 4：用函数返回的引用作为新引用的初始化值</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;<span class="comment">//78.5</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;b&lt;&lt;endl;//78.5</span></span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;<span class="comment">//78.5</span></span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;<span class="comment">//78.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>case 1：用返回值方式调用函数（如下图，图片来源：伯乐在线）：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629205624210.png" alt="image-20220629205624210"></p><p><strong>返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a</strong></p><p><strong>case 2：用函数的返回值初始化引用的方式调用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209234547708.png" alt="image-20211209234547708"></p><p><strong>这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &amp;b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。</strong></p><p> <strong>如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="built_in">fn1</span>(<span class="number">5.0</span>);</span><br><span class="line"><span class="type">int</span> &amp;b=x;</span><br></pre></td></tr></table></figure><p><strong>case 3:用返回引用的方式调用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209234927791.png" alt="image-20211209234927791"></p><p><strong>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。</strong></p><p><strong>case 4:用函数返回的引用作为新引用的初始化值的方式来调用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209235138829.png" alt="image-20211209235138829"></p><p><strong>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。（注意看上边的代码，在最上边声明了全局变量temp，所以是ok的，但是如果temp是函数里的局部变量的话，它就会在函数结束时被析构掉，这时候d就变成了未定义的引用了，危险！）</strong></p><ol start="3"><li><p><strong>不能返回局部变量的引用。</strong>如上面的例子，如果temp是局部变量，那么它会在函数返回后被销毁，此时对temp的引用就会成为“无所指”的引用，程序会进入未知状态。</p></li><li><p><strong>不能返回函数内部通过new分配的内存的引用</strong>。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生</p></li><li><p><strong>当返回类成员的引用时，最好是const引用</strong>。这样可以避免在无意的情况下破坏该类的成员。</p></li></ol><p>到这里的，用引用做返回值的情况就比较清晰了，接下来要弄清楚上边的各种变量是存在哪里的（堆还是栈），还有关于右值引用和move方法。</p><h4 id="用引用实现多态"><a href="#用引用实现多态" class="headerlink" title="用引用实现多态"></a><strong>用引用实现多态</strong></h4><p>在C++中，<strong>引用是除了指针外另一个可以产生多态效果的手段</strong>。也就是说一个基类的引用可以用来绑定其派生类的实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>;<span class="comment">//基类（父类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>：<span class="keyword">public</span> Father&#123;.....&#125;<span class="comment">//Son是Father的派生类</span></span><br><span class="line">Son son;<span class="comment">//son是类Son的一个实例</span></span><br><span class="line">Father &amp;ptr=son;<span class="comment">//用派生类的对象初始化基类对象的使用</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong></p><p><strong>ptr只能用来访问派生类对象中从基类继承下来的成员</strong>。<strong>如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。</strong></p><p> 这里就和java是一样的，通过父类引用指向子类对象来实现多态</p><hr><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>如果形参是某种类型的指针或引用，则通过区分其指向的对象是常量还是非常量可以实现函数重载，此时的<code>const</code>是底层的。当我们传递给重载函数一个非常量对象或者指向非常量对象的指针时，<strong>编译器会优先选用非常量版本的函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions taking const and nonconst references or pointers have different parameters</span></span><br><span class="line"><span class="comment">// declarations for four independent, overloaded functions</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;        <span class="comment">// function that takes a reference to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;  <span class="comment">// new function that takes a const reference</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;        <span class="comment">// new function, takes a pointer to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account*)</span></span>;  <span class="comment">// new function, takes a pointer to const</span></span><br></pre></td></tr></table></figure><p><code>const_cast</code>可以用于函数的重载。当函数的实参不是常量时，将得到普通引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a reference to the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                    <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数匹配（function matching）也叫做重载确定（overload resolution），是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。</p><p>调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</li><li>编译器找不到任何一个函数与实参匹配，发出无匹配（no match）的错误信息。</li><li>有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用（ambiguous call）的错误信息。</li></ul><hr><h4 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h4><p><strong>默认实参</strong></p><p>默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="type">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p><p>如果想使用默认实参，只要在调用函数的时候省略该实参即可。</p><p>虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no default for the height or width parameters</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;      <span class="comment">// error: redeclaration</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;  <span class="comment">// ok: adds default</span></span><br></pre></td></tr></table></figure><p>默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Error: 编译器向前查找函数声明</span></span><br><span class="line">    <span class="comment">//        fun调用形式与声明不符</span></span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>局部变量不能作为函数的默认实参。</p><p>用作默认实参的名字在函数声明所在的作用域内解析，但名字的求值过程发生在函数调用时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the declarations of wd, def, and ht must appear outside a function</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="type">char</span> = def)</span></span>;</span><br><span class="line">string window = <span class="built_in">screen</span>();   <span class="comment">// calls screen(ht(), 80, &#x27; &#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;      <span class="comment">// changes the value of a default argument</span></span><br><span class="line">    sz wd = <span class="number">100</span>;    <span class="comment">// hides the outer definition of wd but does not change the</span></span><br><span class="line">    <span class="keyword">default</span></span><br><span class="line">    window = <span class="built_in">screen</span>();  <span class="comment">// calls screen(ht(), 80, &#x27;*&#x27;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h4><p>内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字<code>inline</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline version: find the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">horterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数声明和定义中都能使用关键字<code>inline</code>，但是建议只在函数定义时使用。</p><p>一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。<strong>内联函数中不允许有循环语句和<code>switch</code>语句，否则函数会被编译为普通函数。</strong></p><p><strong>为什么要有内联函数，内联函数有什么用？</strong></p><p>因为，在大多数机器上，调用函数都要做很多的工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新的位置来执行。而内联函数的目的就是提高函数的执行效率，用关键字 inline 放在函数定义的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开。假设我们将 max 定义为内联函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">则调用： cout&lt;&lt;<span class="built_in">max</span>(a, b)&lt;&lt;endl;</span><br><span class="line">在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;</span><br><span class="line">从而消除了把max写成函数的额外开销。</span><br></pre></td></tr></table></figure><p>定义在类声明之中的成员函数将自动的成为内联函数</p><p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p><p>当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p><blockquote><p>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p><p>定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.<br>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.<br>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。<br>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!<br>另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).<br>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p></blockquote><hr><p><code>constexpr</code>函数是指能用于常量表达式的函数。<code>constexpr</code>函数的返回类型及所有形参的类型都得是字面值类型。另外C++11标准要求<code>constexpr</code>函数体中必须有且只有一条<code>return</code>语句，但是此限制在C++14标准中被删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();   <span class="comment">// ok: foo is a constant expression</span></span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数的返回值可以不是一个常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scale(arg) is a constant expression if arg is a constant expression</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];  <span class="comment">// ok: scale(2) is a constant expression</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;          <span class="comment">// i is not a constant expression</span></span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];   <span class="comment">// error: scale(i) is not a constant expression</span></span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数被隐式地指定为内联函数。</p><p>和其他函数不同，内联函数和<code>constexpr</code>函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或<code>constexpr</code>函数，它的多个定义必须完全一致。因此内联函数和<code>constexpr</code>函数通常定义在头文件中。</p><p><strong>调试帮助</strong></p><table><thead><tr><th align="center">变量名称</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center"><code>__func__</code></td><td align="center">当前函数名称</td></tr><tr><td align="center"><code>__FILE__</code></td><td align="center">当前文件名称</td></tr><tr><td align="center"><code>__LINE__</code></td><td align="center">当前行号</td></tr><tr><td align="center"><code>__TIME__</code></td><td align="center">文件编译时间</td></tr><tr><td align="center"><code>__DATE__</code></td><td align="center">文件编译日期</td></tr></tbody></table><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compares lengths of two strings</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf points to a function returning bool that takes two const string references</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;); <span class="comment">// uninitialized</span></span><br></pre></td></tr></table></figure><p>可以直接使用指向函数的指针来调用函数，无须提前解引用指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">// pf now points to the function named lengthCompare</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// equivalent assignment: address-of operator is optional</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);       <span class="comment">// calls lengthCompare</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);    <span class="comment">// equivalent call</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);    <span class="comment">// equivalent call</span></span><br></pre></td></tr></table></figure><p>对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff; <span class="comment">// pf1 points to ff(unsigned)</span></span><br></pre></td></tr></table></figure><p> 可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// automatically converts the function lengthCompare to a pointer to function</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure><p>关键字<code>decltype</code>作用于函数时，返回的是函数类型，而不是函数指针类型。</p><p>函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。</p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六章-函数&quot;&gt;&lt;a href=&quot;#第六章-函数&quot; class=&quot;headerlink&quot; title=&quot;第六章 函数&quot;&gt;&lt;/a&gt;第六章 函数&lt;/h2&gt;&lt;h4 id=&quot;传引用参数&quot;&gt;&lt;a href=&quot;#传引用参数&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第四章-表达式</title>
    <link href="http://icecorn.github.io/2022/02/21/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://icecorn.github.io/2022/02/21/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-21T12:25:30.000Z</published>
    <updated>2022-06-29T12:53:37.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h2><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。</p><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>C++的表达式分为右值（rvalue）和左值（lvalue）。当一个对象被用作右值的时候，用的是<strong>对象的值（内容）</strong>；当对象被用作左值时，用的是<strong>对象的地址</strong>。<strong>需要右值的地方可以用左值代替，反之则不行。</strong></p><ul><li>赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。</li><li>取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。</li><li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符都返回左值。</li><li>内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。</li></ul><p>如果<code>decltype</code>作用于一个求值结果是左值的表达式，会得到引用类型。</p><p><strong>深度理解左值和右值</strong></p><p>​        在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p><p><strong>右值、将亡值</strong><br>        在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。</p><p>​        C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</p><p>​        将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p><p><strong>左值引用、右值引用</strong><br>        左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p><p>​        右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p><p>​        左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure><p>​        右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line"><span class="type">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  # 编译通过</span><br><span class="line">下表列出了在C++<span class="number">11</span>中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209212749197.png" alt="image-20211209212749197"></p><hr><h4 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h4><p><strong>逻辑运算符注意事项</strong></p><p>逻辑与（logical AND）运算符<code>&amp;&amp;</code>和逻辑或（logical OR）运算符<code>||</code>都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。</p><ul><li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li><li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li></ul><p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值<code>true</code>和<code>false</code>作为运算对象。</p><hr><p><strong>递增和递减运算符</strong></p><p>递增和递减运算符分为前置版本和后置版本：</p><ul><li>前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。</li><li>后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;    <span class="comment">// j = 1, i = 1: prefix yields the incremented value</span></span><br><span class="line">j = i++;    <span class="comment">// j = 1, i = 2: postfix yields the unincremented value</span></span><br></pre></td></tr></table></figure><p>除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。</p><p>在某些语句中混用解引用和递增运算符可以使程序更简洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>因为后置++返回的是值而非引用，所以 ++++i可以，而i++++不可以。</strong></p><hr><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p><code>sizeof</code>运算符返回一个表达式或一个类型名字所占的字节数，返回值是<code>size_t</code>类型。</p><p>在<code>sizeof</code>的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。</p><p><code>sizeof</code>运算符的结果部分依赖于其作用的类型：</p><ul><li><p>对<code>char</code>或者类型为<code>char</code>的表达式执行<code>sizeof</code>运算，返回值为1。</p></li><li><p>对引用类型执行<code>sizeof</code>运算得到被引用对象所占空间的大小。</p></li><li><p>对指针执行<code>sizeof</code>运算得到指针本身所占空间的大小。</p></li><li><p>对解引用指针执行<code>sizeof</code>运算得到指针指向的对象所占空间的大小，指针不需要有效。</p></li><li><p>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小。</p></li><li><p>对<code>string</code>或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</p><p><strong>就是说对于sizeof(vector)应该等于24，因为vector内有3个指针</strong></p></li></ul><hr><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。</p><p><strong>算术转换</strong></p><p>把一种算术类型转换成另一种算术类型叫做算术转换。</p><p>整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。</p><p><strong>其他隐式类型转换</strong></p><p>在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</p><p>常量整数值0或字面值<code>nullptr</code>能转换成任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code>。</p><p>任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是<code>false</code>，否则是<code>true</code>。</p><p>指向非常量类型的指针能转换成指向相应的常量类型的指针。</p><p><strong>显式转换</strong></p><p>显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。</p><p>命名的强制类型转换（named cast）形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure><p>其中<em>type</em>是转换的目标类型，<em>expression</em>是要转换的值。如果<em>type</em>是引用类型，则转换结果是左值。<em>cast-name</em>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种，用来指定转换的方式。</p><ul><li><code>dynamic_cast</code>支持运行时类型识别。</li><li>任何具有明确定义的类型转换，只要不包含底层<code>const</code>（数据是常量，比如const int），都能使用<code>static_cast</code>。</li><li><code>const_cast</code>只能改变运算对象的底层<code>const</code>，不能改变表达式的类型。同时也只有<code>const_cast</code>能改变表达式的常量属性。<code>const_cast</code>常常用于函数重载。</li><li><code>reinterpret_cast</code>通常为运算对象的位模式提供底层上的重新解释。</li></ul><p>早期版本的C++语言中，显式类型转换包含两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> (expression);    <span class="comment">// function-style cast notation</span></span><br><span class="line">(type) expression;    <span class="comment">// C-language-style cast notation</span></span><br></pre></td></tr></table></figure><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四章-表达式&quot;&gt;&lt;a href=&quot;#第四章-表达式&quot; class=&quot;headerlink&quot; title=&quot;第四章 表达式&quot;&gt;&lt;/a&gt;第四章 表达式&lt;/h2&gt;&lt;h4 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第三章-字符串，向量和数组</title>
    <link href="http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2022-02-20T12:25:30.000Z</published>
    <updated>2022-06-29T12:52:21.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-字符串-向量和数组"><a href="#第三章-字符串-向量和数组" class="headerlink" title="第三章 字符串,向量和数组"></a>第三章 字符串,向量和数组</h2><h3 id="关于string的注意点："><a href="#关于string的注意点：" class="headerlink" title="关于string的注意点："></a>关于string的注意点：</h3><ol><li><p><code>size</code>函数返回<code>string</code>对象的长度，返回值是<code>string::size_type</code>类型，这是一种无符号类型。要使用<code>size_type</code>，必须先指定它是由哪种类型定义的。</p></li><li><p>当把<code>string</code>对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是<code>string</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span>;          <span class="comment">// ok: adding a string and a literal</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>;     <span class="comment">// error: no string operand</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;    <span class="comment">// ok: each + has a string operand</span></span><br></pre></td></tr></table></figure></li><li><p>其实是变量生命周期的问题，在这里记录一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="built_in">string</span>(<span class="string">&quot;string1&quot;</span>); </span><br><span class="line"></span><br><span class="line">string s2 = <span class="built_in">string</span>(<span class="string">&quot;string2&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = s1.<span class="built_in">substr</span>(<span class="number">1</span>).<span class="built_in">data</span>();    <span class="comment">// substr(1)的意思是取[字符串]从下标1到结尾的部分 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p2 = s2.<span class="built_in">substr</span>(<span class="number">1</span>).<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这里输出应该是tring1tring2，却输出了tring2tring2。这是因为s1.substr(1)创建了一个临时对象来存储s1的字串，然后data()获取这个子串内存的指针赋值给p1。但是到下一行，编译器发现刚才的临时对象没用了，就把它析构掉了（注意，析构表明cpu重新获得这块内存的分配权，但是里边的信息01状态不会改变），然后p2进行一样的操作，刚好s2.substr()又分配到了这块内存空间，这就导致最后的结果是p1p2都指向这块内存，而这块内存是tring2！</p><p><strong>所以，在使用接口函数时一定要注意返回值是什么，而且编程时要注意对象的生命周期！</strong> </p></li></ol><hr><h3 id="vector使用注意："><a href="#vector使用注意：" class="headerlink" title="vector使用注意："></a>vector使用注意：</h3><p><code>vector</code>和<code>string</code>对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;   <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)</span><br><span class="line">&#123;</span><br><span class="line">    ivec[ix] = ix;  <span class="comment">// disaster: ivec has no elements</span></span><br><span class="line">    ivec.<span class="built_in">push_back</span>(ix); <span class="comment">// ok: adds a new element with value ix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector原理见stl笔记</p><hr><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><p>数组类似<code>vector</code>，但数组的大小确定不变，不能随意向数组中添加元素。</p><p>如果不清楚元素的确切个数，应该使用<code>vector</code>。</p><h4 id="定义和初始化内置数组（Defining-and-Initializing-Built-in-Arrays）"><a href="#定义和初始化内置数组（Defining-and-Initializing-Built-in-Arrays）" class="headerlink" title="定义和初始化内置数组（Defining and Initializing Built-in Arrays）"></a>定义和初始化内置数组（Defining and Initializing Built-in Arrays）</h4><p>数组是一种复合类型，声明形式为<code>a[d]</code>，其中<em>a</em>是数组名称，<em>d</em>是数组维度（dimension）。维度必须是一个常量表达式。</p><p>默认情况下，数组的元素被默认初始化。</p><p>定义数组的时候必须指定数组的类型，不允许用<code>auto</code>关键字由初始值列表推断类型。</p><p>如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但如果显式指明了维度，那么初始值的数量不能超过指定的大小。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;  <span class="comment">// array of three ints with values 0, 1, 2</span></span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;   <span class="comment">// an array of dimension 3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br><span class="line">string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;;   <span class="comment">// same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;    <span class="comment">// error: too many initializers</span></span><br></pre></td></tr></table></figure><p>可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;        <span class="comment">// list initialization, no null</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">// list initialization, explicit null</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;      <span class="comment">// null terminator added automatically</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>;    <span class="comment">// error: no space for the null!</span></span><br></pre></td></tr></table></figure><p>不能用一个数组初始化或直接赋值给另一个数组。</p><p>从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];              <span class="comment">// ptrs is an array of ten pointers to int</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;    <span class="comment">// error: no arrays of references</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">// Parray points to an array of ten ints</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">// arrRef refers to an array of ten ints</span></span><br></pre></td></tr></table></figure><h4 id="访问数组元素（Accessing-the-Elements-of-an-Array）"><a href="#访问数组元素（Accessing-the-Elements-of-an-Array）" class="headerlink" title="访问数组元素（Accessing the Elements of an Array）"></a>访问数组元素（Accessing the Elements of an Array）</h4><p>数组下标通常被定义成<code>size_t</code>类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。<code>size_t</code>定义在头文件<em>cstddef</em>中。</p><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h4 id="指针和数组（Pointers-and-Arrays）"><a href="#指针和数组（Pointers-and-Arrays）" class="headerlink" title="指针和数组（Pointers and Arrays）"></a>指针和数组（Pointers and Arrays）</h4><p>在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;    <span class="comment">// array of strings</span></span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];   <span class="comment">// p points to the first element in nums</span></span><br><span class="line">string *p2 = nums;      <span class="comment">// equivalent to p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure><p><em><em>这里刚好可以说明一下指针和引用的区别，为什么要有引用这个东西。比如有一个长度为10的数组arr，要改变第五个元素，arr[4] = 0；就可以直接改，这里的arr[4]就是引用，表述起来比较方便，想一下如果要用指针表述的话，就是</em>(&amp;arr[4]) = 0;更复杂的情况会更繁琐，这可能是引用出现的一个因素吧</em>*</p><p>当使用数组作为一个<code>auto</code>变量的初始值时，推断得到的类型是指针而非数组。但<code>decltype</code>关键字不会发生这种转换，直接返回数组类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;   <span class="comment">// ia2 is an int* that points to the first element in ia</span></span><br><span class="line">ia2 = <span class="number">42</span>;       <span class="comment">// error: ia2 is a pointer, and we can&#x27;t assign an int to a pointer</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>;   <span class="comment">// now it&#x27;s clear that ia2 has type int*</span></span><br><span class="line"><span class="comment">// ia3 is an array of ten ints</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ia3 = p;    <span class="comment">// error: can&#x27;t assign an int* to an array</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;     <span class="comment">// ok: assigns the value of i to an element in ia3</span></span><br></pre></td></tr></table></figure><p>C++11在头文件<em>iterator</em>中定义了两个名为<code>begin</code>和<code>end</code>的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;   // ia is an array of ten ints</span><br><span class="line">int *beg = begin(ia);   // pointer to the first element in ia</span><br><span class="line">int *last = end(ia);    // pointer one past the last element in ia</span><br></pre></td></tr></table></figure><p>两个指针相减的结果类型是<code>ptrdiff_t</code>，这是一种定义在头文件<em>cstddef</em>中的带符号类型。</p><p><strong>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。</strong></p><hr><h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><p>C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。</p><p>C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库<code>string</code>要比使用C风格字符串更加安全和高效。</p><p>C风格字符串函数不负责验证其参数的正确性，<strong>传入此类函数的指针必须指向以空字符作为结尾的数组。</strong></p><hr><h4 id="与旧代码的接口（Interfacing-to-Older-Code）"><a href="#与旧代码的接口（Interfacing-to-Older-Code）" class="headerlink" title="与旧代码的接口（Interfacing to Older Code）"></a>与旧代码的接口（Interfacing to Older Code）</h4><p>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：</p><ul><li>允许使用以空字符结束的字符数组来初始化<code>string</code>对象或为<code>string</code>对象赋值。</li><li>在<code>string</code>对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。</li><li>在<code>string</code>对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。</li></ul><p>不能用<code>string</code>对象直接初始化指向字符的指针。为了实现该功能，<code>string</code>提供了一个名为<code>c_str</code>的成员函数，返回<code>const char*</code>类型的指针，指向一个以空字符结束的字符数组，数组的数据和<code>string</code>对象一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    <span class="comment">// s holds Hello World</span></span><br><span class="line"><span class="type">char</span> *str = s;  <span class="comment">// error: can&#x27;t initialize a char* from a string</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>针对<code>string</code>对象的后续操作有可能会让<code>c_str</code>函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p><p>可以使用数组来初始化<code>vector</code>对象，但是需要指明要拷贝区域的首元素地址和尾后地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure><p>在新版本的C++程序中应该尽量使用<code>vector</code>、<code>string</code>和迭代器，避免使用内置数组、C风格字符串和指针。</p><h3 id="多维数组（Multidimensional-Arrays）"><a href="#多维数组（Multidimensional-Arrays）" class="headerlink" title="多维数组（Multidimensional Arrays）"></a>多维数组（Multidimensional Arrays）</h3><p>C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。</p><p>多维数组初始化的几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] =</span><br><span class="line">&#123;   <span class="comment">// three elements; each element is an array of size 4</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,   <span class="comment">// initializers for the row indexed by 0</span></span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,   <span class="comment">// initializers for the row indexed by 1</span></span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;  <span class="comment">// initializers for the row indexed by 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// equivalent initialization without the optional nested braces for each row</span></span><br><span class="line"><span class="type">int</span> ib[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// explicitly initialize only element 0 in each row</span></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125;&#125;;</span><br><span class="line"><span class="comment">// explicitly initialize row 0; the remaining elements are value initialized</span></span><br><span class="line"><span class="type">int</span> id[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assigns the first element of arr to the last element in the last row of ia</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];  <span class="comment">// binds row to the second four-element array in ia</span></span><br></pre></td></tr></table></figure><p>使用范围<code>for</code>语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia)  <span class="comment">// for every element in the outer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)    <span class="comment">// for every element in the inner array</span></span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>如果<em>row</em>不是引用类型，编译器初始化<em>row</em>时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的<em>row</em>就是<code>int*</code>类型，而之后的内层循环则试图在一个<code>int*</code>内遍历，程序将无法通过编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure><p>使用范围<code>for</code>语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。</p><p>因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];       <span class="comment">// array of size 3; each element is an array of ints of size 4</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>] = ia;   <span class="comment">// p points to an array of four ints</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];         <span class="comment">// p now points to the last element in ia</span></span><br></pre></td></tr></table></figure><p>声明指向数组类型的指针时，必须带有圆括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>];     <span class="comment">// array of pointers to int</span></span><br><span class="line"><span class="built_in">int</span> (*ip)[<span class="number">4</span>];   <span class="comment">// pointer to an array of four ints</span></span><br></pre></td></tr></table></figure><p>使用<code>auto</code>和<code>decltype</code>能省略复杂的指针定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print the value of each element in ia, with each inner array on its own line</span></span><br><span class="line"><span class="comment">// p points to an array of four ints</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// q points to the first element of an array of four ints; that is, q points to an int</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三章-字符串-向量和数组&quot;&gt;&lt;a href=&quot;#第三章-字符串-向量和数组&quot; class=&quot;headerlink&quot; title=&quot;第三章 字符串,向量和数组&quot;&gt;&lt;/a&gt;第三章 字符串,向量和数组&lt;/h2&gt;&lt;h3 id=&quot;关于string的注意点：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第二章-变量和基本类型</title>
    <link href="http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-02-20T12:25:30.000Z</published>
    <updated>2022-06-29T11:37:00.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>如果定义变量时未指定初值，则变量被默认初始化（default initialized）。</p><p>对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。</p><p>所以类里边的成员变量一定要初始化，不然会有未定义的结果</p><hr><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明（declaration）使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。(<strong>不分配内存</strong>)</p><p>定义（definition）负责创建与名字相关联的实体。（<strong>分配内存，不一定初始化</strong>）</p><p>如果想声明一个变量而不定义它，就在变量名前添加关键字<code>extern</code>，并且不要显式地初始化变量。</p><p><strong>总结：除了用extern修饰变量，其他的声明都是定义。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="type">int</span> j;      <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure><p><code>extern</code>语句如果包含了初始值就不再是声明了，而变成了定义。</p><p>变量能且只能被定义一次，但是可以被声明多次。</p><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p><h4 id="extern用法详解"><a href="#extern用法详解" class="headerlink" title="extern用法详解"></a>extern用法详解</h4><ol><li><p><strong>extern修饰变量的声明</strong>：</p><p>主要使用的情况是，不同的文件中都需要用到这个变量X（大多数情况是全局变量），而且，extern声明的变量可以在文件中的任何地方声明。</p><p><strong>总结：其实就是类似一个引用的手法，在一个项目中只在某一个地方<code>int x = 1;</code>声明加定义（开辟一块内存），这样在其他地方用到这个变量，只需要<code>extern int x；</code>就相当于获得了这个变量的引用，接下来的程序就可以用了。</strong></p></li><li><p><strong>extern修饰函数声明：</strong></p><p>本质的看，变量和函数没有区别，函数名是指向函数二进制块开头处的指针。也就是说extern在这里，也是一样的，如果A文件中有一个函数<code>int fun()</code>,那么想在B文件里用它，就可以<code>extern int fun()</code>就可以用了。</p><p><em>使用extern和包含头文件引用函数有什么区别呢？</em></p><p><strong>用extern更简洁，想用哪个函数就extern哪个，而不用整体include</strong>，另外的还可以<strong>加速程序的编译</strong>，因为不需要编译不要用到的函数了嘛！</p></li><li><p><strong>extern还可用于指示C或者C++的调用规范：</strong></p><p>比如在C++中调用C的函数，就需要在C++代码中用extern声明要引入的C库函数。这是给<strong>链接器</strong>看的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。</p></li></ol><blockquote><p>用C语言编写程序的时候，我们经常会遇到这样一种情况：<strong>希望在头文件中定义一个全局变量，然后包含到两个不同的c文件中，希望这个全局变量能在两个文件中共用。</strong></p></blockquote><blockquote><p>举例说明：项目文件夹project下有main.c、common.c和common.h三个文件，其中<br>common.h文件分别#include在main.c和common.c文件中。现在希望声明一个字符型变量key，在main.c和common.c中公用。如下图所示：<br>有人想，既然是想两个文件都用，那就在common.h中声明一个unsigned char key，然后由于包含关系，在main.c和common.c中都是可见的，所以就能共用了。<br>这种想法其实是很多初学者都会想到的，想起来确实有道理，但是实际写出来，我们发现编译的时候编译器提示出错，一般提示大概都类似于：Error: L6200E: Symbol key multiply defined (by common.o and main.o). 也就是说编译器认为我们重复定义了key这个变量。这是因为#include命令就是原封不同的把头文件中的内容搬到#include的位置，所以相当于main.c和common.c中都执行了一次unsigned char key，而C语言中全局变量是项目内（或者叫工程内）可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义。<br>正确的解决办法：使用extern关键字来声明变量为外部变量。具体说就是在其中一个c文件中定义一个全局变量key，然后在另一个要使用key这个变量的c文件中使用extern关键字声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：定义和声明。例如在main.c文件中定义变量key，在common.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了。</p></blockquote><hr><h3 id="标识符和名字的作用域"><a href="#标识符和名字的作用域" class="headerlink" title="标识符和名字的作用域"></a>标识符和名字的作用域</h3><p><strong>标识符：</strong></p><p>C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</p><p><strong>名字的作用域</strong></p><p>定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。</p><p>最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。</p><p>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。</p><p>可以用作用域操作符<code>::</code>来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Program for illustration purposes only: It is bad style for a function</span></span><br><span class="line"><span class="comment">// to use a global variable and also define a local variable with the same name</span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>;    <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">    <span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">    <span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。</strong></p><p><strong>总结：内部作用域可以用外部的变量，反之不行，内部作用域会覆盖同名外部作用域。可以用：：选择作用域中的变量。</strong></p><hr><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="引用（References）"><a href="#引用（References）" class="headerlink" title="引用（References）"></a>引用（References）</h4><p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<em>d</em>是变量名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">// refVal refers to (is another name for) ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;       <span class="comment">// error: a reference must be initialized</span></span><br></pre></td></tr></table></figure><p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。</p><p>引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。</p><p>声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。</p><p>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</p><h4 id="指针（Pointer）"><a href="#指针（Pointer）" class="headerlink" title="指针（Pointer）"></a>指针（Pointer）</h4><p>与引用类似，指针也实现了对其他对象的间接访问。</p><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。</li><li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li></ul><p>通过将声明符写成<code>*d</code>的形式来定义指针类型，其中<em>d</em>是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号<code>*</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;     <span class="comment">// both ip1 and ip2 are pointers to int</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;    <span class="comment">// dp2 is a pointer to double; dp is a double</span></span><br></pre></td></tr></table></figure><p>指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符<code>&amp;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br></pre></td></tr></table></figure><p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p><p>声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。</p><p>指针的值（即地址）应属于下列状态之一：</p><ul><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，即指针没有指向任何对象。</li><li>无效指针，即上述情况之外的其他值。</li></ul><p>试图拷贝或以其他方式访问无效指针的值都会引发错误。</p><p>如果指针指向一个对象，可以使用解引用（dereference）符<code>*</code>来访问该对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br><span class="line">cout &lt;&lt; *p;     <span class="comment">// * yields the object to which p points; prints 42</span></span><br></pre></td></tr></table></figure><p>给解引用的结果赋值就是给指针所指向的对象赋值。</p><p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p><strong>空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值<code>nullptr</code>来初始化指针。</strong></p><p>旧版本程序通常使用<code>NULL</code>（预处理变量，定义于头文件<em>cstdlib</em>中，值为0）给指针赋值，但在C++11中，最好使用<code>nullptr</code>初始化空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;  <span class="comment">// equivalent to int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;        <span class="comment">// directly initializes p2 from the literal constant 0</span></span><br><span class="line"><span class="comment">// must #include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;     <span class="comment">// equivalent to int *p3 = 0;</span></span><br></pre></td></tr></table></figure><p>建议初始化所有指针。</p><p><code>void*</code>是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作<code>void*</code>指针所指的对象。</p><h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>指向指针的指针（Pointers to Pointers）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;    <span class="comment">// pi points to an int</span></span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;    <span class="comment">// ppi points to a pointer to an int</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211207145225233.png" alt="image-20211207145225233"></p><p>指向指针的引用（References to Pointers）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;         <span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;    <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line">r = &amp;i;         <span class="comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span></span><br><span class="line">*r = <span class="number">0</span>;         <span class="comment">// dereferencing r yields i, the object to which p points; changes i to 0</span></span><br></pre></td></tr></table></figure><p><strong>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。</strong></p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>在变量类型前添加关键字<code>const</code>可以创建值不能被改变的对象。**<code>const</code>变量必须被初始化。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;    <span class="comment">// input buffer size</span></span><br><span class="line">bufSize = <span class="number">512</span>;      <span class="comment">// error: attempt to write to const object</span></span><br></pre></td></tr></table></figure><p><strong>默认情况下，<code>const</code>对象被设定成仅在文件内有效。当多个文件中出现了同名的<code>const</code>变量时，其实等同于在不同文件中分别定义了独立的变量。</strong></p><p>如果想在多个文件间共享<code>const</code>对象：</p><ul><li><p>若<code>const</code>对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。</p></li><li><p>若<code>const</code>对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时<code>const</code>变量的声明和定义前都应该添加<code>extern</code>关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;   <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><p>把引用绑定在<code>const</code>对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。<strong>这里其实就是因为不能用引用来修改原来是const的变量的值，所以不能有非const的引用，我一个本尊都不能修改，能让你一个假身（引用）修改嘛？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;     <span class="comment">// ok: both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>;        <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;   <span class="comment">// error: non const reference to a const object</span></span><br></pre></td></tr></table></figure><p><strong>大部分情况下，引用的类型要和与之绑定的对象严格匹配。</strong>但是有两个例外：</p><ul><li><p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;      <span class="comment">// we can bind a const int&amp; to a plain int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;     <span class="comment">// ok: r1 is a reference to const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;     <span class="comment">// ok: r3 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r * <span class="number">2</span>;        <span class="comment">// error: r4 is a plain, non const reference</span></span><br></pre></td></tr></table></figure></li><li><p>允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure></li></ul><h4 id="指针和const（Pointers-and-const）"><a href="#指针和const（Pointers-and-const）" class="headerlink" title="指针和const（Pointers and const）"></a>指针和const（Pointers and const）</h4><p><strong>指向常量的指针（pointer to const）</strong>不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;     <span class="comment">// pi is const; its value may not be changed</span></span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;          <span class="comment">// error: ptr is a plain pointer</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;   <span class="comment">// ok: cptr may point to a double that is const</span></span><br><span class="line">*cptr = <span class="number">42</span>;         <span class="comment">// error: cannot assign to *cptr</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>; <span class="comment">// dval is a double; its value can be changed</span></span><br><span class="line">cptr = &amp;dval;       <span class="comment">// ok: but can&#x27;t change dval through cptr</span></span><br></pre></td></tr></table></figure><p>定义语句中把<code>*</code>放在<code>const</code>之前用来说明指针本身是一个常量，<strong>常量指针（const pointer）</strong>必须初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;  <span class="comment">// pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure><p>指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。</p><h4 id="顶层const（Top-Level-const）"><a href="#顶层const（Top-Level-const）" class="headerlink" title="顶层const（Top-Level const）"></a>顶层const（Top-Level const）</h4><p>顶层<code>const</code>表示指针本身是个常量，底层<code>const</code>（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层<code>const</code>也可以是底层<code>const</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;     <span class="comment">// we can&#x27;t change the value of p1; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;      <span class="comment">// we cannot change ci; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;    <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;      <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure><p>当执行拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显：</p><ul><li><p>顶层<code>const</code>没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ci;     <span class="comment">// ok: copying the value of ci; top-level const in ci is ignored</span></span><br><span class="line">p2 = p3;    <span class="comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span></span><br></pre></td></tr></table></figure></li><li><p>拷入和拷出的对象必须具有相同的底层<code>const</code>资格。或者两个对象的数据类型可以相互转换。一般来说，<strong>非常量可以转换成常量</strong>，反之则不行。</p><p><strong>这种就想，如果能把常量转换成非常量的话，这就代表你这个新的指针可以随便改这个值，那原来的变量又怎么能叫做常量呢？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = p3;    <span class="comment">// error: p3 has a low-level const but p doesn&#x27;t</span></span><br><span class="line">p2 = p3;        <span class="comment">// ok: p2 has the same low-level const qualification as p3</span></span><br><span class="line">p2 = &amp;i;        <span class="comment">// ok: we can convert int* to const int*</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;    <span class="comment">// error: can&#x27;t bind an ordinary int&amp; to a const int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">// ok: can bind const int&amp; to plain int</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="constexpr和常量表达式（constexpr-and-Constant-Expressions）"><a href="#constexpr和常量表达式（constexpr-and-Constant-Expressions）" class="headerlink" title="constexpr和常量表达式（constexpr and Constant Expressions）"></a>constexpr和常量表达式（constexpr and Constant Expressions）</h4><p>常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p>一个对象是否为常量表达式由它的数据类型和初始值共同决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;           <span class="comment">// max_files is a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit is a constant expression</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;        <span class="comment">// staff_size is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// sz is not a constant expression</span></span><br></pre></td></tr></table></figure><p>C++11允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;          // 20 is a constant expression</span><br><span class="line">constexpr int limit = mf + 1;   // mf + 1 is a constant expression</span><br><span class="line">constexpr int sz = size();      // ok only if size is a constexpr function</span><br></pre></td></tr></table></figure><p>指针和引用都能定义成<code>constexpr</code>，但是初始值受到严格限制。<code>constexpr</code>指针的初始值必须是0、<code>nullptr</code>或者是存储在某个固定地址中的对象。</p><p>函数体内定义的普通变量一般并非存放在固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化<code>constexpr</code>指针。</p><p>在<code>constexpr</code>声明中如果定义了一个指针，限定符<code>constexpr</code>仅对指针本身有效，与指针所指的对象无关。<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;     <span class="comment">// p是指向int的const指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *cp = &amp;i;   <span class="comment">// cp是指向const int的const指针</span></span><br></pre></td></tr></table></figure><p><code>const</code>和<code>constexpr</code>限定的值都是常量。但<code>constexpr</code>对象的值必须在编译期间确定，而<code>const</code>对象的值可以延迟到运行期间确定。</p><p><strong>建议使用<code>constexpr</code>修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。</strong></p><hr><h3 id="处理类型（Dealing-with-Types）"><a href="#处理类型（Dealing-with-Types）" class="headerlink" title="处理类型（Dealing with Types）"></a>处理类型（Dealing with Types）</h3><h4 id="类型别名（Type-Aliases）"><a href="#类型别名（Type-Aliases）" class="headerlink" title="类型别名（Type Aliases）"></a>类型别名（Type Aliases）</h4><p>类型别名是某种类型的同义词，传统方法是使用关键字<code>typedef</code>定义类型别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;   <span class="comment">// wages is a synonym for double</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base is a synonym for double, p for double*</span></span><br></pre></td></tr></table></figure><p>C++11使用关键字<code>using</code>进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI is a synonym for Sales_item</span></span><br></pre></td></tr></table></figure><h4 id="auto类型说明符（The-auto-Type-Specifier）"><a href="#auto类型说明符（The-auto-Type-Specifier）" class="headerlink" title="auto类型说明符（The auto Type Specifier）"></a>auto类型说明符（The auto Type Specifier）</h4><p>C++11新增<code>auto</code>类型说明符，能让编译器自动分析表达式所属的类型。<code>auto</code>定义的变量必须有初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the type of item is deduced from the type of the result of adding val1 and val2</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// item initialized to the result of val1 + val2</span></span><br></pre></td></tr></table></figure><p>编译器推断出来的<code>auto</code>类型有时和初始值的类型并不完全一样。</p><ul><li><p>当引用被用作初始值时，编译器以引用对象的类型作为<code>auto</code>的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;     <span class="comment">// a is an int (r is an alias for i, which has type int)</span></span><br></pre></td></tr></table></figure></li><li><p><code>auto</code>一般会忽略顶层<code>const</code>。<strong>因为是赋值出来的另一个变量，独立的内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">// b is an int (top-level const in ci is dropped)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">// c is an int (cr is an alias for ci whose const is top-level)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">// d is an int*(&amp; of an int object is int*)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">// e is const int*(&amp; of a const object is low-level const)</span></span><br></pre></td></tr></table></figure><p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要显式指定<code>const auto</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// deduced type of ci is int; f has type const int</span></span><br></pre></td></tr></table></figure></li></ul><p>设置类型为<code>auto</code>的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g is a const int&amp; that is bound to ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;   <span class="comment">// error: we can&#x27;t bind a plain reference to a literal</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;     <span class="comment">// ok: we can bind a const reference to a literal</span></span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符（The-decltype-Type-Specifier）"><a href="#decltype类型指示符（The-decltype-Type-Specifier）" class="headerlink" title="decltype类型指示符（The decltype Type Specifier）"></a>decltype类型指示符（The decltype Type Specifier）</h4><p>C++11新增<code>decltype</code>类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum has whatever type f returns</span></span><br></pre></td></tr></table></figure><p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>有些不同，如果<code>decltype</code>使用的表达式是一个变量，则<code>decltype</code>返回该变量的类型（包括顶层<code>const</code>和引用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;     <span class="comment">// x has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;     <span class="comment">// y has type const int&amp; and is bound to x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;     <span class="comment">// error: z is a reference and must be initialized</span></span><br></pre></td></tr></table></figure><p>如果<code>decltype</code>使用的表达式不是一个变量，则<code>decltype</code>返回表达式结果对应的类型。如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则<code>decltype</code>会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p><p><strong><code>decltype((var))</code>的结果永远是引用</strong>，而<code>decltype(var)</code>的结果只有当<em>var</em>本身是一个引用时才会是引用。</p><hr><h3 id="自定义数据结构（Defining-Our-Own-Data-Structures）"><a href="#自定义数据结构（Defining-Our-Own-Data-Structures）" class="headerlink" title="自定义数据结构（Defining Our Own Data Structures）"></a>自定义数据结构（Defining Our Own Data Structures）</h3><p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p><strong>类内初始值不能使用圆括号。</strong></p><p><strong>类定义的最后应该加上分号。</strong></p><p><strong>头文件（header file）通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</strong></p><p><strong>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</strong></p><p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。<code>#define</code>指令把一个名字设定为预处理变量。<code>#ifdef</code>指令当且仅当变量已定义时为真，<code>#ifndef</code>指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在高级版本的IDE环境中，可以直接使用<code>#pragma once</code>命令来防止头文件的重复包含。</p><p>预处理变量无视C++语言中关于作用域的规则。</p><p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p><p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h2&gt;&lt;h3 id=&quot;变量初始化&quot;&gt;&lt;a href=&quot;#变量初始化&quot; class</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
</feed>
