<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-06-29T14:18:13.925Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统思维导图</title>
    <link href="http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-16T11:37:26.000Z</published>
    <updated>2022-06-29T14:18:13.925Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="http://icecorn.github.io/file/os.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>线程是os能调度的最小单位，它包含在进程中，是进程的实际运作单位，但是它不拥有资源（实际上就是为了将进程拥有资源和接受os调度这两个事分开才有的线程，同时一个进程可拥有多个线程，可以是进程并发的处理任务）</li></ul><h3 id="有什么？"><a href="#有什么？" class="headerlink" title="有什么？"></a>有什么？</h3><ul><li>一个线程执行状态（运行，就绪等）</li><li>线程上下文，一个独立的程序计数器（记录下一条指令地址）</li><li>用于局部变量的一些静态存储空间（栈空间）要注意这个栈空间是私有的</li><li>与进程内其他线程共享的内存和资源的访问权限</li></ul><h3 id="好处？"><a href="#好处？" class="headerlink" title="好处？"></a>好处？</h3><ul><li>使cpu的调度时间片粒度更小，运行一个进程时，可以分成更小的时间片给进程的各个线程</li><li>线程间切换时间要小于进程间切换</li><li>提高了不同执行程序通信的效率，因为进程内的线程共享内存，直接改就行，而不用内核接入切换进程再通信来完成</li></ul><h3 id="两种线程"><a href="#两种线程" class="headerlink" title="两种线程"></a>两种线程</h3><ul><li><p>用户态线程</p><ul><li>这种线程对os来说是未知的，切换线程不需要状态切换，但一个进程同时只能运行一个线程。一个线程阻塞，进程就阻塞。</li></ul></li><li><p>内核态线程</p><ul><li>这种线程实际上就是mini进程，线程切换和进程一样会触发中断进行状态切换。当然它们也就可以再多个处理器上真正的并行执行。</li></ul></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>一个能分配给处理器执行的程序实体</li></ul><h3 id="有什么？-1"><a href="#有什么？-1" class="headerlink" title="有什么？"></a>有什么？</h3><ul><li>1.程序代码</li><li>2.数据集（系统资源）</li><li>3.进程控制块</li></ul><h3 id="进程控制块（由os创建和管理）"><a href="#进程控制块（由os创建和管理）" class="headerlink" title="进程控制块（由os创建和管理）"></a>进程控制块（由os创建和管理）</h3><ul><li>标识符：进程唯一标识符</li><li>状态：执行状态</li><li>优先级：相对其他进程的优先顺序</li><li>程序计数器：程序中即将执行的下一条指令地址</li><li>内存指针：相关代码和数据集以及和其他进程共享内存块的指针</li><li>上下文：执行时处理器寄存器中的数据</li><li>IO信息：IO请求，使用的文件列表等</li><li>记账信息：包括处理器时间总和，时钟数总和等</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>运行态：进程执行中，单核的话只有一个进程为运行态</li><li>就绪态：准备好了，有机会就执行</li><li>阻塞态：在某事发生前不能执行，如IO完成</li><li>新建态：刚创建的进程，通常进程控制块建好了，但没有加载到内存中</li><li>退出态：释放了的进程</li><li>挂起态：不属于上述5个标准的状态，挂起态是把阻塞长的进程换到磁盘中，把能直接执行的进程换到内存中，避免让cpu闲下来</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li><p>中断</p><ul><li>时钟中断：就是时间片到点了</li><li>IO中断：要等打印机了==</li><li>内存失效：要使用到虚存了，要从磁盘里调</li></ul></li><li><p>陷阱：处理一个错误或异常条件</p></li><li><p>系统调用：调用操作系统函数</p></li><li><p>以上三种发生了，处理器都会执行一次模式切换（用户态转到内核态），将控制权交给os例程，os处理完，可以恢复被中断的进程或切换到其他进程</p></li></ul><h2 id="如何控制资源？通过维护一些表。"><a href="#如何控制资源？通过维护一些表。" class="headerlink" title="如何控制资源？通过维护一些表。"></a>如何控制资源？通过维护一些表。</h2><h3 id="内存表"><a href="#内存表" class="headerlink" title="内存表"></a>内存表</h3><ul><li>页表</li><li>段表</li></ul><h3 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h3><ul><li>主进程表：包含每个进程的表项（至少包含一个指向进程映像的指针）</li><li>进程映像：包括程序，数据，栈，属性</li><li>进程可以一部分存在内存，一部分放在外存，这些信息都要存在进程表里。一切目的都是让cpu能够找到而已</li></ul><h3 id="IO表"><a href="#IO表" class="headerlink" title="IO表"></a>IO表</h3><h3 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h3><h2 id="并发性：互斥和同步"><a href="#并发性：互斥和同步" class="headerlink" title="并发性：互斥和同步"></a>并发性：互斥和同步</h2><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul><li><p>通过编程语言来实现</p><ul><li>信号量机制（实际的实现还是硬件或软件方法）</li><li>消息机制</li><li>管程</li><li>生产者/消费者问题</li><li>读/写者问题</li></ul></li><li><p>硬件实现</p><ul><li>中断禁用（临界区禁用中断）</li><li>专用的机器指令</li></ul></li><li><p>软件实现</p><ul><li>通过进程来实现</li></ul></li></ul><h2 id="并发性：死锁和饥饿"><a href="#并发性：死锁和饥饿" class="headerlink" title="并发性：死锁和饥饿"></a>并发性：死锁和饥饿</h2><h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><ul><li><p>产生死锁的3个必要非充分条件</p><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li></ul></li><li><p>充分条件：循环等待（是上边3个必要条件导致的结果）</p></li></ul><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><ul><li>可重用资源（IO，内存等等）</li><li>可消耗资源（中断，IO缓冲区消息等）</li></ul><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul><li><p>预防</p><ul><li><p>一次性请求所有资源</p><ul><li>缺点：</li></ul></li></ul></li></ul><p>1.因阻塞导致占有这么多资源都不能用，别的进程也不能用<br>2.事先不知道需要哪些资源</p><pre><code>- 抢占    - 缺点：</code></pre><p>1.要求两个进程优先级不同<br>2.资源状态要容易保存和恢复</p><pre><code>- 资源排序    - 缺点：</code></pre><p>1.和一次性请求所有资源一样，会拒绝资源访问，浪费资源可使用的时间</p><ul><li><p>避免</p><ul><li>操作以便发现至少一条安全路径</li></ul></li></ul><p>1.若一个进程请求会导致死锁，则不启动该进程<br>2.若一个进程增加资源请求会导致死锁，则不允许这一资源分配</p><pre><code>    - 资源分配拒绝策略</code></pre><p>（银行家算法）</p><pre><code>        - 优点：</code></pre><p>无需死锁预防中的抢占和回滚进程<br>            - 限制：<br>1.必须事先声明每个进程请求的最大资源<br>2.所讨论的进程必须是无关的，即它们的执行顺序没有任何同步要求的限制<br>3.分配的资源数量必须是固定的<br>4.在占有资源时，进程不能退出</p><ul><li><p>检测</p><ul><li><p>周期性检测死锁的存在</p></li><li><p>恢复</p><ul><li>1.取消所有死锁进程（os最常用方法）</li></ul></li></ul></li></ul><p>2.每个死锁进程回滚，并重启所有进程<br>3.连续取消死锁进程直到不再存在死锁<br>4.连续抢占资源直到不在存在死锁</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>重定位</li><li>保护</li><li>共享</li><li>逻辑组织</li><li>物理组织</li></ul><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><ul><li><p>固定分区</p></li><li><p>动态分区</p></li><li><p>伙伴系统</p></li><li><p>分页</p><ul><li>进程分成页<br>内存分成页框（大小相等）<br>每一页很小，windows是4kb<br>进程可以拥有不连续的很多页，通过维护一个页表来找到它们</li></ul></li><li><p>分段</p><ul><li><p>进程和内存被分成很多段<br>段的大小可以不相等</p><ul><li>特点：<br>可以由程序员控制，一般将每个段定义一组逻辑信息，然后映射到内存中去。而分页是定死的，程序员控制不了</li></ul></li></ul></li><li><p>分段和分页区别</p><ul><li><p>1.页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</p></li><li><p>2.页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</p></li><li><p>3.分页的作业地址空间是一维的.分段的地址空间是二维的.</p><ul><li>意思是分页的话，给个虚拟地址就能找到物理地址（因为页是一样大的，可以算出来），而分段的话，需要给段号和虚拟地址才能算出来物理地址，因为段是不定长的嘛</li></ul></li></ul></li><li><p>段页式</p><ul><li>首先将进程按逻辑分成段<br>再将每段分成页<br>查找需要段号，页号，偏移量</li></ul></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>好处：</li></ul><p>1.可以使有限的内存存放更多进程<br>2.可以使程序比整个内存都大，比如某些游戏<br>3.不需要程序的所有页或段都在内存之中</p><h3 id="操作系统处理"><a href="#操作系统处理" class="headerlink" title="操作系统处理"></a>操作系统处理</h3><ul><li><p>为了防止缺页中断太过频繁，os有很多算法来进行内存调度</p><ul><li><p>读取策略：<br>进程页可以在请求时读取，或预先分页，按簇一次读取多页</p></li><li><p>放置策略：<br>对纯分段系统，读取的段必须匹配内存的空间</p></li><li><p>置换策略：<br>内存装满后，必须决定置换哪些页</p></li><li><p>驻留集管理：<br>换入特定进程时，os决定给他分配多少内存，既可以静态分配，也可以动态地变化</p></li><li><p>清除策略：<br>修改过的进程页可在置换时写出，或使用预约式清楚策略，按簇一次写出多页</p></li><li><p>加载控制：<br>主要关注任何给定时刻驻留在内存中的进程数量</p></li></ul></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h3><ul><li><p>处理器调度类型</p><ul><li>长程调度：<br>决定哪些进程可以进入系统中处理（读入内存）</li><li>中程调度：<br>是交换功能的一部分，就是决定进程的一部分读入内存或换出到磁盘</li><li>短程调度：<br>真正决定当前cpu处理哪个进程（运行态）的调度</li></ul></li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><ul><li><p>粒度</p></li><li><p>进程调度</p></li><li><p>线程调度</p><ul><li><p>负载分配</p><ul><li>先来先服务</li><li>最少线程数优先</li><li>可抢占的最少线程数优先</li></ul></li><li><p>组调度</p></li><li><p>专用处理器分配</p></li><li><p>动态调度</p></li></ul></li><li><p>多核线程调度</p></li></ul><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p>进程优先级</p></li><li><p>决策模式：抢占/非抢占</p></li><li><p>调度策略</p><ul><li>先来先服务</li><li>轮转</li><li>最短进程优先</li><li>最短剩余时间</li><li>最高响应比优先</li><li>反馈法</li><li>公平共享调度（进程组）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;http://icecorn.github.io/file/os.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;




&lt;h1</summary>
      
    
    
    
    <category term="操作系统" scheme="http://icecorn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://icecorn.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="思维导图" scheme="http://icecorn.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|专题-四种类型转换的使用</title>
    <link href="http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-03-10T12:25:30.000Z</published>
    <updated>2022-06-29T13:24:31.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专题-四种类型转换的使用"><a href="#专题-四种类型转换的使用" class="headerlink" title="专题 -四种类型转换的使用"></a>专题 -四种类型转换的使用</h2><h3 id="运行时类型识别（Run-Time-Type-Identification）"><a href="#运行时类型识别（Run-Time-Type-Identification）" class="headerlink" title="运行时类型识别（Run-Time Type Identification）"></a>运行时类型识别（Run-Time Type Identification）</h3><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p><ul><li><code>typeid</code>运算符，用于返回表达式的类型。</li><li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</li></ul><p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p><h3 id="dynamic-cast运算符（The-dynamic-cast-Operator）"><a href="#dynamic-cast运算符（The-dynamic-cast-Operator）" class="headerlink" title="dynamic_cast运算符（The dynamic_cast Operator）"></a>dynamic_cast运算符（The dynamic_cast Operator）</h3><p><code>dynamic_cast</code>运算符的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure><p>其中<em>type</em>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<em>e</em>必须是一个有效指针；在第二种形式中，<em>e</em>必须是一个左值；在第三种形式中，<em>e</em>不能是左值。在所有形式中，<em>e</em>的类型必须符合以下条件之一：</p><ul><li><em>e</em>是<em>type</em>的公有派生类。</li><li><em>e</em>是<em>type</em>的公有基类。</li><li><em>e</em>和<em>type</em>类型相同。</li></ul><p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p><ul><li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use the Derived object to which dp points</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   <span class="comment">// bp points at a Base object</span></span><br><span class="line">    <span class="comment">// use the Base object to which bp points</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<em>typeinfo</em>中）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br><span class="line">        <span class="comment">// use the Derived object to which b referred</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_cast)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle the fact that the cast failed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p><p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p><hr><h3 id="四种强制类型转换"><a href="#四种强制类型转换" class="headerlink" title="四种强制类型转换"></a>四种强制类型转换</h3><p><strong>强制类型转换解决的问题：</strong></p><p>强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成<a href="http://c.biancheng.net/c/80/">指针</a>，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p><p><strong>1) 没有从形式上体现转换功能和风险的不同。</strong></p><p>例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。</p><p><strong>2) 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</strong></p><p><strong>3) 难以在程序中寻找到底什么地方进行了强制类型转换。</strong></p><p>强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。</p><p>如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。</p><p>而用 C++ 的方式，则只需要查找**<code>_cast</code>**字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找<code>reinterpret_cast</code>字符串。</p><p>C++ 强制类型转换运算符的用法如下：</p><p>*<em>强制类型转换运算符 &lt;**要转换到的类型**&gt; (*<em>待转换的表达式*</em>)</em>*</p><p>例如：</p><p>double d = static_cast <double> (3<em>5); //将 3</em>5 的值转换成实数</p><hr><p><strong>下面分别介绍四种强制类型转换运算符。</strong></p><h4 id="const-cast-常量转换"><a href="#const-cast-常量转换" class="headerlink" title="const_cast 常量转换"></a>const_cast 常量转换</h4><p>const_cast 运算符仅用于进行<strong>去除 const 属性的转换</strong>，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。</p><p>将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Inception&quot;</span>;</span><br><span class="line">string&amp; p = <span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);</span><br><span class="line">string* ps = <span class="keyword">const_cast</span> &lt;string*&gt; (&amp;s);  <span class="comment">// &amp;s 的类型是 const string*</span></span><br></pre></td></tr></table></figure><p>const int* p; //p可变,p指向的内容不可变<br>int const* p; //p可变,p指向的内容不可变<br>int* const p; //p不可变,p指向的内容可变</p><p>const修饰函数返回值表示返回值不可改变,多用于返回指针的情形<br>volatile可理解为编译器警告指示字<br>volatile用于告诉编译器必须每次去内存中取变量值<br>volatile主要修饰可能被多个线程访问的变量<br>volatile也可以修饰可能被未知因数更改的变量</p><p>1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；<br>2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；<br>3、const_cast一般用于修改指针。如const char *p形式；</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211182748443.png" alt="image-20211211182748443"></p><p>未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 <em>c_val , use_val , ptr_val</em> 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的<em>c_val</em> 会被改变.也有可能编译器对这类行为直接 <em>error</em> 或 <em>warning</em>.</p><h4 id="static-cast-静态类型转换"><a href="#static-cast-静态类型转换" class="headerlink" title="static_cast 静态类型转换"></a><strong>static_cast 静态类型转换</strong></h4><p>1、static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。<br>2、用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。<br>3、用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。                               4、static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)                                5、在c++ primer 中说道：c++ 的任何的隐式转换都是使用 <em>static_cast</em> 来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">char</span>*() &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;New Dragon Inn&quot;</span>;</span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (<span class="number">3.14</span>);  <span class="comment">// n 的值变为 3</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (a);  <span class="comment">//调用 a.operator int，n 的值变为 1</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (a);  <span class="comment">//调用 a.operator char*，p 的值变为 NULL</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (p);  <span class="comment">//编译错误，static_cast不能将指针转换成整型</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (n);  <span class="comment">//编译错误，static_cast 不能将整型转换成指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dynamic-cast-动态类型转换"><a href="#dynamic-cast-动态类型转换" class="headerlink" title="dynamic_cast 动态类型转换"></a>dynamic_cast 动态类型转换</h4><p>用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p><p>dynamic_cast 是通过“<strong>运行时类型检查</strong>”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;  <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived* pd;</span><br><span class="line">    pd = <span class="keyword">reinterpret_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe reinterpret_cast&quot;</span> &lt;&lt; endl; <span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast1&quot;</span> &lt;&lt; endl;  <span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;d);  <span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//此处 pd 不会为 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast2&quot;</span> &lt;&lt; endl;  <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>unsafe dynamic_cast1</p><p>第 20 行，通过判断 pd 的值是否为 NULL，就能知道第 19 行进行的转换是否是安全的。第 23 行同理。</p><p>如果上面的程序中出现了下面的语句：</p><p>Derived &amp; r = dynamic_cast &lt;Derived &amp;&gt; (b);</p><p>那该如何判断该转换是否安全呢？不存在空引用，因此不能通过返回值来判断转换是否安全。C++ 的解决办法是：dynamic_cast 在进行引用的强制转换时，如果发现转换不安全，就会拋出一个异常，通过处理异常，就能发现不安全的转换。</p><hr><p><em>dynamic_cast</em>强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211183405628.png" alt="image-20211211183405628"></p><p>对于<em>从子类到基类的指针转换</em> ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果，</p><p>而<em>从基类到子类的转换</em> , dynamic_cast 在转换时也没有报错,但是输出给 <em>base2sub</em> 是一个 <em>nullptr</em> ,说明dynami_cast 在程序运行时对类型转换对<em>“运行期类型信息”（Runtime type information，RTTI）</em>进行了检查. </p><p>这个检查主要来自<em>虚函数(virtual function)</em> 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。*因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数</p><h4 id="reinterpret-cast-重新解释（类型的比特位）"><a href="#reinterpret-cast-重新解释（类型的比特位）" class="headerlink" title="reinterpret_cast 重新解释（类型的比特位）"></a><strong>reinterpret_cast 重新解释（类型的比特位）</strong></h4><p>reinterpret_cast 用于进行各种不同类型的<strong>指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换</strong>。转换时，执行的是<strong>逐个比特复制</strong>的操作。</p><p>这种转换提供了很强的灵活性，但<strong>转换的安全性只能由程序员的细心来保证了</strong>。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">i</span>(n),<span class="built_in">j</span>(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> &amp;r = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a（即a的首地址）</span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; endl;  <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt; (&amp;n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;  <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="type">int</span>,<span class="type">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="built_in">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>200, 100<br>400<br>5678abcd</p><p>第 19 行的代码不安全，<strong>因为在编译器看来，pa-&gt;j 的存放位置就是 n 后面的 4 个字节</strong>。 本条语句会向这 4 个字节中写入 500。**但这 4 个字节不知道是用来存放什么的（*<em>因为i和j不一定连续存储*<em>），贸然向其中写入可能会导致程序错误甚至崩溃。</em></em></p><p>上面程序中的各种转换都没有实际意义，只是为了演示 reinteipret_cast 的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。</p><p><strong>reinterpret_cast体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。</strong></p><p>提供下IBM C++ 对 reinterpret_cast 推荐使用的地方<br>A pointer to any integral type large enough to hold it （指针转向足够大的整数类型）<br>A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针）<br>A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针）<br>A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针）<br>A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专题-四种类型转换的使用&quot;&gt;&lt;a href=&quot;#专题-四种类型转换的使用&quot; class=&quot;headerlink&quot; title=&quot;专题 -四种类型转换的使用&quot;&gt;&lt;/a&gt;专题 -四种类型转换的使用&lt;/h2&gt;&lt;h3 id=&quot;运行时类型识别（Run-Time-Type-I</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十五章-面向对象程序设计</title>
    <link href="http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-03-10T12:25:30.000Z</published>
    <updated>2022-06-29T13:21:19.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</p><p>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</p><p><strong>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</strong></p><p>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;         <span class="comment">// object of base type</span></span><br><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line">Quote *p = &amp;item;   <span class="comment">// p points to a Quote object</span></span><br><span class="line">p = &amp;bulk;          <span class="comment">// p points to the Quote part of bulk</span></span><br><span class="line">Quote &amp;r = bulk;    <span class="comment">// r bound to the Quote part of bulk</span></span><br></pre></td></tr></table></figure><p>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, </span><br><span class="line">            std::<span class="type">size_t</span> qty, <span class="type">double</span> disc) :</span><br><span class="line">    <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br></pre></td></tr></table></figure><p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p><p><strong>派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。</strong></p><p>派生类可以访问基类的公有成员和受保护成员。</p><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</p><p>已经完整定义的类才能被用作基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> D1 &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p><em>Base</em>是<em>D1</em>的直接基类（direct base），是<em>D2</em>的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。</p><p>C++11中，在类名后面添加<code>final</code>关键字可以禁止其他类继承它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span> &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// NoDerived can&#x27;t be a base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* */</span> &#125;;</span><br><span class="line"><span class="comment">// Last is final; we cannot inherit from Last</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Last</span> <span class="keyword">final</span> : Base &#123; <span class="comment">/* */</span> &#125;;  <span class="comment">// Last can&#x27;t be a base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> : NoDerived &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// error: NoDerived is final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad2</span> : Last &#123; <span class="comment">/* */</span> &#125;;        <span class="comment">// error: Last is final</span></span><br></pre></td></tr></table></figure><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</p><p>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</p><p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p><p>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;   <span class="comment">// error: can&#x27;t convert base to derived</span></span><br><span class="line">Bulk_quote&amp; bulkRef = base;  <span class="comment">// error: can&#x27;t convert base to derived</span></span><br></pre></td></tr></table></figure><p>如果在基类中含有一个或多个虚函数，可以使用<code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。</p><p>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作。</p><p>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</p><p>派生类到基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;   <span class="comment">// uses the Quote::Quote(const Quote&amp;) constructor</span></span><br><span class="line">item = bulk;        <span class="comment">// calls Quote::operator=(const Quote&amp;)</span></span><br></pre></td></tr></table></figure><p>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</p><h3 id="虚函数（Virtual-Functions）"><a href="#虚函数（Virtual-Functions）" class="headerlink" title="虚函数（Virtual Functions）"></a>虚函数（Virtual Functions）</h3><p>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</p><p>在派生类中覆盖某个虚函数时，可以再次使用<code>virtual</code>关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</p><p>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p><p>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</p><p>C++11允许派生类使用<code>override</code>关键字显式地注明虚函数。如果<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。<code>override</code>位于函数参数列表之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;    <span class="comment">// ok: f1 matches f1 in the base</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;      <span class="comment">// error: B has no f2(int) function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: f3 not virtual</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: B doesn&#x27;t have a function named f4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与禁止类继承类似，函数也可以通过添加<code>final</code>关键字来禁止覆盖操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;   <span class="comment">// subsequent classes can&#x27;t override f1(int)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>final</code>和<code>override</code>关键字出现在形参列表（包括任何<code>const</code>或引用修饰符）以及尾置返回类型之后。</p><p><strong>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</strong></p><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</p><p>使用作用域运算符<code>::</code>可以强制执行虚函数的某个版本，不进行动态绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calls the version from the base class regardless of the dynamic type of baseP</span></span><br><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</p><p>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</p><hr><h3 id="抽象基类（Abstract-Base-Classes）"><a href="#抽象基类（Abstract-Base-Classes）" class="headerlink" title="抽象基类（Abstract Base Classes）"></a>抽象基类（Abstract Base Classes）</h3><p>在类内部虚函数声明语句的分号前添加<code>=0</code>可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</p><p>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</p><p><strong>不能创建抽象基类的对象。</strong></p><p>派生类构造函数只初始化它的直接基类。</p><p>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</p><hr><h3 id="关于多继承和虚继承"><a href="#关于多继承和虚继承" class="headerlink" title="关于多继承和虚继承"></a>关于多继承和虚继承</h3><p>多继承很简单就是一个子类可以继承多个父类，且对于一个子类对象，它里面其实包含每个父类的对象各一个，那么怎么协调好变量和函数的继承关系，理解记忆就好了，关键是不产生冲突</p><p>虚继承是为了解决菱形继承出现的，因为如果不是菱形继承，一个子类对象就会有两个一样的爷爷类的对象，这是不对的，而有了虚继承，就是让一个子对象只拥有一个爷爷类对象，不会产生冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十五章-面向对象程序设计&quot;&gt;&lt;a href=&quot;#第十五章-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;第十五章 面向对象程序设计&quot;&gt;&lt;/a&gt;第十五章 面向对象程序设计&lt;/h2&gt;&lt;h3 id=&quot;基类和派生类&quot;&gt;&lt;a href=&quot;#基类和</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十四章 重载运算与类型转换</title>
    <link href="http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-03-08T12:25:30.000Z</published>
    <updated>2022-06-29T13:33:20.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="headerlink" title="第14章 重载运算与类型转换"></a>第14章 重载运算与类型转换</h1><h2 id="基本概念（Basic-Concepts）"><a href="#基本概念（Basic-Concepts）" class="headerlink" title="基本概念（Basic Concepts）"></a>基本概念（Basic Concepts）</h2><p>重载的运算符是具有特殊名字的函数，它们的名字由关键字<code>operator</code>和其后要定义的运算符号组成。</p><p>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p><p>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的<code>this</code>指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</p><p>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</p><p>只能重载大多数已有的运算符，无权声明新的运算符号。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-1.png" alt="14-1"></p><p>重载运算符的优先级和结合律与对应的内置运算符一致。</p><p>可以像调用普通函数一样直接调用运算符函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent calls to a nonmember operator function</span></span><br><span class="line">data1 + data2;              <span class="comment">// normal expression</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);    <span class="comment">// equivalent function call</span></span><br><span class="line">data1 += data2;             <span class="comment">// expression-based &#x27;&#x27;call&#x27;&#x27;</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);    <span class="comment">// equivalent call to a member operator function</span></span><br></pre></td></tr></table></figure><p>通常情况下，不应该重载逗号<code>,</code>、取地址<code>&amp;</code>、逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符。</p><p>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</p><p>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</p><p>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;     <span class="comment">// ok: we can add a const char* to a string</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s;    <span class="comment">// would be an error if + were a member of string</span></span><br></pre></td></tr></table></figure><p>如何选择将运算符定义为成员函数还是普通函数：</p><ul><li>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>和成员访问箭头<code>-&gt;</code>运算符必须是成员函数。</li><li>复合赋值运算符一般是成员函数，但并非必须。</li><li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li><li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li></ul><h2 id="输入和输出运算符（Input-and-Output-Operators）"><a href="#输入和输出运算符（Input-and-Output-Operators）" class="headerlink" title="输入和输出运算符（Input and Output Operators）"></a>输入和输出运算符（Input and Output Operators）</h2><h3 id="重载输出运算符-lt-lt-（Overloading-the-Output-Operator-lt-lt-）"><a href="#重载输出运算符-lt-lt-（Overloading-the-Output-Operator-lt-lt-）" class="headerlink" title="重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）"></a>重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）</h3><p>通常情况下，输出运算符的第一个形参是<code>ostream</code>类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的<code>ostream</code>形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出运算符应该尽量减少格式化操作。</p><p>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</p><h3 id="重载输入运算符-gt-gt-（Overloading-the-Input-Operator-gt-gt-）"><a href="#重载输入运算符-gt-gt-（Overloading-the-Input-Operator-gt-gt-）" class="headerlink" title="重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）"></a>重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）</h3><p>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> price;   <span class="comment">// no need to initialize; we&#x27;ll read into price before we use it</span></span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span> (is)    <span class="comment">// check that the inputs succeeded</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item = <span class="built_in">Sales_data</span>();    <span class="comment">// input failed: give the object the default state</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入运算符必须处理输入失败的情况，而输出运算符不需要。</p><p>以下情况可能导致读取操作失败：</p><ul><li>读取了错误类型的数据。</li><li>读取操作到达文件末尾。</li><li>遇到输入流的其他错误。</li></ul><p>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</p><p>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置<code>failbit</code>状态。<code>eofbit</code>、<code>badbit</code>等错误最好由IO标准库自己标示。</p><h2 id="算术和关系运算符（Arithmetic-and-Relational-Operators）"><a href="#算术和关系运算符（Arithmetic-and-Relational-Operators）" class="headerlink" title="算术和关系运算符（Arithmetic and Relational Operators）"></a>算术和关系运算符（Arithmetic and Relational Operators）</h2><p>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</p><p>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的<code>const</code>类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs;   <span class="comment">// copy data members from lhs into sum</span></span><br><span class="line">    sum += rhs;     <span class="comment">// add rhs into sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。</p><h3 id="相等运算符（Equality-Operators）"><a href="#相等运算符（Equality-Operators）" class="headerlink" title="相等运算符（Equality Operators）"></a>相等运算符（Equality Operators）</h3><p>相等运算符设计准则：</p><ul><li><p>如果类在逻辑上有相等性的含义，则应该定义<code>operator==</code>而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</p></li><li><p>通常情况下，<code>operator==</code>应该具有传递性。</p></li><li><p>如果类定义了<code>operator==</code>，则也应该定义<code>operator!=</code>。</p></li><li><p><code>operator==</code>和<code>operator!=</code>中的一个应该把具体工作委托给另一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">        lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">        lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="关系运算符（Relational-Operators）"><a href="#关系运算符（Relational-Operators）" class="headerlink" title="关系运算符（Relational Operators）"></a>关系运算符（Relational Operators）</h3><p>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较实用。</p><p>关系运算符设计准则：</p><ul><li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li><li>如果类定义了<code>operator==</code>，则关系运算符的定义应该与<code>operator==</code>保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li><li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义<code>operator&lt;</code>。</li></ul><h2 id="赋值运算符（Assignment-Operators）"><a href="#赋值运算符（Assignment-Operators）" class="headerlink" title="赋值运算符（Assignment Operators）"></a>赋值运算符（Assignment Operators）</h2><p>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// alloc_n_copy allocates space and copies elements from the given range</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();     <span class="comment">// destroy the elements in this object and free the space</span></span><br><span class="line">    elements = data.first;      <span class="comment">// update data members to point to the new</span></span><br><span class="line">    space</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member binary operator: left-hand operand is bound to the implicit this pointer</span></span><br><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标运算符（Subscript-Operator）"><a href="#下标运算符（Subscript-Operator）" class="headerlink" title="下标运算符（Subscript Operator）"></a>下标运算符（Subscript Operator）</h2><p>下标运算符必须定义为成员函数。</p><p>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *elements;  <span class="comment">// pointer to the first element in the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递增和递减运算符（Increment-and-Decrement-Operators）"><a href="#递增和递减运算符（Increment-and-Decrement-Operators）" class="headerlink" title="递增和递减运算符（Increment and Decrement Operators）"></a>递增和递减运算符（Increment and Decrement Operators）</h2><p>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</p><p>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix: return a reference to the incremented/decremented object</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++curr;     <span class="comment">// advance the current state</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置递增或递减运算符接受一个额外的（不被使用）<code>int</code>类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// increment and decrement</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();    <span class="comment">// prefix operators</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>);  <span class="comment">// postfix operators</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的<code>const</code>类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;    <span class="comment">// save the current value</span></span><br><span class="line">    ++*<span class="keyword">this</span>;      <span class="comment">// advance one element; prefix ++ checks the increment</span></span><br><span class="line">    <span class="keyword">return</span> ret;   <span class="comment">// return the saved state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;   <span class="comment">// p points to the vector inside a1</span></span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);    <span class="comment">// call postfix operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();     <span class="comment">// call prefix operator++</span></span><br></pre></td></tr></table></figure><h2 id="成员访问运算符（Member-Access-Operators）"><a href="#成员访问运算符（Member-Access-Operators）" class="headerlink" title="成员访问运算符（Member Access Operators）"></a>成员访问运算符（Member Access Operators）</h2><p>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</p><p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];   <span class="comment">// (*p) is the vector to which this object points</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;   <span class="comment">// delegate the real work to the dereference operator</span></span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于形如<code>point-&gt;mem</code>的表达式来说，<em>point</em>必须是指向类对象的指针或者是一个重载了<code>operator-&gt;</code>的类的对象。<em>point</em>类型不同，<code>point-&gt;mem</code>的含义也不同。</p><ul><li>如果<em>point</em>是指针，则调用内置箭头运算符，表达式等价于<code>(*point).mem</code>。</li><li>如果<em>point</em>是重载了<code>operator-&gt;</code>的类的对象，则使用<code>point.operator-&gt;()</code>的结果来获取<em>mem</em>，表达式等价于<code>(point.operator-&gt;())-&gt;mem</code>。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li></ul><h2 id="函数调用运算符（Function-Call-Operator）"><a href="#函数调用运算符（Function-Call-Operator）" class="headerlink" title="函数调用运算符（Function-Call Operator）"></a>函数调用运算符（Function-Call Operator）</h2><p>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">        <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;   <span class="comment">// stream on which to write</span></span><br><span class="line">    <span class="type">char</span> sep;      <span class="comment">// character to print after each output</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer;  <span class="comment">// uses the defaults; prints to cout</span></span><br><span class="line"><span class="built_in">printer</span>(s);     <span class="comment">// prints s followed by a space on cout</span></span><br></pre></td></tr></table></figure><p>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="lambda是函数对象（Lambdas-Are-Function-Objects）"><a href="#lambda是函数对象（Lambdas-Are-Function-Objects）" class="headerlink" title="lambda是函数对象（Lambdas Are Function Objects）"></a>lambda是函数对象（Lambdas Are Function Objects）</h3><p>编写一个<code>lambda</code>后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort words by size, but maintain alphabetical order for words of the same size</span></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// acts like an unnamed object of a class that would look something like</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>默认不能改变它捕获的变量。因此在默认情况下，由<code>lambda</code>产生的类中的函数调用运算符是一个<code>const</code>成员函数。如果<code>lambda</code>被声明为可变的，则调用运算符就不再是<code>const</code>函数了。</p><p><code>lambda</code>通过引用捕获变量时，由程序负责确保<code>lambda</code>执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在<code>lambda</code>产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到<code>lambda</code>中，此时<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to the first element whose size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [sz](<span class="type">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// would generate a class that looks something like</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(<span class="type">size_t</span> n): <span class="built_in">sz</span>(n) &#123; &#125;   <span class="comment">// parameter for each captured variable</span></span><br><span class="line">    <span class="comment">// call operator with the same return type, parameters, and body as the lambda</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> sz;   <span class="comment">// a data member for each variable captured by value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数则通常要视捕获的变量类型而定。</p><h3 id="标准库定义的函数对象（Library-Defined-Function-Objects）"><a href="#标准库定义的函数对象（Library-Defined-Function-Objects）" class="headerlink" title="标准库定义的函数对象（Library-Defined Function Objects）"></a>标准库定义的函数对象（Library-Defined Function Objects）</h3><p>标准库在头文件<em>functional</em>中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-2.png" alt="14-2"></p><p>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string *&gt; nameTable;    <span class="comment">// vector of pointers</span></span><br><span class="line"><span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(),</span><br><span class="line">        [](string *a, string *b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="comment">// ok: library guarantees that less on pointer types is well defined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure><h3 id="可调用对象与function（Callable-Objects-and-function）"><a href="#可调用对象与function（Callable-Objects-and-function）" class="headerlink" title="可调用对象与function（Callable Objects and function）"></a>可调用对象与function（Callable Objects and function）</h3><p>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p><p>标准库<code>function</code>类型是一个模板，定义在头文件<em>functional</em>中，用来表示对象的调用形式。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-3.png" alt="14-3"></p><p>创建一个具体的<code>function</code>类型时必须提供其所表示的对象的调用形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ordinary function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// function-object class</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator, <span class="type">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;      <span class="comment">// function pointer</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = <span class="built_in">div</span>();    <span class="comment">// object of a function-object class</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;;  <span class="comment">// lambda</span></span><br><span class="line">                                   </span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 6</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 8</span></span><br></pre></td></tr></table></figure><p>不能直接将重载函数的名字存入<code>function</code>类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用<code>lambda</code>或者存储函数指针而非函数名字。</p><p>C++11新标准库中的<code>function</code>类与旧版本中的<code>unary_function</code>和<code>binary_function</code>没有关系，后两个类已经被<code>bind</code>函数代替。</p><h2 id="重载、类型转换与运算符（Overloading，Conversions，and-Operators）"><a href="#重载、类型转换与运算符（Overloading，Conversions，and-Operators）" class="headerlink" title="重载、类型转换与运算符（Overloading，Conversions，and Operators）"></a>重载、类型转换与运算符（Overloading，Conversions，and Operators）</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。</p><h3 id="类型转换运算符（Conversion-Operators）"><a href="#类型转换运算符（Conversion-Operators）" class="headerlink" title="类型转换运算符（Conversion Operators）"></a>类型转换运算符（Conversion Operators）</h3><p>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>类型转换运算符可以面向除了<code>void</code>以外的任意类型（该类型要能作为函数的返回类型）进行定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the double argument is converted to int using the built-in conversion</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;     <span class="comment">// calls the SmallInt(int) constructor</span></span><br><span class="line"><span class="comment">// the SmallInt conversion operator converts si to int;</span></span><br><span class="line">si + <span class="number">3.14</span>;     <span class="comment">// that int is converted to double using the built-in conversion</span></span><br></pre></td></tr></table></figure><p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p><p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// the compiler won&#x27;t automatically apply this conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;    <span class="comment">// ok: the SmallInt constructor is not explicit</span></span><br><span class="line">si + <span class="number">3</span>;     <span class="comment">// error: implicit is conversion required, but operator int is explicit</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si) + <span class="number">3</span>;    <span class="comment">// ok: explicitly request the conversion</span></span><br></pre></td></tr></table></figure><p>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</p><ul><li><code>if</code>、<code>while</code>、<code>do-while</code>语句的条件部分。</li><li><code>for</code>语句头的条件表达式。</li><li>条件运算符<code>? :</code>的条件表达式。</li><li>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</li></ul><p>类类型向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般被定义为显式的。</p><h3 id="避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）"><a href="#避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）" class="headerlink" title="避免有二义性的类型转换（Avoiding Ambiguous Conversions）"></a>避免有二义性的类型转换（Avoiding Ambiguous Conversions）</h3><p>在两种情况下可能产生多重转换路径：</p><ul><li><p><em>A</em>类定义了一个接受<em>B</em>类对象的转换构造函数，同时<em>B</em>类定义了一个转换目标是<em>A</em>类的类型转换运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usually a bad idea to have mutual conversions between two class types</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp;); <span class="comment">// converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// also converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);    <span class="comment">// error ambiguous: f(B::operator A())</span></span><br><span class="line">               <span class="comment">// or f(A::A(const B&amp;))</span></span><br></pre></td></tr></table></figure></li><li><p>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);     <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);      <span class="comment">// conversions from arithmetic types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// conversions to arithmetic types</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);    <span class="comment">// error ambiguous: f(A::operator int())</span></span><br><span class="line">          <span class="comment">// or f(A::operator double())</span></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;   <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span></span><br></pre></td></tr></table></figure></li></ul><p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());    <span class="comment">// ok: use B&#x27;s conversion operator</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));     <span class="comment">// ok: use A&#x27;s constructor</span></span><br></pre></td></tr></table></figure><p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</p><p>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</p><p>如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。</p><p>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="comment">// error ambiguous: two different user-defined conversions could be used</span></span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>);    <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span></span><br></pre></td></tr></table></figure><h3 id="函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）"><a href="#函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）" class="headerlink" title="函数匹配与重载运算符（Function Matching and Overloaded Operators）"></a>函数匹配与重载运算符（Function Matching and Overloaded Operators）</h3><p>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="type">const</span> SmallInt&amp;, <span class="type">const</span> SmallInt&amp;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> = <span class="number">0</span>);    <span class="comment">// conversion from int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;    <span class="comment">// conversion to int</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;    <span class="comment">// uses overloaded operator+</span></span><br><span class="line"><span class="type">int</span> i = s3 + <span class="number">0</span>;    <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure><p>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第14章-重载运算与类型转换&quot;&gt;&lt;a href=&quot;#第14章-重载运算与类型转换&quot; class=&quot;headerlink&quot; title=&quot;第14章 重载运算与类型转换&quot;&gt;&lt;/a&gt;第14章 重载运算与类型转换&lt;/h1&gt;&lt;h2 id=&quot;基本概念（Basic-Concep</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十三章-拷贝控制</title>
    <link href="http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</id>
    <published>2022-03-07T12:25:30.000Z</published>
    <updated>2022-06-29T13:17:34.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h2><p>主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。</p><p><strong>关于拷贝不在赘述，主要要记得当一个类里有指针类型时，要注意深拷贝和浅拷贝的问题，比如Myclass b = a；就是如果是浅拷贝的话，b中拷贝过来的指针和a中原来的指针指向的是同一块位置，那么就要考虑要析构b的时候，a对象是否还再用，如果还在用就不能析构指针指向这块内存，防止出现a对象这个指针指向未定义的情况发生。如果是深拷贝的话，就是说a对象和b对象的指针指向的东西也不是在一块内存上，所以可以正常析构。具体要深拷贝还是浅拷贝还是要看业务类型来实现处理。</strong></p><h4 id="对象移动（Moving-Objects）"><a href="#对象移动（Moving-Objects）" class="headerlink" title="对象移动（Moving Objects）"></a>对象移动（Moving Objects）</h4><p>某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。</p><p>在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p><p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。IO类和<code>unique_ptr</code>类可以移动但不能拷贝。</p><h4 id="右值引用（Rvalue-Reference）"><a href="#右值引用（Rvalue-Reference）" class="headerlink" title="右值引用（Rvalue Reference）"></a>右值引用（Rvalue Reference）</h4><p>为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过<code>&amp;&amp;</code>来获得右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;         <span class="comment">// ok: r refers to i</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;       <span class="comment">// error: cannot bind an rvalue reference to an</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;   <span class="comment">// error: i * 42 is an rvalue</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>;    <span class="comment">// ok: we can bind a reference to const to an rvalue</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;        <span class="comment">// ok: bind rr2 to the result of the multiplication</span></span><br></pre></td></tr></table></figure><p>右值引用只能绑定到<strong>即将被销毁，并且没有其他用户的临时对象</strong>上。使用右值引用的代码可以自由地接管所引用对象的资源。</p><p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     <span class="comment">// ok: literals are rvalues</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">// error: the expression rr1 is an lvalue!</span></span><br></pre></td></tr></table></figure><p>调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件<em>utility</em>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure><p>调用<code>move</code>函数的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p><hr><h4 id="移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）"><a href="#移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）" class="headerlink" title="移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）"></a>移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）</h4><p>移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。</p><p>除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。</p><p>在函数的形参列表后面添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常。</p><p>对于构造函数，<code>noexcept</code>位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定<code>noexcept</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// move constructor</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/* member initializers */</span></span><br><span class="line">&#123; <span class="comment">/* constructor body */</span> &#125;</span><br></pre></td></tr></table></figure><p>标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。</p><p>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p><p>在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// direct test for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();     <span class="comment">// free existing elements</span></span><br><span class="line">        elements = rhs.elements;    <span class="comment">// take over resources from rhs</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// leave rhs in a destructible state</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当一个类没有定义任何拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the compiler will synthesize the move operations for X and hasX</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;   <span class="comment">// built-in types can be moved</span></span><br><span class="line">    std::string s;   <span class="comment">// string defines its own move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span></span><br><span class="line">&#123;</span><br><span class="line">    X mem; <span class="comment">// X has synthesized move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);         <span class="comment">// uses the synthesized move constructor</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);   <span class="comment">// uses the synthesized move constructor</span></span><br></pre></td></tr></table></figure><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。</p><p>如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用<code>move</code>函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// other members, but Foo does not define a move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;   <span class="comment">// copy constructor; x is an lvalue</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>;    <span class="comment">// copy constructor, because there is no move constructor</span></span><br></pre></td></tr></table></figure><p>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assignment operator is both the move- and copy-assignment operator</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hp = hp2;   <span class="comment">// hp2 is an lvalue; copy constructor used to copy hp2</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);    <span class="comment">// move constructor moves hp2</span></span><br></pre></td></tr></table></figure><p>建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p><p>移动赋值运算符可以直接检查自赋值情况。</p><p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。</p><p>调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p><p>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用<code>move</code>操作。</p><h4 id="右值引用和成员函数（Rvalue-References-and-Member-Functions）"><a href="#右值引用和成员函数（Rvalue-References-and-Member-Functions）" class="headerlink" title="右值引用和成员函数（Rvalue References and Member Functions）"></a>右值引用和成员函数（Rvalue References and Member Functions）</h4><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>参数，另一个版本接受一个<code>T&amp;&amp;</code>参数（<em>T</em>为类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;   <span class="comment">// copy: binds to any kind of X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// move: binds only to modifiable rvalues of type X</span></span><br></pre></td></tr></table></figure><p>有时可以对右值赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">s1 + s2 = <span class="string">&quot;wow!&quot;</span>;</span><br></pre></td></tr></table></figure><p>在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即<code>this</code>指向的对象）必须是一个左值。</p><p>在非<code>static</code>成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定<code>this</code>的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示<code>this</code>可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &amp;; <span class="comment">// may assign only to modifiable lvalues</span></span><br><span class="line">    <span class="comment">// other members of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;rhs) &amp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do whatever is needed to assign rhs to this object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个非<code>static</code>成员函数可以同时使用<code>const</code>和引用限定符，此时引用限定符跟在<code>const</code>限定符之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="type">const</span></span>;      <span class="comment">// error: const qualifier must come first</span></span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// ok: const qualifier comes first</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用限定符也可以区分成员函数的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;        <span class="comment">// may run on modifiable rvalues</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// may run on any kind of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>();   <span class="comment">// retVal() is an rvalue, calls Foo::sorted() &amp;&amp;</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>();   <span class="comment">// retFoo() is an lvalue, calls Foo::sorted() const &amp;</span></span><br></pre></td></tr></table></figure><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// error: must have reference qualifier</span></span><br><span class="line">    <span class="comment">// Comp is type alias for the function type</span></span><br><span class="line">    <span class="comment">// that can be used to compare int values</span></span><br><span class="line">    <span class="keyword">using</span> Comp = <span class="built_in">bool</span>(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span></span>;  <span class="comment">// ok: different parameter list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>理解move</strong></p><p>这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。</p><p><strong>注意：使用move不会释放源对象，所以一定要确保源对象不会再使用了，才能用move</strong></p><p>详细帖子：</p><p><a href="https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c+++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c%2B%2B+%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十三章-拷贝控制&quot;&gt;&lt;a href=&quot;#第十三章-拷贝控制&quot; class=&quot;headerlink&quot; title=&quot;第十三章 拷贝控制&quot;&gt;&lt;/a&gt;第十三章 拷贝控制&lt;/h2&gt;&lt;p&gt;主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十二章 动态内存</title>
    <link href="http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</id>
    <published>2022-03-05T12:25:30.000Z</published>
    <updated>2022-06-29T13:22:36.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h2><p>程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。</p><h3 id="动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）"><a href="#动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）" class="headerlink" title="动态内存与智能指针（Dynamic Memory and Smart Pointers）"></a>动态内存与智能指针（Dynamic Memory and Smart Pointers）</h3><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p><p>新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<em>memory</em>中。</p><h4 id="shared-ptr类（The-shared-ptr-Class）"><a href="#shared-ptr类（The-shared-ptr-Class）" class="headerlink" title="shared_ptr类（The shared_ptr Class）"></a>shared_ptr类（The shared_ptr Class）</h4><p>智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;      <span class="comment">// shared_ptr that can point at a string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;   <span class="comment">// shared_ptr that can point at a list of ints</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211518263.png" alt="image-20220629211518263"></p><p><code>shared_ptr</code>独有的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211141442645.png" alt="image-20211211141442645"></p><p><code>make_shared</code>函数（定义在头文件<em>memory</em>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr that points to an int with value 42</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 points to a string with value 9999999999</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// p5 points to an int that is value initialized</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// object to which p points has one user</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  <span class="comment">// p and q point to the same object</span></span><br><span class="line">            <span class="comment">// object to which p and q point has two users</span></span><br></pre></td></tr></table></figure><p>每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// int to which r points has one user</span></span><br><span class="line">r = q;  <span class="comment">// assign to r, making it point to a different address</span></span><br><span class="line">        <span class="comment">// increase the use count for the object to which q points</span></span><br><span class="line">        <span class="comment">// reduce the use count of the object to which r had pointed</span></span><br><span class="line">        <span class="comment">// the object r had pointed to has no users; that object is automatically freed</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数会销毁对象并释放空间。</p><p>如果将<code>shared_ptr</code>存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用<code>erase</code>删除不再需要的元素。</p><p>程序使用动态内存通常出于以下三种原因之一：</p><ul><li>不确定需要使用多少对象。</li><li>不确定所需对象的准确类型。</li><li>需要在多个对象间共享数据。</li></ul><h4 id="shared-ptr和new结合使用（Using-shared-ptrs-with-new）"><a href="#shared-ptr和new结合使用（Using-shared-ptrs-with-new）" class="headerlink" title="shared_ptr和new结合使用（Using shared_ptrs with new）"></a>shared_ptr和new结合使用（Using shared_ptrs with new）</h4><p>可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">// error: must use direct initialization</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;     <span class="comment">// ok: uses direct initialization</span></span><br></pre></td></tr></table></figure><p>默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211535799.png" alt="image-20220629211535799"></p><p>不要混合使用内置指针和智能指针。当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr is created and initialized when process is called</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use ptr</span></span><br><span class="line">&#125;   <span class="comment">// ptr goes out of scope and is destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">// dangerous: x is a plain pointer, not a smart pointer</span></span><br><span class="line"><span class="built_in">process</span>(x);     <span class="comment">// error: cannot convert int* to shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));    <span class="comment">// legal, but the memory will be deleted!</span></span><br><span class="line"><span class="type">int</span> j = *x;     <span class="comment">// undefined: x is a dangling pointer!</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;   <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="built_in">process</span>(p);     <span class="comment">// copying p increments its count; in process the reference count is 2</span></span><br><span class="line"><span class="type">int</span> i = *p;     <span class="comment">// ok: reference count is 1</span></span><br></pre></td></tr></table></figure><p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p><p>不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();   <span class="comment">// ok: but don&#x27;t use q in any way that might delete its pointer</span></span><br><span class="line">&#123;   <span class="comment">// new block</span></span><br><span class="line">    <span class="comment">// undefined: two independent shared_ptrs point to the same memory</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(q);</span><br><span class="line">&#125; <span class="comment">// block ends, q is destroyed, and the memory to which q points is freed</span></span><br><span class="line"><span class="type">int</span> foo = *p;   <span class="comment">// undefined; the memory to which p points was freed</span></span><br></pre></td></tr></table></figure><p>可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));   <span class="comment">// we aren&#x27;t alone; allocate a new copy</span></span><br><span class="line">*p += newVal;   <span class="comment">// now that we know we&#x27;re the only pointer, okay to change this object</span></span><br></pre></td></tr></table></figure><h4 id="智能指针和异常（Smart-Pointers-and-Exceptions）"><a href="#智能指针和异常（Smart-Pointers-and-Exceptions）" class="headerlink" title="智能指针和异常（Smart Pointers and Exceptions）"></a>智能指针和异常（Smart Pointers and Exceptions）</h4><p>如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ip = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);    <span class="comment">// dynamically allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">    <span class="keyword">delete</span> ip;     <span class="comment">// free the memory before exiting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">&#125; <span class="comment">// shared_ptr freed automatically when the function ends</span></span><br></pre></td></tr></table></figure><p>默认情况下<code>shared_ptr</code>假定其指向动态内存，使用<code>delete</code>释放对象。创建<code>shared_ptr</code>时可以传递一个（可选）指向删除函数的指针参数，用来代替<code>delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;    <span class="comment">// represents what we are connecting to</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;     <span class="comment">// information needed to use the connection</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;   <span class="comment">// open the connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;    <span class="comment">// close the given connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other parameters */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// use the connection</span></span><br><span class="line">    <span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针规范：</p><ul><li>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</li><li>不释放<code>get</code>返回的指针。</li><li>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</li><li>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</li><li>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</li></ul><hr><h4 id="深度理解智能指针"><a href="#深度理解智能指针" class="headerlink" title="深度理解智能指针"></a>深度理解智能指针</h4><p><strong>1.智能指针的作用</strong></p><p>​    C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><p>理解智能指针需要从下面三个层次：</p><ol><li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同，在Java里面下列代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">　　<span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>   你当然知道，这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a;</span><br><span class="line">Animal b = a;</span><br></pre></td></tr></table></figure><p>   这里却是就是生成了两个对象。</p><p>2.智能指针的实质</p><p>   前面已经说过了，<strong>智能指针是一个类对象（类似迭代器，其实也是用类对象来模拟指针的作用）</strong>，这样在被调函数执行完，程序过期时，对象将会被删除（对象的名字保存在栈变量中），这样不仅对象会被删除，它指向的内存也会被删除的。</p><p>智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、auto_ptr</p><p>建议：</p><p>​      1-每种指针都有不同的使用范围，unique_ptr指针优于其它两种类型，除非对象需要共享时用shared_ptr。</p><p>​      2- 建议– 如果你没有打算在多个线程之间来共享资源的话，那么就请使用unique_ptr。</p><p>​      3 -建议- 使用make_shared而不是裸指针来初始化共享指针。</p><p>​      4 -建议 – 在设计类的时候，当不需要资源的所有权，而且你不想指定这个对象的生命周期时，可以考虑使用weak_ptr代替shared_ptr。</p><p>使用智能指针的时候，只需要将new出的地址值赋值给这种对象，也就是将new出的地址作为实参！</p><p><strong>总结：智能指针其实就是类对象，来模拟指针的效果，从而实现更安全的管理内存的操作，实现了自动释放内存等功能。<br>智能指针分类，最简单实用的是unique_ptr,如果要多个指针指向同一个对象的话，要使用shared_ptr，同时因为多个指针<br>操作一个对象，一定会带来多线程那种读写脏数据的问题，这时候就要加锁，而这里加锁的方式就是通过使用weak_ptr的<br>lock()函数来进行的。而对于shared_ptr的数据结构，其实就是里边有一个count计数的类，并且重载了&gt;和*以及=等操作，<br>并且根据实际需要实现维护count和释放内存的操作。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十二章-动态内存&quot;&gt;&lt;a href=&quot;#第十二章-动态内存&quot; class=&quot;headerlink&quot; title=&quot;第十二章 动态内存&quot;&gt;&lt;/a&gt;第十二章 动态内存&lt;/h2&gt;&lt;p&gt;程序用堆（heap）来存储动态分配（dynamically allocate）的对象</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十一章-关联容器</title>
    <link href="http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2022-03-02T12:25:30.000Z</published>
    <updated>2022-06-29T13:11:59.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><p>关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是<code>map</code>和<code>set</code>。</p><ul><li><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</li><li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</li></ul><p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p><ul><li>是<code>map</code>还是<code>set</code>类型。</li><li>是否允许保存重复的关键字。</li><li>是否按顺序保存元素。</li></ul><p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-1.png" alt="11-1"></p><p><code>map</code>和<code>multimap</code>类型定义在头文件<em>map</em>中；<code>set</code>和<code>multiset</code>类型定义在头文件<em>set</em>中；无序容器定义在头文件<em>unordered_map</em>和<em>unordered_set</em>中。</p><h2 id="使用关联容器（Using-an-Associative-Container）"><a href="#使用关联容器（Using-an-Associative-Container）" class="headerlink" title="使用关联容器（Using an Associative Container）"></a>使用关联容器（Using an Associative Container）</h2><p><code>map</code>类型通常被称为关联数组（associative array）。</p><p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count the number of times each word occurs in the input</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;     <span class="comment">// empty map from string to size_t</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];     <span class="comment">// fetch and increment the counter for word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)    <span class="comment">// for each element in the map</span></span><br><span class="line">    <span class="comment">// print the results</span></span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p><h2 id="关联容器概述（Overview-of-the-Associative-Containers）"><a href="#关联容器概述（Overview-of-the-Associative-Containers）" class="headerlink" title="关联容器概述（Overview of the Associative Containers）"></a>关联容器概述（Overview of the Associative Containers）</h2><h3 id="定义关联容器（Defining-an-Associative-Container）"><a href="#定义关联容器（Defining-an-Associative-Container）" class="headerlink" title="定义关联容器（Defining an Associative Container）"></a>定义关联容器（Defining an Associative Container）</h3><p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p><p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;   <span class="comment">// empty</span></span><br><span class="line"><span class="comment">// list initialization</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// three elements; authors maps last name to first</span></span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p><h3 id="关键字类型的要求（Requirements-on-Key-Type）"><a href="#关键字类型的要求（Requirements-on-Key-Type）" class="headerlink" title="关键字类型的要求（Requirements on Key Type）"></a>关键字类型的要求（Requirements on Key Type）</h3><p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p><p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bookstore can have several transactions with the same ISBN</span></span><br><span class="line"><span class="comment">// elements in bookstore will be in ISBN order</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pair类型（The-pair-Type）"><a href="#pair类型（The-pair-Type）" class="headerlink" title="pair类型（The pair Type）"></a>pair类型（The pair Type）</h3><p><code>pair</code>定义在头文件<em>utility</em>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// holds two strings</span></span><br><span class="line">pair&lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">// holds a string and an size_t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; line;   <span class="comment">// holds string and vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p><p><code>pair</code>支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-2.png" alt="11-2"></p><p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="comment">// list initialize</span></span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// explicitly constructed return value</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联容器操作（Operations-on-Associative-Containers）"><a href="#关联容器操作（Operations-on-Associative-Containers）" class="headerlink" title="关联容器操作（Operations on Associative Containers）"></a>关联容器操作（Operations on Associative Containers）</h2><p>关联容器定义了类型别名来表示容器关键字和值的类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-3.png" alt="11-3"></p><p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是关键字-值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure><h3 id="关联容器迭代器（Associative-Container-Iterators）"><a href="#关联容器迭代器（Associative-Container-Iterators）" class="headerlink" title="关联容器迭代器（Associative Container Iterators）"></a>关联容器迭代器（Associative Container Iterators）</h3><p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to an element in word_count</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// *map_it is a reference to a pair&lt;const string, size_t&gt; object</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;first;          <span class="comment">// prints the key for this element</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; map_it-&gt;second;  <span class="comment">// prints the value of the element</span></span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;      <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second;               <span class="comment">// ok: we can change the value through an iterator</span></span><br></pre></td></tr></table></figure><p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error: keys in a set are read-only</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok: can read the key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p><p>通常不对关联容器使用泛型算法。</p><h3 id="添加元素（Adding-Elements）"><a href="#添加元素（Adding-Elements）" class="headerlink" title="添加元素（Adding Elements）"></a>添加元素（Adding Elements）</h3><p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p><p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// four ways to add word to word_count</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>关联容器的<code>insert</code>操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211132789.png" alt="image-20220629211132789"></p><p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p><ul><li>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</li><li>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</li></ul><h3 id="删除元素（Erasing-Elements）"><a href="#删除元素（Erasing-Elements）" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>关联容器的删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-5.png" alt="11-5"></p><p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p><h3 id="map的下标操作（Subscripting-a-map）"><a href="#map的下标操作（Subscripting-a-map）" class="headerlink" title="map的下标操作（Subscripting a map）"></a>map的下标操作（Subscripting a map）</h3><p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p><p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p><p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p><h3 id="访问元素（Accessing-Elements）"><a href="#访问元素（Accessing-Elements）" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><p>关联容器的查找操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-7.png" alt="11-7"></p><p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">// adds the first element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// ok: adds the second element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;      <span class="comment">// author we&#x27;ll look for</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_item);  <span class="comment">// number of elements</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);      <span class="comment">// first entry for this author</span></span><br><span class="line"><span class="comment">// loop through the number of entries there are for this author</span></span><br><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;   <span class="comment">// print each title</span></span><br><span class="line">    ++iter;      <span class="comment">// advance to the next title</span></span><br><span class="line">    --entries;   <span class="comment">// keep track of how many we&#x27;ve printed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// beg and end denote the range of elements for this author</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;    <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p><p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// pos holds iterators that denote the range of elements for this key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure><h2 id="无序容器（The-Unordered-Containers）"><a href="#无序容器（The-Unordered-Containers）" class="headerlink" title="无序容器（The Unordered Containers）"></a>无序容器（The Unordered Containers）</h2><p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p><p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p><p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p><p>无序容器管理操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-8.png" alt="11-8"></p><p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第11章-关联容器&quot;&gt;&lt;a href=&quot;#第11章-关联容器&quot; class=&quot;headerlink&quot; title=&quot;第11章 关联容器&quot;&gt;&lt;/a&gt;第11章 关联容器&lt;/h1&gt;&lt;p&gt;关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第九章-顺序容器</title>
    <link href="http://icecorn.github.io/2022/02/28/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    <id>http://icecorn.github.io/2022/02/28/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</id>
    <published>2022-02-28T12:25:30.000Z</published>
    <updated>2022-06-29T13:08:35.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第9章-顺序容器"><a href="#第9章-顺序容器" class="headerlink" title="第9章 顺序容器"></a>第9章 顺序容器</h1><h2 id="顺序容器概述（Overview-of-the-Sequential-Containers）"><a href="#顺序容器概述（Overview-of-the-Sequential-Containers）" class="headerlink" title="顺序容器概述（Overview of the Sequential Containers）"></a>顺序容器概述（Overview of the Sequential Containers）</h2><p>顺序容器类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-1.png" alt="9-1"></p><table><thead><tr><th align="center">类型</th><th align="center">特性</th></tr></thead><tbody><tr><td align="center"><code>vector</code></td><td align="center">可变大小数组。支持快速随机访问。在尾部之外的位置插入/删除元素可能很慢</td></tr><tr><td align="center"><code>deque</code></td><td align="center">双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td></tr><tr><td align="center"><code>list</code></td><td align="center">双向链表。只支持双向顺序访问。在任何位置插入/删除速度都很快</td></tr><tr><td align="center"><code>forward_list</code></td><td align="center">单向链表。只支持单向顺序访问。在任何位置插入/删除速度都很快</td></tr><tr><td align="center"><code>array</code></td><td align="center">固定大小数组。支持快速随机访问。不能添加/删除元素</td></tr><tr><td align="center"><code>string</code></td><td align="center">类似<code>vector</code>，但用于保存字符。支持快速随机访问。在尾部插入/删除速度很快</td></tr></tbody></table><p><code>forward_list</code>和<code>array</code>是C++11新增类型。与内置数组相比，<code>array</code>更安全易用。<code>forward_list</code>没有<code>size</code>操作。</p><p>容器选择原则：</p><ul><li>除非有合适的理由选择其他容器，否则应该使用<code>vector</code>。</li><li>如果程序有很多小的元素，且空间的额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code>。</li><li>如果程序要求随机访问容器元素，则应该使用<code>vector</code>或<code>deque</code>。</li><li>如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用<code>deque</code>。</li><li>如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则：<ul><li>先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向<code>vector</code>追加数据，再调用标准库的<code>sort</code>函数重排元素，从而避免在中间位置添加元素。</li><li>如果必须在中间位置插入元素，可以在输入阶段使用<code>list</code>。输入完成后将<code>list</code>中的内容拷贝到<code>vector</code>中。</li></ul></li><li>不确定应该使用哪种容器时，可以先只使用<code>vector</code>和<code>list</code>的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择<code>vector</code>或<code>list</code>都很方便。</li></ul><h2 id="容器库概览（Container-Library-Overview）"><a href="#容器库概览（Container-Library-Overview）" class="headerlink" title="容器库概览（Container Library Overview）"></a>容器库概览（Container Library Overview）</h2><p>每个容器都定义在一个头文件中，文件名与类型名相同。容器均为模板类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-2.png" alt="9-2"></p><h3 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h3><p><code>forward_list</code>类型不支持递减运算符<code>--</code>。</p><p>一个迭代器范围（iterator range）由一对迭代器表示。这两个迭代器通常被称为<code>begin</code>和<code>end</code>，分别指向同一个容器中的元素或尾后地址。<code>end</code>迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为<code>[begin，end）</code>。迭代器<code>begin</code>和<code>end</code>必须指向相同的容器，<code>end</code>可以与<code>begin</code>指向相同的位置，但不能指向<code>begin</code>之前的位置（由程序员确保）。</p><p>假定<code>begin</code>和<code>end</code>构成一个合法的迭代器范围，则：</p><ul><li>如果<code>begin</code>等于<code>end</code>，则范围为空。</li><li>如果<code>begin</code>不等于<code>end</code>，则范围内至少包含一个元素，且<code>begin</code>指向该范围内的第一个元素。</li><li>可以递增<code>begin</code>若干次，令<code>begin</code>等于<code>end</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != end)</span><br><span class="line">&#123;</span><br><span class="line">    *begin = val;   <span class="comment">// ok: range isn&#x27;t empty so begin denotes an element</span></span><br><span class="line">    ++begin;    <span class="comment">// advance the iterator to get the next element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器类型成员（Container-Type-Members）"><a href="#容器类型成员（Container-Type-Members）" class="headerlink" title="容器类型成员（Container Type Members）"></a>容器类型成员（Container Type Members）</h3><p>通过类型别名，可以在不了解容器元素类型的情况下使用元素。如果需要元素类型，可以使用容器的<code>value_type</code>。如果需要元素类型的引用，可以使用<code>reference</code>或<code>const_reference</code>。</p><h3 id="begin和end成员（begin-and-end-Members）"><a href="#begin和end成员（begin-and-end-Members）" class="headerlink" title="begin和end成员（begin and end Members）"></a>begin和end成员（begin and end Members）</h3><p><code>begin</code>和<code>end</code>操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。</p><p><code>begin</code>和<code>end</code>操作有多个版本：带<code>r</code>的版本返回反向迭代器。以<code>c</code>开头的版本（C++11新增）返回<code>const</code>迭代器。不以<code>c</code>开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对<code>const</code>对象调用时，返回<code>const</code>迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();    <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>();   <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();   <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>();  <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure><p>当<code>auto</code>与<code>begin</code>或<code>end</code>结合使用时，返回的迭代器类型依赖于容器类型。但调用以<code>c</code>开头的版本仍然可以获得<code>const</code>迭代器，与容器是否是常量无关。</p><p>当程序不需要写操作时，应该使用<code>cbegin</code>和<code>cend</code>。</p><h3 id="容器定义和初始化（Defining-and-Initializing-a-Container）"><a href="#容器定义和初始化（Defining-and-Initializing-a-Container）" class="headerlink" title="容器定义和初始化（Defining and Initializing a Container）"></a>容器定义和初始化（Defining and Initializing a Container）</h3><p>容器定义和初始化方式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-3.png" alt="9-3"></p><p>将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。</p><p>传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;        <span class="comment">// ok: types match</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;    <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(articles)</span></span>;     <span class="comment">// error: element types must match</span></span><br><span class="line"><span class="comment">// ok: converts const char* elements to string</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br></pre></td></tr></table></figure><p>C++11允许对容器进行列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>定义和使用<code>array</code>类型时，需要同时指定元素类型和容器大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 42&gt;      <span class="comment">// type is: array that holds 42 ints</span></span><br><span class="line">array&lt;string, 10&gt;   <span class="comment">// type is: array that holds 10 strings</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;::size_type i;   <span class="comment">// array type includes element type and size</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt;::size_type j;       <span class="comment">// error: array&lt;int&gt; is not a type</span></span><br></pre></td></tr></table></figure><p>对<code>array</code>进行列表初始化时，初始值的数量不能大于<code>array</code>的大小。如果初始值的数量小于<code>array</code>的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。</p><p>可以对<code>array</code>进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。</p><h3 id="赋值和swap（Assignment-and-swap）"><a href="#赋值和swap（Assignment-and-swap）" class="headerlink" title="赋值和swap（Assignment and swap）"></a>赋值和swap（Assignment and swap）</h3><p>容器赋值操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210627262.png" alt="image-20220629210627262"></p><p>赋值运算符两侧的运算对象必须类型相同。<code>assign</code>允许用不同但相容的类型赋值，或者用容器的子序列赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;   <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="comment">// ok: can convert from const char*to string</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br></pre></td></tr></table></figure><p>由于其旧元素被替换，因此传递给<code>assign</code>的迭代器不能指向调用<code>assign</code>的容器本身。</p><p><code>swap</code>交换两个相同类型容器的内容。除<code>array</code>外，<code>swap</code>不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此可以保证快速完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// vector with ten elements</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;   <span class="comment">// vector with 24 elements</span></span><br><span class="line"><span class="built_in">swap</span>(svec1, svec2);</span><br></pre></td></tr></table></figure><p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而<code>swap</code>操作交换容器内容，不会导致迭代器、引用和指针失效（<code>array</code>和<code>string</code>除外）。</p><p>对于<code>array</code>，<code>swap</code>会真正交换它们的元素。因此在<code>swap</code>操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 3&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换后的值，即4、5、6</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于其他容器类型（除<code>string</code>），指针、引用和迭代器在<code>swap</code>操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换前的值，即1、2、3</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>array</code>不支持<code>assign</code>，也不允许用花括号列表进行赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;;    <span class="comment">// elements all have value 0</span></span><br><span class="line">a1 = a2;    <span class="comment">// replaces elements in a1</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;;   <span class="comment">// error: cannot assign to an array from a braced list</span></span><br></pre></td></tr></table></figure><p>新标准库同时提供了成员和非成员函数版本的<code>swap</code>。非成员版本的<code>swap</code>在泛型编程中非常重要，建议统一使用非成员版本的<code>swap</code>。</p><h3 id="容器大小操作（Container-Size-Operations）"><a href="#容器大小操作（Container-Size-Operations）" class="headerlink" title="容器大小操作（Container Size Operations）"></a>容器大小操作（Container Size Operations）</h3><p><code>size</code>成员返回容器中元素的数量；<code>empty</code>当<code>size</code>为0时返回<code>true</code>，否则返回<code>false</code>；<code>max_size</code>返回一个大于或等于该类型容器所能容纳的最大元素数量的值。<code>forward_list</code>支持<code>max_size</code>和<code>empty</code>，但不支持<code>size</code>。</p><h3 id="关系运算符（Relational-Operators）"><a href="#关系运算符（Relational-Operators）" class="headerlink" title="关系运算符（Relational Operators）"></a>关系运算符（Relational Operators）</h3><p>每个容器类型都支持相等运算符（<code>==</code>、<code>!=</code>）。除无序关联容器外，其他容器都支持关系运算符（<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。关系运算符两侧的容器类型和保存元素类型都必须相同。</p><p>两个容器的比较实际上是元素的逐对比较，其工作方式与<code>string</code>的关系运算符类似：</p><ul><li>如果两个容器大小相同且所有元素对应相等，则这两个容器相等。</li><li>如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li><li>如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">v1 &lt; v2     <span class="comment">// true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]</span></span><br><span class="line">v1 &lt; v3     <span class="comment">// false; all elements are equal, but v3 has fewer of them;</span></span><br><span class="line">v1 == v4    <span class="comment">// true; each element is equal and v1 and v4 have the same size()</span></span><br><span class="line">v1 == v2    <span class="comment">// false; v2 has fewer elements than v1</span></span><br></pre></td></tr></table></figure><p>容器的相等运算符实际上是使用元素的<code>==</code>运算符实现的，而其他关系运算符则是使用元素的<code>&lt;</code>运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。</p><h2 id="顺序容器操作（Sequential-Container-Operations）"><a href="#顺序容器操作（Sequential-Container-Operations）" class="headerlink" title="顺序容器操作（Sequential Container Operations）"></a>顺序容器操作（Sequential Container Operations）</h2><h3 id="向顺序容器添加元素（Adding-Elements-to-a-Sequential-Container）"><a href="#向顺序容器添加元素（Adding-Elements-to-a-Sequential-Container）" class="headerlink" title="向顺序容器添加元素（Adding Elements to a Sequential Container）"></a>向顺序容器添加元素（Adding Elements to a Sequential Container）</h3><p>除<code>array</code>外，所有标准库容器都提供灵活的内存管理，在运行时可以动态添加或删除元素。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-5.png" alt="9-5"></p><p><code>push_back</code>将一个元素追加到容器尾部，<code>push_front</code>将元素插入容器头部。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from standard input, putting each word onto the end of container</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    container.<span class="built_in">push_back</span>(word);</span><br></pre></td></tr></table></figure><p><code>insert</code>将元素插入到迭代器指定的位置之前。一些不支持<code>push_front</code>的容器可以使用<code>insert</code>将元素插入开始位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;string&gt; slist;</span><br><span class="line"><span class="comment">// equivalent to calling slist.push_front(&quot;Hello!&quot;);</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="comment">// no push_front on vector but we can insert before begin()</span></span><br><span class="line"><span class="comment">// warning: inserting anywhere but at the end of a vector might be slow</span></span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure><p>将元素插入到<code>vector</code>、<code>deque</code>或<code>string</code>的任何位置都是合法的，但可能会很耗时。</p><p>在新标准库中，接受元素个数或范围的<code>insert</code>版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回<code>void</code>。如果范围为空，不插入任何元素，<code>insert</code>会返回第一个参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; <span class="number">1</span>st;</span><br><span class="line"><span class="keyword">auto</span> iter = <span class="number">1</span>st.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    iter = <span class="number">1</span>st.<span class="built_in">insert</span>(iter, word);  <span class="comment">// same as calling push_front</span></span><br></pre></td></tr></table></figure><p>新标准库增加了三个直接构造而不是拷贝元素的操作：<code>emplace_front</code>、<code>emplace_back</code>和<code>emplace</code>，其分别对应<code>push_front</code>、<code>push_back</code>和<code>insert</code>。当调用<code>push</code>或<code>insert</code>时，元素对象被拷贝到容器中。而调用<code>emplace</code>时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a Sales_data object at the end of c</span></span><br><span class="line"><span class="comment">// uses the three-argument Sales_data constructor</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// error: there is no version of push_back that takes three arguments</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// ok: we create a temporary Sales_data object to pass to push_back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure><p>传递给<code>emplace</code>的参数必须与元素类型的构造函数相匹配。</p><p><code>forward_list</code>有特殊版本的<code>insert</code>和<code>emplace</code>操作，且不支持<code>push_back</code>和<code>emplace_back</code>。<code>vector</code>和<code>string</code>不支持<code>push_front</code>和<code>emplace_front</code>。</p><h3 id="访问元素（Accessing-Elements）"><a href="#访问元素（Accessing-Elements）" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><p>每个顺序容器都有一个<code>front</code>成员函数，而除了<code>forward_list</code>之外的顺序容器还有一个<code>back</code>成员函数。这两个操作分别返回首元素和尾元素的引用。</p><p>在调用<code>front</code>和<code>back</code>之前，要确保容器非空。</p><p>顺序容器的元素访问操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210649908.png" alt="image-20220629210649908"></p><p>在容器中访问元素的成员函数都返回引用类型。如果容器是<code>const</code>对象，则返回<code>const</code>引用，否则返回普通引用。</p><p>可以快速随机访问的容器（<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code>）都提供下标运算符。保证下标有效是程序员的责任。如果希望确保下标合法，可以使用<code>at</code>成员函数。<code>at</code>类似下标运算，但如果下标越界，<code>at</code>会抛出<code>out_of_range</code>异常。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;  <span class="comment">// empty vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];      <span class="comment">// run-time error: there are no elements in svec!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);   <span class="comment">// throws an out_of_range exception</span></span><br></pre></td></tr></table></figure><h3 id="删除元素（Erasing-Elements）"><a href="#删除元素（Erasing-Elements）" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>顺序容器的元素删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-7.png" alt="9-7"></p><p>删除<code>deque</code>中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除<code>vector</code>或<code>string</code>的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。</p><p>删除元素前，程序员必须确保目标元素存在。</p><p><code>pop_front</code>和<code>pop_back</code>函数分别删除首元素和尾元素。<code>vector</code>和<code>string</code>类型不支持<code>pop_front</code>，<code>forward_list</code>类型不支持<code>pop_back</code>。</p><p><code>erase</code>函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的<code>erase</code>都返回指向删除元素（最后一个）之后位置的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete the range of elements between two iterators</span></span><br><span class="line"><span class="comment">// returns an iterator to the element just after the last removed element</span></span><br><span class="line">elem1 = slist.<span class="built_in">erase</span>(elem1, elem2);  <span class="comment">// after the call elem1 == elem2</span></span><br></pre></td></tr></table></figure><p><code>clear</code>函数删除容器内的所有元素。</p><h3 id="特殊的forward-list操作（Specialized-forward-list-Operations）"><a href="#特殊的forward-list操作（Specialized-forward-list-Operations）" class="headerlink" title="特殊的forward_list操作（Specialized forward_list Operations）"></a>特殊的forward_list操作（Specialized forward_list Operations）</h3><p>在<code>forward_list</code>中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-8.png" alt="9-8"></p><p><code>forward_list</code>的插入和删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-9.png" alt="9-9"></p><h3 id="改变容器大小（Resizing-a-Container）"><a href="#改变容器大小（Resizing-a-Container）" class="headerlink" title="改变容器大小（Resizing a Container）"></a>改变容器大小（Resizing a Container）</h3><p>顺序容器的大小操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210707236.png" alt="image-20220629210707236"></p><p><code>resize</code>函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且<code>resize</code>向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。</p><h3 id="容器操作可能使迭代器失效（Container-Operations-May-Invalidate-Iterators）"><a href="#容器操作可能使迭代器失效（Container-Operations-May-Invalidate-Iterators）" class="headerlink" title="容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）"></a>容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）</h3><p>向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。</p><ul><li>向容器中添加元素后：<ul><li>如果容器是<code>vector</code>或<code>string</code>类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。</li><li>如果容器是<code>deque</code>类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。</li><li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器的迭代器、指针和引用仍然有效。</li></ul></li><li>从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效：<ul><li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器其他位置的迭代器、指针和引用仍然有效。</li><li>如果容器是<code>deque</code>类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。</li><li>如果容器是<code>vector</code>或<code>string</code>类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。</li></ul></li></ul><p>必须保证在每次改变容器后都正确地重新定位迭代器。</p><p>不要保存<code>end</code>函数返回的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// safer: recalculate end on each trip whenever the loop adds/erases elements</span></span><br><span class="line"><span class="keyword">while</span> (begin != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do some processing</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin because we want to insert after this element</span></span><br><span class="line">    begin = v.<span class="built_in">insert</span>(begin, <span class="number">42</span>);    <span class="comment">// insert the new value</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin past the element we just added</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector对象是如何增长的（How-a-vector-Grows）"><a href="#vector对象是如何增长的（How-a-vector-Grows）" class="headerlink" title="vector对象是如何增长的（How a vector Grows）"></a>vector对象是如何增长的（How a vector Grows）</h2><p><code>vector</code>和<code>string</code>的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多新元素。</p><p>容器大小管理操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210726965.png" alt="image-20220629210726965"></p><p><code>capacity</code>函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。<code>reserve</code>函数告知容器应该准备保存多少元素，它并不改变容器中元素的数量，仅影响容器预先分配的内存空间大小。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-12.png" alt="9-12"></p><p>只有当需要的内存空间超过当前容量时，<code>reserve</code>才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，<code>reserve</code>并不会退回内存空间。因此在调用<code>reserve</code>之后，<code>capacity</code>会大于或等于传递给<code>reserve</code>的参数。</p><p>在C++11中可以使用<code>shrink_to_fit</code>函数来要求<code>deque</code>、<code>vector</code>和<code>string</code>退回不需要的内存空间（并不保证退回）。</p><h2 id="额外的string操作（Additional-string-Operations）"><a href="#额外的string操作（Additional-string-Operations）" class="headerlink" title="额外的string操作（Additional string Operations）"></a>额外的string操作（Additional string Operations）</h2><h3 id="构造string的其他方法（Other-Ways-to-Construct-strings）"><a href="#构造string的其他方法（Other-Ways-to-Construct-strings）" class="headerlink" title="构造string的其他方法（Other Ways to Construct strings）"></a>构造string的其他方法（Other Ways to Construct strings）</h3><p>构造<code>string</code>的其他方法：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-13.png" alt="9-13"></p><p>从另一个<code>string</code>对象拷贝字符构造<code>string</code>时，如果提供的拷贝开始位置（可选）大于给定<code>string</code>的大小，则构造函数会抛出<code>out_of_range</code>异常。</p><p>子字符串操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-14.png" alt="9-14"></p><p>如果传递给<code>substr</code>函数的开始位置超过<code>string</code>的大小，则函数会抛出<code>out_of_range</code>异常。</p><h3 id="改变string的其他方法（Other-Ways-to-Change-a-string）"><a href="#改变string的其他方法（Other-Ways-to-Change-a-string）" class="headerlink" title="改变string的其他方法（Other Ways to Change a string）"></a>改变string的其他方法（Other Ways to Change a string）</h3><p>修改<code>string</code>的操作：</p><p><code>append</code>函数是在<code>string</code>末尾进行插入操作的简写形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>, s2 </span>= s;     <span class="comment">// initialize s and s2 to &quot;C++ Primer&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2</span></span><br></pre></td></tr></table></figure><p><code>replace</code>函数是调用<code>erase</code>和<code>insert</code>函数的简写形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">11</span>, <span class="number">3</span>);         <span class="comment">// s == &quot;C++ Primer Ed.&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;5th&quot;</span>);    <span class="comment">// s == &quot;C++ Primer 5th Ed.&quot;</span></span><br><span class="line"><span class="comment">// starting at position 11, erase three characters and then insert &quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&quot;5th&quot;</span>);   <span class="comment">// equivalent: s == s2</span></span><br></pre></td></tr></table></figure><h3 id="string搜索操作（string-Search-Operations）"><a href="#string搜索操作（string-Search-Operations）" class="headerlink" title="string搜索操作（string Search Operations）"></a>string搜索操作（string Search Operations）</h3><p><code>string</code>的每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配位置的下标。如果搜索失败，则返回一个名为<code>string::npos</code>的<code>static</code>成员。标准库将<code>npos</code>定义为<code>const string::size_type</code>类型，并初始化为-1。</p><p>不建议用<code>int</code>或其他带符号类型来保存<code>string</code>搜索函数的返回值。</p><p><code>string</code>搜索操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-16.png" alt="9-16"></p><h3 id="compare函数（The-compare-Functions）"><a href="#compare函数（The-compare-Functions）" class="headerlink" title="compare函数（The compare Functions）"></a>compare函数（The compare Functions）</h3><p><code>string</code>类型提供了一组<code>compare</code>函数进行字符串比较操作，类似C标准库的<code>strcmp</code>函数。</p><p><code>compare</code>函数的几种参数形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210808871.png" alt="image-20220629210808871"></p><h3 id="数值转换（Numeric-Conversions）"><a href="#数值转换（Numeric-Conversions）" class="headerlink" title="数值转换（Numeric Conversions）"></a>数值转换（Numeric Conversions）</h3><p>C++11增加了<code>string</code>和数值之间的转换函数：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-18.png" alt="9-18"></p><p>进行数值转换时，<code>string</code>参数的第一个非空白字符必须是符号（<code>+</code>或<code>-</code>）或数字。它可以以<code>0x</code>或<code>0X</code>开头来表示十六进制数。对于转换目标是浮点值的函数，<code>string</code>参数也可以以小数点开头，并可以包含<code>e</code>或<code>E</code>来表示指数部分。</p><p>如果给定的<code>string</code>不能转换为一个数值，则转换函数会抛出<code>invalid_argument</code>异常。如果转换得到的数值无法用任何类型表示，则抛出<code>out_of_range</code>异常。</p><h2 id="容器适配器（Container-Adaptors）"><a href="#容器适配器（Container-Adaptors）" class="headerlink" title="容器适配器（Container Adaptors）"></a>容器适配器（Container Adaptors）</h2><p>标准库定义了<code>stack</code>、<code>queue</code>和<code>priority_queue</code>三种容器适配器。容器适配器可以改变已有容器的工作机制。</p><p>所有容器适配器都支持的操作和类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-19.png" alt="9-19"></p><p>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是基于<code>vector</code>实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on top of vector</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure><p>所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在<code>array</code>上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用<code>forward_list</code>构造适配器。</p><p>栈适配器<code>stack</code>定义在头文件<em>stack</em>中，其支持的操作如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210825536.png" alt="image-20220629210825536"></p><p>队列适配器<code>queue</code>和<code>priority_queue</code>定义在头文件<em>queue</em>中，其支持的操作如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/9-21.png" alt="9-21"></p><p><code>queue</code>使用先进先出（first-in，first-out，FIFO）的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第9章-顺序容器&quot;&gt;&lt;a href=&quot;#第9章-顺序容器&quot; class=&quot;headerlink&quot; title=&quot;第9章 顺序容器&quot;&gt;&lt;/a&gt;第9章 顺序容器&lt;/h1&gt;&lt;h2 id=&quot;顺序容器概述（Overview-of-the-Sequential-Contain</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第八章-IO库</title>
    <link href="http://icecorn.github.io/2022/02/26/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-IO%E5%BA%93/"/>
    <id>http://icecorn.github.io/2022/02/26/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-IO%E5%BA%93/</id>
    <published>2022-02-26T12:25:30.000Z</published>
    <updated>2022-06-29T13:04:00.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第8章-IO库"><a href="#第8章-IO库" class="headerlink" title="第8章 IO库"></a>第8章 IO库</h1><p>部分IO库设施：</p><ul><li><code>istream</code>：输入流类型，提供输入操作。</li><li><code>ostream</code>：输出流类型，提供输出操作。</li><li><code>cin</code>：<code>istream</code>对象，从标准输入读取数据。</li><li><code>cout</code>：<code>ostream</code>对象，向标准输出写入数据。</li><li><code>cerr</code>：<code>ostream</code>对象，向标准错误写入数据。</li><li><code>&gt;&gt;</code>运算符：从<code>istream</code>对象读取输入数据。</li><li><code>&lt;&lt;</code>运算符：向<code>ostream</code>对象写入输出数据。</li><li><code>getline</code>函数：从<code>istream</code>对象读取一行数据，写入<code>string</code>对象。</li></ul><h2 id="IO类（The-IO-Classes）"><a href="#IO类（The-IO-Classes）" class="headerlink" title="IO类（The IO Classes）"></a>IO类（The IO Classes）</h2><p>头文件<em>iostream</em>定义了用于读写流的基本类型，<em>fstream</em>定义了读写命名文件的类型，<em>sstream</em>定义了读写内存中<code>string</code>对象的类型。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210314294.png" alt="image-20220629210314294"></p><p>宽字符版本的IO类型和函数的名字以<code>w</code>开始，如<code>wcin</code>、<code>wcout</code>和<code>wcerr</code>分别对应<code>cin</code>、<code>cout</code>和<code>cerr</code>。它们与其对应的普通<code>char</code>版本都定义在同一个头文件中，如头文件<em>fstream</em>定义了<code>ifstream</code>和<code>wifstream</code>类型。</p><p>可以将派生类的对象当作其基类的对象使用。</p><h3 id="IO象无拷贝或赋值（No-Copy-or-Assign-for-IO-Objects）"><a href="#IO象无拷贝或赋值（No-Copy-or-Assign-for-IO-Objects）" class="headerlink" title="IO象无拷贝或赋值（No Copy or Assign for IO Objects）"></a>IO象无拷贝或赋值（No Copy or Assign for IO Objects）</h3><p>不能拷贝或对IO对象赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ofstream out1, out2;</span><br><span class="line">out1 = out2;    <span class="comment">// error: cannot assign stream objects</span></span><br><span class="line"><span class="function">ofstream <span class="title">print</span><span class="params">(ofstream)</span></span>;   <span class="comment">// error: can&#x27;t initialize the ofstream parameter</span></span><br><span class="line">out2 = <span class="built_in">print</span>(out2);     <span class="comment">// error: cannot copy stream objects</span></span><br></pre></td></tr></table></figure><p>由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是<code>const</code>的。</p><h3 id="条件状态（Condition-States）"><a href="#条件状态（Condition-States）" class="headerlink" title="条件状态（Condition States）"></a>条件状态（Condition States）</h3><p>IO库条件状态：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8-2.png" alt="8-2"></p><p><code>badbit</code>表示系统级错误，如不可恢复的读写错误。通常情况下，一旦<code>badbit</code>被置位，流就无法继续使用了。在发生可恢复错误后，<code>failbit</code>会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，<code>eofbit</code>和<code>failbit</code>都会被置位。如果流未发生错误，则<code>goodbit</code>的值为0。如果<code>badbit</code>、<code>failbit</code>和<code>eofbit</code>任何一个被置位，检测流状态的条件都会失败。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok: read operation successful...</span></span><br></pre></td></tr></table></figure><p><code>good</code>函数在所有错误均未置位时返回<code>true</code>。而<code>bad</code>、<code>fail</code>和<code>eof</code>函数在对应错误位被置位时返回<code>true</code>。此外，在<code>badbit</code>被置位时，<code>fail</code>函数也会返回<code>true</code>。因此应该使用<code>good</code>或<code>fail</code>函数确定流的总体状态，<code>eof</code>和<code>bad</code>只能检测特定错误。</p><p>流对象的<code>rdstate</code>成员返回一个<code>iostate</code>值，表示流的当前状态。<code>setstate</code>成员用于将指定条件置位（叠加原始流状态）。<code>clear</code>成员的无参版本清除所有错误标志；含参版本接受一个<code>iostate</code>值，用于设置流的新状态（覆盖原始流状态）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remember the current state of cin</span></span><br><span class="line"><span class="keyword">auto</span> old_state = cin.<span class="built_in">rdstate</span>();     <span class="comment">// remember the current state of cin</span></span><br><span class="line">cin.<span class="built_in">clear</span>();    <span class="comment">// make cin valid</span></span><br><span class="line"><span class="built_in">process_input</span>(cin);     <span class="comment">// use cin</span></span><br><span class="line">cin.<span class="built_in">setstate</span>(old_state);    <span class="comment">// now reset cin to its old state</span></span><br></pre></td></tr></table></figure><h3 id="管理输出缓冲（Managing-the-Output-Buffer）"><a href="#管理输出缓冲（Managing-the-Output-Buffer）" class="headerlink" title="管理输出缓冲（Managing the Output Buffer）"></a>管理输出缓冲（Managing the Output Buffer）</h3><p>每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多：</p><ul><li>程序正常结束。</li><li>缓冲区已满。</li><li>使用操纵符（如<code>endl</code>）显式刷新缓冲区。</li><li>在每个输出操作之后，可以用<code>unitbuf</code>操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对<code>cerr</code>是设置<code>unitbuf</code>的，因此写到<code>cerr</code>的内容都是立即刷新的。</li><li>一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，<code>cin</code>和<code>cerr</code>都关联到<code>cout</code>，因此，读<code>cin</code>或写<code>cerr</code>都会刷新<code>cout</code>的缓冲区。</li></ul><p><code>flush</code>操纵符刷新缓冲区，但不输出任何额外字符。<code>ends</code>向缓冲区插入一个空字符，然后刷新缓冲区。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; endl;   <span class="comment">// writes hi and a newline, then flushes the buffer</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; flush;  <span class="comment">// writes hi, then flushes the buffer; adds no data</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;hi!&quot;</span> &lt;&lt; ends;   <span class="comment">// writes hi and a null, then flushes the buffer</span></span><br></pre></td></tr></table></figure><p>如果想在每次输出操作后都刷新缓冲区，可以使用<code>unitbuf</code>操纵符。它令流在接下来的每次写操作后都进行一次<code>flush</code>操作。而<code>nounitbuf</code>操纵符则使流恢复使用正常的缓冲区刷新机制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; unitbuf;    <span class="comment">// all writes will be flushed immediately</span></span><br><span class="line"><span class="comment">// any output is flushed immediately, no buffering</span></span><br><span class="line">cout &lt;&lt; nounitbuf;  <span class="comment">// returns to normal buffering</span></span><br></pre></td></tr></table></figure><p>如果程序异常终止，输出缓冲区不会被刷新。</p><p>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将<code>cout</code>和<code>cin</code>关联在一起，因此下面的语句会导致<code>cout</code>的缓冲区被刷新：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; ival;</span><br></pre></td></tr></table></figure><p>交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。</p><p>使用<code>tie</code>函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。<code>tie</code>的第二个版本接受一个指向<code>ostream</code>的指针，将本对象关联到此<code>ostream</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cin.<span class="built_in">tie</span>(&amp;cout);     <span class="comment">// illustration only: the library ties cin and cout for us</span></span><br><span class="line"><span class="comment">// old_tie points to the stream (if any) currently tied to cin</span></span><br><span class="line">ostream *old_tie = cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>); <span class="comment">// cin is no longer tied</span></span><br><span class="line"><span class="comment">// ties cin and cerr; not a good idea because cin should be tied to cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(&amp;cerr);     <span class="comment">// reading cin flushes cerr, not cout</span></span><br><span class="line">cin.<span class="built_in">tie</span>(old_tie);   <span class="comment">// reestablish normal tie between cin and cout</span></span><br></pre></td></tr></table></figure><p>每个流同时最多关联一个流，但多个流可以同时关联同一个<code>ostream</code>。向<code>tie</code>传递空指针可以解开流的关联。</p><h2 id="文件输入输出（File-Input-and-Output）"><a href="#文件输入输出（File-Input-and-Output）" class="headerlink" title="文件输入输出（File Input and Output）"></a>文件输入输出（File Input and Output）</h2><p>头文件<em>fstream</em>定义了三个类型来支持文件IO：<code>ifstream</code>从给定文件读取数据，<code>ofstream</code>向指定文件写入数据，<code>fstream</code>可以同时读写指定文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629210334141.png" alt="image-20220629210334141"></p><h3 id="使用文件流对象（Using-File-Stream-Objects）"><a href="#使用文件流对象（Using-File-Stream-Objects）" class="headerlink" title="使用文件流对象（Using File Stream Objects）"></a>使用文件流对象（Using File Stream Objects）</h3><p>每个文件流类型都定义了<code>open</code>函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。</p><p>创建文件流对象时，如果提供了文件名（可选），<code>open</code>会被自动调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;   <span class="comment">// construct an ifstream and open the given file</span></span><br><span class="line">ofstream out;   <span class="comment">// output file stream that is not associated with any file</span></span><br></pre></td></tr></table></figure><p>在C++11中，文件流对象的文件名可以是<code>string</code>对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。</p><p>在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受<code>iostream</code>类型引用或指针参数的函数，可以用对应的<code>fstream</code>类型来调用。</p><p>可以先定义空文件流对象，再调用<code>open</code>函数将其与指定文件关联。如果<code>open</code>调用失败，<code>failbit</code>会被置位。</p><p>对一个已经打开的文件流调用<code>open</code>会失败，并导致<code>failbit</code>被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用<code>close</code>关闭当前文件，再调用<code>clear</code>重置流的条件状态（<code>close</code>不会重置流的条件状态）。</p><p>当<code>fstream</code>对象被销毁时，<code>close</code>会自动被调用。</p><h3 id="文件模式（File-Modes）"><a href="#文件模式（File-Modes）" class="headerlink" title="文件模式（File Modes）"></a>文件模式（File Modes）</h3><p>每个流都有一个关联的文件模式，用来指出如何使用文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8-4.png" alt="8-4"></p><ul><li>只能对<code>ofstream</code>或<code>fstream</code>对象设定<code>out</code>模式。</li><li>只能对<code>ifstream</code>或<code>fstream</code>对象设定<code>in</code>模式。</li><li>只有当<code>out</code>被设定时才能设定<code>trunc</code>模式。</li><li>只要<code>trunc</code>没被设定，就能设定<code>app</code>模式。在<code>app</code>模式下，即使没有设定<code>out</code>模式，文件也是以输出方式打开。</li><li>默认情况下，即使没有设定<code>trunc</code>，以<code>out</code>模式打开的文件也会被截断。如果想保留以<code>out</code>模式打开的文件内容，就必须同时设定<code>app</code>模式，这会将数据追加写到文件末尾；或者同时设定<code>in</code>模式，即同时进行读写操作。</li><li><code>ate</code>和<code>binary</code>模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。</li><li>与<code>ifstream</code>对象关联的文件默认以<code>in</code>模式打开，与<code>ofstream</code>对象关联的文件默认以<code>out</code>模式打开，与<code>fstream</code>对象关联的文件默认以<code>in</code>和<code>out</code>模式打开。</li></ul><p>默认情况下，打开<code>ofstream</code>对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定<code>app</code>或<code>in</code>模式。</p><p>流对象每次打开文件时都可以改变其文件模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ofstream out;   <span class="comment">// no file mode is set</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;scratchpad&quot;</span>);    <span class="comment">// mode implicitly out and trunc</span></span><br><span class="line">out.<span class="built_in">close</span>();    <span class="comment">// close out so we can use it for a different file</span></span><br><span class="line">out.<span class="built_in">open</span>(<span class="string">&quot;precious&quot;</span>, ofstream::app);   <span class="comment">// mode is out and app</span></span><br><span class="line">out.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure><h2 id="string流（string-Streams）"><a href="#string流（string-Streams）" class="headerlink" title="string流（string Streams）"></a>string流（string Streams）</h2><p>头文件<em>sstream</em>定义了三个类型来支持内存IO：<code>istringstream</code>从<code>string</code>读取数据，<code>ostringstream</code>向<code>string</code>写入数据，<code>stringstream</code>可以同时读写<code>string</code>的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8-5.png" alt="8-5"></p><h3 id="使用istringstream（Using-an-istringstream）"><a href="#使用istringstream（Using-an-istringstream）" class="headerlink" title="使用istringstream（Using an istringstream）"></a>使用istringstream（Using an istringstream）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// members are public by default</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PersonInfo</span></span><br><span class="line">&#123;</span><br><span class="line">    string name;</span><br><span class="line">    vector&lt;string&gt; phones;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string line, word;   <span class="comment">// will hold a line and word from input, respectively</span></span><br><span class="line">vector&lt;PersonInfo&gt; people;    <span class="comment">// will hold all the records from the input</span></span><br><span class="line"><span class="comment">// read the input a line at a time until cin hits end-of-file (or another error)</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">&#123;</span><br><span class="line">    PersonInfo info;    <span class="comment">// create an object to hold this record&#x27;s data</span></span><br><span class="line">    <span class="function">istringstream <span class="title">record</span><span class="params">(line)</span></span>;    <span class="comment">// bind record to the line we just read</span></span><br><span class="line">    record &gt;&gt; info.name;    <span class="comment">// read the name</span></span><br><span class="line">    <span class="keyword">while</span> (record &gt;&gt; word)  <span class="comment">// read the phone numbers</span></span><br><span class="line">        info.phones.<span class="built_in">push_back</span>(word);   <span class="comment">// and store them</span></span><br><span class="line">    people.<span class="built_in">push_back</span>(info);    <span class="comment">// append this record to people</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用ostringstream（Using-ostringstreams）"><a href="#使用ostringstream（Using-ostringstreams）" class="headerlink" title="使用ostringstream（Using ostringstreams）"></a>使用ostringstream（Using ostringstreams）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;entry : people)</span><br><span class="line">&#123; <span class="comment">// for each entry in people</span></span><br><span class="line">    ostringstream formatted, badNums;   <span class="comment">// objects created on each loop</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;nums : entry.phones)</span><br><span class="line">    &#123; <span class="comment">// for each number</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">valid</span>(nums))</span><br><span class="line">        &#123;</span><br><span class="line">            badNums &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; nums;  <span class="comment">// string in badNums</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// &#x27;&#x27;writes&#x27;&#x27; to formatted&#x27;s string</span></span><br><span class="line">            formatted &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; format(nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badNums.<span class="built_in">str</span>().<span class="built_in">empty</span>())   <span class="comment">// there were no bad numbers</span></span><br><span class="line">        os &lt;&lt; entry.name &lt;&lt; <span class="string">&quot; &quot;</span>  <span class="comment">// print the name</span></span><br><span class="line">            &lt;&lt; formatted.<span class="built_in">str</span>() &lt;&lt; endl;   <span class="comment">// and reformatted numbers</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">// otherwise, print the name and bad numbers</span></span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;input error: &quot;</span> &lt;&lt; entry.name</span><br><span class="line">            &lt;&lt; <span class="string">&quot; invalid number(s) &quot;</span> &lt;&lt; badNums.<span class="built_in">str</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第8章-IO库&quot;&gt;&lt;a href=&quot;#第8章-IO库&quot; class=&quot;headerlink&quot; title=&quot;第8章 IO库&quot;&gt;&lt;/a&gt;第8章 IO库&lt;/h1&gt;&lt;p&gt;部分IO库设施：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;istream&lt;/code&gt;：输入流类型，提</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第七章-类</title>
    <link href="http://icecorn.github.io/2022/02/24/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/"/>
    <id>http://icecorn.github.io/2022/02/24/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/</id>
    <published>2022-02-24T12:25:30.000Z</published>
    <updated>2022-06-29T12:58:17.632Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七章-类"><a href="#第七章-类" class="headerlink" title="第七章 类"></a>第七章 类</h2><h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><p>成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// new members: operations on Sales_data objects</span></span><br><span class="line">    <span class="function">std::string <span class="title">isbn</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="type">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// data members</span></span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>成员函数通过一个名为<code>this</code>的隐式额外参数来访问调用它的对象。<code>this</code>参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用<code>this</code>指针。 </p><p>默认情况下，<code>this</code>的类型是指向类类型非常量版本的常量指针。<code>this</code>也遵循初始化规则，所以默认不能把<code>this</code>绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。</p><p>C++允许在成员函数的参数列表后面添加关键字<code>const</code>，表示<code>this</code>是一个指向常量的指针。使用关键字<code>const</code>的成员函数被称作常量成员函数（const member function）。</p><p>下边这种就是错误的：因为上边声明了isbn（）是一个const的成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pseudo-code illustration of how the implicit this pointer is used</span></span><br><span class="line"><span class="comment">// this code is illegal: we may not explicitly define the this pointer ourselves</span></span><br><span class="line"><span class="comment">// note that this is a pointer to const because isbn is a const member</span></span><br><span class="line"><span class="function">std::string <span class="title">Sales_data::isbn</span><span class="params">(<span class="type">const</span> Sales_data *<span class="type">const</span> <span class="keyword">this</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;isbn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量对象和指向常量对象的引用或指针都只能调用常量成员函数。</p><p><strong>总结：因为this默认指向非常量的成员函数，所以常量对象不能调用非常量的函数，常量对象只能调用常量的成员函数（后边加const的，这时用this的话，this是一个常量指针）。另外const成员函数的声明和定义后边必须都有const</strong></p><hr><h3 id="防止隐式构造函数转换"><a href="#防止隐式构造函数转换" class="headerlink" title="防止隐式构造函数转换"></a>防止隐式构造函数转换</h3><p>在要求隐式转换的程序上下文中，可以通过将构造函数声明为<code>explicit</code>的加以阻止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sales_data</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Sales_data</span>(<span class="type">const</span> std::string &amp;s, <span class="type">unsigned</span> n, <span class="type">double</span> p):</span><br><span class="line">        <span class="built_in">bookNo</span>(s), <span class="built_in">units_sold</span>(n), <span class="built_in">revenue</span>(p*n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span>: bookNo(s) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(std::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>explicit</code>关键字只对接受一个实参的构造函数有效。</p><p>只能在类内声明构造函数时使用<code>explicit</code>关键字，在类外定义时不能重复。</p><p>执行拷贝初始化时（使用<code>=</code>）会发生隐式转换，所以<code>explicit</code>构造函数只能用于直接初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// ok: direct initialization</span></span><br><span class="line"><span class="comment">// error: cannot use the copy form of initialization with an explicit constructor</span></span><br><span class="line">Sales_data item2 = null_book;</span><br></pre></td></tr></table></figure><p>可以使用<code>explicit</code>构造函数显式地强制转换类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ok: the argument is an explicitly constructed Sales_data object</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));</span><br><span class="line"><span class="comment">// ok: static_cast can use an explicit constructor</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(cin));</span><br></pre></td></tr></table></figure><hr><h3 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h3><p>使用关键字<code>static</code>可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string owner;</span><br><span class="line">    <span class="type">double</span> amount;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为<code>const</code>的，也不能在静态成员函数内使用<code>this</code>指针。</p><p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> r;</span><br><span class="line">r = Account::<span class="built_in">rate</span>(); <span class="comment">// access a static member using the scope operator</span></span><br><span class="line"></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// equivalent ways to call the static member rate function</span></span><br><span class="line">r = ac1.<span class="built_in">rate</span>(); <span class="comment">// through an Account object or reference</span></span><br><span class="line">r = ac2-&gt;<span class="built_in">rate</span>(); <span class="comment">// through a pointer to an Account object</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> interestRate;</span><br><span class="line">    <span class="comment">// remaining members as before</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类外部定义静态成员时，不能重复<code>static</code>关键字，其只能用于类内部的声明语句。</p><p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define and initialize a static class member</span></span><br><span class="line"><span class="type">double</span> Account::interestRate = <span class="built_in">initRate</span>();</span><br></pre></td></tr></table></figure><p>建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。</p><p>尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供<code>const</code>整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的<code>constexpr</code>。初始值必须是常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">rate</span><span class="params">(<span class="type">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> period = <span class="number">30</span>;  <span class="comment">// period is a constant</span></span><br><span class="line">    <span class="type">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>静态数据成员的类型可以是它所属的类类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> Bar mem1;   <span class="comment">// ok: static member can have incomplete type</span></span><br><span class="line">    Bar *mem2;    <span class="comment">// ok: pointer member can have incomplete type</span></span><br><span class="line">    Bar mem3;   <span class="comment">// error: data members must have complete type</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用静态成员作为函数的默认实参。</p><hr><h3 id="static关键字详解"><a href="#static关键字详解" class="headerlink" title="static关键字详解"></a>static关键字详解</h3><p>从程序的存储上来看：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211112444578.png" alt="image-20211211112444578"></p><ol><li>正文段<br>CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是经常环境指针环境表环境字符串执行的程序(如文本编辑程序、C编译程序、s h e l l等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令。</li><li>初始化数据段<br>通常将此段称为数据段，它包含了程序中需赋初值的变量。初始化的全局变量和静态变量存放在这里。例如，C程序中任何函数之外的说明：int maxcount = 99; 使此变量以初值存放在初始化数据段中。<br>a.初始化的全局变量<br>b.初始化的静态变量</li><li>非初始化数据段<br>通常将此段称为bss段，这一名称来源于早期汇编程序的一个操作符，意思是“block started by symbol（由符号开始的块）”，未初始化的全局变量和静态变量存放在这里。在程序开始执行之前，内核将此段初始化为0。函数外的说明：long sum[1000] ; 使此变量存放在非初始化数据段中。<br>a.未初始化的全局变量<br>b.未初始化的静态变量</li><li>堆<br>需要由程序员分配释放管理，若程序员不释放，程序结束时可能由OS回收。通常在堆中进行动态存储分配。<br>如程序中的malloc, calloc, realloc等函数都从这里面分配。堆是从下向上分配的。</li><li>栈<br>由编译器自动分配释放管理。局部变量及每次函数调用时返回地址、以及调用者的环境信息（例如某些机器寄存器）都存放在栈中。新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C函数可以递归调用。递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响另一个函数调用实例中的变量。<br>a.局部变量<br>b.函数调用时返回地址<br>c.调用者的环境信息（例如某些机器寄存器）</li></ol><h4 id="c-中static用法："><a href="#c-中static用法：" class="headerlink" title="c++中static用法："></a>c++中static用法：</h4><p><strong>1、static 数据成员</strong></p><p>在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c);</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">GetSum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> a,b,c;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> Sum; <span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Myclass::Sum=<span class="number">0</span>; <span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"><span class="comment">//static int Myclass::Sum = 0; //注意加static， 是错误的</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> Sum+=a+b+c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> M.<span class="built_in">GetSum</span>(); <span class="comment">// cout 6</span></span><br><span class="line"></span><br><span class="line"> <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> N.<span class="built_in">GetSum</span>(); <span class="comment">// cout 21</span></span><br><span class="line"> M.<span class="built_in">GetSum</span>(); <span class="comment">// cout 21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，static数据成员有以下特点：<br>(1). 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。</p><p>(2). 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。</p><p>在上例中，语句 int Myclass::Sum = 0; 是定义静态数据成员；</p><p>(3). 静态数据成员和普通数据成员一样遵从public, protected, private 访问规则；除了定义，定义不要管访问规则。</p><p>(4). 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它；</p><p>(5). 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞</span></span><br><span class="line"><span class="type">int</span> Myclass::Sum=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>(6). 类的静态数据成员有两种 访问形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//＜类对象名＞.＜静态数据成员名＞</span></span><br><span class="line">M.Sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//＜类类型名＞::＜静态数据成员名＞</span></span><br><span class="line">Myclass::Sum = <span class="number">0</span> </span><br></pre></td></tr></table></figure><p>但是上面这个例子是不行的，因为他是private的变量，如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ；</p><p>(7). 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了；</p><p>(8). 同全局变量相比，使用静态数据成员有两个优势：<br>a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；<br>b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能；</p><p><strong>2、static 成员函数</strong><br>  static 成员函数，它为类的全部对象服务而不是为某一个类的具体对象服务。普通的成员函数一般都隐含了一个this指针，但静态成员函数由于不是与任何的对象相联系，因此<strong>它不具有this指针</strong>。从这个意义上讲，<strong>它无法访问属于类对象的no-static数据成员，也无法访问no-static成员函数，它只能调用其余的静态成员函数。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c);</span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">GetSum</span><span class="params">()</span></span>; /声明静态成员函数</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="type">int</span> a,b,c;</span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> Sum; <span class="comment">//声明静态数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Myclass::Sum = <span class="number">0</span>;<span class="comment">//定义并初始化静态数据成员</span></span><br><span class="line"></span><br><span class="line">Myclass::<span class="built_in">Myclass</span>(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line"> <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line"> <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line"> Sum+=a+b+c; <span class="comment">//非静态成员函数可以访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static void Myclass::GetSum()&#123;...&#125; //加上static是错误的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Myclass::GetSum</span><span class="params">()</span> <span class="comment">//静态成员函数的实现</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">//cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员</span></span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;Sum=&quot;</span>&lt;&lt;Sum&lt;&lt;endl; <span class="comment">//静态函数是能访问静态数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Myclass <span class="title">M</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line"> M.<span class="built_in">GetSum</span>();</span><br><span class="line"></span><br><span class="line"> <span class="function">Myclass <span class="title">N</span><span class="params">(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line"> N.<span class="built_in">GetSum</span>();</span><br><span class="line"></span><br><span class="line"> Myclass::<span class="built_in">GetSum</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于静态成员函数，可以总结为以下几点：</p><p>(1). 在类体外，静态函数的定义前不能加关键字static；</p><p>(2). static成员之间可以相互访问，包括static成员函数访问static数据成员和访问static成员函数；</p><p>(3). 非静态成员函数可以任意地访问静态成员函数和静态数据成员；</p><p>(4). 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的；</p><p>(5). 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长；</p><p>(6). 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)或直接用类名调用静态成员函数</p><p>M.GetSum();<br>Myclass::GetSum();调用类的静态成员函数。<br><strong>但是，一样 要遵从 public，protected，private 访问规则 。</strong></p><hr><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><h4 id="1-栈简介"><a href="#1-栈简介" class="headerlink" title="1.栈简介"></a>1.栈简介</h4><p>栈由操作系统自动分配释放 ，用于<strong>存放函数的参数值、局部变量等</strong>，其操作方式类似于数据结构中的栈。参考如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> b;<span class="comment">//栈</span></span><br><span class="line"><span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//栈</span></span><br><span class="line"><span class="type">char</span> *p2;<span class="comment">//栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如上面代码中变量 s 的地址小于变量 b 的地址，p2 地址小于 s 的地址。<strong>栈中存储的数据的生命周期随着函数的执行完成而结束。</strong></p><h4 id="2-堆简介"><a href="#2-堆简介" class="headerlink" title="2. 堆简介"></a>2. 堆简介</h4><p>堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。参考如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// C 中用 malloc() 函数申请</span></span><br><span class="line"><span class="type">char</span>* p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">cout&lt;&lt;(<span class="type">int</span>*)p1&lt;&lt;endl;<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 free() 函数释放</span></span><br><span class="line"><span class="built_in">free</span>(p1);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// C++ 中用 new 运算符申请</span></span><br><span class="line"><span class="type">char</span>* p2 = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">10</span>];</span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>*)p2 &lt;&lt; endl;<span class="comment">//输出：00000000003BA0C0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用 delete 运算符释放</span></span><br><span class="line"><span class="keyword">delete</span>[] p2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 p1 所指的 10 字节的内存空间与 p2 所指的 10 字节内存空间都是存在于堆。堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，<strong>后申请的内存空间并不一定在先申请的内存空间的后面</strong>，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。<strong>堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。</strong></p><p>关于堆上内存空间的分配过程，首先应该知道<strong>操作系统有一个记录空闲内存地址的链表</strong>，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。**另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。(这就是为什么stl中pool_allocator更好的原因，可以节省一些存放分配大小的首地址的开销)**由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。</p><p>1.3 堆与栈区别<br>堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：<br>（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；</p><p>（2）空间大小不同。<strong>每个进程拥有的栈大小要远远小于堆大小。</strong>理论上，进程可申请的堆大小为<strong>虚拟内存</strong>大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；</p><p>（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。</p><p>（4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloc()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。</p><p>（5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。</p><p>（6）存放内容不同。栈存放的内容，<strong>函数返回地址、相关参数、局部变量和寄存器内容等。</strong>当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。</p><p>从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。</p><p>无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第七章-类&quot;&gt;&lt;a href=&quot;#第七章-类&quot; class=&quot;headerlink&quot; title=&quot;第七章 类&quot;&gt;&lt;/a&gt;第七章 类&lt;/h2&gt;&lt;h3 id=&quot;成员函数&quot;&gt;&lt;a href=&quot;#成员函数&quot; class=&quot;headerlink&quot; title=&quot;成员函数&quot;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第六章-函数</title>
    <link href="http://icecorn.github.io/2022/02/23/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
    <id>http://icecorn.github.io/2022/02/23/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/</id>
    <published>2022-02-23T12:25:30.000Z</published>
    <updated>2022-06-29T12:56:42.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章-函数"><a href="#第六章-函数" class="headerlink" title="第六章 函数"></a>第六章 函数</h2><h4 id="传引用参数"><a href="#传引用参数" class="headerlink" title="传引用参数"></a>传引用参数</h4><p>使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。</p><p>除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。</p><p>如果函数无须改变引用形参的值，最好将其声明为常量引用。</p><p>一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。</p><hr><h4 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a>const形参和实参</h4><p>当形参有顶层<code>const</code>时，传递给它常量对象或非常量对象都是可以的。</p><p>可以使用非常量对象初始化一个底层<code>const</code>形参，但是反过来不行。</p><p>把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。</p><p><strong>所以，“不变”的参数一定要记得加上const</strong></p><hr><h4 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h4><p>因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each function has a single parameter of type const int*</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;    <span class="comment">// shows the intent that the function takes an array</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// dimension for documentation purposes (at best)</span></span><br></pre></td></tr></table></figure><p>因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。</p><p>因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。</p><p>以数组作为形参的函数必须确保使用数组时不会越界。</p><p>如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。</p><p>形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。</p><p>将多维数组传递给函数时，数组第二维（以及后面所有维度）的大小是数组类型的一部分，不能省略。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">int</span> &amp;arr[<span class="number">10</span>])     <span class="comment">// error: declares arr as an array of references</span></span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">int</span> (&amp;arr)[<span class="number">10</span>])   <span class="comment">// ok: arr is a reference to an array of ten ints</span></span><br></pre></td></tr></table></figure><hr><h4 id="关于函数返回引用"><a href="#关于函数返回引用" class="headerlink" title="关于函数返回引用"></a>关于函数返回引用</h4><p><strong>调用一个返回引用的函数会得到左值，其他返回类型得到右值。</strong></p><ul><li><p>如果返回的是引用的话，是可以当作左值来使用的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> error=<span class="number">-1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">func</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&gt;=<span class="number">0</span>&amp;&amp;n&lt;=<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">return</span> value[n];<span class="comment">//返回的引用所绑定的变量一定是全局变量，不能是函数中定义的局部变量 </span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">0</span>)=<span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">4</span>)=<span class="number">12</span>;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">0</span>]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;value[<span class="number">4</span>]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>C++函数返回的步骤是：<br>1、一般情况下计算结果保存在某个局部变量内，上面的程序，结果保存在变量 result 内。<br>2、return result 的时候，result 的值会“复制” 到一个临时变量中，假设变量名为 temp，即执行 temp = result，然后，函数生命周期结束。<br>3、最后， 主程序把 temp 变量的值“复制”到目标变量中，例如：x4 = temp。</p><p>这里面有两次“复制”过程，因此需要构造temp和目标变量。有些编译器会自动优化，甚至只需要构造一次 result 就解决问题了。这样虽然效率提高了很多，但是这样的源代码却不合适，因为换成其他的编译器可能效率就低下来了。</p></li></ul><p><strong>引用作为函数的返回值</strong></p><ol><li>引用作为函数的返回值时，<strong>必须在定义函数时在函数名前将&amp;</strong></li><li>用引用作函数的返回值的<strong>最大的好处是在内存中不产生返回值的副本</strong></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码来源：RUNOOB</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">float</span> temp;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">fn1</span><span class="params">(<span class="type">float</span> r)</span></span>&#123;</span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">float</span> &amp;<span class="title">fn2</span><span class="params">(<span class="type">float</span> r)</span></span>&#123; <span class="comment">//&amp;说明返回的是temp的引用，换句话说就是返回temp本身</span></span><br><span class="line">    temp=r*r*<span class="number">3.14</span>;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">float</span> a=<span class="built_in">fn1</span>(<span class="number">5.0</span>); <span class="comment">//case 1：返回值</span></span><br><span class="line">    <span class="comment">//float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type &#x27;float&amp;&#x27; from an rvalue of type &#x27;float&#x27;</span></span><br><span class="line">                           <span class="comment">//（有些编译器可以成功编译该语句，但会给出一个warning） </span></span><br><span class="line">    <span class="type">float</span> c=<span class="built_in">fn2</span>(<span class="number">5.0</span>);<span class="comment">//case 3：返回引用</span></span><br><span class="line">    <span class="type">float</span> &amp;d=<span class="built_in">fn2</span>(<span class="number">5.0</span>);<span class="comment">//case 4：用函数返回的引用作为新引用的初始化值</span></span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;<span class="comment">//78.5</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;b&lt;&lt;endl;//78.5</span></span><br><span class="line">    cout&lt;&lt;c&lt;&lt;endl;<span class="comment">//78.5</span></span><br><span class="line">    cout&lt;&lt;d&lt;&lt;endl;<span class="comment">//78.5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>case 1：用返回值方式调用函数（如下图，图片来源：伯乐在线）：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629205624210.png" alt="image-20220629205624210"></p><p><strong>返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a</strong></p><p><strong>case 2：用函数的返回值初始化引用的方式调用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209234547708.png" alt="image-20211209234547708"></p><p><strong>这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &amp;b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。</strong></p><p> <strong>如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="built_in">fn1</span>(<span class="number">5.0</span>);</span><br><span class="line"><span class="type">int</span> &amp;b=x;</span><br></pre></td></tr></table></figure><p><strong>case 3:用返回引用的方式调用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209234927791.png" alt="image-20211209234927791"></p><p><strong>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。</strong></p><p><strong>case 4:用函数返回的引用作为新引用的初始化值的方式来调用函数</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209235138829.png" alt="image-20211209235138829"></p><p><strong>这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。（注意看上边的代码，在最上边声明了全局变量temp，所以是ok的，但是如果temp是函数里的局部变量的话，它就会在函数结束时被析构掉，这时候d就变成了未定义的引用了，危险！）</strong></p><ol start="3"><li><p><strong>不能返回局部变量的引用。</strong>如上面的例子，如果temp是局部变量，那么它会在函数返回后被销毁，此时对temp的引用就会成为“无所指”的引用，程序会进入未知状态。</p></li><li><p><strong>不能返回函数内部通过new分配的内存的引用</strong>。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生</p></li><li><p><strong>当返回类成员的引用时，最好是const引用</strong>。这样可以避免在无意的情况下破坏该类的成员。</p></li></ol><p>到这里的，用引用做返回值的情况就比较清晰了，接下来要弄清楚上边的各种变量是存在哪里的（堆还是栈），还有关于右值引用和move方法。</p><h4 id="用引用实现多态"><a href="#用引用实现多态" class="headerlink" title="用引用实现多态"></a><strong>用引用实现多态</strong></h4><p>在C++中，<strong>引用是除了指针外另一个可以产生多态效果的手段</strong>。也就是说一个基类的引用可以用来绑定其派生类的实例</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>;<span class="comment">//基类（父类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>：<span class="keyword">public</span> Father&#123;.....&#125;<span class="comment">//Son是Father的派生类</span></span><br><span class="line">Son son;<span class="comment">//son是类Son的一个实例</span></span><br><span class="line">Father &amp;ptr=son;<span class="comment">//用派生类的对象初始化基类对象的使用</span></span><br></pre></td></tr></table></figure><p><strong>特别注意：</strong></p><p><strong>ptr只能用来访问派生类对象中从基类继承下来的成员</strong>。<strong>如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。</strong></p><p> 这里就和java是一样的，通过父类引用指向子类对象来实现多态</p><hr><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>如果形参是某种类型的指针或引用，则通过区分其指向的对象是常量还是非常量可以实现函数重载，此时的<code>const</code>是底层的。当我们传递给重载函数一个非常量对象或者指向非常量对象的指针时，<strong>编译器会优先选用非常量版本的函数</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// functions taking const and nonconst references or pointers have different parameters</span></span><br><span class="line"><span class="comment">// declarations for four independent, overloaded functions</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;        <span class="comment">// function that takes a reference to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account&amp;)</span></span>;  <span class="comment">// new function that takes a const reference</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;        <span class="comment">// new function, takes a pointer to Account</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account*)</span></span>;  <span class="comment">// new function, takes a pointer to const</span></span><br></pre></td></tr></table></figure><p><code>const_cast</code>可以用于函数的重载。当函数的实参不是常量时，将得到普通引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return a reference to the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1, string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s1),</span><br><span class="line">                    <span class="built_in">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;(s2));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数匹配（function matching）也叫做重载确定（overload resolution），是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。</p><p>调用重载函数时有三种可能的结果：</p><ul><li>编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</li><li>编译器找不到任何一个函数与实参匹配，发出无匹配（no match）的错误信息。</li><li>有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用（ambiguous call）的错误信息。</li></ul><hr><h4 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h4><p><strong>默认实参</strong></p><p>默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>, sz wid = <span class="number">80</span>, <span class="type">char</span> backgrnd = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。</p><p>如果想使用默认实参，只要在调用函数的时候省略该实参即可。</p><p>虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// no default for the height or width parameters</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz, sz, <span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;      <span class="comment">// error: redeclaration</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>, sz = <span class="number">80</span>, <span class="type">char</span>)</span></span>;  <span class="comment">// ok: adds default</span></span><br></pre></td></tr></table></figure><p>默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Error: 编译器向前查找函数声明</span></span><br><span class="line">    <span class="comment">//        fun调用形式与声明不符</span></span><br><span class="line">    <span class="built_in">fun</span>();</span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> n = <span class="number">0</span>)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br></pre></td></tr></table></figure><p>局部变量不能作为函数的默认实参。</p><p>用作默认实参的名字在函数声明所在的作用域内解析，但名字的求值过程发生在函数调用时。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the declarations of wd, def, and ht must appear outside a function</span></span><br><span class="line">sz wd = <span class="number">80</span>;</span><br><span class="line"><span class="type">char</span> def = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="type">char</span> = def)</span></span>;</span><br><span class="line">string window = <span class="built_in">screen</span>();   <span class="comment">// calls screen(ht(), 80, &#x27; &#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    def = <span class="string">&#x27;*&#x27;</span>;      <span class="comment">// changes the value of a default argument</span></span><br><span class="line">    sz wd = <span class="number">100</span>;    <span class="comment">// hides the outer definition of wd but does not change the</span></span><br><span class="line">    <span class="keyword">default</span></span><br><span class="line">    window = <span class="built_in">screen</span>();  <span class="comment">// calls screen(ht(), 80, &#x27;*&#x27;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内联函数和constexpr函数"><a href="#内联函数和constexpr函数" class="headerlink" title="内联函数和constexpr函数"></a>内联函数和constexpr函数</h4><p>内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字<code>inline</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline version: find the shorter of two strings</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">horterString</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在函数声明和定义中都能使用关键字<code>inline</code>，但是建议只在函数定义时使用。</p><p>一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。<strong>内联函数中不允许有循环语句和<code>switch</code>语句，否则函数会被编译为普通函数。</strong></p><p><strong>为什么要有内联函数，内联函数有什么用？</strong></p><p>因为，在大多数机器上，调用函数都要做很多的工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新的位置来执行。而内联函数的目的就是提高函数的执行效率，用关键字 inline 放在函数定义的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开。假设我们将 max 定义为内联函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line">则调用： cout&lt;&lt;<span class="built_in">max</span>(a, b)&lt;&lt;endl;</span><br><span class="line">在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;</span><br><span class="line">从而消除了把max写成函数的额外开销。</span><br></pre></td></tr></table></figure><p>定义在类声明之中的成员函数将自动的成为内联函数</p><p>内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。</p><p>当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。</p><blockquote><p>Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数.</p><p>定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.<br>优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.<br>缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。<br>结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!<br>另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).<br>有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数.</p></blockquote><hr><p><code>constexpr</code>函数是指能用于常量表达式的函数。<code>constexpr</code>函数的返回类型及所有形参的类型都得是字面值类型。另外C++11标准要求<code>constexpr</code>函数体中必须有且只有一条<code>return</code>语句，但是此限制在C++14标准中被删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();   <span class="comment">// ok: foo is a constant expression</span></span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数的返回值可以不是一个常量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scale(arg) is a constant expression if arg is a constant expression</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">new_sz</span>() * cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];  <span class="comment">// ok: scale(2) is a constant expression</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;          <span class="comment">// i is not a constant expression</span></span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];   <span class="comment">// error: scale(i) is not a constant expression</span></span><br></pre></td></tr></table></figure><p><code>constexpr</code>函数被隐式地指定为内联函数。</p><p>和其他函数不同，内联函数和<code>constexpr</code>函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或<code>constexpr</code>函数，它的多个定义必须完全一致。因此内联函数和<code>constexpr</code>函数通常定义在头文件中。</p><p><strong>调试帮助</strong></p><table><thead><tr><th align="center">变量名称</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center"><code>__func__</code></td><td align="center">当前函数名称</td></tr><tr><td align="center"><code>__FILE__</code></td><td align="center">当前文件名称</td></tr><tr><td align="center"><code>__LINE__</code></td><td align="center">当前行号</td></tr><tr><td align="center"><code>__TIME__</code></td><td align="center">文件编译时间</td></tr><tr><td align="center"><code>__DATE__</code></td><td align="center">文件编译日期</td></tr></tbody></table><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compares lengths of two strings</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf points to a function returning bool that takes two const string references</span></span><br><span class="line"><span class="built_in">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;); <span class="comment">// uninitialized</span></span><br></pre></td></tr></table></figure><p>可以直接使用指向函数的指针来调用函数，无须提前解引用指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pf = lengthCompare; <span class="comment">// pf now points to the function named lengthCompare</span></span><br><span class="line">pf = &amp;lengthCompare; <span class="comment">// equivalent assignment: address-of operator is optional</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">pf</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);       <span class="comment">// calls lengthCompare</span></span><br><span class="line"><span class="type">bool</span> b2 = (*pf)(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);    <span class="comment">// equivalent call</span></span><br><span class="line"><span class="type">bool</span> b3 = <span class="built_in">lengthCompare</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;goodbye&quot;</span>);    <span class="comment">// equivalent call</span></span><br></pre></td></tr></table></figure><p>对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*pf1)(<span class="type">unsigned</span> <span class="type">int</span>) = ff; <span class="comment">// pf1 points to ff(unsigned)</span></span><br></pre></td></tr></table></figure><p> 可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// third parameter is a function type and is automatically treated as a pointer to function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> pf(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="comment">// equivalent declaration: explicitly define the parameter as a pointer to function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2, <span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;, <span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// automatically converts the function lengthCompare to a pointer to function</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure><p>关键字<code>decltype</code>作用于函数时，返回的是函数类型，而不是函数指针类型。</p><p>函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。</p><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六章-函数&quot;&gt;&lt;a href=&quot;#第六章-函数&quot; class=&quot;headerlink&quot; title=&quot;第六章 函数&quot;&gt;&lt;/a&gt;第六章 函数&lt;/h2&gt;&lt;h4 id=&quot;传引用参数&quot;&gt;&lt;a href=&quot;#传引用参数&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第四章-表达式</title>
    <link href="http://icecorn.github.io/2022/02/21/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://icecorn.github.io/2022/02/21/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-21T12:25:30.000Z</published>
    <updated>2022-06-29T12:53:37.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四章-表达式"><a href="#第四章-表达式" class="headerlink" title="第四章 表达式"></a>第四章 表达式</h2><h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><p>C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。</p><h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>C++的表达式分为右值（rvalue）和左值（lvalue）。当一个对象被用作右值的时候，用的是<strong>对象的值（内容）</strong>；当对象被用作左值时，用的是<strong>对象的地址</strong>。<strong>需要右值的地方可以用左值代替，反之则不行。</strong></p><ul><li>赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。</li><li>取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。</li><li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code>和<code>vector</code>的下标运算符都返回左值。</li><li>内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。</li></ul><p>如果<code>decltype</code>作用于一个求值结果是左值的表达式，会得到引用类型。</p><p><strong>深度理解左值和右值</strong></p><p>​        在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。</p><p><strong>右值、将亡值</strong><br>        在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。</p><p>​        C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。</p><p>​        将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。</p><p><strong>左值引用、右值引用</strong><br>        左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。</p><p>​        右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。</p><p>​        左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;a = <span class="number">2</span>;       # 左值引用绑定到右值，编译失败</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;        # 非常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> d = <span class="number">2</span>;  # 常量左值</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;e = c; # 常量左值引用绑定到常量左值，编译通过</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b =<span class="number">2</span>;  # 常量左值引用绑定到右值，编程通过</span><br></pre></td></tr></table></figure><p>​        右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;&amp;r1 = c;             # 编译失败</span><br><span class="line"><span class="type">int</span> &amp;&amp;r2 = std::<span class="built_in">move</span>(a);  # 编译通过</span><br><span class="line">下表列出了在C++<span class="number">11</span>中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211209212749197.png" alt="image-20211209212749197"></p><hr><h4 id="关于运算符"><a href="#关于运算符" class="headerlink" title="关于运算符"></a>关于运算符</h4><p><strong>逻辑运算符注意事项</strong></p><p>逻辑与（logical AND）运算符<code>&amp;&amp;</code>和逻辑或（logical OR）运算符<code>||</code>都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。</p><ul><li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。</li><li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。</li></ul><p>进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值<code>true</code>和<code>false</code>作为运算对象。</p><hr><p><strong>递增和递减运算符</strong></p><p>递增和递减运算符分为前置版本和后置版本：</p><ul><li>前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。</li><li>后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i;    <span class="comment">// j = 1, i = 1: prefix yields the incremented value</span></span><br><span class="line">j = i++;    <span class="comment">// j = 1, i = 2: postfix yields the unincremented value</span></span><br></pre></td></tr></table></figure><p>除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。</p><p>在某些语句中混用解引用和递增运算符可以使程序更简洁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; *iter++ &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>因为后置++返回的是值而非引用，所以 ++++i可以，而i++++不可以。</strong></p><hr><h4 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h4><p><code>sizeof</code>运算符返回一个表达式或一个类型名字所占的字节数，返回值是<code>size_t</code>类型。</p><p>在<code>sizeof</code>的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。</p><p><code>sizeof</code>运算符的结果部分依赖于其作用的类型：</p><ul><li><p>对<code>char</code>或者类型为<code>char</code>的表达式执行<code>sizeof</code>运算，返回值为1。</p></li><li><p>对引用类型执行<code>sizeof</code>运算得到被引用对象所占空间的大小。</p></li><li><p>对指针执行<code>sizeof</code>运算得到指针本身所占空间的大小。</p></li><li><p>对解引用指针执行<code>sizeof</code>运算得到指针指向的对象所占空间的大小，指针不需要有效。</p></li><li><p>对数组执行<code>sizeof</code>运算得到整个数组所占空间的大小。</p></li><li><p>对<code>string</code>或<code>vector</code>对象执行<code>sizeof</code>运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。</p><p><strong>就是说对于sizeof(vector)应该等于24，因为vector内有3个指针</strong></p></li></ul><hr><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。</p><p><strong>算术转换</strong></p><p>把一种算术类型转换成另一种算术类型叫做算术转换。</p><p>整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。</p><p><strong>其他隐式类型转换</strong></p><p>在大多数表达式中，数组名字自动转换成指向数组首元素的指针。</p><p>常量整数值0或字面值<code>nullptr</code>能转换成任意指针类型；指向任意非常量的指针能转换成<code>void*</code>；指向任意对象的指针能转换成<code>const void*</code>。</p><p>任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是<code>false</code>，否则是<code>true</code>。</p><p>指向非常量类型的指针能转换成指向相应的常量类型的指针。</p><p><strong>显式转换</strong></p><p>显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。</p><p>命名的强制类型转换（named cast）形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cast-<span class="built_in">name</span>&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure><p>其中<em>type</em>是转换的目标类型，<em>expression</em>是要转换的值。如果<em>type</em>是引用类型，则转换结果是左值。<em>cast-name</em>是<code>static_cast</code>、<code>dynamic_cast</code>、<code>const_cast</code>和<code>reinterpret_cast</code>中的一种，用来指定转换的方式。</p><ul><li><code>dynamic_cast</code>支持运行时类型识别。</li><li>任何具有明确定义的类型转换，只要不包含底层<code>const</code>（数据是常量，比如const int），都能使用<code>static_cast</code>。</li><li><code>const_cast</code>只能改变运算对象的底层<code>const</code>，不能改变表达式的类型。同时也只有<code>const_cast</code>能改变表达式的常量属性。<code>const_cast</code>常常用于函数重载。</li><li><code>reinterpret_cast</code>通常为运算对象的位模式提供底层上的重新解释。</li></ul><p>早期版本的C++语言中，显式类型转换包含两种形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> (expression);    <span class="comment">// function-style cast notation</span></span><br><span class="line">(type) expression;    <span class="comment">// C-language-style cast notation</span></span><br></pre></td></tr></table></figure><hr><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四章-表达式&quot;&gt;&lt;a href=&quot;#第四章-表达式&quot; class=&quot;headerlink&quot; title=&quot;第四章 表达式&quot;&gt;&lt;/a&gt;第四章 表达式&lt;/h2&gt;&lt;h4 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第三章-字符串，向量和数组</title>
    <link href="http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2022-02-20T12:25:30.000Z</published>
    <updated>2022-06-29T12:52:21.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第三章-字符串-向量和数组"><a href="#第三章-字符串-向量和数组" class="headerlink" title="第三章 字符串,向量和数组"></a>第三章 字符串,向量和数组</h2><h3 id="关于string的注意点："><a href="#关于string的注意点：" class="headerlink" title="关于string的注意点："></a>关于string的注意点：</h3><ol><li><p><code>size</code>函数返回<code>string</code>对象的长度，返回值是<code>string::size_type</code>类型，这是一种无符号类型。要使用<code>size_type</code>，必须先指定它是由哪种类型定义的。</p></li><li><p>当把<code>string</code>对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是<code>string</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s4 = s1 + <span class="string">&quot;, &quot;</span>;          <span class="comment">// ok: adding a string and a literal</span></span><br><span class="line">string s5 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;, &quot;</span>;     <span class="comment">// error: no string operand</span></span><br><span class="line">string s6 = s1 + <span class="string">&quot;, &quot;</span> + <span class="string">&quot;world&quot;</span>;    <span class="comment">// ok: each + has a string operand</span></span><br></pre></td></tr></table></figure></li><li><p>其实是变量生命周期的问题，在这里记录一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="built_in">string</span>(<span class="string">&quot;string1&quot;</span>); </span><br><span class="line"></span><br><span class="line">string s2 = <span class="built_in">string</span>(<span class="string">&quot;string2&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p1 = s1.<span class="built_in">substr</span>(<span class="number">1</span>).<span class="built_in">data</span>();    <span class="comment">// substr(1)的意思是取[字符串]从下标1到结尾的部分 </span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p2 = s2.<span class="built_in">substr</span>(<span class="number">1</span>).<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>这里输出应该是tring1tring2，却输出了tring2tring2。这是因为s1.substr(1)创建了一个临时对象来存储s1的字串，然后data()获取这个子串内存的指针赋值给p1。但是到下一行，编译器发现刚才的临时对象没用了，就把它析构掉了（注意，析构表明cpu重新获得这块内存的分配权，但是里边的信息01状态不会改变），然后p2进行一样的操作，刚好s2.substr()又分配到了这块内存空间，这就导致最后的结果是p1p2都指向这块内存，而这块内存是tring2！</p><p><strong>所以，在使用接口函数时一定要注意返回值是什么，而且编程时要注意对象的生命周期！</strong> </p></li></ol><hr><h3 id="vector使用注意："><a href="#vector使用注意：" class="headerlink" title="vector使用注意："></a>vector使用注意：</h3><p><code>vector</code>和<code>string</code>对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivec;   <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(ivec.<span class="built_in">size</span>()) ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)</span><br><span class="line">&#123;</span><br><span class="line">    ivec[ix] = ix;  <span class="comment">// disaster: ivec has no elements</span></span><br><span class="line">    ivec.<span class="built_in">push_back</span>(ix); <span class="comment">// ok: adds a new element with value ix</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>vector原理见stl笔记</p><hr><h3 id="数组（Arrays）"><a href="#数组（Arrays）" class="headerlink" title="数组（Arrays）"></a>数组（Arrays）</h3><p>数组类似<code>vector</code>，但数组的大小确定不变，不能随意向数组中添加元素。</p><p>如果不清楚元素的确切个数，应该使用<code>vector</code>。</p><h4 id="定义和初始化内置数组（Defining-and-Initializing-Built-in-Arrays）"><a href="#定义和初始化内置数组（Defining-and-Initializing-Built-in-Arrays）" class="headerlink" title="定义和初始化内置数组（Defining and Initializing Built-in Arrays）"></a>定义和初始化内置数组（Defining and Initializing Built-in Arrays）</h4><p>数组是一种复合类型，声明形式为<code>a[d]</code>，其中<em>a</em>是数组名称，<em>d</em>是数组维度（dimension）。维度必须是一个常量表达式。</p><p>默认情况下，数组的元素被默认初始化。</p><p>定义数组的时候必须指定数组的类型，不允许用<code>auto</code>关键字由初始值列表推断类型。</p><p>如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但如果显式指明了维度，那么初始值的数量不能超过指定的大小。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;  <span class="comment">// array of three ints with values 0, 1, 2</span></span><br><span class="line"><span class="type">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;   <span class="comment">// an array of dimension 3</span></span><br><span class="line"><span class="type">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br><span class="line">string a4[<span class="number">3</span>] = &#123;<span class="string">&quot;hi&quot;</span>, <span class="string">&quot;bye&quot;</span>&#125;;   <span class="comment">// same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;    <span class="comment">// error: too many initializers</span></span><br></pre></td></tr></table></figure><p>可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>&#125;;        <span class="comment">// list initialization, no null</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;  <span class="comment">// list initialization, explicit null</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span>;      <span class="comment">// null terminator added automatically</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> a4[<span class="number">6</span>] = <span class="string">&quot;Daniel&quot;</span>;    <span class="comment">// error: no space for the null!</span></span><br></pre></td></tr></table></figure><p>不能用一个数组初始化或直接赋值给另一个数组。</p><p>从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];              <span class="comment">// ptrs is an array of ten pointers to int</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;    <span class="comment">// error: no arrays of references</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">// Parray points to an array of ten ints</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">// arrRef refers to an array of ten ints</span></span><br></pre></td></tr></table></figure><h4 id="访问数组元素（Accessing-the-Elements-of-an-Array）"><a href="#访问数组元素（Accessing-the-Elements-of-an-Array）" class="headerlink" title="访问数组元素（Accessing the Elements of an Array）"></a>访问数组元素（Accessing the Elements of an Array）</h4><p>数组下标通常被定义成<code>size_t</code>类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。<code>size_t</code>定义在头文件<em>cstddef</em>中。</p><p>大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p><h4 id="指针和数组（Pointers-and-Arrays）"><a href="#指针和数组（Pointers-and-Arrays）" class="headerlink" title="指针和数组（Pointers and Arrays）"></a>指针和数组（Pointers and Arrays）</h4><p>在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;    <span class="comment">// array of strings</span></span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];   <span class="comment">// p points to the first element in nums</span></span><br><span class="line">string *p2 = nums;      <span class="comment">// equivalent to p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure><p><em><em>这里刚好可以说明一下指针和引用的区别，为什么要有引用这个东西。比如有一个长度为10的数组arr，要改变第五个元素，arr[4] = 0；就可以直接改，这里的arr[4]就是引用，表述起来比较方便，想一下如果要用指针表述的话，就是</em>(&amp;arr[4]) = 0;更复杂的情况会更繁琐，这可能是引用出现的一个因素吧</em>*</p><p>当使用数组作为一个<code>auto</code>变量的初始值时，推断得到的类型是指针而非数组。但<code>decltype</code>关键字不会发生这种转换，直接返回数组类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;   <span class="comment">// ia is an array of ten ints</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;   <span class="comment">// ia2 is an int* that points to the first element in ia</span></span><br><span class="line">ia2 = <span class="number">42</span>;       <span class="comment">// error: ia2 is a pointer, and we can&#x27;t assign an int to a pointer</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>;   <span class="comment">// now it&#x27;s clear that ia2 has type int*</span></span><br><span class="line"><span class="comment">// ia3 is an array of ten ints</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">ia3 = p;    <span class="comment">// error: can&#x27;t assign an int* to an array</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;     <span class="comment">// ok: assigns the value of i to an element in ia3</span></span><br></pre></td></tr></table></figure><p>C++11在头文件<em>iterator</em>中定义了两个名为<code>begin</code>和<code>end</code>的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;;   // ia is an array of ten ints</span><br><span class="line">int *beg = begin(ia);   // pointer to the first element in ia</span><br><span class="line">int *last = end(ia);    // pointer one past the last element in ia</span><br></pre></td></tr></table></figure><p>两个指针相减的结果类型是<code>ptrdiff_t</code>，这是一种定义在头文件<em>cstddef</em>中的带符号类型。</p><p><strong>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。</strong></p><hr><h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><p>C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。</p><p>C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库<code>string</code>要比使用C风格字符串更加安全和高效。</p><p>C风格字符串函数不负责验证其参数的正确性，<strong>传入此类函数的指针必须指向以空字符作为结尾的数组。</strong></p><hr><h4 id="与旧代码的接口（Interfacing-to-Older-Code）"><a href="#与旧代码的接口（Interfacing-to-Older-Code）" class="headerlink" title="与旧代码的接口（Interfacing to Older Code）"></a>与旧代码的接口（Interfacing to Older Code）</h4><p>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替：</p><ul><li>允许使用以空字符结束的字符数组来初始化<code>string</code>对象或为<code>string</code>对象赋值。</li><li>在<code>string</code>对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。</li><li>在<code>string</code>对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。</li></ul><p>不能用<code>string</code>对象直接初始化指向字符的指针。为了实现该功能，<code>string</code>提供了一个名为<code>c_str</code>的成员函数，返回<code>const char*</code>类型的指针，指向一个以空字符结束的字符数组，数组的数据和<code>string</code>对象一样。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;Hello World&quot;</span>)</span></span>;    <span class="comment">// s holds Hello World</span></span><br><span class="line"><span class="type">char</span> *str = s;  <span class="comment">// error: can&#x27;t initialize a char* from a string</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = s.<span class="built_in">c_str</span>();    <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>针对<code>string</code>对象的后续操作有可能会让<code>c_str</code>函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p><p>可以使用数组来初始化<code>vector</code>对象，但是需要指明要拷贝区域的首元素地址和尾后地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// ivec has six elements; each is a copy of the corresponding element in int_arr</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure><p>在新版本的C++程序中应该尽量使用<code>vector</code>、<code>string</code>和迭代器，避免使用内置数组、C风格字符串和指针。</p><h3 id="多维数组（Multidimensional-Arrays）"><a href="#多维数组（Multidimensional-Arrays）" class="headerlink" title="多维数组（Multidimensional Arrays）"></a>多维数组（Multidimensional Arrays）</h3><p>C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。</p><p>多维数组初始化的几种方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] =</span><br><span class="line">&#123;   <span class="comment">// three elements; each element is an array of size 4</span></span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,   <span class="comment">// initializers for the row indexed by 0</span></span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,   <span class="comment">// initializers for the row indexed by 1</span></span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;  <span class="comment">// initializers for the row indexed by 2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// equivalent initialization without the optional nested braces for each row</span></span><br><span class="line"><span class="type">int</span> ib[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// explicitly initialize only element 0 in each row</span></span><br><span class="line"><span class="type">int</span> ic[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123; <span class="number">0</span> &#125;, &#123; <span class="number">4</span> &#125;, &#123; <span class="number">8</span> &#125;&#125;;</span><br><span class="line"><span class="comment">// explicitly initialize row 0; the remaining elements are value initialized</span></span><br><span class="line"><span class="type">int</span> id[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure><p>可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assigns the first element of arr to the last element in the last row of ia</span></span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];  <span class="comment">// binds row to the second four-element array in ia</span></span><br></pre></td></tr></table></figure><p>使用范围<code>for</code>语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;row : ia)  <span class="comment">// for every element in the outer array</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)    <span class="comment">// for every element in the inner array</span></span><br><span class="line">        cout &lt;&lt; col &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>如果<em>row</em>不是引用类型，编译器初始化<em>row</em>时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的<em>row</em>就是<code>int*</code>类型，而之后的内层循环则试图在一个<code>int*</code>内遍历，程序将无法通过编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)</span><br></pre></td></tr></table></figure><p>使用范围<code>for</code>语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。</p><p>因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];       <span class="comment">// array of size 3; each element is an array of ints of size 4</span></span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>] = ia;   <span class="comment">// p points to an array of four ints</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];         <span class="comment">// p now points to the last element in ia</span></span><br></pre></td></tr></table></figure><p>声明指向数组类型的指针时，必须带有圆括号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip[<span class="number">4</span>];     <span class="comment">// array of pointers to int</span></span><br><span class="line"><span class="built_in">int</span> (*ip)[<span class="number">4</span>];   <span class="comment">// pointer to an array of four ints</span></span><br></pre></td></tr></table></figure><p>使用<code>auto</code>和<code>decltype</code>能省略复杂的指针定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print the value of each element in ia, with each inner array on its own line</span></span><br><span class="line"><span class="comment">// p points to an array of four ints</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// q points to the first element of an array of four ints; that is, q points to an int</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第三章-字符串-向量和数组&quot;&gt;&lt;a href=&quot;#第三章-字符串-向量和数组&quot; class=&quot;headerlink&quot; title=&quot;第三章 字符串,向量和数组&quot;&gt;&lt;/a&gt;第三章 字符串,向量和数组&lt;/h2&gt;&lt;h3 id=&quot;关于string的注意点：&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第二章-变量和基本类型</title>
    <link href="http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-02-20T12:25:30.000Z</published>
    <updated>2022-06-29T11:37:00.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>如果定义变量时未指定初值，则变量被默认初始化（default initialized）。</p><p>对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。</p><p>所以类里边的成员变量一定要初始化，不然会有未定义的结果</p><hr><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明（declaration）使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。(<strong>不分配内存</strong>)</p><p>定义（definition）负责创建与名字相关联的实体。（<strong>分配内存，不一定初始化</strong>）</p><p>如果想声明一个变量而不定义它，就在变量名前添加关键字<code>extern</code>，并且不要显式地初始化变量。</p><p><strong>总结：除了用extern修饰变量，其他的声明都是定义。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="type">int</span> j;      <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure><p><code>extern</code>语句如果包含了初始值就不再是声明了，而变成了定义。</p><p>变量能且只能被定义一次，但是可以被声明多次。</p><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p><h4 id="extern用法详解"><a href="#extern用法详解" class="headerlink" title="extern用法详解"></a>extern用法详解</h4><ol><li><p><strong>extern修饰变量的声明</strong>：</p><p>主要使用的情况是，不同的文件中都需要用到这个变量X（大多数情况是全局变量），而且，extern声明的变量可以在文件中的任何地方声明。</p><p><strong>总结：其实就是类似一个引用的手法，在一个项目中只在某一个地方<code>int x = 1;</code>声明加定义（开辟一块内存），这样在其他地方用到这个变量，只需要<code>extern int x；</code>就相当于获得了这个变量的引用，接下来的程序就可以用了。</strong></p></li><li><p><strong>extern修饰函数声明：</strong></p><p>本质的看，变量和函数没有区别，函数名是指向函数二进制块开头处的指针。也就是说extern在这里，也是一样的，如果A文件中有一个函数<code>int fun()</code>,那么想在B文件里用它，就可以<code>extern int fun()</code>就可以用了。</p><p><em>使用extern和包含头文件引用函数有什么区别呢？</em></p><p><strong>用extern更简洁，想用哪个函数就extern哪个，而不用整体include</strong>，另外的还可以<strong>加速程序的编译</strong>，因为不需要编译不要用到的函数了嘛！</p></li><li><p><strong>extern还可用于指示C或者C++的调用规范：</strong></p><p>比如在C++中调用C的函数，就需要在C++代码中用extern声明要引入的C库函数。这是给<strong>链接器</strong>看的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。</p></li></ol><blockquote><p>用C语言编写程序的时候，我们经常会遇到这样一种情况：<strong>希望在头文件中定义一个全局变量，然后包含到两个不同的c文件中，希望这个全局变量能在两个文件中共用。</strong></p></blockquote><blockquote><p>举例说明：项目文件夹project下有main.c、common.c和common.h三个文件，其中<br>common.h文件分别#include在main.c和common.c文件中。现在希望声明一个字符型变量key，在main.c和common.c中公用。如下图所示：<br>有人想，既然是想两个文件都用，那就在common.h中声明一个unsigned char key，然后由于包含关系，在main.c和common.c中都是可见的，所以就能共用了。<br>这种想法其实是很多初学者都会想到的，想起来确实有道理，但是实际写出来，我们发现编译的时候编译器提示出错，一般提示大概都类似于：Error: L6200E: Symbol key multiply defined (by common.o and main.o). 也就是说编译器认为我们重复定义了key这个变量。这是因为#include命令就是原封不同的把头文件中的内容搬到#include的位置，所以相当于main.c和common.c中都执行了一次unsigned char key，而C语言中全局变量是项目内（或者叫工程内）可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义。<br>正确的解决办法：使用extern关键字来声明变量为外部变量。具体说就是在其中一个c文件中定义一个全局变量key，然后在另一个要使用key这个变量的c文件中使用extern关键字声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：定义和声明。例如在main.c文件中定义变量key，在common.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了。</p></blockquote><hr><h3 id="标识符和名字的作用域"><a href="#标识符和名字的作用域" class="headerlink" title="标识符和名字的作用域"></a>标识符和名字的作用域</h3><p><strong>标识符：</strong></p><p>C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</p><p><strong>名字的作用域</strong></p><p>定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。</p><p>最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。</p><p>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。</p><p>可以用作用域操作符<code>::</code>来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Program for illustration purposes only: It is bad style for a function</span></span><br><span class="line"><span class="comment">// to use a global variable and also define a local variable with the same name</span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>;    <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">    <span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">    <span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。</strong></p><p><strong>总结：内部作用域可以用外部的变量，反之不行，内部作用域会覆盖同名外部作用域。可以用：：选择作用域中的变量。</strong></p><hr><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="引用（References）"><a href="#引用（References）" class="headerlink" title="引用（References）"></a>引用（References）</h4><p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<em>d</em>是变量名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">// refVal refers to (is another name for) ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;       <span class="comment">// error: a reference must be initialized</span></span><br></pre></td></tr></table></figure><p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。</p><p>引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。</p><p>声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。</p><p>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</p><h4 id="指针（Pointer）"><a href="#指针（Pointer）" class="headerlink" title="指针（Pointer）"></a>指针（Pointer）</h4><p>与引用类似，指针也实现了对其他对象的间接访问。</p><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。</li><li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li></ul><p>通过将声明符写成<code>*d</code>的形式来定义指针类型，其中<em>d</em>是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号<code>*</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;     <span class="comment">// both ip1 and ip2 are pointers to int</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;    <span class="comment">// dp2 is a pointer to double; dp is a double</span></span><br></pre></td></tr></table></figure><p>指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符<code>&amp;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br></pre></td></tr></table></figure><p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p><p>声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。</p><p>指针的值（即地址）应属于下列状态之一：</p><ul><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，即指针没有指向任何对象。</li><li>无效指针，即上述情况之外的其他值。</li></ul><p>试图拷贝或以其他方式访问无效指针的值都会引发错误。</p><p>如果指针指向一个对象，可以使用解引用（dereference）符<code>*</code>来访问该对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br><span class="line">cout &lt;&lt; *p;     <span class="comment">// * yields the object to which p points; prints 42</span></span><br></pre></td></tr></table></figure><p>给解引用的结果赋值就是给指针所指向的对象赋值。</p><p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p><strong>空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值<code>nullptr</code>来初始化指针。</strong></p><p>旧版本程序通常使用<code>NULL</code>（预处理变量，定义于头文件<em>cstdlib</em>中，值为0）给指针赋值，但在C++11中，最好使用<code>nullptr</code>初始化空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;  <span class="comment">// equivalent to int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;        <span class="comment">// directly initializes p2 from the literal constant 0</span></span><br><span class="line"><span class="comment">// must #include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;     <span class="comment">// equivalent to int *p3 = 0;</span></span><br></pre></td></tr></table></figure><p>建议初始化所有指针。</p><p><code>void*</code>是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作<code>void*</code>指针所指的对象。</p><h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>指向指针的指针（Pointers to Pointers）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;    <span class="comment">// pi points to an int</span></span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;    <span class="comment">// ppi points to a pointer to an int</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211207145225233.png" alt="image-20211207145225233"></p><p>指向指针的引用（References to Pointers）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;         <span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;    <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line">r = &amp;i;         <span class="comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span></span><br><span class="line">*r = <span class="number">0</span>;         <span class="comment">// dereferencing r yields i, the object to which p points; changes i to 0</span></span><br></pre></td></tr></table></figure><p><strong>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。</strong></p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>在变量类型前添加关键字<code>const</code>可以创建值不能被改变的对象。**<code>const</code>变量必须被初始化。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;    <span class="comment">// input buffer size</span></span><br><span class="line">bufSize = <span class="number">512</span>;      <span class="comment">// error: attempt to write to const object</span></span><br></pre></td></tr></table></figure><p><strong>默认情况下，<code>const</code>对象被设定成仅在文件内有效。当多个文件中出现了同名的<code>const</code>变量时，其实等同于在不同文件中分别定义了独立的变量。</strong></p><p>如果想在多个文件间共享<code>const</code>对象：</p><ul><li><p>若<code>const</code>对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。</p></li><li><p>若<code>const</code>对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时<code>const</code>变量的声明和定义前都应该添加<code>extern</code>关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;   <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><p>把引用绑定在<code>const</code>对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。<strong>这里其实就是因为不能用引用来修改原来是const的变量的值，所以不能有非const的引用，我一个本尊都不能修改，能让你一个假身（引用）修改嘛？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;     <span class="comment">// ok: both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>;        <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;   <span class="comment">// error: non const reference to a const object</span></span><br></pre></td></tr></table></figure><p><strong>大部分情况下，引用的类型要和与之绑定的对象严格匹配。</strong>但是有两个例外：</p><ul><li><p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;      <span class="comment">// we can bind a const int&amp; to a plain int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;     <span class="comment">// ok: r1 is a reference to const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;     <span class="comment">// ok: r3 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r * <span class="number">2</span>;        <span class="comment">// error: r4 is a plain, non const reference</span></span><br></pre></td></tr></table></figure></li><li><p>允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure></li></ul><h4 id="指针和const（Pointers-and-const）"><a href="#指针和const（Pointers-and-const）" class="headerlink" title="指针和const（Pointers and const）"></a>指针和const（Pointers and const）</h4><p><strong>指向常量的指针（pointer to const）</strong>不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;     <span class="comment">// pi is const; its value may not be changed</span></span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;          <span class="comment">// error: ptr is a plain pointer</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;   <span class="comment">// ok: cptr may point to a double that is const</span></span><br><span class="line">*cptr = <span class="number">42</span>;         <span class="comment">// error: cannot assign to *cptr</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>; <span class="comment">// dval is a double; its value can be changed</span></span><br><span class="line">cptr = &amp;dval;       <span class="comment">// ok: but can&#x27;t change dval through cptr</span></span><br></pre></td></tr></table></figure><p>定义语句中把<code>*</code>放在<code>const</code>之前用来说明指针本身是一个常量，<strong>常量指针（const pointer）</strong>必须初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;  <span class="comment">// pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure><p>指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。</p><h4 id="顶层const（Top-Level-const）"><a href="#顶层const（Top-Level-const）" class="headerlink" title="顶层const（Top-Level const）"></a>顶层const（Top-Level const）</h4><p>顶层<code>const</code>表示指针本身是个常量，底层<code>const</code>（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层<code>const</code>也可以是底层<code>const</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;     <span class="comment">// we can&#x27;t change the value of p1; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;      <span class="comment">// we cannot change ci; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;    <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;      <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure><p>当执行拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显：</p><ul><li><p>顶层<code>const</code>没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ci;     <span class="comment">// ok: copying the value of ci; top-level const in ci is ignored</span></span><br><span class="line">p2 = p3;    <span class="comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span></span><br></pre></td></tr></table></figure></li><li><p>拷入和拷出的对象必须具有相同的底层<code>const</code>资格。或者两个对象的数据类型可以相互转换。一般来说，<strong>非常量可以转换成常量</strong>，反之则不行。</p><p><strong>这种就想，如果能把常量转换成非常量的话，这就代表你这个新的指针可以随便改这个值，那原来的变量又怎么能叫做常量呢？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = p3;    <span class="comment">// error: p3 has a low-level const but p doesn&#x27;t</span></span><br><span class="line">p2 = p3;        <span class="comment">// ok: p2 has the same low-level const qualification as p3</span></span><br><span class="line">p2 = &amp;i;        <span class="comment">// ok: we can convert int* to const int*</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;    <span class="comment">// error: can&#x27;t bind an ordinary int&amp; to a const int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">// ok: can bind const int&amp; to plain int</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="constexpr和常量表达式（constexpr-and-Constant-Expressions）"><a href="#constexpr和常量表达式（constexpr-and-Constant-Expressions）" class="headerlink" title="constexpr和常量表达式（constexpr and Constant Expressions）"></a>constexpr和常量表达式（constexpr and Constant Expressions）</h4><p>常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p>一个对象是否为常量表达式由它的数据类型和初始值共同决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;           <span class="comment">// max_files is a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit is a constant expression</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;        <span class="comment">// staff_size is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// sz is not a constant expression</span></span><br></pre></td></tr></table></figure><p>C++11允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;          // 20 is a constant expression</span><br><span class="line">constexpr int limit = mf + 1;   // mf + 1 is a constant expression</span><br><span class="line">constexpr int sz = size();      // ok only if size is a constexpr function</span><br></pre></td></tr></table></figure><p>指针和引用都能定义成<code>constexpr</code>，但是初始值受到严格限制。<code>constexpr</code>指针的初始值必须是0、<code>nullptr</code>或者是存储在某个固定地址中的对象。</p><p>函数体内定义的普通变量一般并非存放在固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化<code>constexpr</code>指针。</p><p>在<code>constexpr</code>声明中如果定义了一个指针，限定符<code>constexpr</code>仅对指针本身有效，与指针所指的对象无关。<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;     <span class="comment">// p是指向int的const指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *cp = &amp;i;   <span class="comment">// cp是指向const int的const指针</span></span><br></pre></td></tr></table></figure><p><code>const</code>和<code>constexpr</code>限定的值都是常量。但<code>constexpr</code>对象的值必须在编译期间确定，而<code>const</code>对象的值可以延迟到运行期间确定。</p><p><strong>建议使用<code>constexpr</code>修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。</strong></p><hr><h3 id="处理类型（Dealing-with-Types）"><a href="#处理类型（Dealing-with-Types）" class="headerlink" title="处理类型（Dealing with Types）"></a>处理类型（Dealing with Types）</h3><h4 id="类型别名（Type-Aliases）"><a href="#类型别名（Type-Aliases）" class="headerlink" title="类型别名（Type Aliases）"></a>类型别名（Type Aliases）</h4><p>类型别名是某种类型的同义词，传统方法是使用关键字<code>typedef</code>定义类型别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;   <span class="comment">// wages is a synonym for double</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base is a synonym for double, p for double*</span></span><br></pre></td></tr></table></figure><p>C++11使用关键字<code>using</code>进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI is a synonym for Sales_item</span></span><br></pre></td></tr></table></figure><h4 id="auto类型说明符（The-auto-Type-Specifier）"><a href="#auto类型说明符（The-auto-Type-Specifier）" class="headerlink" title="auto类型说明符（The auto Type Specifier）"></a>auto类型说明符（The auto Type Specifier）</h4><p>C++11新增<code>auto</code>类型说明符，能让编译器自动分析表达式所属的类型。<code>auto</code>定义的变量必须有初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the type of item is deduced from the type of the result of adding val1 and val2</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// item initialized to the result of val1 + val2</span></span><br></pre></td></tr></table></figure><p>编译器推断出来的<code>auto</code>类型有时和初始值的类型并不完全一样。</p><ul><li><p>当引用被用作初始值时，编译器以引用对象的类型作为<code>auto</code>的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;     <span class="comment">// a is an int (r is an alias for i, which has type int)</span></span><br></pre></td></tr></table></figure></li><li><p><code>auto</code>一般会忽略顶层<code>const</code>。<strong>因为是赋值出来的另一个变量，独立的内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">// b is an int (top-level const in ci is dropped)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">// c is an int (cr is an alias for ci whose const is top-level)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">// d is an int*(&amp; of an int object is int*)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">// e is const int*(&amp; of a const object is low-level const)</span></span><br></pre></td></tr></table></figure><p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要显式指定<code>const auto</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// deduced type of ci is int; f has type const int</span></span><br></pre></td></tr></table></figure></li></ul><p>设置类型为<code>auto</code>的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g is a const int&amp; that is bound to ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;   <span class="comment">// error: we can&#x27;t bind a plain reference to a literal</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;     <span class="comment">// ok: we can bind a const reference to a literal</span></span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符（The-decltype-Type-Specifier）"><a href="#decltype类型指示符（The-decltype-Type-Specifier）" class="headerlink" title="decltype类型指示符（The decltype Type Specifier）"></a>decltype类型指示符（The decltype Type Specifier）</h4><p>C++11新增<code>decltype</code>类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum has whatever type f returns</span></span><br></pre></td></tr></table></figure><p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>有些不同，如果<code>decltype</code>使用的表达式是一个变量，则<code>decltype</code>返回该变量的类型（包括顶层<code>const</code>和引用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;     <span class="comment">// x has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;     <span class="comment">// y has type const int&amp; and is bound to x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;     <span class="comment">// error: z is a reference and must be initialized</span></span><br></pre></td></tr></table></figure><p>如果<code>decltype</code>使用的表达式不是一个变量，则<code>decltype</code>返回表达式结果对应的类型。如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则<code>decltype</code>会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p><p><strong><code>decltype((var))</code>的结果永远是引用</strong>，而<code>decltype(var)</code>的结果只有当<em>var</em>本身是一个引用时才会是引用。</p><hr><h3 id="自定义数据结构（Defining-Our-Own-Data-Structures）"><a href="#自定义数据结构（Defining-Our-Own-Data-Structures）" class="headerlink" title="自定义数据结构（Defining Our Own Data Structures）"></a>自定义数据结构（Defining Our Own Data Structures）</h3><p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p><strong>类内初始值不能使用圆括号。</strong></p><p><strong>类定义的最后应该加上分号。</strong></p><p><strong>头文件（header file）通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</strong></p><p><strong>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</strong></p><p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。<code>#define</code>指令把一个名字设定为预处理变量。<code>#ifdef</code>指令当且仅当变量已定义时为真，<code>#ifndef</code>指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在高级版本的IDE环境中，可以直接使用<code>#pragma once</code>命令来防止头文件的重复包含。</p><p>预处理变量无视C++语言中关于作用域的规则。</p><p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p><p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h2&gt;&lt;h3 id=&quot;变量初始化&quot;&gt;&lt;a href=&quot;#变量初始化&quot; class</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--应用层</title>
    <link href="http://icecorn.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-02-16T11:25:30.000Z</published>
    <updated>2022-06-29T10:21:15.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–应用层"><a href="#计算机网络–应用层" class="headerlink" title="计算机网络–应用层"></a>计算机网络–应用层</h1><p>本章主要掌握各种应用层协议的使用方法和实现方法</p><p>常见的基于UDP和TCP的应用</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419210323.png"></p><h2 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1 域名系统DNS"></a>1 域名系统DNS</h2><p>我们打开一个网页比如百度通常是使用<a href="http://www.baidu.com而不是它的ip地址加端口号,这就是靠域名服务器进行域名解析实现的.主机发送dns请求报文(使用udp)给**域名服务器**,收到响应中的ip地址后可与目的主机进行通信./">www.baidu.com而不是它的ip地址加端口号，这就是靠域名服务器进行域名解析实现的。主机发送DNS请求报文（使用UDP）给**域名服务器**，收到响应中的ip地址后可与目的主机进行通信。</a></p><hr><p>全球只用一个域名服务器显然是不现实的，所以域名服务器实际上是一个分布式系统，并且按如下划分了域名空间</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419170454.png"></p><p><strong>权限域名服务器</strong>：负责一个区的域名服务器，一般是一个公司内部的，比如可以划分abc.com和y.abc.com</p><p><strong>本地域名服务器</strong>：又叫做<strong>默认域名服务器</strong>，一般是离主机最近的服务器</p><hr><p>主机向本地域名服务器的查询一般采用<strong>递归查询</strong></p><p>本地服务器向根服务器的查询一般采用<strong>迭代查询</strong>，当然也可以用递归查询</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419174635.png"></p><p><strong>递归查询</strong>就是自己只发送一次查询报文然后剩下的一层层处理最后拿个结果就好了（小弟派小弟层层转包）</p><p><strong>迭代查询</strong>是自己发送查询接收响应反复操作最后得到结果（事必躬亲）</p><hr><h2 id="2-文件传送协议"><a href="#2-文件传送协议" class="headerlink" title="2 文件传送协议"></a>2 文件传送协议</h2><p>FTP基于TCP，TFTP基于UDP</p><h3 id="2-1-FTP协议"><a href="#2-1-FTP协议" class="headerlink" title="2.1 FTP协议"></a>2.1 FTP协议</h3><p>FTP使用客户服务器方式，FTP服务器由一个<strong>主进程</strong>和<strong>若干个从属进程</strong>组成，这是因为FTP服务器要接收好多个客户的请求，每次和一个客户连接后马上给这个客户分配几个从属进程，快点把主进程空出来给别的客户访问</p><p>对于一个主机来说，与服务器一般建立两个TCP连接，一个<strong>控制进程</strong>，一个<strong>数据传送进程</strong>，通信中控制进程一直连接着吗，因此FTP控制信息是<strong>带外</strong>的</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419180528.png" alt="一个主机与服务器的通信"></p><p>TCP只能整体传送文件，这就有了<strong>网络文件系统NFS</strong>，它可以允许应用程序只读取并修改指定位置的信息，减少了通信量</p><hr><h3 id="2-2-TFTP协议"><a href="#2-2-TFTP协议" class="headerlink" title="2.2 TFTP协议"></a>2.2 TFTP协议</h3><p>基于UDP的超级简单的协议，只支持传输不支持交互</p><p>优点：</p><ul><li>多个主机同时从服务器下载东西（因为UDP可以一对多嘛，可以理解类似于多播）</li><li>开销小，占内存小，这就适合很多不需要太多功能的开源硬件</li></ul><p>另外虽然UDP是不可靠传输，但TFTP类似与停止等待协议，这就是靠应用层实现传输控制来保证的</p><hr><h3 id="2-3-远程终端协议TELNET"><a href="#2-3-远程终端协议TELNET" class="headerlink" title="2.3 远程终端协议TELNET"></a>2.3 远程终端协议TELNET</h3><p>用来远程控制桌面的东东，只需要知道怎么用以及它是基于TCP的就ok</p><hr><h2 id="3-万维网协议"><a href="#3-万维网协议" class="headerlink" title="3 万维网协议"></a>3 万维网协议</h2><p>就是我们熟悉的www啦，了解万维网，主要了解一下几个问题：</p><ul><li>怎样标志分布在整个互联网上的各种万维网文档？ URL</li><li>用什么协议实现万维网的连接？  HTTP</li><li>不同风格的文档在不同主机怎么显示？  HTML</li><li>怎样查找需要的信息？  搜索引擎</li></ul><hr><h3 id="3-1-统一资源定位符URL"><a href="#3-1-统一资源定位符URL" class="headerlink" title="3.1 统一资源定位符URL"></a>3.1 统一资源定位符URL</h3><p>相当于互联网上任一文件的指针，一般形式为：</p><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>协议常见的有http，ftp等，端口和路径可以省略</p><hr><h3 id="3-2-超文本传输协议HTTP"><a href="#3-2-超文本传输协议HTTP" class="headerlink" title="3.2 超文本传输协议HTTP"></a>3.2 超文本传输协议HTTP</h3><p>HTTP是<strong>面向事务</strong>的应用层协议，基于TCP</p><p>特点：</p><ul><li><strong>无连接的</strong>：意思就是http不用先建立连接再通信，因为是基于TCP的，由TCP来保证可靠传输</li><li><strong>无状态的</strong>： 意思是同一个客户再来访问结果还是一样，服务器不会记得</li><li><strong>面向文本</strong>： 意思是http报文中的每一个字段都是一些ASCII码，长度是由用户输入决定的</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419185159.png"></p><hr><p>http首先要与服务器建立TCP连接，这就需要3次握手，由传输层的知识我们知道这样就会导致客户实际收到消息时需要2RTT的时间间隔，而http1.0协议使用<strong>非持续传输</strong>，意思就是访问这个网页（服务器不同路径）上的任何一个元素都需要重新建立TCP连接，这就会浪费好多个2RTT时间</p><p>所以http1.1采用了<strong>持续连接</strong>，意思就是访问同一个服务器上东西的时候TCP连接不用断开，就用着一个就完事了，省下来很多<strong>握手时间</strong>，具体方式还分为<strong>流水线</strong>和<strong>非流水线</strong>方式，不赘述了</p><hr><p><strong>代理服务器</strong>，又叫做<strong>万维网高速缓存</strong></p><p>这玩意就是保存了一个局域网内最近主机的请求和响应信息，当又有主机访问相同的资源的时候就不用再去远端查找了。这就减少了链路的通信量。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419190059.png"></p><hr><p><strong>HTTP的报文结构</strong></p><p>主要就是<strong>请求报文</strong>和<strong>响应报文</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419190831.png"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419191111.png"></p><hr><h3 id="3-3-万维网文档"><a href="#3-3-万维网文档" class="headerlink" title="3.3 万维网文档"></a>3.3 万维网文档</h3><p><strong>超文本标记语言HTML</strong>：用于在浏览器上显示数据</p><p><strong>可扩展标记语言XML</strong>： 用于传输数据</p><p><strong>可扩展超文本标记语言XHTML</strong>： 更严格的html版本</p><p><strong>层叠样式表CSS</strong>： 用于定义html文档布局</p><hr><p><strong>动态文档</strong></p><p>上述都是<strong>静态文档</strong>，而<strong>动态文档</strong>只是文档的生成方法不同，静态文档只要放在服务器上就ok了，动态文档允许客户和服务器进行交互，也就是说服务器获取到客户的信息后进行一系列处理之后生成文档</p><p>这就需要在服务器中新增加一个应用程序叫做<strong>CGI程序</strong>，也叫作CGI脚本。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419192922.png"></p><hr><p><strong>活动文档</strong></p><p>它是用来满足更复杂的需求比如动画交互之类的，如果一直让服务器来传送的话太浪费资源，所以<strong>活动文档</strong>相当于是在服务器上的一个静态文档，类似一个浏览器可执行的小应用程序，现在常用的JS脚本</p><hr><h3 id="3-4-万维网的信息检索系统"><a href="#3-4-万维网的信息检索系统" class="headerlink" title="3.4 万维网的信息检索系统"></a>3.4 万维网的信息检索系统</h3><p>分为两种：</p><p><strong>全文检索搜索</strong>： 比如谷歌百度这种，本质是使用爬虫在数据库里搜索相关信息</p><p><strong>分类目录搜索</strong>： 比如门户网站这些，已经给你分配好了的专栏</p><hr><h2 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h2><p>主要涉及<strong>简单邮件传送协议SMTP</strong>，<strong>互联网邮件扩充MIME</strong>，<strong>邮局协议POP3</strong>，<strong>网际报文存取协议IMAP</strong></p><p><strong>要注意的是这些都是基于TCP的</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419195202.png"></p><p>上图基本给出了用户代理，发送方和接收方邮件服务器的作用</p><hr><p><strong>由于SMTP有以下缺点</strong>：</p><ul><li>不能传送可执行文件和其他的二进制对象</li><li>只能传送7位的ASCII码，导致其他国家文字不能传输</li><li>SMTP服务器会拒绝超出一定长度的邮件</li><li>将制表符tab转换为若干个空格</li></ul><p>由此提出了<strong>互联网扩充协议MIME</strong></p><p>具体看书吧，记住有了MIME实现了上述这些功能就行了</p><hr><p><strong>两种接收协议的特点</strong>：</p><p>POP3：</p><p>优点：简单</p><p>缺点：邮件读了后就自动删除了</p><p>IMAP：</p><p>优点：可以在不同主机上随时处理邮件服务器的邮件，支持阅读部分邮件</p><p>缺点：必须上网连接IMAP服务器才能阅读邮件</p><hr><p>互联网邮箱：</p><p>现在多数都是这些，记住<strong>浏览器和互联网上的邮件服务器通信使用的是HTTP协议，而邮件服务器之间通信使用SMTP即可</strong></p><hr><h2 id="5-动态主机配置协议DHCP"><a href="#5-动态主机配置协议DHCP" class="headerlink" title="5 动态主机配置协议DHCP"></a>5 动态主机配置协议DHCP</h2><p>DCHP使用UDP进行传输。就是动态的分配<strong>IP地址，子网掩码，默认路由地址，域名服务器地址</strong>（就是我们常用的自动配置IP）</p><p>一个新的主机第一次连接到一个网络，按照以下步骤：</p><ul><li>主机发送<strong>广播</strong>（目的地址全1）给网络中的<strong>DCHP中继代理</strong>（一般是一个路由器）</li><li>路由器发送<strong>单播</strong>告诉DCHP服务器</li><li>DCHP发送响应给主机A</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419201257.png"></p><p>注意两点：</p><ul><li>主机在一个网络中连了一次网，分配的IP就记录在DCHP服务器中了，下次联网还是这个IP地址</li><li>给了IP地址后，不是一直可以使用的，有一个<strong>租用期</strong>，长短有DCHP服务器控制，过半后主机发送续租报文，服务器同意就续上，不同意就不能用这个IP了</li></ul><h2 id="6-P2P应用"><a href="#6-P2P应用" class="headerlink" title="6 P2P应用"></a>6 P2P应用</h2><h3 id="6-1-集中服务器的P2P工作方式"><a href="#6-1-集中服务器的P2P工作方式" class="headerlink" title="6.1 集中服务器的P2P工作方式"></a>6.1 集中服务器的P2P工作方式</h3><p>在集中式目录服务器中建立一个数据库保存哪个资源都哪些主机有，这是要想下载一个东西就先去集中服务器查找，返回一串主机，在选一个主机进行下载</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419203549.png"></p><hr><h3 id="6-2-全分布式结构P2P共享程序"><a href="#6-2-全分布式结构P2P共享程序" class="headerlink" title="6.2 全分布式结构P2P共享程序"></a>6.2 全分布式结构P2P共享程序</h3><p>使用<strong>洪泛法</strong>，在网络内进行<strong>有限范围的洪泛查询</strong>，具有代表性的就是BT种子了（某播：技术是无罪的==）</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419203910.png"></p><p>P2P的本质就是惠人惠己，比如我们要下载一部小电影，实际上在p2p网络中这个小电影是由好多个<strong>文件块</strong>组成的，有好多主机上边都有这些文件块，可能这个给你一块那个给你一块那么我们就能很快把这个小电影下载完，当然之后我们电脑上有这个文件了（即使一些文件块）也要给别人下载，不能太自私啦。这些和我们互相交互下载文件块的主机叫做<strong>对等方</strong>。</p><p>同时在发送过程中有两个规则：</p><ul><li><strong>最稀有优先</strong>：意思就是小电影中哪个文件块在现在网上拥有的数目最少就要先下载哪个，不然那些主机都下线最后少了这个文件块导致看不了小电影就很难受QAQ</li><li><strong>优先发送对等方选择</strong>：前面说我们也要给别人下载，那么怎么确定优先给谁发呢？当然要优先发给给我们发送文件块的对等方了（按速率排序，互惠互利）。一般保持4个最高速的对等方，这些对等方叫<strong>已疏通的或无障碍的对等方</strong></li></ul><p>还有一个问题就是分布式结构到底怎么确定小电影在哪些主机上有呢？</p><p><strong>洪泛法的效率太低且浪费资源</strong>，所以最好还是建立一个<strong>分布式数据库</strong>，又不能像集中式服务器那样，所以现在有个算法是<strong>分布式散列表</strong>，具体内容再看吧QAQ</p><hr><h2 id="7-应用进程和系统调用"><a href="#7-应用进程和系统调用" class="headerlink" title="7 应用进程和系统调用"></a>7 应用进程和系统调用</h2><p>我们知道程序员的业务逻辑代码基本都是在应用层，对运输层的控制很少（只能设置最大数据长度MSS等），那么进行网络编程时实际上都是使用API（也可以说套接字）来对接操作系统从而实现网络通信</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419205843.png"></p><p>进行TCP的基本API调用流程如下，细节的话联系操作系统</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419210211.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–应用层&quot;&gt;&lt;a href=&quot;#计算机网络–应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–应用层&quot;&gt;&lt;/a&gt;计算机网络–应用层&lt;/h1&gt;&lt;p&gt;本章主要掌握各种应用层协议的使用方法和实现方法&lt;/p&gt;
&lt;p&gt;常见的基于UDP和TC</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--运输层</title>
    <link href="http://icecorn.github.io/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2022-02-14T06:16:07.000Z</published>
    <updated>2022-06-29T10:20:45.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–运输层"><a href="#计算机网络–运输层" class="headerlink" title="计算机网络–运输层"></a>计算机网络–运输层</h1><h2 id="1-运输层基本概念"><a href="#1-运输层基本概念" class="headerlink" title="1. 运输层基本概念"></a>1. 运输层基本概念</h2><p>运输层向应用层提供通信服务，在运输层中，<strong>通信的真正端点不是主机而是主机中的进程</strong></p><p>网络层为主机之间提供逻辑通信，运输层为应用进程提供端到端的逻辑通信</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415155007.png"></p><hr><p>运输层连个主要协议：</p><ul><li>用户数据报协议UDP（不用连接）</li><li>传输控制协议TCP（面向连接）</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415155252.png" alt="使用这两种协议的应用及协议"></p><hr><p>运输层支持<strong>复用</strong>和<strong>分用</strong>，方法是使用<strong>协议端口号</strong>（端口）</p><p>这里的端口号是指软件端口，分为两大类：</p><ul><li><p>服务器端使用的端口号</p><p>1.熟知端口号（系统端口号）：  0~1023 比如FTP是21</p><p>2.登记算口号：  1024~49151  其他应用使用的</p></li><li><p>客户端使用的端口号</p><p>数值49152~65535  在客户进程运行时才动态选择，又叫<strong>短暂端口号</strong>  ，在不同主机可以随意分配</p></li></ul><hr><h2 id="2-用户数据报协议UDP"><a href="#2-用户数据报协议UDP" class="headerlink" title="2 用户数据报协议UDP"></a>2 用户数据报协议UDP</h2><p>UDP在IP数据报服务上增加了复用分用功能和差错检测功能</p><p>主要特点：</p><ul><li><strong>是无连接的</strong></li><li><strong>尽最大努力交付：</strong>  即不保证可靠交付</li><li><strong>是面向报文的：</strong>  意思是UDP接收到应用层报文不做任何操作仅仅加上UDP首部就构成了UDP报文，这就要求应用层控制报文大小（太大会导致IP报文需要分片，太小导致传输效率太低）</li><li><strong>没有拥塞控制</strong></li><li><strong>支持1对1,1对多，多对1，多对多的交互通信</strong></li><li><strong>首部开销小</strong>：  只有8字节</li></ul><hr><p>UDP 首部格式</p><p>首部共8字节，四个字段，分别是<strong>源端口</strong>  <strong>目的端口</strong>  <strong>长度</strong>（UDP报文总长度，最小为8只有首部）  <strong>检验和</strong>  每个字段2字节</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415161027.png"></p><p>伪首部只在计算检验和时被用于计算，检验方法类似IP数据报首部校验方法，<strong>区别是UDP的校验是把首部和数据部分一起都检验</strong></p><hr><h2 id="3-传输控制协议TCP"><a href="#3-传输控制协议TCP" class="headerlink" title="3 传输控制协议TCP"></a>3 传输控制协议TCP</h2><p>TCP具有可靠传输，流量控制，拥塞控制等等功能</p><p>主要特点：</p><ul><li><strong>面向连接</strong>：通信前必须建立TCP连接</li><li><strong>点对点</strong>：每一条TCP连接只能有两个端点，即只能1对1传输</li><li><strong>提供可靠交付</strong>： 无差错，不丢失，不重复，按序到达</li><li><strong>全双工通信</strong>：TCP连接两端设有<strong>发送缓存</strong>和<strong>接收缓存</strong></li><li><strong>面向字节流</strong>：对TCP来说应用程序发送的数据仅仅看成一连串<strong>无结构的字节流</strong>，TCP不理解这些玩意代表啥意思，只是必须把这些字节流按照顺序完整的传达到终点，它的任务就完成了。解析的活就交给终端处理就好</li></ul><p><strong>这里有一个UDP与TCP的差别就是，UDP发送的报文长度是应用进程给出的，而TCP是根据对方的窗口值和网络拥塞之类的自己判断（如果应用数据太长就分几段，太短就攒几个一起发）</strong></p><hr><p>TCP连接的端点叫<strong>套接字socket</strong>，将端口号拼接到IP地址就是套接字</p><p>比如 192.3.4.5:80</p><p>TCP把连接作为最基本的抽象，每条TCP连接唯一的被通信两端的套接字确定</p><p>TCP连接::={socket1,socket2}={(IP1:port1),(IP2,port2)}</p><hr><h2 id="4-TCP报文段首部格式"><a href="#4-TCP报文段首部格式" class="headerlink" title="4 TCP报文段首部格式"></a>4 TCP报文段首部格式</h2><p>TCP首部前20字节是固定的，后边可根据需要增加4n字节</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415164539.png" alt="TCP报文段首部格式"></p><ul><li><strong>源端口和目的端口</strong>：各占2字节，目的是实现分用</li><li><strong>序号</strong>：4字节，TCP是面向字节流的，所以该字段是指<strong>本报文段所发送的第一个字节的序号</strong></li><li><strong>确认号</strong>：4字节，是<strong>期望收到对方下一个报文段的第一个数据字节序号</strong></li><li><strong>数据偏移</strong>：4位，和IP数据报中的首部长度类似，表示的是TCP首部的实际长度（最大二进制15,4字节为单位，所以TCP首部最大也是60字节）</li><li><strong>保留</strong>：目前没用，置0</li><li><strong>紧急URG</strong>：1位，置1时代表高优先级优先发送</li><li><strong>确认ACK</strong>：1位，置1时才有效，TCP连接建立后所有报文ACK都为1</li><li><strong>推送PSH</strong>：1位，表示接收端收到就上交给应用层（不用少量信息攒一波），很少用</li><li><strong>复位RST</strong>：1位，TCP连接出现严重差错，该字段置1重建连接</li><li><strong>同步SYN</strong>：1位，建立连接时用来同步序号，置1表示这是一个连接请求或连接接受报文</li><li><strong>终止FIN</strong>：1位，用来释放一个连接，置1表示发送方数据发送完毕，请求释放运输连接</li><li><strong>窗口</strong>：2字节，是指发送本报文段的一方的<strong>接收窗口</strong></li><li><strong>检验和</strong>：2字节，检验首部和数据两部分，和UDP一样计算时也加伪首部</li><li><strong>紧急指针</strong>：2字节，仅在URG置1时有意义，指出<strong>紧急数据在的末尾在此报文段中的位置</strong></li><li><strong>选项</strong>：长度可变，最多40字节</li></ul><hr><h2 id="5-可靠传输的原理和实现"><a href="#5-可靠传输的原理和实现" class="headerlink" title="5 可靠传输的原理和实现"></a>5 可靠传输的原理和实现</h2><p>TCP是面向连接且可靠的传输协议，理想的传输协议需要具备以下两点：</p><ul><li>传输信道不产生差错</li><li> 不管发送方以多快的速度发送分组，接收端总能正确接收并处理</li></ul><hr><h3 id="5-1-停止等待协议"><a href="#5-1-停止等待协议" class="headerlink" title="5.1 停止等待协议"></a>5.1 停止等待协议</h3><p>停止等待是最简单的可靠传输，<strong>A发生完一个分组就停止发送等待对方的确认</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415181928.png" alt="停止等待协议"></p><p><strong>超时重传</strong>：当发送方发送的分组出现差错没有送达接收方，就会启动<strong>超时重传机制</strong>，A每发送一个分组立刻设置一个<strong>超时计时器</strong>。这里有三点需要注意：</p><ul><li>A发送一个分组后，必须暂时保留该<strong>分组副本</strong>，收到确认后才删除</li><li>分组和确认分组都要进行<strong>编号</strong>，对于停止等待来说 0和1两个编号循环使用就行</li><li>超时重传时间应该设置的比<strong>数据传输的平均往返时间</strong>长一些</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415182617.png" alt="确认丢失额确认迟到"></p><p>确认丢失时B忽略第二次收到的重复分组并发送确认给A</p><p>确认迟到B同样忽略第二次收到的重复分组，A忽略重复确认</p><p>这样我们就在不可靠的传输网络上实现了可靠通信，这种可靠传输协议叫做<strong>自动重传请求ARQ</strong></p><hr><h3 id="5-2-流水线传输"><a href="#5-2-流水线传输" class="headerlink" title="5.2 流水线传输"></a>5.2 流水线传输</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低，所以出现了流水线传输。流水线传输需要用到<strong>连续ARQ协议，回退N帧（gobackN）协议，滑动窗口协议等等</strong></p><hr><p>连续ARQ协议：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415183407.png" alt="连续ARQ协议工作原理"></p><p>发送方根据接收方的<strong>窗口</strong>参数和<strong>自身的发送缓存</strong>决定窗口大小，窗口内的分组都是可以发送的，每收到一个确认窗口就向前移动一个分组</p><p><strong>累计确认</strong>：接收方不用每收到一个分组就发送一条确认，而是攒几个发送一个确认（<strong>按序到达的最后一个分组编号</strong>）即可。</p><p>累计确认的优点是<strong>容易实现</strong>，<strong>减少了通信量</strong>，<strong>即使确认丢失也不用重传</strong>。</p><p>累计确认的缺点是<strong>不能向发送方反应已经正确收到的所有分组信息</strong></p><p><strong>比如发送了前5个分组，接收方收到了1 2 4 5，那么接收方直接发送收到了2，这样发送方就必须重新发送3 4 5，哪怕4 5 已经收到了，这就叫做回退N帧协议（Go-back-N）</strong></p><hr><h3 id="5-3-滑动窗口协议"><a href="#5-3-滑动窗口协议" class="headerlink" title="5.3 滑动窗口协议"></a>5.3 滑动窗口协议</h3><p>滑动窗口协议其实就是<strong>以字节为单位</strong>的连续ARQ协议，但是研究的时候通常也可以以分组为单位研究</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415184550.png"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415185230.png" alt="缓存与窗口的关系"></p><p>这里要注意以下几点：</p><ul><li>A<strong>根据B可接收的窗口大小</strong>和<strong>A的发送缓存大小</strong>（取较小值）来确定A的发送窗口，当然有时还可以根据<strong>拥塞状况</strong>适当减小。</li><li>发送窗口中已发送数据在<strong>没收到确认之前</strong>不能删除</li><li>接收方一定要支持<strong>累计确认</strong>功能，减小传输开销</li><li>TCP是全双工通信，通信双方都有发送窗口和接收窗口</li></ul><hr><h3 id="5-4-超时重传时间的选择"><a href="#5-4-超时重传时间的选择" class="headerlink" title="5.4 超时重传时间的选择"></a>5.4 超时重传时间的选择</h3><p>重传时间的选择是TCP中最复杂的问题，TCP采用一种自适应的算法线算出报文段的往返时间RTT，再计算一个加权平均往返时间RTTS。</p><p>不想写了，用到的话看书吧QAQ</p><hr><h3 id="5-5-选择确认SACK"><a href="#5-5-选择确认SACK" class="headerlink" title="5.5 选择确认SACK"></a>5.5 选择确认SACK</h3><p>若接收方收到的分组无差错，只是没按序号，或者只有中间的几个分组丢失了，能不能告诉发送方只发送这几个分组？</p><p>没错，这玩意就是解决这个问题的，要在TCP建立连接时在扩展首部里加上“允许SACK”选项</p><p>具体内容不写了，QAQ</p><hr><h2 id="6-TCP流量控制"><a href="#6-TCP流量控制" class="headerlink" title="6 TCP流量控制"></a>6 TCP流量控制</h2><h3 id="6-1-利用滑动窗口实现流量控制"><a href="#6-1-利用滑动窗口实现流量控制" class="headerlink" title="6.1 利用滑动窗口实现流量控制"></a>6.1 利用滑动窗口实现流量控制</h3><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417165127.png"></p><p>TCP是面向字节流的，seq代表发送字节的序号，ACK是确认位，ack是确认编号，rwnd是<strong>接收端允许发送端发送的数据窗口大小</strong></p><p>图中最后rwnd置0，说明此时A不能再发送字节了，要是之后B发送重置rwnd时确认丢失，就会产生死锁，解决方案就是TCP的每条连接都有一个<strong>持续计时器</strong>，在发送端收到rwnd置0消息时开启，超时后发送端发送一个<strong>1字节的零窗口探测报文段</strong>，这样接收端就知道响应报文丢失了。</p><hr><h3 id="6-2-TCP的传输效率"><a href="#6-2-TCP的传输效率" class="headerlink" title="6.2 TCP的传输效率"></a>6.2 TCP的传输效率</h3><p>对于UDP来说，什么时候发送报文是应用程序决定的，UDP只需要原封不动的转发就行。但是对于TCP，应用进程把数据传送到TCP的发送缓存后就不管了，所以TCP是什么时候发送报文就是一个很重要的问题，有下面几种机制来发送：</p><ul><li>TCP维持一个<strong>最大报文段长度MSS</strong>变量，只要缓存中数据达到MSS字节就发送</li><li>发送方的应用进程指明要求发送报文段，即TCP支持<strong>推送</strong>操作</li><li>用一个计时器规定时间，到点发送</li></ul><p><strong>Nagle算法</strong>：发送方先发送<strong>第一个数据字节</strong>，将后续应用程序输入的字节保存在<strong>发送缓存</strong>，收到接收方的<strong>确认</strong>后，将攒了一波的数据发送出去（当然不能超过MSS），同时继续保存发送缓存。在收到接收方确认，再发送数据报。<strong>另外，当发送缓存中数据已经到达窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</strong></p><p><strong>糊涂窗口综合症</strong>：  这个玩意是指TCP<strong>接收方的缓存</strong>已经满了，并且接受方的<strong>应用程序</strong>比较懒，一次处理一个字节，那么接收缓存每次仅仅空出一个字节还每次都发送确认（并把rwnd设置为1，导致发送方每次有效传输只有1字节），发送1字节还要加上TCP首部20字节，IP首部20字节，这样效率实在太低</p><p>解决方案可以<strong>让接收方等一会，等接收缓存空出来一个最大报文段或者等到接收缓存有一半以上空地方</strong></p><p>总结： 发送效率主要就是要减少40字节的首部的占比，所以记住发送方别发送太短的报文，接收方也别没事就发信号让发送方发报文就完事了。</p><hr><h3 id="6-3-吞吐量"><a href="#6-3-吞吐量" class="headerlink" title="6.3 吞吐量"></a>6.3 吞吐量</h3><p>吞吐量是指一个传输周期内传输的字节速率，注意单位是<strong>bit/s</strong>，经常会有和<strong>发送窗口</strong>相关的计算题</p><p>一个TCP连接下面使用256Kb/s的链路，其端到端时延为128ms。经测试，发现吞吐量只有120kb/s，则发送窗口大约是</p><p>A．3614字节<br>B．7228字节<br>C．57826字节<br>D．120k比特</p><p>本题目主要考查的是“TCP流量控制”。<br>为了提高报文段的传输效率，TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位为字节。发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。发送端利用发送窗口调节向网络注入分组的速率不仅是为了使接收端来得及接收，而且还是为了对网络进行拥塞控制。在每一个运输连接上报文段是断续发送的，这样就有了两种速率。一种是链路层的数据率，另一种是从运输层看到的数据注入速率。<br>题目中给出端到端时延为128ms，则在一个传输周期里，从发送第一个报文段到收到所有确认时间为：W/R+2<em>T，其中w为发送窗口的大小，R为链路速率，T为端到端时延。因此吞吐量TP=W/(W/R+2</em>T)，将题目中的具体数据代入，即可求得W=7228字节。</p><hr><h2 id="7-TCP的拥塞控制"><a href="#7-TCP的拥塞控制" class="headerlink" title="7 TCP的拥塞控制"></a>7 TCP的拥塞控制</h2><h3 id="7-1-拥塞控制概念"><a href="#7-1-拥塞控制概念" class="headerlink" title="7.1 拥塞控制概念"></a>7.1 拥塞控制概念</h3><p><strong>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不会过载</strong></p><p>拥塞控制和流量控制的区别是：拥塞控制涉及到是整条通信线路上所有的资源（主机，路由器，链路等等），所以需要控制调整的措施也比较复杂。而<strong>流量控制是端到端的交流</strong>，就是接收端告诉发送端你慢点，我吃不消了QAQ</p><p>拥塞控制主要分为两种方法：</p><ul><li><strong>开环控制</strong>：在设计网络时将会导致拥塞的因素都考虑到，运行时就基本不能改了</li><li><strong>闭环控制</strong>：基于反馈环路，几种措施 </li></ul><p>​             1.监测网络拥塞发生在何处</p><p>​             2.把拥塞信息传达到可以采取行动的地方</p><p>​             3.调整网络系统的运行解决问题</p><hr><h3 id="7-2-TCP的拥塞控制方法"><a href="#7-2-TCP的拥塞控制方法" class="headerlink" title="7.2 TCP的拥塞控制方法"></a>7.2 TCP的拥塞控制方法</h3><p>TCP进行拥塞控制的算法有四种：<strong>慢开始</strong>  <strong>拥塞避免</strong>  <strong>快重传</strong>  <strong>快恢复</strong></p><p>首先，发送当要维持一个<strong>拥塞窗口cnwd变量</strong>，<strong>发送方让自己的发送窗口等于拥塞窗口</strong>，cnwd的单位是<strong>发送方的最大报文段SMSS</strong>，一般初始设置为1。</p><p><strong>慢开始</strong>：意思就是初始cnwd设置为1，然后以指数方式增长</p><p><strong>拥塞避免</strong>：当cnwd超过预设门限值ssthresh时，改为线性增大，尽量避免拥塞发生</p><p><strong>快重传</strong>：  为了避免发送方一检测到<strong>超时</strong>就进行慢开始（有时候超时不意味着拥塞），快重传就是说发送方收到连续3次确认（因为中间一个数据报丢了，后边的收到了累计确认），这时发送方直接重传丢失数据报</p><p><strong>快恢复</strong>：  3ACK后不进行慢开始，而是直接把cnwd置为一半</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417184443.png" alt="TCP拥塞控制流程"></p><p>这就是所谓的<strong>加法增大，乘法减小</strong></p><p>另外<strong>发送窗口</strong>大小还取决于接收方的<strong>通知窗口</strong>，所以<strong>发送窗口</strong>取值=MIN[rnwd,cnwd]</p><hr><p><strong>主动队列管理AQM</strong></p><p>在通信链路中的路由器中，路由器缓存队列一般都是<strong>先进先出</strong>，而一旦发生拥塞后来的分组就会被路由器丢弃，那么发送方就会进行<strong>慢开始</strong>，而由于TCP的<strong>复用</strong>特性（路由器接到的都是IP数据报，同一个IP地址可能包装了不同的端口号），这就会导致一时间整个网络很多的TCP连接都<strong>慢开始</strong>了，这种现象叫<strong>全局同步</strong>，严重影响了传送效率</p><p>而AQM就是解决这个问题的，AQM其中一种方法叫<strong>随机早期检测RED</strong>，其实就是给路由器的缓存设置一个门限值，不让它到满了的时候再丢弃，用一个随机算法在它超过门限时就随机丢弃，这就保证了不是所有TCP都会同时慢开始了。</p><hr><h2 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8.TCP的运输连接管理"></a>8.TCP的运输连接管理</h2><p>TCP连接三个阶段：连接建立，数据传送，连接释放</p><p>TCP连接建立采用<strong>客户服务器</strong>方式</p><h3 id="8-1-连接建立"><a href="#8-1-连接建立" class="headerlink" title="8.1 连接建立"></a>8.1 连接建立</h3><p>就是著名的<strong>三次握手</strong>啦</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417190511.png"></p><ul><li>SYN报文不允许携带数据，但是<strong>消耗一个序号</strong></li><li>ACK报文<strong>携带数据的话消耗序号，不携带的话不消耗序号</strong></li></ul><p>为什么最后A一定要在发送一次确认给B呢？</p><p>这是因为假设A发送请求滞留在路由器里导致超时了，这是A以为报文丢了就重发了一个请求与B建立了连接通信后又断开连接。然后这是A的第一个请求报文到达了B，B就会发送确认给A，此时A知道已经连接完了不搭理B，但B还会傻傻的等着A给他发消息，这就浪费了很多资源。</p><hr><h3 id="8-2-连接释放"><a href="#8-2-连接释放" class="headerlink" title="8.2 连接释放"></a>8.2 连接释放</h3><p>四次挥手</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417200113.png"></p><ul><li>FIN不携带数据，但是消耗序号</li><li>ACK不携带数据不消耗序号，携带消耗</li></ul><p>MSL叫做<strong>最长报文段寿命</strong>，为什么time-wait状态后要有2MSL等待时间呢？</p><p>1.因为B再发送完FIN-ACK确认报文后还在等着A发送确认，而A的最后一个确认报文可能会丢失，丢失了B收不到确认就会发送重传，此时如果没有2MSL时间A直接结束了连接，B就会一直发确认，资源浪费</p><p>2.就是上边提到的A重复发送连接请求，第一个请求延迟到达了的情况，有了2MSL就能使本连接持续时间内产生的所有报文段都从网络中消失</p><p><strong>保活计时器</strong>：有时候建立连接后客户端突然挂掉，这是服务器就会一直等着，所以要有这个保活计时器，服务器没收到一次数据就重置保活计时器，时间大约2小时，2小时没有新的数据，服务器就发送一个探测报文段，每75s发送一次，连续10次无反应服务器就关闭连接</p><hr><h3 id="8-3-TCP状态机"><a href="#8-3-TCP状态机" class="headerlink" title="8.3 TCP状态机"></a>8.3 TCP状态机</h3><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417201411.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–运输层&quot;&gt;&lt;a href=&quot;#计算机网络–运输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–运输层&quot;&gt;&lt;/a&gt;计算机网络–运输层&lt;/h1&gt;&lt;h2 id=&quot;1-运输层基本概念&quot;&gt;&lt;a href=&quot;#1-运输层基本概念&quot; class</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--网络层</title>
    <link href="http://icecorn.github.io/2022/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2022-02-13T08:53:09.000Z</published>
    <updated>2022-06-29T10:20:16.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–网络层"><a href="#计算机网络–网络层" class="headerlink" title="计算机网络–网络层"></a>计算机网络–网络层</h1><h2 id="1-网络层的两种服务形式"><a href="#1-网络层的两种服务形式" class="headerlink" title="1 网络层的两种服务形式"></a>1 网络层的两种服务形式</h2><p>一种是虚电路服务，另一种是数据报服务，虚电路面向连接的通信方式，在分组交换中建立一条虚电路来预留通信双方所需的一切网络资源，这样在网络层实现可靠传输。数据报服务是采用分组传输方式，网络层向上只提供简单的，无连接的，尽最大努力的不可靠传输。</p><p>本质是是否要在网络层实现可靠传输的问题，由于现在的终端相比于过去的电话设备具有更强的处理能力，所以现在数据报服务成为主流，将可靠传输的实现上移到传输层和用户主机由TCP处理。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414104232.png" alt="两种服务"></p><table><thead><tr><th>对比</th><th>虚电路</th><th>数据报</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信由网络层保证</td><td>可靠通信由用户主机保证</td></tr><tr><td>连接建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在建立连接时使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组转发</td><td>同一条虚电路分组由同一路由器转发</td><td>每个分组独立选择路由器转发</td></tr><tr><td>结点故障</td><td>所有通过故障结点的虚电路均不能工作</td><td>出故障结点可能会丢失分组，但可以选择其他路由器发送分组</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点不一定按先后顺序</td></tr><tr><td>端到端差错处理及流量控制</td><td>可以由网络负责也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><hr><h2 id="2-网际协议IP"><a href="#2-网际协议IP" class="headerlink" title="2 网际协议IP"></a>2 网际协议IP</h2><p>IP协议是很重要的协议，它也是一族协议</p><p>除了IP协议外还有与之配套的</p><ul><li>地址解析协议 ARP</li><li>网际控制报文协议 ICMP</li><li>网际组管理协议 IGMP</li></ul><p>要把世界上数以万计的网络连接起来是非常复杂的，并且没有一种网络能够满足所有用户的需求。所以，在网络层使用IP协议构成一个虚拟互连网络，也就是说对于ip协议的网络层，下边的数据链路层和物理层是透明的。</p><hr><h3 id="2-1-分类的IP地址"><a href="#2-1-分类的IP地址" class="headerlink" title="2.1 分类的IP地址"></a>2.1 分类的IP地址</h3><p>IP地址就是给互联网上每一台主机或路由器分配一个全世界范围内唯一的32位的标识符，这里只研究IPv4。</p><p>IP地址的编码方式经历了三个阶段：</p><ul><li>分类的IP地址</li><li>划分子网</li><li>构成超网</li></ul><p>本节研究分类的IP地址，就是将IP地址划分为若干个固定类，每一类地址由两个固定长度字段组成，第一个字段是<strong>网络号</strong>，第二个阻断是<strong>主机号</strong>，全网唯一</p><p>分为以下几类：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414152321.png" alt="IP地址分类"></p><ul><li>其中A B C类都是单播地址（1对1）</li><li>A B C类地址网络号分别为1,2,3字节，且网络号前边类别位分别为0,10,110</li><li>D类地址是多播地址，类别位1110</li><li>E类地址目前不使用</li></ul><p>采用点分十进制来记录IP，如128.0.0.1</p><hr><p>常见的三类IP地址</p><p>对于A B C类IP地址来说，都有几个不能指派的网络号和主机号</p><p>对A类地址，网络号全0不能指派，用来表示“此网络”，全1也不能指派，用来表示“环回测试”；主机号全0表示“本主机”，全1表示“所有主机”</p><p>对B类和C类地址，因为网络号有类别码10和110故不存在全0全1，但去除掉类别码后的网络号也不能设置为全0，表示的意义和A类一样；主机号也不能全0全1</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414160355.png" alt="一般不使用的特殊IP地址"></p><hr><p>IP地址特点：</p><ul><li>由网络号+主机号组成，分配时只分配网络号，主机号由单位自行分配。另一个好处是路由器转发时可以根据网络号转发分组，减少路由表存储空间</li><li>实际上IP地址标志一台主机和一条链路的接口，这意味着路由器两端连接两个网络就必然拥有两个IP地址，而连接两个网络的主机叫做多归属主机</li><li>一个网络通常是指网络号相同的网络，所以用转发器和网桥连接起来的局域网通常认为是一个网络</li><li>IP地址中，所有分配到网络号的网络都是平等的</li></ul><hr><h3 id="2-2-IP地址和硬件地址"><a href="#2-2-IP地址和硬件地址" class="headerlink" title="2.2 IP地址和硬件地址"></a>2.2 IP地址和硬件地址</h3><p>IP地址是逻辑地址，封装在IP数据报首部</p><p>硬件地址是物理地址，存放在适配器ROM中，封装在MAC帧首部</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414162049.png" alt="IP地址和硬件地址"></p><p>这里只要记住通信时网络层，数据链路层同一层级的传输都是透明的，即不需要考虑封装帧，解析帧之类的。可以理解为网络层直接传送IP数据报，数据链路层只传送MAC帧。</p><p>那么有一个问题是路由器转发IP数据报需要包装成MAC帧格式在数据链路层传输，怎么才能知道要添加的MAC地址是多少呢？换句话说怎样通过目的IP得到目的MAC地址？这就需要使用ARP地址解析协议了。</p><hr><h3 id="2-3-地址解析协议ARP"><a href="#2-3-地址解析协议ARP" class="headerlink" title="2.3 地址解析协议ARP"></a>2.3 地址解析协议ARP</h3><p>主要作用就是根据目的IP地址找出目的MAC地址，实现方法是在每一个主机都设有一个ARP高速缓存，里边保存<strong>本局域网</strong>上各主机和路由器的IP地址到MAC地址映射表。主机A要向B发送IP数据报时，先去高速缓存查找B的映射，如果有直接就找到了，没有的话就要运行ARP根据以下步骤找到B的MAC地址。</p><ol><li>ARP进程在本局域网上广播一个ARP请求分组，主要内容是“我的IP地址是xxx。MAC地址是xxx，我想知道IP地址是XXX的主机的硬件地址”</li><li>本局域网上所有主机的ARP进程都收到消息</li><li>主机B发现A要找的人是自己，，向A发送一个响应分组（注意这里是单播） 内容是“我的IP地址是XXX，我的MAC地址是XXX”，同时把A的映射记录在自己的高速缓存中（这一步是为了以后B向A发消息方便），非B的其他主机当然对A发送的请求分组不理睬</li><li>A收到B的响应，将B的映射记录在高速缓存中</li></ol><p>总结就是一个喊话（广播）找人的过程，且找人必须要先自报家门让别人可以响应，喊道谁的名字谁就答应（单播），并且互相都把对方的映射记录了下来，<strong>这就方便了之后再进行通信，否则每次都要广播喊话再响应浪费资源</strong>。</p><p>另外，ARP高速缓存每一份映射都要设置生存时间（如10~20分钟），这是因为适配器可能会故障，比如B的适配器坏了，MAC地址失效了，A用失效的MAC地址也找不到B，留着没用还浪费资源，所以定期删除重新广播建立联系，确保不会有“死掉”的映射浪费资源</p><p>这里有一个最重要的点就是<strong>ARP协议是运行在同一个局域网上</strong>的，如果如下图H1要向不在同一个局域网的H4发送消息，那么首先ARP协议会找到路由器R1的MAC地址，A将MAC帧封装的IP数据报发给R1，接下来交给R1来找下一跳的路由器R2，再次运次ARP协议找到和R1同属一个网络的路由器R2的MAC地址，如此反复进行ARP解析。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414165140.png" alt="ARP解析"></p><p>那么有一个问题是既然最后在链路上传送的帧最终都是要用MAC地址送出，为什么还要用抽象的IP地址而不直接用MAC地址呢？</p><p>这是因为全世界有各种不同的网络和设备，就有不同的硬件地址，要使这些异构网络通信就必须进行复杂的硬件地址转接工作，而使用IP地址将这些差异屏蔽掉，给用户就带来了极大的方便，对于用户来说只要关注IP地址就好了，反正ARP是自动运行的，对于用户是透明的。</p><hr><h3 id="2-4-IP数据报格式"><a href="#2-4-IP数据报格式" class="headerlink" title="2.4 IP数据报格式"></a>2.4 IP数据报格式</h3><p>这里介绍IPv4，在TCP/IP中，各种数据报格式常常以32位（4字节）为单位来描述。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414165738.png" alt="IP数据报格式"></p><p>IP数据报由首部+数据部分组成，首部前一部分固定长度20字节，后边还有一些可选字段（一般不用，用了必须是4字节的倍数）</p><ul><li>版本 占4位，是指IPv4或IPv6</li><li>首部长度  4位，这里必须要注意的是首部长度表示数的单位是32位（4字节，意思是首部长度是数字1实际上代表4字节），最小必须要20字节（也就是十进制5，二进制0101），最大为60字节（因为只占4位，二进制最大1111，相当于十进制15）</li><li>区分服务  8位，一般不用这个字段</li><li>总长度  16位，单位为字节。最大长度是2的16次幂-1 = 65535字节，实际一般不会这么长。这个总长度指的是<strong>首部+数据部分</strong>。这是因为总程度不能大于数据链路层的最大传送单元MTU，一般MTU = 1500，超过就要进行分片处理。<strong>分片后总长度指的是每一片的首部+数据部分</strong>     另外，大部分路由器必须能够接受长度不超过576的IP数据报，至于支不支持1500的根据路由器而定</li><li>标识  16位，这个字段是每产生一个数据报，计数器+1，将这个数写入标识符。<strong>主要作用是分片后的每一片都是这个标识，接受端根据这个标识把每一片拼在一起</strong></li><li>标志  3位  只有前两位有意义，最低位MF（1代表后边还有分片，0标识没了）；中间位DF（1代表不允许分片，0才允许分片）</li><li>片偏移  13位  分片后每一片在原数据中的位置，意思是代表这片是从原数据何处开始的。片偏移以8个字节为偏移单位，每个分片长度一定是8的整数倍，具体结合问题去看</li><li>生存时间  8位  TTL  现在一般代表跳数，最大值为255，意味着跳了255次路由器就会把它扔掉</li><li>协议  8位  指出数据报携带的数据使用哪种协议，上交给谁。常见的有TCP  UDP  ICMP  IGMP  IP等等</li><li>首部校验和  16位  <strong>只检验首部，不包括数据部分</strong> 。这是因为每经过一个路由器可能分片信息之类的会发生变化，需要校验。不用复杂的CRC算法，使用16位反码相加的方法，具体参考书本</li><li>源地址 32位</li><li>目的地址  32位</li></ul><p>首部可变部分：这里可以添加很多字段支持排错，安全等但是一般不用，<strong>只要记住如果使用必须要填充字节变成4的倍数</strong></p><hr><h3 id="2-5-IP层分组转发流程"><a href="#2-5-IP层分组转发流程" class="headerlink" title="2.5 IP层分组转发流程"></a>2.5 IP层分组转发流程</h3><p>在IP层进行分组转发，主要是根据路由器中的转发表来进行转发，本节不介绍路由器中的转发表是怎么生成和更新的，放在后边处理。</p><p>这里要注意的是每个路由器连接几个子网，并且每个子网都有若干台主机，都记录路由转发表的话数据量过多，所以路由器转发是根据网段（网络号）来转发的，并且从源地址到目的地址不是一蹴而就的（不能从开始就知道整条路径），而是进行若干个下一跳达到终点。</p><p>每条路由最主要的两个信息（目的网络地址，下一跳地址）</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414180341.png" alt="路由转发"></p><p>特定路由： 目的网络地址可以设置一个特定的路由器，直接转发到该路由器即可</p><p>默认路由：  是指路由表中没有指定跳到哪个路由器时直接转发给默认路由器进行处理（路由表中记为0.0.0.0）</p><p><strong>分组转发算法：</strong></p><ol><li>从数据报首部提取目的主机的IP地址D，得出网络地址N</li><li>若N是与此路由器直连的某个地址，则<strong>直接交付</strong> ，不需要经过别的路由器（当然这里必须使用ARP协议解析出目的主机MAC地址，封装后传输，但是研究网络层时看成透明的即可）；否则进行<strong>间接交付</strong> ，执行3</li><li>若路由表中有目的地址为D的<strong>特定路由</strong>，则跳到特定路由</li><li>若路由表中有到网络N的路由，进行下一跳即可</li><li>若都没有，而路由表中有一个<strong>默认路由</strong>，则跳到默认路由，都没有执行6</li><li>报告分组转发出错</li></ol><hr><h2 id="3-划分子网和构成超网"><a href="#3-划分子网和构成超网" class="headerlink" title="3 划分子网和构成超网"></a>3 划分子网和构成超网</h2><h3 id="3-1-划分子网"><a href="#3-1-划分子网" class="headerlink" title="3.1 划分子网"></a>3.1 划分子网</h3><p>本质是拥有许多物理网络的单位，将所属的物理网络划分为若干个<strong>子网</strong>，但是对外表现仍然是一个网络。</p><p>IP地址 = 网络号 + 子网号 + 主机号</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414182543.png" alt="划分子网"></p><p>外部路由器还是按网络号145.13.0.0找到R1，R1对内分为145.13.3.0,145.13.7.-，145.13.21.0三个子网进行转发</p><p>划分子网知识把IP地址主机号这部分再划分一下</p><hr><p>子网掩码：由连续的1和连续的0构成的32位数据</p><p>因为IP首部没有标识子网信息的位置，所以使用子网掩码来解决，每一个路由器的路由表中都要配置一项子网掩码。使用时将目的IP地址和子网掩码<strong>按位与</strong>运算得到子网的网络号，再进行传输。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414183430.png" alt="子网掩码运算"></p><p>要注意的是即使没有划分子网，单使用A B C类划分地址也要有默认的子网掩码</p><p><strong>路由器在交换路由表时，要把自己所连接的子网和对应的子网掩码同时发送交换</strong></p><p>划分子网的目的是增加灵活性，看需求分配主机数不同的子网掩码</p><hr><p>划分子网后路由表必须有三项内容： 目的网络地址，子网掩码，下一跳地址</p><p>分组转发比不划分子网的情况多了用子网掩码按位与操作</p><hr><h3 id="3-2-构成超网（无分类编址CIDR）"><a href="#3-2-构成超网（无分类编址CIDR）" class="headerlink" title="3.2 构成超网（无分类编址CIDR）"></a>3.2 构成超网（无分类编址CIDR）</h3><p>为了应对B类地址即将用完，互联网路由表项目急速增长，IPv4地址空间将要耗尽等问题，提出了无分类域间路由选择CIDR</p><p>取消了分类地址和划分子网，采用网络前缀和主机号两级编址方式</p><p>IP地址 = 网络前缀+主机号</p><p>记为形如10.0.0.0/10  或者 00001010 00*（ *后边是主机号）</p><p>代表前10位是网络前缀，后22位是主机号</p><p>CIDR的好处主要有两个：</p><ul><li>增加了IP地址的数量</li><li>形成地址聚合，从而减少路由表中的条目</li></ul><hr><p>最长前缀匹配：</p><p>使用CIDR，路由表的每个项目由<strong>网络前缀</strong>和<strong>下一跳地址</strong>来组成，而由于地址聚合的性质，同一个目的IP地址在路由表中匹配不同的CIDR可能都符合，这时就要选择匹配成功中的最长前缀的下一跳地址来转发（因为短的包含长的，换句换说长的CIDR是短的精细再分配后的）</p><hr><p>二叉线索查找：</p><p>由于采用最长前缀匹配，那么最长采用的方法就是遍历路由表来找到最长前缀匹配，但过于浪费时间和资源，所以诞生了二叉线索查找的方法更快的找出目的前缀，具体算法参考教材</p><hr><h2 id="4-网际控制报文协议ICMP"><a href="#4-网际控制报文协议ICMP" class="headerlink" title="4 网际控制报文协议ICMP"></a>4 网际控制报文协议ICMP</h2><p>ICMP协议是IP协议族中的，不是高层协议，因为ICMP的报文是装在IP数据报中的，作为数据部分。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414212811.png" alt="ICMP报文格式"></p><p>类型字段代表协议类型，代码字段细分类型中的具体情况，<strong>校验和保证ICMP报文（即IP数据报数据部分）正确，还记得IP报文首部校验和只计算IP首部不计算IP数据部分吧</strong></p><hr><h3 id="4-1-ICMP报文种类"><a href="#4-1-ICMP报文种类" class="headerlink" title="4.1 ICMP报文种类"></a>4.1 ICMP报文种类</h3><p>种类有两种： <strong>ICMP差错报告报文</strong>    <strong>ICMP询问报文</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414213302.png" alt="常见ICMP报文类型"></p><p><strong>ICMP差错报告报文</strong>主要有四种：</p><ul><li>终点不可达</li><li>时间超过：还记得IP首部生存时间字段吧，TTL为0时丢弃该IP数据报并向源点发送此条ICMP报文</li><li>参数问题：收到的数据报首部有字段值不正确发送</li><li>改变路由（重定向）：主要是默认路由器找到更优秀的线路时发送</li></ul><p>ICMP差错报文格式如下，将要发送差错的IP数据报的首部和紧跟着的8字节（这里是端口号，为上层TCP UDP服务的）拼上ICMP前8字节（差错类型）组成ICMP差错报文发送</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414214603.png" alt="ICMP差错报文格式"></p><p>不该发送ICMP差错报文情况：</p><ul><li>对ICMP差错报文，不再发送ICMP差错报文</li><li>对第一个分片数据报的后续分片不发送</li><li>对多播的数据报不发送</li><li>对特殊地址127.0.0.0/0.0.0.0（环回测试）不发送</li></ul><hr><p><strong>ICMP询问报文</strong>：</p><ul><li>回送请求和回答：测试目的站状态</li><li>时间戳请求和回答：用于时钟同步和时间测量</li></ul><hr><h3 id="4-2-ICMP应用举例"><a href="#4-2-ICMP应用举例" class="headerlink" title="4.2 ICMP应用举例"></a>4.2 ICMP应用举例</h3><p><strong>分组网间探测PING</strong>，测试主机间连通性，PING使用了ICMP询问报文中的回送请求和回答。<strong>注意PING应用是应用层直接使用网络层ICMP协议的一个典型例子，没有通过运输层的TCP或UDP</strong></p><hr><p>traceroute应用，用来跟踪一个分组从源点到终点的路径</p><p>原理是源主机向终点发送一串<strong>IP数据报</strong>，数据报中封装的是无法交付的<strong>UDP用户数据报</strong>。第一个数据报的<strong>TTL</strong>设为1，第二个设为2等等。这样第一个数据报到达路径上第一个路由器R1，TTL变成0，于是R1将第一个数据报丢弃同时向源站发送<strong>ICMP时间超过报文</strong>。同理我们得到第二个路由器R2发回来的<strong>ICMP时间超时报文</strong>等等。当有一个数据报成功到达终点时，又因为UDP用户数据报无法被接受，于是终点会向源点发送<strong>ICMP终点不可达报文</strong>，这样就得到了源点到终点的整条路径。</p><hr><h2 id="5-互联网路由选择协议"><a href="#5-互联网路由选择协议" class="headerlink" title="5 互联网路由选择协议"></a>5 互联网路由选择协议</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>路由选择协议就是讨论路由表中的路由是怎样得出的</p><p>理想的路由算法：</p><ul><li>算法必须是正确的和完整的</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑变化（自适应性，更新路由表）</li><li>稳定性（一段时间内端到端基本保持一条路径）</li><li>公平性（照顾到所有用户）</li><li>能够找出最佳的路径</li></ul><p>从能否适应通信量和网络拓扑变化来划分为两大类：</p><ul><li>静态路由选择策略（非自适应）</li><li>动态路由选择策略</li></ul><hr><p>互联网采用的都是动态的，分布式的路由选择协议</p><p>可以将整个互联网划分成若干个自治系统AS，比如一个大ISP，在这个基础上分为两大类：</p><ul><li>内部网关协议IGP：  研究的是在一个AS中用的什么路由选择协议，主要有RIP和OSPF协议。这种路由选择也叫域内路由选择</li><li>外部网关协议EPG：  研究的是不同AS间主机通信的路由选择，主要用BGP-4协议。这种路由选择也叫域间路由选择</li></ul><p>每个AS内自主决定用什么IGP，而在每个AS的边界都要有一个或者几个路由器不仅运行IGP还要运行EPG实现系统外通信</p><hr><h3 id="5-2-内部网关协议RIP"><a href="#5-2-内部网关协议RIP" class="headerlink" title="5.2 内部网关协议RIP"></a>5.2 内部网关协议RIP</h3><p>RIP是一种<strong>基于距离向量</strong>的路由选择协议，优点是简单</p><p><strong>可以把使用RIP协议的所有路由器想象成一张图，那么距离就是图中顶点到顶点的距离，并且RIP实际上最求的就是最短距离参考，实际上路由表中维护的就是图中每个顶点到其他顶点的最短路径</strong></p><p>RIP将直连的两个路由器距离向量记为1（当然也可以记作0），同时RIP允许一条路径上最多包含15个路由器，因此距离16相当于不可达，这代表<strong>RIP只适用于小型互联网</strong></p><p>不管是RIP还是OSPF都是动态分布式协议，我们要注意三个问题，<strong>和那些路由器交换信息？</strong>  <strong>交换什么信息？</strong>  <strong>什么时候交换信息？</strong></p><p>RIP协议特点：</p><ul><li>只和相邻路由器交换信息</li><li>交换全部的信息，即整个路由表</li><li>按固定时间间隔交换（30s）或者网络拓扑发生变化</li></ul><hr><p>距离向量算法：用相邻路由发来的信息更新自己的路由表，做个例题很容易理解</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414223831.png" alt="R6更新R4发来的信息"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414223952.png" alt="解答"></p><hr><p>RIP报文格式：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414224635.png" alt="RIP报文格式"></p><p>主要掌握RIP协议使用<strong>UDP用户数据报</strong>进行传送</p><p>RIP有一个特点是<strong>好消息传播的快，坏消息传播的慢</strong></p><p>这个主要是指R1连接的网1故障了，却收到R2之前记录的信息，从而在R1R2之间反复横跳，直到都变成16不可达，具体查看教材</p><h3 id="5-3-内部网关协议OSPF"><a href="#5-3-内部网关协议OSPF" class="headerlink" title="5.3 内部网关协议OSPF"></a>5.3 内部网关协议OSPF</h3><p>OSPF（开放最短路径优先，因为使用了dijkstra算法）是使用分布式的<strong>链路状态协议</strong></p><p>特点：</p><ul><li>向AS中<strong>所有路由器</strong>发送信息，采用<strong>洪泛法</strong></li><li>发送的信息是与本路由器<strong>相邻的所有路由器的链路状态</strong>以及<strong>代价</strong>（带宽，时延之类的）</li><li>只有<strong>链路状态发生变化</strong>时，才发送信息</li></ul><p>通过这种方式最终所有路由器都能建立一个<strong>链路状态数据库</strong>，实际上就是<strong>全网的拓扑结构图</strong>，在全网是<strong>一致的</strong>。这样每个路由器根据这个数据库生成自己的路由表</p><p>OSPF可以支持很多的路由器接入，为了方便管理将AS划分成一些小的区域，每个区域内路由器数目最好小于200个</p><hr><p>OSPF<strong>直接用IP数据报传送</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414232323.png" alt="OSPF报文格式"></p><p>其他优点：</p><ul><li>建立路径时允许计算代价而不是单单看最短路径</li><li>负载平衡（几条相同代价的线路平均分配通信量）</li></ul><hr><p>OSPF有五种分组类型：</p><p>问候分组，数据库描述分组，链路请求分组，链路状态更新，链路状态确认</p><p>OSPF规定每隔10s相邻站点发送问候分组确定有没有站点挂掉，超过40s没有回应，则用剩下4种分组进行更新操作，更新时采用<strong>可靠的洪泛法</strong></p><hr><h3 id="5-4-外部网关协议BGP"><a href="#5-4-外部网关协议BGP" class="headerlink" title="5.4 外部网关协议BGP"></a>5.4 外部网关协议BGP</h3><p>解决不同AS之间的路由选择问题</p><p>BGP采用<strong>路径向量</strong>路由选择协议，每个AS至少选择一个<strong>BGP发言人</strong>，一般是边界路由器，但也可以不是</p><p>需要知道的是BGP发言人之间<strong>通过建立TCP连接</strong>来交换信息，在主干网上发出生命，例如BGP1：“到达N1可以经过AS1”</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414234412.png" alt="BGP报文格式"></p><hr><h2 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6 IPv6"></a>6 IPv6</h2><p>相比IPv4主要变化：</p><ul><li>更大的地址空间：128位</li><li>首部固定为40字节</li><li>扩展的地址层次结构：空间大，可划分层次多</li><li>灵活的首部格式：IPv6精简了首部字段，并且在数据部分支持各种扩展首部</li><li>改进的选项：允许在数据部分增加控制信息</li><li>允许协议继续扩充</li><li>支持即插即用（自动配置）：IPv6不需要DHCP</li><li>支持资源预分配</li><li>首部改为8字节对齐，IPv4是4字节对齐</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414235650.png" alt="IPv6数据报一般形式"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414235738.png" alt="IPv6首部字段"></p><ul><li>版本： 4位，指明IPv6</li><li>通信量类：  8位，为了区分不同的IPv6数据报的类别或优先级</li><li>流标号：  20位，主要视为流媒体进行资源预分配</li><li>有效载荷长度：  16位，指明数据报除了基本首部的字节数，最大值65535字节</li><li>下一个首部：  8位，可选字段，标识下一个扩展首部的类型</li><li>跳数限制：  8位，就是TTL改个名</li><li>源地址：  128位</li><li>目的地址：  128位</li></ul><p><strong>数据报途中经过的路由器都不处理扩展首部，大大提高了路由器处理效率</strong></p><hr><p>IPv6数据报的目的地址可以是三种类型：</p><ul><li>单播  同ipv4</li><li>多播  同ipv4，ipv6认为广播时特殊的多播</li><li>任播  终点是一组计算机，但只交付其中的一个，通常是最近的</li></ul><hr><p>IPv6使用<strong>冒号十六进制记法</strong></p><p>68E6:8C33:FFFF:FFFF:0:DF34:2376:FFFF</p><p>中间的0可以压缩： </p><p>FF05::B3</p><p>还可以结合点分十进制法表示之前的ipv4地址：</p><p>::128.0.0.1</p><p>CIDR也可以使用：</p><p>12AB:0:0:CD30::/60</p><hr><p>IPv4向IPv6过渡</p><p>两种方法，<strong>双协议栈</strong>    <strong>隧道技术</strong></p><ul><li>双协议栈：将一部分的主机/路由器同时支持两种协议，不支持的网络通过<strong>转换首部</strong>来实现通信，当然不可避免会丢失一些字段</li><li>隧道技术：原理是在经过ipv4网络时，将ipv6数据报文整个封装进ipv4数据报里，出了ipv4网络再去掉。</li></ul><hr><p>ICMPv6是IPv6支持的控制协议，比ipv4的ICMP更加复杂，并且ICMPv6将ARP和IGMP等协议都合并到一起了</p><hr><h2 id="7-IP多播"><a href="#7-IP多播" class="headerlink" title="7 IP多播"></a>7 IP多播</h2><p>多播就是一对多进行传播，需要支持多播的路由器实现。多播的标识符就是IP地址中的D类地址，用一个D类地址标识一个多播组，是<strong>尽最大努力交付的（即不保证多播组中每个主机都收到消息）</strong>，使用的是IGMP协议，故不产生ICMP差错报文</p><p>分为<strong>硬件多播</strong>和<strong>互联网多播</strong></p><p>需要使用<strong>IGMP协议</strong>（使用IP数据报传送报文，即IGMP报文构成IP数据报的数据部分）和<strong>多播路由选择协议</strong>，具体查看教材</p><hr><h2 id="8-虚拟专用网VPN"><a href="#8-虚拟专用网VPN" class="headerlink" title="8 虚拟专用网VPN"></a>8 虚拟专用网VPN</h2><p>实际上一个部门内不是所有的主机都要接入互联网，给这些主机分配全球唯一IP是一种浪费，这时只给这些主机分配本地地址就可以</p><p>所以规定了一些<strong>专用地址</strong>（可重用地址），这些地址只能作为<strong>本地地址</strong>不能作为<strong>全球地址</strong></p><p>由这些专用地址组成的网络叫做<strong>专用网</strong>，假定一个部门在两地拥有两个专用A和B，AB通信的话就要使用公用的互联网作为专用网间的通信载体，这种专用网叫做<strong>虚拟专用网VPN</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415004337.png" alt="隧道技术实现虚拟专用网"></p><hr><h2 id="9-网络地址转换NAT"><a href="#9-网络地址转换NAT" class="headerlink" title="9 网络地址转换NAT"></a>9 网络地址转换NAT</h2><p>如果专用网内的主机已经分配了本地IP地址，但是又想和互联网连接，这时就要用到网络地址转换NAT了</p><p>方法是将专用网连接到互联网的路由器装上NAT插件，这样的路由器叫<strong>NAT路由器</strong>，它必须有至少一个全球IP地址</p><p>主机A发送数据报时，NAT路由器将数据报中的本地IP地址转换成全球IP地址用于通信，接收到目的服务器响应后将收到数据报中的全球IP地址转换成主机A的本地IP地址</p><p>同一时刻有几个全球IP地址就可以有几个专用网主机与外界通信</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415005114.png" alt="NAT路由器工作原理"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415005331.png" alt="NAT地址转换表"></p><p>也可以加上端口号，这样就可以实现不同端口访问不同的外界服务器。这时一个全球IP地址就可以分配不同的端口给不同专用网内主机使用了。这样的NAT较做<strong>网络地址与端口号转换NAPT</strong></p><hr><h2 id="10-多协议标记交换MPLS"><a href="#10-多协议标记交换MPLS" class="headerlink" title="10 多协议标记交换MPLS"></a>10 多协议标记交换MPLS</h2><p>一种新的面向连接的协议，看书吧QAQ</p><p>特点：</p><ul><li>支持面向连接的服务质量</li><li>支持流量工程，平衡网络负载</li><li>有效地支持虚拟专用网VPN</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–网络层&quot;&gt;&lt;a href=&quot;#计算机网络–网络层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–网络层&quot;&gt;&lt;/a&gt;计算机网络–网络层&lt;/h1&gt;&lt;h2 id=&quot;1-网络层的两种服务形式&quot;&gt;&lt;a href=&quot;#1-网络层的两种服务形式&quot;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--数据链路层</title>
    <link href="http://icecorn.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-02-11T09:25:10.000Z</published>
    <updated>2022-06-29T10:19:25.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–数据链路层"><a href="#计算机网络–数据链路层" class="headerlink" title="计算机网络–数据链路层"></a>计算机网络–数据链路层</h1><p>数据链路层主要研究的是同一个局域网中，数据分组怎样从一台主机传送到另一台主机，不经过路由器的转发。局域网虽然是网络但不放在网络层来研究，因为网络层主要是研究多个网络之间的互连。</p><p>数据链路层使用的信道有两种类型： 点对点信道      广播信道</p><hr><h2 id="1-点对点信道的数据链路层"><a href="#1-点对点信道的数据链路层" class="headerlink" title="1 点对点信道的数据链路层"></a>1 点对点信道的数据链路层</h2><h3 id="1-1-数据链路和帧"><a href="#1-1-数据链路和帧" class="headerlink" title="1.1 数据链路和帧"></a>1.1 数据链路和帧</h3><p><strong>链路</strong>：  链路是从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有其他的交换节点。（物理链路）</p><p><strong>数据链路</strong>：  传送数据时，还需要必要的通信协议来控制数据的传输，吧实现这些协议的硬件和软件加到链路上就构成了数据链路。（逻辑链路）</p><p><strong>帧</strong>：  数据链路层的协议数据单元  PDU</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413164754.png" alt="点对点信道传输模型"></p><p>主机A将IP数据报封装成帧→A发送帧给B→B去掉帧头帧尾取出IP数据报</p><p>另外，对于数据链路层，不需要考虑物理层，即物理层是透明的。</p><hr><h3 id="1-2-三个基本问题"><a href="#1-2-三个基本问题" class="headerlink" title="1.2 三个基本问题"></a>1.2 三个基本问题</h3><p>对于数据链路层有不同种协议，但都要实现三个基本的问题。分别是封装成帧，透明传输，差错检测。</p><ul><li>封装成帧</li></ul><p>将IP数据报加上帧头和帧尾构成帧，首部和尾部的重要作用是<strong>帧定界</strong>。</p><p>为了提高传输效率，帧的数据部分应尽可能大于首部和尾部。</p><p>帧的<strong>数据部分长度上限</strong>——<strong>最大传送单元MTU</strong></p><p>帧定界使用特殊的帧定符：</p><p>帧开始符SOH（start of head） 十六进制编码01（二进制00000001）</p><p>帧结束符EOT（end of transmission） 十六进制编码04（二进制00000100）</p><ul><li>透明传输</li></ul><p>主要目的是防止传输的文件中含有和控制字符SOH或EOT相同的二进制bit导致接收方解析帧错误。</p><p>解决方案是在传输数据中出现的SOH或EOT前面加上一个转义字符ESC（十六进制编码1B，二进制00011011）。如果转义字符也出现在数据当中，那么就在ESC前再加一个ESC，接收端解析时会自动去掉前边一个，这种方法叫做字节填充或字符填充。</p><ul><li>差错检验</li></ul><p>通信链路会因干扰导致比特差错，即0变成1之类。为了保证传输可靠性，我们使用循环冗余检验CRC。</p><p>具体的CRC方法参考课本例题，需要知道的是CRC差错检验仅仅保证无比特差错，但这并不代表实现了可靠传输。因为还有另一类传输差错比如帧丢失，帧重复和帧失序等，由于成本原因这类问题不放在数据链路层解决，而由传输层的TCP协议来解决。<strong>即不要求数据链路层向上提供可靠的传输服务。</strong>这样可以提高通信效率。</p><h2 id="2-点对点ppp协议"><a href="#2-点对点ppp协议" class="headerlink" title="2 点对点ppp协议"></a>2 点对点ppp协议</h2><p>ppp协议用于用户和ISP进行通信时使用的数据链路协议</p><h3 id="2-1-ppp协议要求"><a href="#2-1-ppp协议要求" class="headerlink" title="2.1 ppp协议要求"></a>2.1 ppp协议要求</h3><ol><li>简单：  意味着不可靠，只需要进行CRC校验</li><li>封装成帧：  使用帧定界符</li><li>透明性：  字节填充ESC</li><li>多种网络层协议：  要在同一条物理链路上支持多种网络层协议（如IP和IPX），连接的局域网或路由器同理</li><li>多种类型链路：  电的，光的，交换的或非交换的链路。以太网PPPOE</li><li>差错检测：  CRC</li><li>检测连接状态：  及时检测链路故障的功能</li><li>最大传送单元：  MTU，如果超过最大长度，ppp就将帧丢弃</li><li>网络层地址协商：  提供一种机制使通信的两个网络层实体能够知道彼此的网络层地址，IP地址</li><li>数据压缩协商：  提供一种方法来协商使用数据压缩算法</li><li>PPP协议只支持全双工链路</li></ol><hr><h3 id="2-2-ppp帧格式"><a href="#2-2-ppp帧格式" class="headerlink" title="2.2 ppp帧格式"></a>2.2 ppp帧格式</h3><ul><li>字段意义</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413173932.png" alt="ppp帧格式"></p><p>首尾各一个字节标志字段F（flag，0x7E，01111110），表示帧开始和结束，连续两帧间只需要一个。连续两个标志字段代表空帧，丢弃。</p><p>首部地址字段A规定为FF，控制字段C规定为03，不能改。</p><p>首部协议字段2字节，为0x0021时表示IP数据报，0xC021表示ppp链路控制协议LCP数据，0x8021表示网络层的控制数据。</p><p>尾部FCS是CRC的帧检验序列、</p><p>信息部分最大1500字节</p><hr><ul><li>字节填充</li></ul><p>和上文中字节填充一样，ppp选用转义字符为0x7D(01111101)</p><p>信息字段出现 0x7E 变成 0x7D 0x5E</p><p>信息字段出现 0x7D变成 0x7D 0x5D</p><p>信息字段出现ASCII码的控制字符（即数值小于0x20的字符）如0x23变成 0x7D 0x23</p><hr><ul><li>零比特填充</li></ul><p>另一种实现透明传输的方法，适用于同步传输（一连串的比特连续发送）</p><p>具体方法是发现有5个连续的1，立刻填入一个0，因此可以保证信息字段不会出现连续的6个1（因为7E的二进制01111110），接收端发现连续的5个1时把后边的0去掉即可实现透明传输</p><hr><h3 id="2-3-ppp协议的工作状态"><a href="#2-3-ppp协议的工作状态" class="headerlink" title="2.3 ppp协议的工作状态"></a>2.3 ppp协议的工作状态</h3><p>简单的说就是用户点击拨号上网，此时调制解调器发出载波信号被路由器监听到，建立了一条物理连接。然后用户电脑向ISP发送链路控制协议LCP分组（封装成多个ppp帧），配置了一些参数建立LCP连接。之后进行网络层配置，网络控制协议给用户电脑分配一个临时的IP地址，实现通信。通信结束后，NCP释放网络层连接，收回IP地址，LCP释放数据链路层连接，最后释放物理层连接。</p><p>几个状态：</p><ul><li>链路静止：  这是用户电脑和ISP路由器间无物理连接</li><li>链路建立：  拨号后，建立物理连接后进入该状态，目的建立LCP连接</li><li>鉴别：  建立LCP连接后进入该状态，发送鉴别协议分组等待鉴别</li><li>网络层协议：  ppp协议两端的网络层协商所使用的网络层配置</li><li>链路打开：  此时可以正常通信</li><li>链路终止：出现故障或鉴定错误等问题时跳变的状态</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413181656.png" alt="ppp协议状态图"></p><hr><h2 id="3-广播信道的数据链路层"><a href="#3-广播信道的数据链路层" class="headerlink" title="3 广播信道的数据链路层"></a>3 广播信道的数据链路层</h2><h3 id="3-1-局域网的数据链路层"><a href="#3-1-局域网的数据链路层" class="headerlink" title="3.1 局域网的数据链路层"></a>3.1 局域网的数据链路层</h3><p>局域网优点：</p><ul><li>具有广播功能，局域网内主机共享各种硬件软件资源</li><li>便于系统的扩展和逐渐演变，设备位置灵活调整改变</li><li>提高系统的可靠性，可用性，生存性</li></ul><hr><p>按网络拓扑分类：</p><p>星型网，环型网，总线网</p><hr><p>为保证众多用户共享媒体资源，采用两种技术方法</p><ul><li>静态划分信道： 频分，时分，波分，码分复用等等，代价高，不适合局域网使用</li><li>动态媒体接入控制：随机接入（重点），受控接入</li></ul><hr><p>两种以太网标准：</p><p>DIX Ethernet V2标准和IEEE 802.3标准，802.3比较繁琐，所以目前主要使用的还是V2版本</p><hr><p>适配器的作用：</p><p>适配器，即是网络接口卡（NIC   网卡），其与局域网通信是通过双绞线或无线连接等传输媒体（串行传输），与计算机通信则是通过主板上的I/O总线（并行传输）。</p><p>所以网卡中须有缓存的存储芯片来协调接受或发送网络通信内容传达给CPU进行处理。且我们说的MAC地址就在适配器的ROM之中。</p><hr><h3 id="3-2-CSMA-CD协议"><a href="#3-2-CSMA-CD协议" class="headerlink" title="3.2 CSMA/CD协议"></a>3.2 CSMA/CD协议</h3><p>以太网采用随机接入，而一条总线网络同一时间只能传送一条信息，这就会导致会有信息的碰撞，CSMA/CD协议就是为了解决这个问题诞生的。</p><p>协议要点：</p><ul><li>多点接入：  说明是总线型网络，多台主机接入</li><li>载波监听：  检测信道，总线上每个站时刻不停的检测信道</li><li>碰撞检测：  边发送边监听，发送时判断有没有其他站也在发送信息，发生碰撞立刻停止发送</li></ul><p>CSMA/CD协议中的每个站不可能同时发送和接收，故只能半双工通信</p><p>把总线上单程端到端的传播时延记为T，每个站发出一个帧后最长需要经过2T时间可以知道是否发生了碰撞，故2T叫做<strong>争用期</strong>（碰撞窗口）。对于10Mbit/s的以太网，争用期时间为51.2微秒，征用期内可发送512bit，即64字节。也可以说争用期是512bit时间，用bit作为争用期的单位。</p><p>发生碰撞后以太网使用<strong>截断二进制指数退避</strong>选择重传的时机，从离散集合【0,1，…,2的k次幂-1】随机取出一个数r，等待r倍的争用期再进行重传。重传16次仍不成功，丢弃该帧，向上级反映。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413192126.png" alt="碰撞检测"></p><p><strong>重点：</strong>一种特殊情况是某个站发出了一个很短的帧，在发送完毕前没有检测到碰撞，而实际上该帧发生了碰撞并被丢弃，但发送站不知道碰撞从而不会进行重发。</p><p>为了避免这种状况，以太网规定一个最短帧长64字节，即512bit（争用期时间），不满64字节的帧要补充到64字节，所以如果收到小于64字节的帧即为错误帧，舍弃。</p><p><strong>强化碰撞：</strong>发送站发现碰撞，立刻停止发送，并且发送32bit或48bit的<strong>人为干扰信号</strong>，此举是为了让所有的站都知道现在发生了碰撞。</p><p><strong>帧间最小间隔</strong>：  以太网规定最小间隔为96bit时间。</p><hr><h3 id="3-3-以太网信道利用率"><a href="#3-3-以太网信道利用率" class="headerlink" title="3.3 以太网信道利用率"></a>3.3 以太网信道利用率</h3><p>因为会发生碰撞，所以以太网信道利用率不会是100%，T是bit端到端单程的时间，T1是帧的发送时间</p><p>a = T/T1</p><p>a越小信道利用率越高，故可采用的办法有两个，限制以太网连线的长度，适当增大以太网帧的长度</p><p>信道的利用率S = T/T+T1 = 1/1+a  </p><hr><h3 id="3-4-以太网MAC层"><a href="#3-4-以太网MAC层" class="headerlink" title="3.4 以太网MAC层"></a>3.4 以太网MAC层</h3><p>MAC地址又叫硬件地址或物理地址，是在适配器ROM中存在的具有唯一性的标识。MAC地址格式为6字节（48bit）由IEEE分配的全球唯一标识。</p><p>主机通信时，适配器使用过滤功能，主要有三种情况</p><ul><li>单播帧（一对一）：  收到帧的MAC地址与自己的相同</li><li>广播帧（一对全体）：  发送给本局域网多有站点的帧（全1地址）</li><li>多播帧（一对多）：  发送给局域网上一部分站点，需要多播协议设置，有的适配器不支持</li></ul><p><strong>MAC帧的格式：</strong></p><p>只介绍V2的帧格式：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413194806.png" alt="以太网V2MAC帧格式"></p><p>很简单前边两个字段是目的地址和源地址，类型字段用来标志数据使用的是什么协议，0x0800代表IP数据报。数据是46~1500，46是因为最小长度64-首尾18=46。尾部FCS用于CRC校验。</p><p>另外，帧的前边有8字节的前同步码，是因为MAC帧是异步传输，需要与适配器进行时钟同步，最后一个字节是帧定界符，最后的11告诉适配器接下来的就是有用的MAC帧消息了。还有个问题是，MAC帧没有长度字段怎么确定数据部分是从哪到哪呢？</p><p>这是因为以太网采用了曼彻斯特编码，具有自同步功能，当接受完全部的帧信息后，从后往前数4个字节就可以得到IP数据报的结束位置了，这也是MAC帧不需要结尾帧定界的原因。</p><hr><h3 id="3-5-以太网的扩展"><a href="#3-5-以太网的扩展" class="headerlink" title="3.5 以太网的扩展"></a>3.5 以太网的扩展</h3><ul><li>物理层</li></ul><p>物理层的以太网使用多个集线器，连接成很大范围内的以太网</p><p>好处：</p><ol><li>可以使远端计算机互相连接</li><li>扩大了以太网范围，因为集线器最大距离只有100m</li></ol><p>坏处：</p><p>   1.碰撞域也增大了，大的以太网上同一时间也只能传送一个帧</p><ol start="2"><li>不同速率的适配器不能连接在一起</li></ol><ul><li>数据链路层</li></ul><p>网桥：可以对收到的MAC帧进行转发和过滤，根据网桥中的地址表选择转发和丢弃</p><p>交换机：实质上是一个多接口的网桥，可以使多对主机同时通信，其内部的地址表不用像网桥一样配置而是通过自学习算法自主建立的。最大的优点是每个用户可以使用独自的带宽</p><p>交换机的自学习功能：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413201405.png" alt="以太网交换机"></p><p>A向B发送帧，把自己的MAC地址和接口1写入地址表，然后去地址表查有没有B的地址，有就转发，没有就向除了自己的接口1之外的其他接口<strong>广播</strong>这个帧，这是B发现和自己的MAC地址一样就接受了，C D扔掉。</p><p><strong>中心思想就是谁发帧谁登记，这样慢慢的所有主机都记录在地址表上了</strong></p><p>另外两个交互接空闲接口多的时候广播时容易发生兜圈子现象，这是就要使用生成树协议STP从逻辑上切断某些链路</p><p>总结： 集线器工作在物理层，用它连接后的网络依然还是一个网，需要使用CSMA/CD协议，且集线器只是转发电信号而已。网桥有一定的转发过滤功能，只有两个接口，网桥两边的网络可以理解为分开的网络，是全双工的不会发生碰撞。交换机是加强版的网桥，有很多接口，全双工不会发生碰撞，并且有强大的自学习算法不需要人工配置地址表。换句话说集线器连接的网络整个都是冲突域，网桥是端口两端分别为冲突域，而交换机每个端口是一个冲突域。</p><hr><h3 id="3-6-虚拟局域网"><a href="#3-6-虚拟局域网" class="headerlink" title="3.6 虚拟局域网"></a>3.6 虚拟局域网</h3><p>利用交换机实现的一种逻辑上的局域网</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413202553.png" alt="虚拟局域网"></p><p>支持虚拟局域网的以太网帧扩展：最大长度从1518字节增加到1522字节</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413202656.png" alt="802.1Q帧"></p><hr><h3 id="3-7-使用以太网进行宽带接入"><a href="#3-7-使用以太网进行宽带接入" class="headerlink" title="3.7 使用以太网进行宽带接入"></a>3.7 使用以太网进行宽带接入</h3><p>因为以太网帧格式中没有标识用户名字段的位置，所以采用pppoe（ppp over ethernet）的方法连接互联网。现在的光纤入户宽带接入都是采用这种方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–数据链路层&quot;&gt;&lt;a href=&quot;#计算机网络–数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–数据链路层&quot;&gt;&lt;/a&gt;计算机网络–数据链路层&lt;/h1&gt;&lt;p&gt;数据链路层主要研究的是同一个局域网中，数据分组怎样从一台主机传送到另</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--物理层</title>
    <link href="http://icecorn.github.io/2022/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-02-10T06:35:54.000Z</published>
    <updated>2022-06-29T09:48:26.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–物理层"><a href="#计算机网络–物理层" class="headerlink" title="计算机网络–物理层"></a>计算机网络–物理层</h1><h2 id="1-物理层的基本概念"><a href="#1-物理层的基本概念" class="headerlink" title="1. 物理层的基本概念"></a>1. 物理层的基本概念</h2><p>物理层的主要任务是尽可能的屏蔽掉不同传输媒体和通信手段的差异，使物理层之上的数据链路层使用起来是透明的。物理层的协议又叫做规程。</p><p>物理层的主要任务描述为确定与传输媒体的接口有关的一些特性：</p><ul><li>机械特性：  指明接口所用的接线器的形状，尺寸，引脚数目和排列，固定等。平时常见的各种规格的接插件都有严格的标准化规定。</li><li>电气特性：  指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：  指明某条线上出现的某一电平的电压的意义。</li><li>过程特性：  指明对于不同功能的各种可能事件的的出现顺序。</li></ul><hr><p>物理层协议：点对点，多点连接，广播连接</p><p>传输媒体：  </p><ul><li>导引型传输媒体：架空明线，双绞线，同轴电缆，光缆</li><li>非导引型传输媒体：  各种波段的无线信道，微波，卫星通信</li></ul><h2 id="2-数据通信的基础知识"><a href="#2-数据通信的基础知识" class="headerlink" title="2. 数据通信的基础知识"></a>2. 数据通信的基础知识</h2><h3 id="2-1-通信系统三部分："><a href="#2-1-通信系统三部分：" class="headerlink" title="2.1 通信系统三部分："></a>2.1 通信系统三部分：</h3><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413114817.png" alt="数据通信系统模型"></p><p>源系统： </p><ul><li>源点： 产生要传输数据的设备   如计算机产生数字比特流，又叫源站，信源</li><li>发送器：  比特流要经过发送器编码才能传输，典型发送器就是调制器，计算机使用内置的调制解调器</li></ul><p>目的系统：</p><ul><li>接收器：接受传输系统发出的信号，并转换为终端设备可处理的信号，典型接收器就是解调器，将模拟信号解调还原发送端产生的数字比特流。</li><li>终点：  从接收器获取数字比特流，显示在输出设备上，如屏幕</li></ul><p>传输系统：  可以使简单的传输线，也可以是复杂的网络系统</p><hr><p>消息：  话音，文字，图像，视频</p><p>数据：  运送消息的实体</p><p>信号：  是数据的电气或者电磁表现  分为模拟信号（连续信号）和数字信号（离散信号）两种</p><h3 id="2-2-信道的概念及极限容量"><a href="#2-2-信道的概念及极限容量" class="headerlink" title="2.2 信道的概念及极限容量"></a>2.2 信道的概念及极限容量</h3><p>信道一般表示向某一个方向传送信息的媒体，一条通信电路包括一条发送信道和一条接收信道。</p><table><thead><tr><th>通信方式</th><th>信道</th><th>举例</th></tr></thead><tbody><tr><td>单工通信</td><td>一条</td><td>无线广播</td></tr><tr><td>半双工通信</td><td>一条（正向或反向）</td><td>对讲机</td></tr><tr><td>全双工通信</td><td>两条（正反各一条）</td><td>手机</td></tr></tbody></table><p>文字图像等信源输出的信号属于基带信号，传输不便，故需要进行调制。</p><p>调制方法：</p><ul><li>基带调制：  将数字信号转换为另一种数字信号，变换后仍为基带信号，故称编码。</li><li>载波调制：  将基带信号频率调到较高的频段，转换为模拟信号，能更好的在模拟信道中传输，调制后的信号成为带通信号（仅在一段频率范围内能够通过信道），故也称为带通调制。</li></ul><hr><p>常见编码方式：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413121418.png" alt="编码方式"></p><p>曼彻斯特编码是看周期中心的跳变是正还是负（上下），差分曼彻斯特编码是看位开始边界是否有跳变。曼彻斯特编码有自同步能力，不归零则没有。</p><p>要注意的是以上每种编码的0/1都是人为规定的，所以是可以互换的。</p><hr><p>基本带通调制：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413122157.png" alt="带通调制"></p><p>另外还有QAM16为代表的正交振幅调制，利用编码让每一个码元携带更多比特的信息量。</p><hr><p><strong>奈氏准则</strong>：  在任何信道中，码元传输的速率是有上限的，传输速率超过上限，就会出现码间串扰，影响接收端的识别。</p><p><strong>信噪比</strong>：  信号的平均功率和噪声的平均功率之比。记作S/N，度量单位为分贝db</p><p>信噪比（db） = 10 log10（S/N）（db）</p><p><strong>香农公式</strong>： 信道的极限信息传输速率C</p><p>C = W * log2（1+S/N）(bit/s)   </p><p>其中W为信道带宽（单位HZ），S为信道内信号的平均功率，N为信道内高斯噪声功率。</p><p>香农公式表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</p><hr><h3 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3 信道复用技术"></a>2.3 信道复用技术</h3><ul><li>频分复用 FDM：  所有用户在同一时间内占用不同的带宽资源（频带宽度HZ）。即频带分片</li><li>时分复用 TDM：  所有用户在不同时间占用同样的频带宽度。即时间分片</li><li>统计时分复用 STDM：  一种改进的时分复用，明显提高信道的利用率，又叫异步时分复用。</li><li>波分复用 WDM： 光的频分复用。分光器</li><li>码分复用 CDM：  码分多址CDMA，抗干扰能力强，广泛应用与民用的移动通信中，特别是无线局域网。</li></ul><p>在CDMA中，每一个比特时间再划分为m个短的时间间隔，称为码片，m通常为64或128，实际就是发送64个比特来表示一个逻辑比特0或1，虽然降低了发送效率，但是完成了加密更安全。</p><p>一个站要发送比特1，则发送自己的m bit码片序列，发送0则发送码片序列的二进制补码。CDMA系统给每一个站分配的码片序列不仅必须各不相同而且必须互相正交。这样可以保证每一个码片都与其他站的码片的內积为0。另外码片自身的內积为1，自身与自身补码的內积为-1（-1代表二进制0）。</p><p>现假定一个站X要接受站S发送的数据，则X需要知道S的码片序列，在同一时刻会有很多不同的站发来数据，而此时X使用S的码片序列与接收到的比特流进行內积操作，这样X收到其他非S站的数据內积均是0，只有收到S的比特流內积可以得出1或者-1，即可获得S站发出的逻辑比特流。</p><hr><h3 id="2-4-宽带接入技术"><a href="#2-4-宽带接入技术" class="headerlink" title="2.4 宽带接入技术"></a>2.4 宽带接入技术</h3><ul><li><strong>ADSL 技术</strong>：  非对称数字用户线ADSL技术是用数字技术对现有的模拟电话用户线进行改造。ADSL将0~4khz的低端频谱保留给传统电话使用，4khz以上的高频谱分为上行带宽和下行带宽。</li><li><strong>光纤同轴混合网</strong>：  即HFC网，是一种基于有线电视网的居民宽带。</li><li><strong>FTTx技术</strong>：及光纤入户，光纤入楼。使用分光器使几十户人家共用一根光纤干线。  使用光线路终端OLT把收到的下行数据发往无源的1：N光分路器，然后用广播方式向所有用户端的光网络单元ONU发送。ONU在用户家中即是光纤入户，从ONU到个人电脑一般用以太网连接，使用5类线作为传输媒体。</li></ul><hr><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="3-1-传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？"><a href="#3-1-传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？" class="headerlink" title="3.1 传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？"></a>3.1 传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？</h3><p>不是，传输媒体在物理层下面。由于物理层是体系结构第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号是什么意思，即不知道传输的信号什么时候代表1，什么时候代表0。但物理层由于规定了电气特性，所以能够识别比特流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–物理层&quot;&gt;&lt;a href=&quot;#计算机网络–物理层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–物理层&quot;&gt;&lt;/a&gt;计算机网络–物理层&lt;/h1&gt;&lt;h2 id=&quot;1-物理层的基本概念&quot;&gt;&lt;a href=&quot;#1-物理层的基本概念&quot; cla</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://icecorn.github.io/2022/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://icecorn.github.io/2022/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-02-09T11:37:26.000Z</published>
    <updated>2022-06-29T11:19:33.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="1-Markdown-的基础语法"><a href="#1-Markdown-的基础语法" class="headerlink" title="1.Markdown 的基础语法"></a>1.Markdown 的基础语法</h2><p>本文介绍markdown的基本语法，很容易掌握，一看就会。</p><h3 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h3><p>  这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。Markdown 支持 6 种级别的标题，对应 HTML 标签 h1 ~ h6。l例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># h1</span></span><br><span class="line"><span class="comment">## h2</span></span><br><span class="line"><span class="comment">### h3</span></span><br><span class="line"><span class="comment">#### h4</span></span><br><span class="line"><span class="comment">##### h5</span></span><br><span class="line"><span class="comment">###### h6</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>```<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  和标题之间建议保留一个字符的空格，这是最标准的 Markdown 写法。以上标记效果如下：</span><br><span class="line"></span><br><span class="line">  ![ ](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/h1.png)</span><br><span class="line"></span><br><span class="line">- 除此之外，Markdown 还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">这是一级标题</span><br><span class="line">===</span><br><span class="line">这是二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul><p>以上标记效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/h2.png" alt=" "></p><p>  这种处理方式在 Github 的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。</p><h3 id="1-2段落及区块引用"><a href="#1-2段落及区块引用" class="headerlink" title="1.2段落及区块引用"></a>1.2段落及区块引用</h3><p>  <strong>需要记住的是，Markdown 其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。</strong>其最终依然会转换为 HTML 标签，因此使用 Markdown 分段非常简单，将你要分段的部分前后至少保留一个空行即可。<br>  而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown 提供了一个特殊符号 &gt; 用于段首进行强调，被强调的文字部分将会高亮显示。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|&gt; 如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><blockquote><p>如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。</p></blockquote><p>注意：</p><ul><li>聪明的你可能已经发现了，上面显示的引用效果和文章开头引用百度百科的效果是一样的。没错，本站所有文章均采用 Markdown 语法写作，而且大家在评论时也可以采用 Markdown 语法进行评论。这也是为什么第二篇文章写 Markdown 的原因之一了。至于我渲染出来的结果为什么跟你不一样，这是因为我们采用了不同的 CSS 进行调节，这一内容会在后面的教程进行讲解。</li><li>引用完后，一定记得空出一行再写其他东西，不然，你接下来写作的内容也都在引用内容里。</li><li><code>&gt;</code>与你要引用的文字之间一定有<code>一个空格</code>，不然会被认为是普通的文本。<code>&gt;</code>前面不能有文字，必须单独一行才能引用。</li></ul><h3 id="1-3目录"><a href="#1-3目录" class="headerlink" title="1.3目录"></a>1.3目录</h3><p>  Markdown引入目录非常简单，只需要在你想加入目录的地方输入<code>[TOC]</code>就可以了。</p><h3 id="1-4首行缩进方法"><a href="#1-4首行缩进方法" class="headerlink" title="1.4首行缩进方法"></a>1.4首行缩进方法</h3><p>  在用中文写文章时，我们通常习惯段首缩进两个字，但是使用 Markdown 编辑时我们手打空格缩进是不起作用的，因此我们需要通过使用 HTML 中的空格实体来帮助我们实现缩进效果。<br>  为了让本文不那么难以理解，这一部分我只打算讲一个，也是我比较推荐的一个，<code>&amp;emsp</code>;。一个汉字占两个空格大小，所以使用四个空格就可以达到首行缩进两个汉字的效果。而一个 <code>&amp;emsp</code>; 代表两个空格，所以用两个 <code>&amp;emsp</code>; 就代表两个汉字、四个空格了。</p><h3 id="1-5分割线"><a href="#1-5分割线" class="headerlink" title="1.5分割线"></a>1.5分割线</h3><p>  分割线可以由 <code>*</code> 、 <code>-</code> 、 _（星号，减号，底线）这 3 个符号的至少 3 个符号表示，注意至少要 3 个，且不需要连续，有空格也可以。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br><span class="line">* * *</span><br><span class="line">****</span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><hr><hr><hr><hr><hr><h3 id="1-6粗体和斜体"><a href="#1-6粗体和斜体" class="headerlink" title="1.6粗体和斜体"></a>1.6粗体和斜体</h3><p>  Markdown 的粗体和斜体也非常简单，用<code>**</code>或者<code>__</code>包含一段文本就是粗体的语法，用<code>*</code>或者<code>_</code>包含一段文本就是斜体的语法。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*始于颜值、陷于才华、忠于人品*</span><br><span class="line">_始于颜值、陷于才华、忠于人品_</span><br><span class="line">**始于颜值、陷于才华、忠于人品**</span><br><span class="line">__始于颜值、陷于才华、忠于人品__</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><p><em>始于颜值、陷于才华、忠于人品</em><br><em>始于颜值、陷于才华、忠于人品</em><br><strong>始于颜值、陷于才华、忠于人品</strong><br><strong>始于颜值、陷于才华、忠于人品</strong></p><h3 id="1-7删除线"><a href="#1-7删除线" class="headerlink" title="1.7删除线"></a>1.7删除线</h3><p>  用 ~~ 包含一段文本就是删除线了。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~请删除我~~</span><br></pre></td></tr></table></figure><p>其显示结果如下：<del>请删除我</del></p><h3 id="1-8列表"><a href="#1-8列表" class="headerlink" title="1.8列表"></a>1.8列表</h3><p>  Markdown 支持有序列表和无序列表两种形式：无序列表使用<code>*</code>或<code>+</code>或<code>-</code> 标识；有序列表使用数字加 . 标识。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* 黄瓜</span><br><span class="line">* 玉米</span><br><span class="line">* 茄子</span><br><span class="line"></span><br><span class="line">+ 黄瓜</span><br><span class="line">+ 玉米</span><br><span class="line">+ 茄子</span><br><span class="line"></span><br><span class="line">- 黄瓜</span><br><span class="line">- 玉米</span><br><span class="line">- 茄子</span><br><span class="line"></span><br><span class="line">1. 黄瓜</span><br><span class="line">2. 玉米</span><br><span class="line">3. 茄子</span><br><span class="line"></span><br><span class="line">4. 黄瓜</span><br><span class="line">5. 玉米</span><br><span class="line">6. 茄子</span><br><span class="line"></span><br><span class="line">7. 黄瓜</span><br><span class="line">8. 玉米</span><br><span class="line">9. 茄子</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><ul><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li></ul><ol><li>黄瓜</li><li>玉米</li><li>茄子</li><li>黄瓜</li><li>玉米</li><li>茄子</li><li>黄瓜</li><li>玉米</li><li>茄子</li></ol><p>注意：</p><ul><li>有序表不用 1. 2. 3. 这样排下去，可以直接 1. 1. 1. 这样，如果以 3. 开头，如 3. 2. 1. 这样，那么结果是 3. 4. 5.。即以什么数字开头，结果就以什么数字开头，后面的数字可以随便写。如果中间要再插入一项，就不用修改整个列表的序号了。</li><li>如果需要写多级列表，这可以用缩进的办法实现，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 动物</span><br><span class="line">  1. 哺乳动物</span><br><span class="line">  2. 爬行动物</span><br><span class="line">  3. 鸟类</span><br><span class="line">  4. 其他</span><br><span class="line">2. 植物</span><br><span class="line">  5. 被子植物</span><br><span class="line">  6. 裸子植物</span><br><span class="line">  7. 其他</span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><ol><li>动物</li><li>哺乳动物</li><li>爬行动物</li><li>鸟类</li><li>其他</li><li>植物</li><li>被子植物</li><li>裸子植物</li><li>其他</li></ol><h3 id="1-9代办清单-To-do-List"><a href="#1-9代办清单-To-do-List" class="headerlink" title="1.9代办清单 To-do List"></a>1.9代办清单 To-do List</h3><p>  你可以在 Markdown 中编写代办清单，相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- [x] 已完成项目<span class="number">1</span></span><br><span class="line">  - [x] 已完成事项</span><br><span class="line">  - [ ] 代办事项</span><br><span class="line">- [ ] 代办项目<span class="number">2</span></span><br><span class="line">- [ ] 代办项目<span class="number">3</span></span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><ul><li>已完成项目1</li><li>已完成事项</li><li>代办事项</li><li>代办项目2</li><li>代办项目3</li></ul><h3 id="1-10插入链接"><a href="#1-10插入链接" class="headerlink" title="1.10插入链接"></a>1.10插入链接</h3><p>  Markdown 针对链接的处理比较简单，可以使用下面的语法进行标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[点击跳转至百度](http://www.baidu.com)</span><br></pre></td></tr></table></figure><p>其显示结果如下：<a href="http://www.baidu.com/">点击跳转至百度</a></p><h2 id="2-Markdown-的高级语法"><a href="#2-Markdown-的高级语法" class="headerlink" title="2.Markdown 的高级语法"></a>2.Markdown 的高级语法</h2><p>  通过上一节的讲解，我们现在已经可以进行简单的纯文字写作了。你可能想问，Markdown 只能处理纯文本吗，那如果我想插入表格，图片，公式等等该怎么办。不要急，Markdown 虽然语法简单，但是功能很强大的，上面的这些需求完全可以满足。</p><h3 id="2-1插入图片"><a href="#2-1插入图片" class="headerlink" title="2.1插入图片"></a>2.1插入图片</h3><h4 id="2-1-1基本用法"><a href="#2-1-1基本用法" class="headerlink" title="2.1.1基本用法"></a>2.1.1基本用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![当链接内容不存在时显示的内容](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya2.jpg)</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya2.jpg" alt="当链接内容不存在时显示的内容"></p><p><strong>当链接内容不存在时显示的内容</strong></p><h4 id="2-1-2加入图名和居中对齐"><a href="#2-1-2加入图名和居中对齐" class="headerlink" title="2.1.2加入图名和居中对齐"></a>2.1.2加入图名和居中对齐</h4><p>  Markdown 图片默认左对齐，如果需要居中对齐，就需要采用 HTML 的语法了（注：博主采用了样式表，使图片默认居中，显示图名）。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;&lt;img src=<span class="string">&quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot;</span>&gt;&lt;/br&gt;小雅&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/cdn@1.2/cover/loading3.gif" alt="img"></p><p>小雅</p><h4 id="2-1-3控制图片大小"><a href="#2-1-3控制图片大小" class="headerlink" title="2.1.3控制图片大小"></a>2.1.3控制图片大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src = <span class="string">&quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot;</span> width = 50%/&gt;</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg" alt="img"></p><h4 id="2-1-4其他"><a href="#2-1-4其他" class="headerlink" title="2.1.4其他"></a>2.1.4其他</h4><p>  主要采用的是HTML标记语言和CSS样式表来控制图片格式的。本系列教程不涉及这些，如果你有需要，可以点击<a href="https://www.runoob.com/html/html-images.html">HTML图片|菜鸟教程</a>和<a href="https://www.runoob.com/css3/css3-images.html">CSS图片|菜鸟教程</a> 进行学习。</p><h4 id="2-1-5图床"><a href="#2-1-5图床" class="headerlink" title="2.1.5图床"></a>2.1.5图床</h4><p>图床请参考我的<a href="https://www.liuyao-blog.cn/posts/7410.html">Github+Hexo博客搭建小白教程</a> 里面详细的介绍了七牛云图床的使用方法</p><h3 id="2-2表格"><a href="#2-2表格" class="headerlink" title="2.2表格"></a>2.2表格</h3><p>  表格是 Markdown 语法中比较复杂的一个，也是我们平常常用的样式之一，但也不是无迹可寻。</p><h4 id="2-2-1基本用法"><a href="#2-2-1基本用法" class="headerlink" title="2.2.1基本用法"></a>2.2.1基本用法</h4><ul><li>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</li><li>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界。</li><li>在表头下方的分隔线标记中加入<code>:</code>，即可标记下方单元格内容的对齐方式。</li></ul><blockquote><p>:— 代表左对齐<br>:–: 代表居中对齐<br>—: 代表右对齐<br>  例如：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | <span class="variable">$1600</span> |</span><br><span class="line">| col 2 is      | centered      |   <span class="variable">$12</span> |</span><br><span class="line">| zebra stripes | are neat      |    <span class="variable">$1</span> |</span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><table><thead><tr><th align="left">Tables</th><th align="left">Are</th><th align="left">Cool</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="left">right-aligned</td><td align="left">$1600</td></tr><tr><td align="left">col 2 is</td><td align="left">centered</td><td align="left">$12</td></tr><tr><td align="left">zebra stripes</td><td align="left">are neat</td><td align="left">$1</td></tr></tbody></table><p> 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | <span class="built_in">cat</span></span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><table><thead><tr><th align="left">dog</th><th align="left">bird</th><th align="left">cat</th></tr></thead><tbody><tr><td align="left">foo</td><td align="left">foo</td><td align="left">foo</td></tr><tr><td align="left">bar</td><td align="left">bar</td><td align="left">bar</td></tr><tr><td align="left">baz</td><td align="left">baz</td><td align="left">baz</td></tr></tbody></table><p>注意：</p><ul><li><code>| 、 - 、:</code> 之间的多余空格会被忽略，不影响布局。</li><li>默认标题栏居中对齐，内容居左对齐。</li><li>-: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。</li><li>内容和 | 之间的多余空格会被忽略，每行第一个<code>|</code>和最后一个<code>|</code>可以省略，<code>-</code>的数量至少有一个。</li></ul><h4 id="2-2-2加入表头"><a href="#2-2-2加入表头" class="headerlink" title="2.2.2加入表头"></a>2.2.2加入表头</h4><p>  Markdown 默认语法里面没有关于表头的，但如果我们需要有表头，那该怎么办呢。通过图片章节的学习，我想你应该知道解决办法了。对，没错，就是 HTML + CSS。点击 HTML 表格 | 菜鸟教程 进行学习。</p><h3 id="2-3插入代码块"><a href="#2-3插入代码块" class="headerlink" title="2.3插入代码块"></a>2.3插入代码块</h3><p>  Markdown 在 IT 圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码，其实我在前面已经多次向大家展示了代码块的最终效果。代码块的语法特别简单，只要把你想要展示的代码片段用 <code>包裹就可以了。行内代码用一个</code> 包裹，如 <code>var y=x^3+2</code><br>  如果要插入一整段代码，就需要至少三个` 进行包裹，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">num=[];</span><br><span class="line">i=2</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(2,100):</span><br><span class="line">  j=2</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(2,i):</span><br><span class="line">      <span class="keyword">if</span>(i%j==0):</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        num.append(i)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>  上面的例子就是输出100以内的素数的Python代码。</p><p>注意：</p><ul><li>在代码前面，三个反引号后面填写你插入代码的类型，如 Markdown、Python，这样就可以高亮你的代码块了。</li><li>很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧 esc 键下面的第一个键点击即可。</li></ul><h3 id="2-4数学公式"><a href="#2-4数学公式" class="headerlink" title="2.4数学公式"></a>2.4数学公式</h3><p>  Markdown 可以插入 LaTex 数学公式，这一点我非常的喜欢，因为我是先学习了 LaTex，然后再接触到 Markdown 的，Markdown 几乎支持 LaTex 的所有数学公式语法。至于 LaTex 是什么，我会在后面的文章进行介绍，现在你只要知道 Markdown 适合记一些笔记，写一些文字，但它并不适合写论文，而 LaTex 就是为排版而生的。<br>  下面引用百度百科的介绍：</p><blockquote><p>LaTeX（LATEX，音译 “拉泰赫”）是一种基于 ΤΕΧ 的排版系统，由美国计算机学家莱斯利・兰伯特（Leslie Lamport）在 20 世纪 80 年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由 TeX 所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。</p></blockquote><p>  从百度百科的介绍中我们可以知道，LaTex 非常适合生成复杂的数学公式，理工科的同学看到这点是不是很激动啊。在 Word 里面输入公式，我们一般会用到 Mathtype 这个插件，但每次都需要点很多次才能输入我们想要的公式，这严重影响到了我们的思绪。而 LaTex 只需要记住少量的代码，就可以非常流畅且快速的书写数学公式了。我曾在知乎上面看到过这样的介绍，「1700 页数学笔记火了！全程敲代码，速度飞快易搜索，硬核小哥教你上手 LaTeX+Vim」，虽然有 Vim 这样的编辑器之神（此处多说几句，自从用上Vim后，对其他编辑器的操作方式再也没正眼瞧过，看我文章的应该没有Emacs党吧）加持，但依然从侧面说明了 LaTex 在书写数学公式方面的强大和易用。<br>  由于数学公式语法较多，后面我会在 LaTex 系列专门写一篇文章进行介绍，这里就展示几个例子。</p><ul><li>行内公式：将公式插入到本行内，用一个美元符号包裹公式。</li><li>独行公式：将公式插入到新的一行内，并且居中，用两个美元符号包裹公式。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%欧拉公式</span><br><span class="line">$<span class="variable">$e</span>^&#123;i\pi&#125;+1=0$$</span><br><span class="line">%薛定谔方程</span><br><span class="line">$$</span><br><span class="line">i \hbar \frac&#123;\partial&#125;&#123;\partial t&#125; \Psi(\boldsymbol&#123;r&#125;, t)=-\frac&#123;\hbar^&#123;2&#125;&#125;&#123;2 m&#125; \nabla^&#123;2&#125; \Psi(\boldsymbol&#123;r&#125;, t)+V(\boldsymbol&#123;r&#125;, t) \Psi(\boldsymbol&#123;r&#125;, t)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="2-5特殊符号处理"><a href="#2-5特殊符号处理" class="headerlink" title="2.5特殊符号处理"></a>2.5特殊符号处理</h3><p>  Markdown 使用反斜杠 \ 插入语法中用到的特殊符号。在 Markdown 中，主要有以下几种特殊符号需要处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.\ 反斜线</span><br><span class="line">2.` 反引号</span><br><span class="line">3.* 星号</span><br><span class="line">4._ 底线</span><br><span class="line">5.&#123;&#125; 花括号</span><br><span class="line">6.[] 方括号</span><br><span class="line">7.括弧</span><br><span class="line">8.<span class="comment"># 井字号</span></span><br><span class="line">9.+ 加号</span><br><span class="line">10.- 减号</span><br><span class="line">11.. 英文句点</span><br><span class="line">12.! 惊叹号</span><br></pre></td></tr></table></figure><p>1.\ 反斜线<br>2.` 反引号<br>3.* 星号<br>4._ 底线<br>5.{} 花括号<br>6.[] 方括号<br>7.括弧<br>8.# 井字号<br>9.+ 加号<br>10.- 减号<br>11.. 英文句点<br>12.! 惊叹号</p><h2 id="3-Markdown-软件推荐"><a href="#3-Markdown-软件推荐" class="headerlink" title="3.Markdown 软件推荐"></a>3.Markdown 软件推荐</h2><p>  对于初学者，我推荐你使用Typora，Typora 的优点太多了：简洁美观、实时预览、扩展语法、跨平台、免费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;1-Markdown-的基础语法&quot;&gt;&lt;a href=&quot;#1-Mar</summary>
      
    
    
    
    <category term="工具" scheme="http://icecorn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Markdown" scheme="http://icecorn.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
