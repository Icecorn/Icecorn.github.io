<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-08-07T16:22:58.708Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试八股|C++篇</title>
    <link href="http://icecorn.github.io/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"/>
    <id>http://icecorn.github.io/2022/08/03/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</id>
    <published>2022-08-03T09:25:10.000Z</published>
    <updated>2022-08-07T16:22:58.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面试八股C-篇"><a href="#面试八股C-篇" class="headerlink" title="面试八股C++篇"></a>面试八股C++篇</h1><h2 id="define和const区别"><a href="#define和const区别" class="headerlink" title="define和const区别"></a>define和const区别</h2><ul><li>define是在预处理阶段，const是在编译，运行阶段</li><li>define只是简单的字节流替换，而const是有类型的</li><li>define就只是宏展开，它定义的宏常量在内存中有多个（哪里使用哪里就有一块内存），而const定义的常量在内存中只有一个</li><li>const常量是可以调试的，而define是不可以调试的，因为在预处理阶段就被替换掉了</li></ul><p><strong>const优点：</strong></p><ul><li>因为const有类型，所以编译器可以对其进行类型安全检查，而define不可以</li><li>const可调试，define不可以</li><li>const内存中只有一个，省内存</li></ul><hr><h2 id="为什么静态成员不能在类内初始化？"><a href="#为什么静态成员不能在类内初始化？" class="headerlink" title="为什么静态成员不能在类内初始化？"></a><strong>为什么静态成员不能在类内初始化？</strong></h2><p>在C++中，类的<a href="https://so.csdn.net/so/search?q=%E9%9D%99%E6%80%81%E6%88%90%E5%91%98&spm=1001.2101.3001.7020">静态成员</a>（static member）必须在类内声明，在类外初始化，像下面这样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count ; <span class="comment">// 类内声明 </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 类外定义并初始化，不必再加static关键字</span></span><br><span class="line"><span class="type">int</span> A::count = <span class="number">0</span> ; </span><br></pre></td></tr></table></figure><p>或者只进行定义不赋初始值，但是默认值是否是0，可能会与具体的编译器有关吧？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只进行定义不赋初始值，但默认值视编译器而定</span></span><br><span class="line"><span class="type">int</span> A::count;</span><br></pre></td></tr></table></figure><p>为什么？</p><p>因为静态成员属于整个类，而不属于某个对象，如果在类内初始化，会导致多个对象对该成员进行更改。<strong>第一个对象将它初始化count=0,在之后的程序流程中我们修改它为count=1,这是我们再实例化一个对象B，那么B在构造是就会更改count=0,这显然不对</strong></p><p>如果不增加int A::count = 0 ; //变量定义，在编译的时候将会报出：‘A::count’未定义的引用”错误。这是因为静态成员变量count未定义，也就是还没有分配内存，显然是不可以访问的。</p><p>《c++primer》里面说在类外定义和初始化是保证<a href="https://so.csdn.net/so/search?q=static&spm=1001.2101.3001.7020">static</a>成员变量只被定义一次的好方法。 但为什么static const int就可以在类里面初始化呢？<br>想起C中一个函数里定义一个static变量是为了保证只初始化一次。</p><p>那么，是否可以这样理解: static数据成员在类外定义和初始化是为了保证只被定义和初始化一次,static const int可以在类里面初始化，是因为它既然是const的，那程序就不会再去试图更改了。</p><hr><h2 id="左值，右值，左值引用，右值引用"><a href="#左值，右值，左值引用，右值引用" class="headerlink" title="左值，右值，左值引用，右值引用"></a>左值，右值，左值引用，右值引用</h2><p><strong>左值：</strong></p><p>有地址能够取地址的就是左值，能放在=左边</p><ul><li>函数名，变量名</li><li>返回左值引用的函数调用</li><li>前置自增自减，++i,–i</li><li>解引用表达式 *p</li><li>赋值表达式 a=b;a+=b等</li><li>字符串型字面值“abcd”（因为它存在全局数据区，为了方便复用）</li></ul><p><strong>右值：</strong></p><p>右值分为纯右值和将亡值</p><p>纯右值：</p><ul><li>除了字符串类型的所有其他字面值， 比如 10（因为它是用的时候直接在寄存器里生成的）</li><li>返回非左值引用的函数调用</li><li>后置自增自减 –i；++i；</li><li>算数表达式 a+b；</li><li>取地址表达式 &amp;a</li><li>lamda表达式</li></ul><p>将亡值：</p><p>A&amp;&amp; ， std::move的返回值</p><p><strong>左值引用：</strong></p><p>能绑定左值的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = a; <span class="comment">// b 是左值引用</span></span><br><span class="line">b = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">// error，10 无法取地址，无法进行引用</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;d = <span class="number">10</span>; <span class="comment">// ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址</span></span><br></pre></td></tr></table></figure><p><strong>右值引用：</strong></p><p>绑定右值的引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> &amp;&amp;b = a; <span class="comment">// error, a 是左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;c = std::<span class="built_in">move</span>(a); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p><strong>深拷贝和浅拷贝：</strong></p><p>浅拷贝要注意防止析构时内存释放两次引发错误，所以我们用std::move和移动构造来避免这个，并且不要忘记把原来对象的指针置nullptr</p><p><strong>完美转发：</strong></p><p>完美转发应用场景：</p><p><a href="https://blog.csdn.net/qq_45698148/article/details/120692470">https://blog.csdn.net/qq_45698148/article/details/120692470</a></p><p>引用折叠：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A&amp; &amp; 折叠成 A&amp;</span><br><span class="line">A&amp; &amp;&amp; 折叠成 A&amp;</span><br><span class="line">A&amp;&amp; &amp; 折叠成 A&amp;</span><br><span class="line">A&amp;&amp; &amp;&amp; 折叠成 A&amp;&amp;</span><br></pre></td></tr></table></figure><p>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::forward()内部实现就是static_cast成模板T的类型，从而实现完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">g</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//std::move()内部实现就是static_cast转换成右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Tp</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> _LIBCPP_CONSTEXPR</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> _LIBCPP_NODEBUG_TYPE <span class="keyword">typename</span> remove_reference&lt;_Tp&gt;::type _Up;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Up&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="虚函数和纯虚函数的区别？"><a href="#虚函数和纯虚函数的区别？" class="headerlink" title="虚函数和纯虚函数的区别？"></a>虚函数和纯虚函数的区别？</h2><p><strong>虚函数：</strong>是c++实现运行时多态的方式，通过基类指针指向子类对象从而调用子类的虚函数实现多态，具体实现就是虚函数表，虚函数表指针那一套。<strong>虚表指针是对象拥有的，和对象存储在一起（堆或栈），虚函数表是在全局数据区存储的，而每个虚函数是在代码区（编译时生成的）</strong></p><p><strong>纯虚函数：</strong>纯虚函数是为了保证面向对象的可读性，比如父类是动物，子类是老虎，大象之类的，很显然动物不能实例化对象（语义不通），这就有了纯虚函数的性质：</p><ul><li>含有纯虚拟函数的类称为抽象类，它不能生成对象。</li><li>定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。所有继承它的子类必须要重写这个接口，不然该子类就还是抽象类，不能生成对象。</li><li>在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。</li><li>友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。</li><li>析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。</li><li>定义纯虚函数就是为了让基类不可实例化化</li></ul><hr><h2 id="虚函数原理"><a href="#虚函数原理" class="headerlink" title="虚函数原理"></a>虚函数原理</h2><p><a href="https://xiaomaweifu.blog.csdn.net/article/details/81326699">https://xiaomaweifu.blog.csdn.net/article/details/81326699</a></p><p><a href="https://blog.csdn.net/u011857683/article/details/79790967">https://blog.csdn.net/u011857683/article/details/79790967</a></p><p><strong>总结：</strong></p><ul><li>虚表指针和对象存储在一起（堆或栈），虚函数表存储在全局区，虚函数存储在代码区</li><li>单继承只有一个虚表指针，在对象首部，子类和父类的虚函数表不是一个，子类重写对应虚函数的话，子类虚表就会覆盖对应地址</li><li>子类自己的虚函数按照顺序排在虚函数表后边，但是要注意不能用父类的指针去调用父类没有的子类自己的虚函数，会编译错误</li><li>多继承继承几个父类子类就有几个虚函数表，子类自己的虚函数存放在第一个虚函数表后边，并且多继承时子类对象的内存分布是一个父类一个父类来的，而不是所有的虚函数表指针都在最上边，而且要满足内存对齐规则</li><li>虚函数表区域结束以0x00000000为标志。</li></ul><hr><h2 id="类模板和函数模板的区别"><a href="#类模板和函数模板的区别" class="headerlink" title="类模板和函数模板的区别"></a>类模板和函数模板的区别</h2><ul><li><p>类模板默认参数必须从右往左（不能跳着），而函数模板没有这个规定</p></li><li><p>类模板实例化的时候必须显示指定，但函数模板不需要（可以自动推导）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person &lt;string, <span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//正确</span></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>; <span class="comment">//错误，因为不能自动推导</span></span><br></pre></td></tr></table></figure></li><li><p>C11支持变长参数模板</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; t)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;<span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> T&amp; t, Args ... args)</span></span>&#123;</span><br><span class="line">cout &lt;&lt; t &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line"><span class="built_in">func</span>(args...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="C11列表初始化"><a href="#C11列表初始化" class="headerlink" title="C11列表初始化"></a>C11列表初始化</h2><p><strong>规则:</strong></p><ul><li>聚合类型可以直接初始化列表，比如vector,Int[],char[]</li><li>类的话必须满足以下条件：<ul><li>没有用户声明的构造函数 </li><li>没有用户提供的构造函数(允许显示预置或弃置的构造函数) </li><li>没有私有或保护的非静态数据成员 </li><li>没有基类</li><li>没有虚函数 </li><li>没有{}和=直接初始化的非静态数据成员 </li><li>没有默认成员初始化器</li></ul></li></ul><p><strong>初始化列表怎么实现接收不同长度的参数的？</strong></p><p>通过std::initializer_list<int>实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;; <span class="comment">//不同长度</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">CustomVec</span> &#123;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line"><span class="built_in">CustomVec</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = list.<span class="built_in">begin</span>(); iter != list.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">data.<span class="built_in">push_back</span>(*iter);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>初始化列表好处？</strong></p><ul><li><p>方便，且基本上可以替代括号初始化  </p></li><li><p>可以使用初始化列表接受任意长度 </p></li><li><p>可以防止类型窄化，避免精度丢失的隐式类型转换</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1.2</span>; <span class="comment">// ok</span></span><br><span class="line"><span class="type">int</span> b = &#123;<span class="number">1.2</span>&#125;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="构造函数初始化列表和函数内赋值区别？"><a href="#构造函数初始化列表和函数内赋值区别？" class="headerlink" title="构造函数初始化列表和函数内赋值区别？"></a>构造函数初始化列表和函数内赋值区别？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y):<span class="built_in">m_x</span>(x),<span class="built_in">m_y</span>(y)&#123;&#125;</span><br><span class="line"><span class="comment">//构造函数内赋值</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x, <span class="type">int</span> y)&#123;m_x = x;m_y = y;&#125;</span><br></pre></td></tr></table></figure><p><strong>初始化列表是在实例化类对象给成员变量分配内存的时候就进行初始化了，而构造函数内赋值是全部分配完内存后再执行赋值操作，这就意味着某些情况下初始化列表效率更高</strong></p><ul><li>对于内置数据类型，复合类型（指针，应用）两者效率一致，都是要写入一次而已</li><li>对于类类型，初始化列表要快很多，因为它在分配的那块内存上直接调用类类型的构造函数构造这个类对象，而构造函数赋值，是先分配一个内存，然后进入构造函数体（栈），构造一个类对象，再把它拷贝到分配的内存那块，这就多增加一次拷贝的开销</li></ul><p><strong>必须使用初始化列表的情况：</strong></p><ul><li>成员类型是没有默认构造函数的类。若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。</li><li>const成员或reference引用类型的成员。const对象或引用类型只能初始化，不能对他们赋值。构造函数的函数体内只能做赋值而不是初始化，因此初始化const对象或引用的唯一机会是构造函数</li></ul><p><strong>引申知识点：</strong></p><p>不能在父类的构造函数中调用子类的构造函数，或初始化列表构造子类</p><p>因为子类对象的实例化是先实例化父类部分，再实例化子类部分，如果按照下边这种情况，就会无限循环，形成套娃</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A是B的父类，以下都不行 </span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x):<span class="built_in">B</span>(x)&#123;&#125; </span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x)&#123;<span class="built_in">B</span>(x);&#125;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/c1348208475/article/details/105354323">https://blog.csdn.net/c1348208475/article/details/105354323</a></p><hr><h2 id="C11-std-function和lamda表达式"><a href="#C11-std-function和lamda表达式" class="headerlink" title="C11 std::function和lamda表达式"></a>C11 std::function和lamda表达式</h2><h3 id="为什么要有std-function"><a href="#为什么要有std-function" class="headerlink" title="为什么要有std::function?"></a><strong>为什么要有std::function?</strong></h3><p>C++中有如下几种可调用对象：<strong>函数、函数指针、lambda表达式、bind对象、函数对象</strong>。其中，lambda表达式和bind对象是C++11标准中提出的(bind机制并不是新标准中首次提出，而是对旧版本中bind1st和bind2st的合并)。个人认为五种可调用对象中，函数和函数指针本质相同，而lambda表达式、bind对象及函数对象则异曲同工。</p><p><strong>函数：</strong>函数是存放在代码区的，fun()实际就是找到该函数在代码区的地址执行一遍</p><p><strong>函数指针：</strong>函数指针就是我们用一个指针来保存函数的地址</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Ftype)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line">Ftype fp = funAdd; <span class="comment">//实例化一个int(*Ftype)(int,int)的函数指针fp,funAdd函数在代码区</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(fp) &lt;&lt; endl;<span class="comment">//指针占8字节</span></span><br><span class="line"><span class="built_in">fp</span>(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//调用函数</span></span><br></pre></td></tr></table></figure><p><strong>lamda表达式：</strong>lamda表达式是一个匿名对象(仿函数)，它实际上是一个右值临时对象（也叫闭包对象），它的类型是特殊的类类型（闭包类型），只要记得它是右值没地址就好，具体用法下边说</p><p><strong>bind对象：</strong>可以新产生一个可调用对象，参数&lt;=原来的可调用对象，用placeholder先绑定一部分参数</p><p><strong>函数对象：</strong>就是仿函数（实质是个类）重载了函数调用运算符<code>()</code>的类的对象，即为函数对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line">myadd md;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(myadd) &lt;&lt; endl; <span class="comment">//和一般的类一样，sizeof是测试它的一个实例化对象的大小，这个对象在堆或栈区，大小遵循内存对齐，此例4字节</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">md</span>(<span class="number">2</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><strong>基于此，需要使用一个统一的方式保存可调用对象或者传递可调用对象。于是，<code>std::function</code>就诞生了。</strong></p><h3 id="std-function的应用"><a href="#std-function的应用" class="headerlink" title="std::function的应用"></a>std::function的应用</h3><p><strong>std::function是一个可调用对象包装器，是一个类模板，可以容纳除了类成员函数指针之外的所有可调用对象，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟它们的执行</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> std::function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; comfun;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">addFun</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// lambda表达式</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="type">int</span> a, <span class="type">int</span> b)&#123; <span class="keyword">return</span> a % b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">divide</span>&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator, <span class="type">int</span> divisor)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator/divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Ftype)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    comfun a = addFun;</span><br><span class="line">    comfun b = mod;</span><br><span class="line">comfun c = <span class="built_in">divide</span>();</span><br><span class="line">    Ftype fp = addFun;</span><br><span class="line">    comfun d = fp;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">a</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">b</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//lamda</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">c</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//仿函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">d</span>(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; std::endl; <span class="comment">//函数指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::function可以取代函数指针的作用，因为它可以延迟函数的执行，特别适合作为<strong>回调函数</strong>使用。它比普通函数指针更加的灵活和便利。</p><p>故而，std::function的作用可以归结于：</p><ul><li><p>std::function对C++中各种可调用实体(普通函数、Lambda表达式、函数指针、以及其它函数对象等)的封装，形成一个新的可调用的std::function对象，简化调用；</p></li><li><p>std::function对象是对C++中现有的可调用实体的一种类型安全的包裹(如：函数指针这类可调用实体，是类型不安全的)。</p></li><li><p>对于函数和函数指针，C11之前使用typedef定义函数指针类型，可读性差</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*Ftype)</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span> <span class="comment">//表示返回值int，参数（int,int)的函数指针</span></span></span><br></pre></td></tr></table></figure></li></ul><h3 id="std-bind应用"><a href="#std-bind应用" class="headerlink" title="std::bind应用"></a>std::bind应用</h3><p>std::bind可以看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表。</p><p>std::bind将可调用对象与其参数一起进行绑定，绑定后的结果可以使用std::function保存。std::bind主要有以下两个作用：</p><ul><li><p>将可调用对象和其参数绑定成一个仿函数；</p></li><li><p>只绑定部分参数，减少可调用对象传入的参数。</p><p>调用bind的一般形式：</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure><p>该形式表达的意思是：当调用newCallable时，会调用callable，并传给它arg_list中的参数。</p><p>需要注意的是：arg_list中的参数可能包含形如n的名字。其中n是一个整数，这些参数是占位符，表示newCallable的参数，它们占据了传递给newCallable的参数的位置。数值n表示生成的可调用对象中参数的位置：1为newCallable的第一个参数，_2为第二个参数，以此类推。</p><p><strong>总结：</strong></p><ul><li>预绑定的参数是以值传递的形式，不预绑定的参数要用std::placeholders(占位符)的形式占位，从_1开始，依次递增，是以引用传递的形式；</li><li>std::placeholders表示新的可调用对象的第几个参数，而且与原函数的该占位符所在位置的进行匹配；</li><li>bind绑定类成员函数时，第一个参数表示对象的成员函数的指针，第二个参数表示对象的地址，<strong>这是因为对象的成员函数需要有this指针。</strong>并且编译器不会将对象的成员函数隐式转换成函数指针，需要通过&amp;手动转换；</li><li>std::bind的返回值是可调用实体，可以直接赋给std::function。</li></ul><p>细节见：<a href="https://blog.csdn.net/qq_38410730/article/details/103637778">https://blog.csdn.net/qq_38410730/article/details/103637778</a></p><h3 id="lamda表达式"><a href="#lamda表达式" class="headerlink" title="lamda表达式"></a>lamda表达式</h3><p>lambda 表达式可以说是 c++11 引用的最重要的特性之一，它定义了一个匿名函数，可以捕获一定范围的变量在函数内部使用，一般有如下语法形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [capture] (params) opt -&gt; ret </span><br></pre></td></tr></table></figure><p>其中 func 是可以当作 lambda 表达式的名字，作为一个函数使用，capture 是捕获列表，params 是参数表，opt 是函数选项(mutable 之类)， ret 是返回值类型，func_body 是函数体。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> func1 = [](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> func2 = [](<span class="type">int</span> a) &#123; <span class="keyword">return</span> a + <span class="number">2</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">func1</span>(<span class="number">1</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">func2</span>(<span class="number">2</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>lambda 表达式允许捕获一定范围内的变量：</p><ul><li>[]不捕获任何变量</li><li>[&amp;]引用捕获，捕获外部作用域所有变量，在函数体内当作引用使用</li><li>[=]值捕获，捕获外部作用域所有变量，在函数内内有个副本使用</li><li>[=, &amp;a]值捕获外部作用域所有变量，按引用捕获 a 变量  </li><li>[a]只值捕获 a 变量，不捕获其它变量 </li><li>[this]捕获当前类中的 this 指针</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=]()&#123; <span class="keyword">return</span> a; &#125;; <span class="comment">// 值捕获 a</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">auto</span> f2 = [=]() &#123; <span class="keyword">return</span> a++; &#125;; <span class="comment">// 修改按值捕获的外部变量，error</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> a++; &#125;;</span><br></pre></td></tr></table></figure><p><strong>代码中的 f2 是编译不过的，因为我们修改了按值捕获的外部变量，其实 lambda 表达式就相当于是一个仿函数，仿函数是一个有 operator()成员函数的类对象，这个 operator()默认是 const 的，所以不能修改成员变量，而加了 mutable，就是去掉const 属性。</strong></p><p>lamda还可以用作sort之类的函数的比较参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="type">const</span> <span class="type">int</span>&amp; a,<span class="type">const</span> <span class="type">int</span>&amp; b)&#123;<span class="keyword">return</span> a&lt;b;&#125;);</span><br></pre></td></tr></table></figure><h3 id="std-function和lamda的比较"><a href="#std-function和lamda的比较" class="headerlink" title="std::function和lamda的比较"></a>std::function和lamda的比较</h3><p>lamda因为是匿名对象，生命周期只存在于当前作用域，所以其适用于写一个简单函数，此函数不复用，只用于当前作用域，比较灵活方便</p><p>std::function则更具有普遍性，可以包装<strong>函数，函数指针，bind，lamda，仿函数</strong>这五种可调用对象，尤其是在c++中要实现回调函数，一定要用std::function</p><hr><h2 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h2><p>C++中的struct相比C中有了很多新增功能，它可以有成员函数，也可以继承，也可以实现多态</p><p>和class的区别主要是：</p><ul><li>struct默认public，而class默认private</li><li>class可以用作定义模板时代替typename，struct不可以</li></ul><hr><h2 id="内联函数和宏函数展开"><a href="#内联函数和宏函数展开" class="headerlink" title="内联函数和宏函数展开"></a>内联函数和宏函数展开</h2><h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>由于普通的函数被调用时，要压函数栈，并且寄存器保存变量等比较浪费性能，所以对于比较短的函数可以使用内联函数，它可以在编译时展开，不需要调用函数压栈这些。</p><ul><li>内联函数在<strong>编译时</strong>展开，节省性能</li><li>内联函数声明和实现应该放在一起，放在头文件中，inline关键字</li><li>内联函数适用于比较短（十行以内的函数）</li><li>内联函数通过<strong>编译器</strong>控制实现的，宏是<strong>预处理</strong>时实现的</li><li>内联函数也是和宏展开一样，在每一个调用处都展开一遍，比较浪费内存（空间换时间）</li><li>内联函数是可以调试的，弥补了宏展开的不足</li></ul><h3 id="宏函数展开"><a href="#宏函数展开" class="headerlink" title="宏函数展开"></a>宏函数展开</h3><ul><li>宏展开只是简单的二进制字符串替换</li><li>宏展开是在<strong>预处理</strong>时完成的，运行时不花费时间</li><li>宏展开没有类型</li><li>宏展开和内联函数一样，在每一个它替换的地方都展开一遍，浪费内存</li></ul><hr><h2 id="const用法和与宏的区别"><a href="#const用法和与宏的区别" class="headerlink" title="const用法和与宏的区别"></a>const用法和与宏的区别</h2><p><strong>const作用：限制类型</strong></p><ol><li>const仅仅用来修饰右边的变量（基本数据变量p，指针变量*p）</li><li>被const修饰的变量是只读的</li></ol><p><strong>const的用法：</strong></p><ul><li><p>const修饰全局变量和数组，只能初始化不能被修改，他们是存放在<strong>全局数据区</strong>的</p></li><li><p>const修饰局部变量，是存放在<strong>栈</strong>上的，也是不可修改的</p></li><li><p>const修饰指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="type">int</span> *<span class="type">const</span> p ； p为只读，*p为变量。<span class="comment">//只看const右边是什么就行</span></span><br><span class="line"><span class="number">2.</span> <span class="type">const</span> <span class="type">int</span> *p ； *p为只读，p为变量。</span><br><span class="line"><span class="number">3.</span> <span class="type">int</span> <span class="type">const</span> * <span class="type">const</span> p ；*p、p都为只读。</span><br><span class="line"><span class="number">4.</span> <span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p ；*p、p都为只读。</span><br></pre></td></tr></table></figure></li><li><p>const修饰函数参数，表明该函数不能修改这个参数</p></li><li><p>const修饰成员函数，放在函数尾后，表明该成员函数不能修改成员变量</p></li></ul><p><strong>const和宏定义的区别</strong></p><ul><li><p>就定义常量说的话， const 定义的常数是变量也带类型， #define 定义的只是个常数不带类型。</p></li><li><p>就起作用的阶段而言，#define 是在编译的<strong>预处理</strong>阶段起作用，而 const 是在<strong>编译、运行</strong>的时候起作用。</p></li><li><p>就起作用的方式而言，#define 只是简单的字符串替换，没有类型检查。而 const 有对应的数据类型，是要进行判断的，可以避免一些低级的错误。 正因为 define 只是简单的字符串替换会导致边界效应，具体举例可以参考下面代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 2+3     <span class="comment">// 我们预想的 N 值是 5，我们这样使用 </span></span></span><br><span class="line">Ndouble a = N/<span class="number">2</span>;  <span class="comment">// 我们预想的  a 的值是 2.5，可实际上 a 的值是 3.5</span></span><br></pre></td></tr></table></figure></li><li><p>就空间占用而言， 例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14     <span class="comment">//预处理后 占用代码段空间</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">float</span> PI=<span class="number">3.14</span>;    <span class="comment">// 本质上还是一个 float，占用数据段间</span></span><br></pre></td></tr></table></figure></li><li><p>从代码调试的方便程度而言, const 常量可以进行调试的，#define 是不能进行调试的，因为在预编译阶段就已经替换掉了</p></li><li><p>从是否可以再定义的角度而言, const 不足的地方，是与生俱来的，const 不能重定义，而 #define 可以通过 #undef 取消某个符号的定义，再重新定义</p></li></ul><hr><h2 id="C11智能指针"><a href="#C11智能指针" class="headerlink" title="C11智能指针"></a>C11智能指针</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220807114227794.png" alt="image-20220807114227794"></p><p><strong>智能指针的本质是一个模板类，对普通指针进行了封装，通过在构造函数中初始化分配内存，在析构函数中释放内存，达到自己管理内存，不需要手动管理内存的效果</strong></p><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>shared_ptr通过引用计数来记录有多少个shared指针指向这块内存</p><p>具体原理和使用方法查看博客：</p><p><a href="https://blog.csdn.net/YYY_77/article/details/123299662">https://blog.csdn.net/YYY_77/article/details/123299662</a></p><p><strong>注意事项：</strong></p><ul><li><p>不要用同一个裸指针初始化多个shared_ptr，会造成内存二次释放的错误</p></li><li><p>尽量不要和裸指针进行混用（通过p.get()获得裸指针），除非是传入模板参数时使用（因为模板不能传入智能指针，编译器推测不出来）</p></li><li><p>不要再函数参数里创建shared_ptr,因为它的创建<strong>不是原子</strong>的，编译器会进行一些顺序上的优化，就有可能发生异常内存泄漏的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">processWidget</span>(std::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget),  <span class="comment">//潜在的资源泄露 </span></span><br><span class="line">              <span class="built_in">computePriority</span>());     </span><br><span class="line"><span class="comment">//编译器可能会执行以下顺序优化</span></span><br><span class="line">执行“<span class="keyword">new</span> Widget”。</span><br><span class="line">执行computePriority。<span class="comment">//如果再这一步抛出异常，那么已经new了的widget就会泄露</span></span><br><span class="line">执行std::shared_ptr的构造函数。</span><br></pre></td></tr></table></figure><p><strong>可以使用make_shared（）来避免</strong></p></li><li><p>避免循环引用</p></li><li><p>线程安全问题（make_shared和引用计数加锁处理）</p></li><li><p>通过 shared_from_this()返回 this 指针，不要把 this 指针作为 shared_ptr 返回出来，因为this 指针本质就是裸指针，通过 this 返回可能 会导致重复析构，不能把 this 指针交给智能指针管理。</p></li><li><p>不要 delete get()返回来的裸指针。</p></li></ul><p><a href="https://blog.csdn.net/yagerfgcs/article/details/72886630">https://blog.csdn.net/yagerfgcs/article/details/72886630</a></p><p><a href="https://blog.csdn.net/bureau123/article/details/121300979">https://blog.csdn.net/bureau123/article/details/121300979</a></p><h3 id="make-shared-优势"><a href="#make-shared-优势" class="headerlink" title="make_shared()优势"></a>make_shared()优势</h3><ul><li>提升性能，通过裸指针创建shared_ptr实际上需要new两次（第一次new目标对象，第二次new引用计数），而make_shared()只需要new一次（把他们俩的内存一起分配了），并且它内部还使用了placement new（就是内存池那种用到再切一块），提高了性能</li><li>异常安全，就是上文提到的，因为shared_ptr裸指针创建不是<strong>原子的</strong>，在编译器的优化下会存在内存泄漏，而make_shared（）就是保证了这个时间的原子性</li></ul><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr本身也是一个模板类，但是不能直接用它来定义一个智能指针的对象，只能配合shared_ptr来使用，可以将shared_ptr的对象赋值给weak_ptr，并且这样并不会改变引用计数的值。查看weak_ptr的代码时发现，它主要有lock、swap、reset、expired、operator=、use_count几个函数，与shared_ptr相比多了lock、expired函数，但是却少了get函数，甚至连operator* 和 operator-&gt;都没有，可用的函数数量少的可怜，下面通过一些例子来了解一下weak_ptr的具体用法。</p><p><strong>注意点：</strong></p><ul><li>weak_ptr虽然是一个模板类，但是不能用来直接定义指向原始指针的对象。</li><li>weak_ptr接受shared_ptr类型的变量赋值，但是反过来是行不通的，需要使用lock函数</li><li>weak_ptr设计之初就是为了服务于shared_ptr的，所以不增加引用计数就是它的核心功能。</li><li>由于不知道什么之后weak_ptr所指向的对象就会被析构掉，所以使用之前请先使用expired函数检测一下。</li></ul><p><strong>核心函数：</strong></p><ul><li>expired（），由于weak_ptr指向的对象有可能已经被析构掉了，所以每次使用前要使用expired来判断是否已经过期了</li><li>lock(),如果是可用的，使用lock()函数获得对应shared_ptr的指针</li></ul><p><a href="https://blog.csdn.net/albertsh/article/details/82286999">https://blog.csdn.net/albertsh/article/details/82286999</a></p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p><strong>它持有对对象的独有权，即两个 unique_ptr 不能指向一个对象，不能进行复制操作只能进行移动操作。</strong></p><p>unique_ptr 之所以叫这个名字，是因为它<strong>只能指向一个对象</strong>，即当它指向其他对象时，之前所指向的对象会被摧毁。其次，当 unique_ptr 超出作用域时，指向的对象也会被自动摧毁，帮助程序员实现了自动释放的功能。</p><p>unique_ptr 也可能还未指向对象，这时的状态被称为 empty。</p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h3><p><a href="https://blog.csdn.net/xp178171640/article/details/102674428">https://blog.csdn.net/xp178171640/article/details/102674428</a></p><hr><h2 id="C11-nullptr"><a href="#C11-nullptr" class="headerlink" title="C11 nullptr"></a>C11 nullptr</h2><p>C11新增了空指针nullptr，之前的NULL实际上是一个int值0，会产生而意性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func ptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;func i&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>); <span class="comment">// 编译失败，会产生二义性</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>); <span class="comment">// 输出 func ptr</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="C11-final和override和explicit"><a href="#C11-final和override和explicit" class="headerlink" title="C11 final和override和explicit"></a>C11 final和override和explicit</h2><p>final关键字修饰类（放在类名后边）表明这个类不能被继承</p><p>override用于成员函数重写（放在函数名后边），表明重写父类的虚函数</p><p>explicit只能修饰构造函数，表明只能显示构造，不能隐式转换</p><hr><h2 id="C11-constexpr和const区别"><a href="#C11-constexpr和const区别" class="headerlink" title="C11 constexpr和const区别"></a>C11 constexpr和const区别</h2><p>constexpr是编译期常量，而const可以是编译器或运行期常量</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这种const就是编译器常量，会在编译期就生成一个ci的内存地址，它=100，且不能改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//这种const就是运行时常量，它只是保证了在运行期间ci不能改而已</span></span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = a;cpp</span><br></pre></td></tr></table></figure><p>constexpr说明了对象是一个变量，程序运行期间不会改变他的值，并且在编译期间就能知道该对象的值是多少。（可以将其理解为第一类const）</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;面试八股C-篇&quot;&gt;&lt;a href=&quot;#面试八股C-篇&quot; class=&quot;headerlink&quot; title=&quot;面试八股C++篇&quot;&gt;&lt;/a&gt;面试八股C++篇&lt;/h1&gt;&lt;h2 id=&quot;define和const区别&quot;&gt;&lt;a href=&quot;#define和const区别&quot; c</summary>
      
    
    
    
    <category term="C++" scheme="http://icecorn.github.io/categories/C/"/>
    
    
    <category term="面试八股" scheme="http://icecorn.github.io/tags/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第九课-高级动画技术</title>
    <link href="http://icecorn.github.io/2022/08/01/Games-104/Games104--%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF9/"/>
    <id>http://icecorn.github.io/2022/08/01/Games-104/Games104--%E9%AB%98%E7%BA%A7%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF9/</id>
    <published>2022-08-01T09:25:10.000Z</published>
    <updated>2022-08-07T16:27:09.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="高级动画技术"><a href="#高级动画技术" class="headerlink" title="高级动画技术"></a>高级动画技术</h1><h2 id="动画混合"><a href="#动画混合" class="headerlink" title="动画混合"></a>动画混合</h2><p>不同的动画怎么给它进行一个有效的组织呢？比如从走到跑，避免直接切换观感突兀，所以要进行线性插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802095342177.png" alt="image-20220802095342177"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802095422279.png" alt="image-20220802095422279"></p><p>根据速度计算两个动画的权重，从而用于插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802095715844.png" alt="image-20220802095715844"></p><p>步进也要保持一致，就是说在走的动画里的抬脚落脚要和跑的动画里的抬脚落脚要对上，避免出现滑步问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802100001128.png" alt="image-20220802100001128"></p><h2 id="混合空间"><a href="#混合空间" class="headerlink" title="混合空间"></a>混合空间</h2><h3 id="一维混合空间"><a href="#一维混合空间" class="headerlink" title="一维混合空间"></a>一维混合空间</h3><p>一维的动画混合空间，就是说可以有多个采样动画，比如往左走，往前走，往右走这些动画，我们可以根据指令的输入来进行插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802100214875.png" alt="image-20220802100214875"></p><h3 id="二维混合空间"><a href="#二维混合空间" class="headerlink" title="二维混合空间"></a>二维混合空间</h3><p>如果又要表达出往左右走，又要有走和跑的表达呢？就可以用二维混合空间来表达，如下图，在二维区域上确定唯一的坐标，然后进行插值。至于怎么插值，我们可以用delaunay三角剖分将平面区域分成三角形，这样对于任意二位点，我们只要判断它在哪个三角形里，使用三角形的三个顶点插值即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802100547277.png" alt="image-20220802100547277"></p><h3 id="Blend-Mask"><a href="#Blend-Mask" class="headerlink" title="Blend Mask"></a>Blend Mask</h3><p>比如有一个鼓掌的动画，我们的需求是在人物任何姿势都可以鼓掌，但是我们不可能为每个姿势都做一个鼓掌动画。我们可以用blend mask，就是上半身只应用鼓掌动画，下半身骨骼用别的动画进行一个复合，实现效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802101200036.png" alt="image-20220802101200036"></p><h3 id="Additive-Blending"><a href="#Additive-Blending" class="headerlink" title="Additive Blending"></a>Additive Blending</h3><p>就是在最后再叠加一层动画，比如点头，因为我们需要让点头这个动作和模型的朝向相关，所以在最后再叠加一个动画。</p><hr><h2 id="动作状态机"><a href="#动作状态机" class="headerlink" title="动作状态机"></a>动作状态机</h2><p>Animation State Machine</p><p>比如Jump动画，因为我们不知道跳多久落地，一个台阶或是10个台阶。所以我们做三个动画，分别是起跳，空中过程，落地。它们在三个状态有序的变化，</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802102233854.png" alt="image-20220802102233854"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802102426075.png" alt="image-20220802102426075"></p><p>为了适应切动画时多种需求，比如说跳起在空中要停一下在落下，我们可以设置多种不同的插值曲线在两个动画之间。这个有点类似ps里边两个图片之间切换淡入淡出啊这些东西，目的都是达到我们想要的并且丝滑的效果。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802102757539.png" alt="image-20220802102757539"></p><hr><h2 id="动画混合树"><a href="#动画混合树" class="headerlink" title="动画混合树"></a>动画混合树</h2><p>这块没咋理解，先放着把</p><hr><h2 id="IK技术"><a href="#IK技术" class="headerlink" title="IK技术"></a>IK技术</h2><p>反向动力学</p><p>有约束的运动，比如握着一个把手，身体跟着运动</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802112853795.png" alt="image-20220802112853795"></p><p>为了确保人走路脚一定能踩到某一个点上（加约束），那么我们可以根据大腿和小腿的长度，和大腿根到目标点的连线确定一个三角形，算出角度。</p><p>当然在三维空间存在很多满足条件的三角形，这时我们要给定一个朝向，这样我们就能确定唯一的姿势了。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802113243120.png" alt="image-20220802113243120"></p><p>IK技术貌似就是解各种约束下的方程（各个关节的约束），最后解出姿势。</p><p>很多启发式方法</p><p>这个地方没看懂，以后再看把==</p><hr><h2 id="表情动画"><a href="#表情动画" class="headerlink" title="表情动画"></a>表情动画</h2><p>把表情定义出不同的动作单元，来组合出各种各样的表情</p><p>28个AU</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802115437376.png" alt="image-20220802115437376"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;高级动画技术&quot;&gt;&lt;a href=&quot;#高级动画技术&quot; class=&quot;headerlink&quot; title=&quot;高级动画技术&quot;&gt;&lt;/a&gt;高级动画技术&lt;/h1&gt;&lt;h2 id=&quot;动画混合&quot;&gt;&lt;a href=&quot;#动画混合&quot; class=&quot;headerlink&quot; title=&quot;动</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第八课-动画技术基础</title>
    <link href="http://icecorn.github.io/2022/07/31/Games-104/Games104--%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%808/"/>
    <id>http://icecorn.github.io/2022/07/31/Games-104/Games104--%E5%8A%A8%E7%94%BB%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%808/</id>
    <published>2022-07-31T09:25:10.000Z</published>
    <updated>2022-08-07T16:19:51.150Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动画技术基础"><a href="#动画技术基础" class="headerlink" title="动画技术基础"></a>动画技术基础</h1><h2 id="2D动画"><a href="#2D动画" class="headerlink" title="2D动画"></a>2D动画</h2><p>Live2D：</p><ul><li>图元设置深度值，控制图元是否可见</li><li>用网格来控制图元，比如说眉毛舒展还是皱起来，其实就是参数化映射</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730005858572.png" alt="image-20220730005858572"></p><hr><h2 id="3D动画"><a href="#3D动画" class="headerlink" title="3D动画"></a>3D动画</h2><p>动画的核心就是对刚体运动的表达，刚体在不同自由度上运动</p><p>6D眼镜其实就是6个自由度，上下左右前后</p><h3 id="基于顶点的动画"><a href="#基于顶点的动画" class="headerlink" title="基于顶点的动画"></a>基于顶点的动画</h3><p>模拟旗帜随风飘扬是，除了基于物理的动画，也有基于顶点的动画</p><p>把每一个顶点随着时间变化的位置存下来，一般会存两个texture</p><p>横坐标就是顶点数量，比如10000个顶点，纵坐标是每一帧的offset，这样每一帧顶点位置有改变，那么法向就会改变，所以为了方便，可以再来一张texture，来存每个顶点的法向每一帧的变化</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730010412043.png" alt="image-20220730010412043"></p><h3 id="Morph-Target-顶点动画"><a href="#Morph-Target-顶点动画" class="headerlink" title="Morph Target 顶点动画"></a>Morph Target 顶点动画</h3><p>关键帧插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730092617176.png" alt="image-20220730092617176"></p><h3 id="蒙皮动画"><a href="#蒙皮动画" class="headerlink" title="蒙皮动画"></a>蒙皮动画</h3><p>通过骨骼驱动网格形变</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730092912146.png" alt="image-20220730092912146"></p><h3 id="基于物理的动画"><a href="#基于物理的动画" class="headerlink" title="基于物理的动画"></a>基于物理的动画</h3><p>比如衣服模拟，流体模拟</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730093016506.png" alt="image-20220730093016506"></p><h3 id="动画实现方式"><a href="#动画实现方式" class="headerlink" title="动画实现方式"></a>动画实现方式</h3><ul><li>关键帧动画</li><li>动捕</li></ul><hr><h2 id="蒙皮动画的实现"><a href="#蒙皮动画的实现" class="headerlink" title="蒙皮动画的实现"></a>蒙皮动画的实现</h2><p>一般在VS中去算顶点位置</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730093434835.png" alt="image-20220730093434835"></p><p>模型坐标系，世界坐标系，局部坐标系localSpace（每一根骨骼的坐标系）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730093720822.png" alt="image-20220730093720822"></p><p>骨骼树状图，一般根设置在胯部</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730094220210.png" alt="image-20220730094220210"></p><p>实际上我们存储的是关节，两个关节之间定义一根骨骼</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730094411736.png" alt="image-20220730094411736"></p><p>一个标准角色骨骼大概100个左右，但是为了实现复杂的表情变化，面部可能搞了一堆骨骼</p><p>root骨骼一般放在两脚之间，四足动物的话放在肚子下面</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730094630221.png" alt="image-20220730094630221"></p><p>绑定动画，绑定两个模型，比如人进入汽车，那么就会有一帧人的屁股绑定在车上，他俩一起动</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730094914993.png" alt="image-20220730094914993"></p><p>关节pos</p><p>有9个自由度，区别于刚体只有平移旋转，还可以放缩</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730095125114.png" alt="image-20220730095125114"></p><hr><h2 id="3D旋转数学原理"><a href="#3D旋转数学原理" class="headerlink" title="3D旋转数学原理"></a>3D旋转数学原理</h2><h3 id="2D旋转"><a href="#2D旋转" class="headerlink" title="2D旋转"></a>2D旋转</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730095307892.png" alt="image-20220730095307892"></p><h3 id="3D旋转"><a href="#3D旋转" class="headerlink" title="3D旋转"></a>3D旋转</h3><h4 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h4><p>沿着x,y,z轴分别旋转，在叠加起来，这就是欧拉角</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730095413210.png" alt="image-20220730095413210"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220730140354962.png" alt="image-20220730140354962"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731112128417.png" alt="image-20220731112128417"></p><p><strong>缺点：</strong></p><ul><li>欧拉角的计算有严格的顺序依赖，必须约定好顺序，比如z,x,y（所以排列组合一共有6种顺规）</li><li>万象锁：当沿着Y轴旋转90度后，x轴和z轴会重合，使得欧拉角退化变成两个自由度</li><li>很难去插值</li><li>很难去叠加，就是先旋转多少度，再旋转多少度</li><li>不能沿着任意轴旋转</li></ul><h4 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h4><p>对于二维空间的旋转，我们把向量alpha = a +bi, beta = c+di，用复平面表示，这时可以看出a就是cos(alpha),b就是sin(alpha)，所以看右下角构造旋转矩阵作用于beta向量就完成了旋转，而且这个结果恰恰等于两复数相乘！</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731112933833.png" alt="image-20220731112933833"></p><p>对于三维空间</p><p>四元数表达，一个实部，三个虚部，从二维推广一下，两个四元数相乘可以转化为坐下角的左乘一个矩阵这样。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731113633247.png" alt="image-20220731113633247"></p><p>欧拉角转换成四元数，用的都是半角</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731172218251.png" alt="image-20220731172218251"></p><p>如果是一个4维空间的向量，旋转的话直接两个四元数相乘就可以</p><p>但是对于一个三维空间的向量V,使用四元数旋转的话要类似SVD分解那样，左乘q又乘q的逆。这个也可以理解成因为我们要的三维向量时有三个系数（虚部的三个），但是四元数是一个vec4，我们要把它的实部变成0，这样它才是一个在三维空间有意义的向量，如果实部不为0，那么实际上它是一个四维空间的矢量，我们就不能用了。而用一个q作用与V时，得到的结果实部是不为0的，或者说我们旋转到4维空间上去了，这是后我们应该再用一个q的逆取作用在结果上，两次旋转就把实部的值给抵消掉，变成0了，这样我们就得到了一个旋转后的三维空间的向量，这也是为什么要旋转半角的原因。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731175021665.png" alt="image-20220731175021665"></p><p>几种应用场景：</p><ul><li>逆旋转，就是虚部相反的q即可，即共轭</li><li>旋转的叠加，连着乘就行</li><li>求两个单位向量的旋转四元数，先求出旋转轴W作为虚部，在用下方公式算出实部</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731175918805.png" alt="image-20220731175918805"></p><p>给定轴计算四元数，和旋转后向量，实部就是cos(theta/2),虚部就是sin(theta/2)*对应轴的分量，至于为什么是半角，上边有说，就是要把结果的实部抵消成0</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731180307791.png" alt="image-20220731180307791"></p><hr><h2 id="关节与蒙皮"><a href="#关节与蒙皮" class="headerlink" title="关节与蒙皮"></a>关节与蒙皮</h2><p>动画JointPose，主要是旋转的变化，平移（人的蹲起，弓箭）和放缩（大眼镜）不常用</p><p>旋转用四元数表达，可转化为3*4的矩阵，平移和放缩也可以用矩阵表达，最后组合成一个矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731182233249.png" alt="image-20220731182233249"></p><p>从根节点开始，一个骨骼一个骨骼算上来</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731182535101.png"></p><p>为了保证正确插值旋转，要在local space里进行插值，而不是Model space</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220731183901635.png" alt="image-20220731183901635"></p><p>关节点动了，皮肤上的点要跟着动，当然这是一根骨骼的情况</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220801084322449.png" alt="image-20220801084322449"></p><p>变换的时候要乘一个绑定矩阵的逆矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220801154854015.png" alt="image-20220801154854015"></p><p>从右往左看，一个模型空间的点（它绑定了一根骨骼），先左乘这根骨骼的逆绑定矩阵，变成local space中的点，然后左乘关节到模型空间的矩阵，变成新的模型空间的点，然后再左乘世界空间变换矩阵，变换到世界空间的点</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220801155312506.png" alt="image-20220801155312506"></p><h3 id="多根骨骼的情况"><a href="#多根骨骼的情况" class="headerlink" title="多根骨骼的情况"></a>多根骨骼的情况</h3><p>皮肤上的点可以绑定多根骨骼（一般不超过4个），他们的权重加起来要等于1，计算时根据每一个关节逆矩阵和当前的关节模型位置矩阵计算出皮肤上的点相对每一个绑定关节的<strong>模型空间上的坐标，然后进行插值，注意这个插值一定要在模型空间</strong>（因为local space每一个关节都不一样）</p><h3 id="动画插值"><a href="#动画插值" class="headerlink" title="动画插值"></a>动画插值</h3><h4 id="NLERP"><a href="#NLERP" class="headerlink" title="NLERP"></a>NLERP</h4><p>插值后要除以模，才是正确的NLERP</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220801162412672.png" alt="image-20220801162412672"></p><p>最短路径插值：因为旋转可以正反两个方向都行，所以我们规定一下，两个四元数点乘&gt;=0直接插值，&lt;0反向插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220801171149017.png" alt="image-20220801171149017"></p><h4 id="SLERP"><a href="#SLERP" class="headerlink" title="SLERP"></a>SLERP</h4><p>由于插值过程中角度变化不均匀，所以可以用slerp就是用角度来插值，但角度太小就会不敏感</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802091127322.png" alt="image-20220802091127322"></p><p><strong>实际动画中，角度大的时候用slerp，角度小的时候直接用nlerp，可以设置一个门限两种插值过度</strong></p><h4 id="动画管线"><a href="#动画管线" class="headerlink" title="动画管线"></a>动画管线</h4><p>CPU工作：</p><p>首先输入一堆clips（就是骨架的pos），然后我们就可以插值出它的上一帧和下一帧<br>然后算出每一个关节在local space的坐标<br>然后计算出在model space的坐标</p><p>GPU工作：</p><p>对每一个点（包括皮肤上的），应用上面算出的各种矩阵，算出当前帧在世界空间的坐标</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802091629132.png" alt="image-20220802091629132"></p><hr><h2 id="动画的压缩"><a href="#动画的压缩" class="headerlink" title="动画的压缩"></a>动画的压缩</h2><h3 id="关键帧压缩"><a href="#关键帧压缩" class="headerlink" title="关键帧压缩"></a>关键帧压缩</h3><p>对于动画来说，假设1s30帧，70个关节，那么就要存30*70个关节的放缩，平移，旋转的数据，这个数据量很大。</p><p>大部分的关节的放缩和平移其实都不变，可以不存</p><p>另外可以使用关键帧来处理，在关键帧之间插值，大部分是旋转</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802092233235.png" alt="image-20220802092233235"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802092752687.png" alt="image-20220802092752687"></p><p>这里感觉就是用一个三次样条（catmull曲线）来确定旋转的关键帧是哪些</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p>四元数4个float，要32个字节，比较费，用一些trick可以做到15个字节就能存了</p><h3 id="误差处理"><a href="#误差处理" class="headerlink" title="误差处理"></a>误差处理</h3><p>既然有压缩，就会损失一些精度，不同骨骼对于误差的敏感度是不同的，解决方案先不看了==</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802093342224.png" alt="image-20220802093342224"></p><h2 id="动画制作的流程"><a href="#动画制作的流程" class="headerlink" title="动画制作的流程"></a>动画制作的流程</h2><p>使用3dsMax，Maya等软件进行骨骼和网格的绑定，然后设计师会设置关键帧和时间间隔，这时候动画资产就可以导出了</p><p>要注意的是有人物跳跃时，我们要单独给root节点存一个位移曲线</p><p>然后可以进行导出，这也是引擎程序员做的主要工作，比如导出乘FBX格式文件</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220802093959360.png" alt="image-20220802093959360"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;动画技术基础&quot;&gt;&lt;a href=&quot;#动画技术基础&quot; class=&quot;headerlink&quot; title=&quot;动画技术基础&quot;&gt;&lt;/a&gt;动画技术基础&lt;/h1&gt;&lt;h2 id=&quot;2D动画&quot;&gt;&lt;a href=&quot;#2D动画&quot; class=&quot;headerlink&quot; title=&quot;2</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>算法系列|经典题目合集</title>
    <link href="http://icecorn.github.io/2022/07/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/"/>
    <id>http://icecorn.github.io/2022/07/09/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E5%90%88%E9%9B%86/</id>
    <published>2022-07-09T09:25:10.000Z</published>
    <updated>2022-07-25T03:44:03.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="经典题目"><a href="#经典题目" class="headerlink" title="经典题目"></a>经典题目</h1><h2 id="二叉树最近公共祖先节点"><a href="#二叉树最近公共祖先节点" class="headerlink" title="二叉树最近公共祖先节点"></a>二叉树最近公共祖先节点</h2><p>剑指offer2–68</p><p>解题思路：</p><ul><li>思考递归的返回值的含义</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 若树里面存在p，也存在q，则返回他们的公共祖先。</span><br><span class="line"><span class="bullet">2.</span> 若树里面只存在p，或只存在q，则返回存在的那一个。</span><br><span class="line"><span class="bullet">3.</span> 若树里面即不存在p，也不存在q，则返回null。</span><br></pre></td></tr></table></figure><p>对每一个递归的元素先判断是否为null，为null返回null，如果为p或q，直接返回p或q</p><p>之后递归左右孩子，对左右孩子可能出现的情况进行讨论，分三种情况：<br>1.左右都为null，则说明左右子树都不包含p或q<br>2.如果左右一个为null，一个不为null，则返回不为null的那个<br>3.如果都不为null，说明左右子树分别包含了p和q，那么祖先自然就是root了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        root-&gt;right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp; root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>) <span class="keyword">return</span>  root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>( root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="盛水最多的容器lc-11"><a href="#盛水最多的容器lc-11" class="headerlink" title="盛水最多的容器lc-11"></a>盛水最多的容器lc-11</h3><p>思路就是对向的双指针，且每次求雨水面积，并且每次左右两边小的那个往中间移动</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> area = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> low = <span class="built_in">min</span>(height[l],height[r]);</span><br><span class="line">            area = <span class="built_in">max</span>(area,low*(r-l));</span><br><span class="line">            height[l]&lt;height[r]?l++:r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="三数之和lc-15"><a href="#三数之和lc-15" class="headerlink" title="三数之和lc-15"></a>三数之和lc-15</h3><p>思路是固定一个数，然后另外两个对象双指针，往里走。要注意剪枝，负数，边界条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;<span class="comment">//注意i&gt;0</span></span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[l]+nums[r]&gt;-nums[i]) r--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[l]+nums[r]&lt;-nums[i]) l++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;<span class="comment">//注意l&lt;r,只要双指针就要带判断条件</span></span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r+<span class="number">1</span>]) r--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="删除倒数第N个节点lc-19"><a href="#删除倒数第N个节点lc-19" class="headerlink" title="删除倒数第N个节点lc-19"></a>删除倒数第N个节点lc-19</h3><p><strong>很多链表的题有一个共性就是有时候要操作头节点，这时候就要考虑没有头节点的情况，很麻烦，我们可以采用新建一个node指向头节点这种方法避免考虑头节点的特殊性，最后返回dummy-&gt;next就可以啦</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* dummy =<span class="keyword">new</span> <span class="built_in">ListNode</span>();<span class="comment">//这里新建一个节点充当头节点</span></span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        ListNode* prey = dummy;<span class="comment">//同时也方便了prey的操作</span></span><br><span class="line">        <span class="keyword">while</span>(n--) fast = fast-&gt;next;     </span><br><span class="line">        <span class="keyword">while</span>(fast)</span><br><span class="line">        &#123;   </span><br><span class="line">            fast=fast-&gt;next;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            prey=prey-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        prey-&gt;next = head-&gt;next;</span><br><span class="line">        <span class="built_in">delete</span>(head);</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/yi-wen-dai-ni-shua-bian-er-fen-cha-zhao-dtadq/">https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/yi-wen-dai-ni-shua-bian-er-fen-cha-zhao-dtadq/</a></p><h3 id="旋转数组找target-lc-33"><a href="#旋转数组找target-lc-33" class="headerlink" title="旋转数组找target lc-33"></a>旋转数组找target lc-33</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">将数组一分为二，其中一定有一个是有序的，另一个可能是有序，也能是部分有序。</span></span><br><span class="line"><span class="string">此时有序部分用二分法查找。无序部分再一分为二，其中一个一定有序，另一个可能有序，可能无序。就这样循环.</span> </span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[l]&lt;=nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[l]&amp;&amp;target&lt;nums[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r]) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">几个注意点,二分模板</span><br><span class="line">while(l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line">if(nums[mid]==target) return mid;</span><br><span class="line">...</span><br><span class="line">l=mid+1;</span><br><span class="line">r=mid-1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="最小栈lc-155"><a href="#最小栈lc-155" class="headerlink" title="最小栈lc-155"></a>最小栈lc-155</h2><h3 id="双栈方法"><a href="#双栈方法" class="headerlink" title="双栈方法"></a>双栈方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(x);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单栈方法"><a href="#单栈方法" class="headerlink" title="单栈方法"></a>单栈方法</h3><p>单栈方法栈中存放 val-min ,再用一个min变量存放最小值 val - min = stk.top();</p><p>这样递推就好了，top</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; m_stk;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_min;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_min=val;</span><br><span class="line">            m_stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_stk.<span class="built_in">push</span>(val-m_min);</span><br><span class="line">            <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>) m_min=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            m_min -= m_stk.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>) <span class="keyword">return</span> m_min;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m_stk.<span class="built_in">top</span>()+m_min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>此类题代表lc207，lc210主要是判断有向图是否有环</p><p>可以使用dfs和bfs两种方法来处理</p><h3 id="DFS："><a href="#DFS：" class="headerlink" title="DFS："></a><strong>DFS：</strong></h3><p>dfs的思路其实就是暴力递归，把所有节点视为起点进行遍历，节点分为三种状态，状态0代表未访问过，状态1代表当前dfs路径中访问过的，状态2表示已经访问完的。如果在同一个dfs路径中又经过了状态1的节点，说明有环。</p><p>关于为什么要分状态1和状态2，比如1-&gt;2-&gt;3-&gt;4; 5-&gt;3;这种情况第一次dfs路径1234如果不把他们标记成状态2还是状态1的话，下一条路径53是就会错误的识别成有环状态</p><p>另外我们可以用valid进行剪枝，已经有环了就不用继续dfs下去了，同时其他路径也不用在开始dfs了</p><p>dfs方法最后拓扑排序我们在每次节点变成状态2时存，必然是递归到最后出度为0的点，这样的结果是倒序的，需要最后reverse或者用stack来存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//存储结果用的res，是倒序的，也可以用stack来存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;<span class="comment">//剪枝1</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//识别有环</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;<span class="comment">//这里valid剪枝2</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">//逆序输出</span></span><br><span class="line">        <span class="keyword">return</span> valid?res:vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="BFS"><a href="#BFS" class="headerlink" title="BFS:"></a><strong>BFS:</strong></h3><p>bfs的思路是先建立邻接矩阵，统计好所有节点的度，把所有度为0的节点入队，然后每次出队把当前节点连接的节点的度-1，如果为0的话就入队。每有一个出队就visit++，最终如果无环的环应该刚好每个节点visit一遍，也就是visit的值等于节点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pre:prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            indeg[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> visit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            visit++;</span><br><span class="line">            <span class="type">int</span> x= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; c:edges[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[c]==<span class="number">0</span>) q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visit==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>bfs比较好想且代码好写，并且稍微出队顺序就是拓扑排序的顺序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            visit++;</span><br><span class="line">            <span class="type">int</span> x= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(x);<span class="comment">//出队时加入节点就行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; c:edges[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[c]==<span class="number">0</span>) q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> res.<span class="built_in">size</span>()==numCourses?res:vector&lt;<span class="type">int</span>&gt;&#123;&#125;;<span class="comment">//有环的话输出空数组</span></span><br></pre></td></tr></table></figure><hr><h2 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h2><p>又叫字典树，用来存储字符串并且可以实现快速查找字符串及前缀</p><p><strong>实现方式就是26叉树</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;经典题目&quot;&gt;&lt;a href=&quot;#经典题目&quot; class=&quot;headerlink&quot; title=&quot;经典题目&quot;&gt;&lt;/a&gt;经典题目&lt;/h1&gt;&lt;h2 id=&quot;二叉树最近公共祖先节点&quot;&gt;&lt;a href=&quot;#二叉树最近公共祖先节点&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（五）|股票交易</title>
    <link href="http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/"/>
    <id>http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%E8%82%A1%E7%A5%A8%E4%BA%A4%E6%98%93/</id>
    <published>2022-07-08T09:25:10.000Z</published>
    <updated>2022-07-25T03:43:18.017Z</updated>
    
    <content type="html"><![CDATA[<h1 id="股票交易问题"><a href="#股票交易问题" class="headerlink" title="股票交易问题"></a>股票交易问题</h1><p>股票交易通常使用动态规划来解决</p><h2 id="买卖股票最佳时机一-LC-121"><a href="#买卖股票最佳时机一-LC-121" class="headerlink" title="买卖股票最佳时机一 LC-121"></a>买卖股票最佳时机一 LC-121</h2><p>给一个数组，某一天买入，某一天卖出，算最大利润</p><p>这个不用dp，直接遍历一边，每天保存最小的买入价，遍历一边即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> res=INT_MIN,minP = INT_MAX;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> p:prices)</span><br><span class="line">       &#123;</span><br><span class="line">           minP = <span class="built_in">min</span>(minP,p);</span><br><span class="line">           res = <span class="built_in">max</span>(res,p-minP);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="买卖股票最佳时机二-LC122"><a href="#买卖股票最佳时机二-LC122" class="headerlink" title="买卖股票最佳时机二 LC122"></a>买卖股票最佳时机二 LC122</h2><p>本题是能买卖无数次，但是同时只能买一只股票</p><p>dp来做，有两个状态，所以开两个vector</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>]表示当天有股票的情况最大利润，dp[i][<span class="number">1</span>]表示当天无股票情况最大利润</span><br><span class="line">计算总利润时，买入就是-price[i]，卖出就是+price[i]</span><br><span class="line">初始条件dp[<span class="number">0</span>][<span class="number">0</span>] = -price[<span class="number">0</span>]</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>观察状态转移方程之和前一位有关，所以用两个变量代替两个数组即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> f0 = -prices[<span class="number">0</span>];</span><br><span class="line"> <span class="type">int</span> f1=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> nf0 = <span class="built_in">max</span>(f0,f1-prices[i]);</span><br><span class="line">     f1 = <span class="built_in">max</span>(f1,f0+prices[i]);</span><br><span class="line">     f0 = nf0;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> f1;</span><br></pre></td></tr></table></figure><h2 id="买卖股票最佳时机三-LC123"><a href="#买卖股票最佳时机三-LC123" class="headerlink" title="买卖股票最佳时机三 LC123"></a>买卖股票最佳时机三 LC123</h2><p>这题条件是只能交易两次</p><p>因此有五种状态</p><ul><li>没买入</li><li>买入一次 buy1</li><li>卖出一次 sell1</li><li>买入两次 buy2</li><li>卖出两次 sell2</li></ul><p>通过五种状态很容易得到状态转移方程，<strong>要注意的是初始值buy2= -price[0]，这是因为在第一天买入一次卖出一次收益为0，再买入一次收益自然是-price[0]</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> buy1 = -prices[<span class="number">0</span>], sell1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> buy2 = -prices[<span class="number">0</span>], sell2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy1 = <span class="built_in">max</span>(buy1, -prices[i]);</span><br><span class="line">            sell1 = <span class="built_in">max</span>(sell1, buy1 + prices[i]);</span><br><span class="line">            buy2 = <span class="built_in">max</span>(buy2, sell1 - prices[i]);</span><br><span class="line">            sell2 = <span class="built_in">max</span>(sell2, buy2 + prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="买入股票最佳时机四-LC-188"><a href="#买入股票最佳时机四-LC-188" class="headerlink" title="买入股票最佳时机四 LC-188"></a>买入股票最佳时机四 LC-188</h2><p>本题条件是最多交易k次，解法和3类似，升一维建立二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = prices.<span class="built_in">size</span>();</span><br><span class="line">        k = <span class="built_in">min</span>(k, n / <span class="number">2</span>);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buy</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sell</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(k + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        buy[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        sell[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">            buy[<span class="number">0</span>][i] = sell[<span class="number">0</span>][i] = INT_MIN / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            buy[i][<span class="number">0</span>] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>][<span class="number">0</span>], sell[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">                buy[i][j] = <span class="built_in">max</span>(buy[i - <span class="number">1</span>][j], sell[i - <span class="number">1</span>][j] - prices[i]);</span><br><span class="line">                sell[i][j] = <span class="built_in">max</span>(sell[i - <span class="number">1</span>][j], buy[i - <span class="number">1</span>][j - <span class="number">1</span>] + prices[i]);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(sell[n - <span class="number">1</span>].<span class="built_in">begin</span>(), sell[n - <span class="number">1</span>].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="含冷冻期的最大利润-LC-309"><a href="#含冷冻期的最大利润-LC-309" class="headerlink" title="含冷冻期的最大利润 LC-309"></a>含冷冻期的最大利润 LC-309</h2><p>有三个状态：</p><ul><li>此时有股票</li><li>此时无股票，且在冷冻期</li><li>此时无股票，且不在冷冻期</li></ul><p>想清楚每种状态怎么转移就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//有股票：要么上一天也有股票，要么是今天买的，既然今天能买，那么上一天必须不在冷冻期</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);</span><br><span class="line">            <span class="comment">//无股票且在冷冻期：必须是上一天把股票卖了</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];</span><br><span class="line">            <span class="comment">//无股票且不在冷冻期：从上一天也是无股票状态转移过来，因为前一天如果有股票但今天无股票的话那么今天必然在冷冻期，有矛盾所以不能从有股票状态转移过来</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可用三个变量优化</p><h2 id="股票交易含手续费-LC714"><a href="#股票交易含手续费-LC714" class="headerlink" title="股票交易含手续费 LC714"></a>股票交易含手续费 LC714</h2><p>和二相比，只是多了一个手续费而已</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">&#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">0</span>]+prices[i]-fee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][<span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;股票交易问题&quot;&gt;&lt;a href=&quot;#股票交易问题&quot; class=&quot;headerlink&quot; title=&quot;股票交易问题&quot;&gt;&lt;/a&gt;股票交易问题&lt;/h1&gt;&lt;p&gt;股票交易通常使用动态规划来解决&lt;/p&gt;
&lt;h2 id=&quot;买卖股票最佳时机一-LC-121&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（六）|二叉树前中后序遍历--迭代法</title>
    <link href="http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    <id>http://icecorn.github.io/2022/07/08/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</id>
    <published>2022-07-08T09:25:10.000Z</published>
    <updated>2022-07-25T06:05:58.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉树的前中后序遍历"><a href="#二叉树的前中后序遍历" class="headerlink" title="二叉树的前中后序遍历"></a>二叉树的前中后序遍历</h1><p>迭代法的二叉树前中后序遍历</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *right = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">TreeNode</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法前序遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preyorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    stack&lt;TreeNode *&gt; stk;</span><br><span class="line">    stk.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = stk.<span class="built_in">top</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法中序遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    <span class="comment">//当前结点不为空或者栈不为空</span></span><br><span class="line">    <span class="comment">//也就是说，循环结束条件是：</span></span><br><span class="line">    <span class="comment">//当前结点为空且栈为空</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果当前结点不为空，那么就放入栈，</span></span><br><span class="line">        <span class="comment">//然后当前指针指向其左孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前结点为空，说明已经到目前最左的尽头，</span></span><br><span class="line">        <span class="comment">//那么指向栈顶元素</span></span><br><span class="line">        <span class="comment">//此时的栈顶元素为以当前结点为根的子树的根</span></span><br><span class="line">        <span class="comment">//其左孩子因为已经为空，所以目前遍历根</span></span><br><span class="line">        <span class="comment">//遍历完后再让当前指针指向其右孩子结点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法后续遍历二叉树</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; ret;      <span class="comment">// ret保存遍历结果</span></span><br><span class="line">    stack&lt;TreeNode *&gt; st; <span class="comment">// st保存树的节点指针</span></span><br><span class="line">    TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *cur = root; <span class="comment">// cur指向当前遍历到的节点</span></span><br><span class="line">    <span class="comment">// cur不为空代表树没访问完， st不为空代表栈中还有数据</span></span><br><span class="line">    <span class="keyword">while</span> (cur || !st.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//遍历左子树</span></span><br><span class="line">        <span class="keyword">while</span> (cur)</span><br><span class="line">        &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(cur);    <span class="comment">//当前节点入栈</span></span><br><span class="line">            cur = cur-&gt;left; <span class="comment">//继续遍历左子树</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左子树遍历完，从栈顶取出cur并指向右子树继续遍历</span></span><br><span class="line">        TreeNode *top = st.<span class="built_in">top</span>();</span><br><span class="line">        <span class="comment">//右子树为null代表当前节点top左右子树都为空则输出，</span></span><br><span class="line">        <span class="comment">//但是可能死循环，因为判断节点右子树时可能会被访问两次</span></span><br><span class="line">        <span class="comment">//访问两次的标志就是当前节点的右树等于上一次访问的节点</span></span><br><span class="line">        <span class="keyword">if</span> (top-&gt;right == <span class="literal">nullptr</span> || top-&gt;right == prev)</span><br><span class="line">        &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(top-&gt;val);</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            prev = top;</span><br><span class="line">            cur = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur = top-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    root-&gt;val = <span class="number">3</span>;</span><br><span class="line">    TreeNode *n1 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n1-&gt;val = <span class="number">4</span>;</span><br><span class="line">    TreeNode *n2 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n2-&gt;val = <span class="number">5</span>;</span><br><span class="line">    TreeNode *n3 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n3-&gt;val = <span class="number">6</span>;</span><br><span class="line">    TreeNode *n4 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n4-&gt;val = <span class="number">7</span>;</span><br><span class="line">    TreeNode *n5 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n5-&gt;val = <span class="number">8</span>;</span><br><span class="line">    TreeNode *n6 = (TreeNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(TreeNode));</span><br><span class="line">    n6-&gt;val = <span class="number">9</span>;</span><br><span class="line">    root-&gt;left = n1;</span><br><span class="line">    root-&gt;right = n2;</span><br><span class="line">    n1-&gt;left = n3;</span><br><span class="line">    n1-&gt;right = n4;</span><br><span class="line">    n2-&gt;left = n5;</span><br><span class="line">    n2-&gt;right = n6;</span><br><span class="line">    n3-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n3-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    n4-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n4-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    n5-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n5-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    n6-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    n6-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; preyIt = <span class="built_in">preyorderTraversal</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; inIt = <span class="built_in">inorderTraversal</span>(root);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; postIt = <span class="built_in">postorderTraversal</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inIt.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; postIt[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;二叉树的前中后序遍历&quot;&gt;&lt;a href=&quot;#二叉树的前中后序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的前中后序遍历&quot;&gt;&lt;/a&gt;二叉树的前中后序遍历&lt;/h1&gt;&lt;p&gt;迭代法的二叉树前中后序遍历&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>图形学常见问题指针</title>
    <link href="http://icecorn.github.io/2022/07/05/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8C%87%E9%92%88/"/>
    <id>http://icecorn.github.io/2022/07/05/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%8C%87%E9%92%88/</id>
    <published>2022-07-05T09:25:10.000Z</published>
    <updated>2022-07-23T02:39:05.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="图形学常见问题指针"><a href="#图形学常见问题指针" class="headerlink" title="图形学常见问题指针"></a>图形学常见问题指针</h1><h2 id="透视矫正的推导"><a href="#透视矫正的推导" class="headerlink" title="透视矫正的推导"></a>透视矫正的推导</h2><p><a href="https://zhuanlan.zhihu.com/p/403259571">https://zhuanlan.zhihu.com/p/403259571</a></p><h2 id="透视除法与齐次坐标"><a href="#透视除法与齐次坐标" class="headerlink" title="透视除法与齐次坐标"></a>透视除法与齐次坐标</h2><p><a href="https://www.jianshu.com/p/7e701d7bfd79">https://www.jianshu.com/p/7e701d7bfd79</a></p><h2 id="法向变换矩阵的推导"><a href="#法向变换矩阵的推导" class="headerlink" title="法向变换矩阵的推导"></a>法向变换矩阵的推导</h2><p>在计算机图形学中，<a href="https://www.zhihu.com/search?q=%E6%B3%95%E5%90%91%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">法向量</a>（垂直于某个面的向量）有着广泛的应用，比如处理光照需要用到法向量来计算光线的<a href="https://www.zhihu.com/search?q=%E5%85%A5%E5%B0%84%E8%A7%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">入射角</a>，最终渲染出逼真的场景。</p><p>3D<a href="https://www.zhihu.com/search?q=%E5%BB%BA%E6%A8%A1&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">建模</a>工具设计出的模型文件一般都是包含了顶点坐标和每个面的法向量信息，也就是说法向量是已知的，模型一旦确定，每个面的法向量就确定了。但是，事情没有那么简单，场景要动起来才会丰富多彩，完全静止的东西往往缺乏生气，这就需要用到<a href="https://www.zhihu.com/search?q=%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">模型变换</a>，比如平移、缩放（等比例/不等比例）、旋转等，而不管如何变换，法向量和对应面的<a href="https://www.zhihu.com/search?q=%E5%9E%82%E7%9B%B4&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">垂直</a>关系必须成立，否则场景渲染的效果就会失真甚至完全不正常。</p><p>3D模型是由大量的<a href="https://www.zhihu.com/search?q=%E9%A1%B6%E7%82%B9%E5%9D%90%E6%A0%87&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">顶点坐标</a>组成的，只要模型变换矩阵乘以顶点坐标就完成了模型的变换，但是法向量却不能直接与模型变换矩阵相乘，因为向量是有向的线段，而顶点坐标仅仅表示一个点，这个本质的不同导致<a href="https://www.zhihu.com/search?q=%E5%8F%98%E6%8D%A2%E7%9F%A9%E9%98%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">变换矩阵</a>与法向量相乘后很可能不再和变换后的面垂直。</p><p>举个简单的例子，参见下图，假设针对3D模型做沿y轴向上平移1个单位的变换，向量p为垂直于其中某个面的法向量。如果向量p=(1,0)执行同样的平移操作，则变成了向量p’=(1,1)，p和p’并不是平行关系，显然针对法向量做相同的<a href="https://www.zhihu.com/search?q=%E5%B9%B3%E7%A7%BB%E5%8F%98%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">平移变换</a>之后，p’不可能再垂直于平移后的平面，因为平面沿y轴向上平移1个单位之后仍然与变换前平面平行。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-5c43f49040ee3be76a3534cba778ec79_b.jpg" alt="img"></p><p>这仅仅是平移变换带来的问题，还有众多其他类型的变换，不太可能分析所有变换对法向量的影响是怎样的，然后进行一一修正。显然，需要找到一种通用的方法来处理法向量的变换。</p><p>假设p0与p1是变换前某平面上的两个点，<a href="https://www.zhihu.com/search?q=%E5%88%87%E5%90%91%E9%87%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">切向量</a>s=p1−p0，与之垂直的法向量为n；p0’和p1’为p0和p1变换后的点，变换后的切向量s′=p1′−p0′，变换后法向量为n’，其中模型变换矩阵为M，<a href="https://www.zhihu.com/search?q=%E6%B3%95%E5%90%91%E9%87%8F%E5%8F%98%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">法向量变换</a>矩阵为M’，变换后n’与s’需要互相垂直。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710212522068.png" alt="image-20220710212522068"> </p><p>使用公式可以表示为：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-98f85d18e640a0f742d14ace76b8d6db_b.jpg" alt="img"></p><p>s’和n’互相垂直，可以得知n’和s’的点积为0，所以有：</p><p><img src="https://pic1.zhimg.com/v2-e0a4566106fae5036ca7b4ccb6c157b4_b.jpg" alt="img"></p><p>进一步对公式进行变换，可以得出：</p><p><img src="https://pic2.zhimg.com/v2-0c050d77bc6f8ca87ba4b5fb1d1dc851_b.jpg" alt="img"></p><blockquote><p>T表示矩阵的转置，就是将原矩阵的<a href="https://www.zhihu.com/search?q=%E8%A1%8C%E5%88%97%E4%BA%92%E6%8D%A2&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">行列互换</a></p></blockquote><p>由于n⋅s=nT×s可以得出M′×M=I，因为只有I×s=s，这样就可以保证公式始终成立。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-9b64678336e9bc95f6b606528ee7a86b_b.jpg" alt="img"></p><blockquote><p>I表示<a href="https://www.zhihu.com/search?q=%E5%8D%95%E4%BD%8D%E7%9F%A9%E9%98%B5&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22article%22,%22sourceId%22:%22479809019%22%7D">单位矩阵</a></p></blockquote><p>由M′T×M=I可得M′T=M−1，最终得出M′=(M−1)T，即法向量的变换矩阵为模型变换矩阵的逆转置矩阵。</p><p><img src="https://pic1.zhimg.com/v2-bc61269f943a6c50cad79936bd44a318_b.jpg" alt="img"></p><p>本文来自知乎：<br>作者：一点鑫得<br>链接：<a href="https://zhuanlan.zhihu.com/p/479809019">https://zhuanlan.zhihu.com/p/479809019</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;图形学常见问题指针&quot;&gt;&lt;a href=&quot;#图形学常见问题指针&quot; class=&quot;headerlink&quot; title=&quot;图形学常见问题指针&quot;&gt;&lt;/a&gt;图形学常见问题指针&lt;/h1&gt;&lt;h2 id=&quot;透视矫正的推导&quot;&gt;&lt;a href=&quot;#透视矫正的推导&quot; class=&quot;he</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="图形学" scheme="http://icecorn.github.io/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>PBR渲染管线详解</title>
    <link href="http://icecorn.github.io/2022/07/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6/PBR%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://icecorn.github.io/2022/07/04/%E5%9B%BE%E5%BD%A2%E5%AD%A6/PBR%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-04T09:25:10.000Z</published>
    <updated>2022-07-23T02:37:29.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PBR管线"><a href="#PBR管线" class="headerlink" title="PBR管线"></a>PBR管线</h1><p>基于物理的着色模型三要素</p><ol><li>基于微平面(Microfacet)的表面模型。</li><li>能量守恒。</li><li>应用基于物理的BRDF。</li></ol><h2 id="微表面模型"><a href="#微表面模型" class="headerlink" title="微表面模型"></a>微表面模型</h2><p>在微观尺度下，没有任何平面是完全光滑的。然而由于这些微平面已经微小到无法逐像素的继续对其进行区分，因此我们只有假设一个粗糙度(Roughness)参数，然后用统计学的方法来概略的估算微平面的粗糙程度。我们可以基于一个平面的粗糙度来计算出某个向量的方向与微平面平均取向方向一致的概率。</p><p>这个向量便是位于光线向量l和视线向量v之间的中间向量(Halfway Vector)。我们曾经在之前的[高级光照](<a href="https://learnopengl-cn.github.io/05">https://learnopengl-cn.github.io/05</a> Advanced Lighting/01 Advanced Lighting/)教程中谈到过中间向量，它的计算方法如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718213826545.png" alt="image-20220718213826545"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718213641496.png" alt="image-20220718213641496"></p><p>微平面的取向方向与中间向量的方向越是一致，镜面反射的效果就越是强烈越是锐利。然后再加上一个介于0到1之间的粗糙度参数，这样我们就能概略的估算微平面的取向情况了：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718213912201.png" alt="image-20220718213912201"></p><p>较高的粗糙度值显示出来的镜面反射的轮廓要更大一些。与之相反地，较小的粗糙值显示出的镜面反射轮廓则更小更锐利。</p><h2 id="能量守恒"><a href="#能量守恒" class="headerlink" title="能量守恒"></a>能量守恒</h2><p>微平面近似法使用了这样一种形式的能量守恒(Energy Conservation)：出射光线的能量永远不能超过入射光线的能量（发光面除外）。</p><p>为了遵守能量守恒定律，我们需要对<strong>漫反射光</strong>和<strong>镜面反射光</strong>之间做出明确的区分。</p><p>要注意的是漫反射实际上就是折射光的一部分，它们进入物体表面然后弹弹弹最终弹出表面，当然另一部分会消耗掉产生内能，这并不在我们的考虑范围内。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718214238611.png" alt="image-20220718214238611"></p><p><strong>在blinn-phong模型中我们并没有考虑能量守恒，而在PBR中，我们要严格控制镜面反射+漫反射=1</strong></p><p>首先计算镜面反射部分，它的值等于入射光线被反射的能量所占的百分比。然后折射光部分就可以直接由镜面反射部分计算得出：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220718214712609.png" alt="image-20220718214712609"></p><p>而对于不同材质我们设置不同的属性，比如：</p><p><strong>金属材质：</strong>对于金属材质，只考虑<strong>镜面反射</strong>，认为其没有折射光/漫反射光</p><p><strong>非金属材质：</strong> 非金属材质要考虑<strong>镜面反射</strong>和<strong>漫反射</strong></p><p>当然所有的材质都要保证能量守恒，就是加起来=1</p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>D 法向分布函数：描述多少光反射出去</p><p>参数：Ｎ，Ｈ，粗糙度</p><p>Ｇ　几何函数：自遮挡阴影</p><p>参数：Ｎ　Ｖ　Ｌ　粗糙度ｋ，注意ｌ和ｖ方向都有遮挡</p><p>Ｆ　菲涅尔项：描述被反射法向和折射方向所占的比率，就是能量守恒里的ＫＳ</p><p>参数：ｆ0（是测出来的属性，非金属是0.04，金属是1，因为金属没有漫反射）</p><p>兰伯特光照：ｃ／ＰＩ，ｃ是纹理颜色</p><p>ＩＢＬ模拟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PBR管线&quot;&gt;&lt;a href=&quot;#PBR管线&quot; class=&quot;headerlink&quot; title=&quot;PBR管线&quot;&gt;&lt;/a&gt;PBR管线&lt;/h1&gt;&lt;p&gt;基于物理的着色模型三要素&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于微平面(Microfacet)的表面模型。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="PBR渲染管线" scheme="http://icecorn.github.io/tags/PBR%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构|GPU渲染管线详解</title>
    <link href="http://icecorn.github.io/2022/07/03/GPU%E6%9E%B6%E6%9E%84/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/"/>
    <id>http://icecorn.github.io/2022/07/03/GPU%E6%9E%B6%E6%9E%84/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-03T09:25:10.000Z</published>
    <updated>2022-07-23T02:36:34.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU渲染管线详解"><a href="#GPU渲染管线详解" class="headerlink" title="GPU渲染管线详解"></a>GPU渲染管线详解</h1><p>顶点和片元着色器想必大家已然十分熟悉，但它们之间<strong>各种弯弯绕绕的固定管线操作</strong>，由于一直被GPU所承包，我们反倒陌生了起来。本文将<strong>以三角形的第一人称视角展开叙述</strong>，让读者更加沉浸式地踏上GPU这片土地，希望大家看得开心~</p><h2 id="Ⅰ-从CPU到GPU：来自异世界的召唤"><a href="#Ⅰ-从CPU到GPU：来自异世界的召唤" class="headerlink" title="Ⅰ 从CPU到GPU：来自异世界的召唤"></a>Ⅰ 从CPU到GPU：来自异世界的召唤</h2><h3 id="从硬盘到显存：在故土的最后时光"><a href="#从硬盘到显存：在故土的最后时光" class="headerlink" title="从硬盘到显存：在故土的最后时光"></a>从硬盘到显存：在故土的最后时光</h3><p>我，是一个三角形，跟周围成千上万个三角形没有什么不同。可能跟你们熟悉的世界不太一样，我们虽然都拥有三个顶点，但是<strong>顶点很可能需要跟其他三角形共用</strong>，真正能体现我作为个体而存在的，是三个<strong>顶点索引</strong>。如果我的样子让你觉得无趣，我很抱歉：</p><ul><li>顶点缓冲区：······、*<strong>vertex231*<strong>、</strong>*vertex232**<em>、vertex233、vertex234、vertex235、</em></strong>vertex236***、······</li><li>索引缓冲区：······、231、232、233、*<strong>231*<strong>、</strong>*232**<em>、</em></strong>236***、······</li></ul><p>那一天，我同往常一样，和同伴们躺在广袤无垠而又冰冷刺骨的<strong>硬盘</strong>中。时间仿佛停滞一般，看不到来处也望不见尽头，我甚至都不记得自己是何时出现在这里。我对未来也没有什么期待，毕竟，在这拥挤的空间里，梦想根本无处落脚。</p><p>似乎是来自CPU的指令，人群开始骚动，我跟着同伴不停辗转，温度逐渐升高起来。这里的人似乎都很忙碌，仿佛有着用不完的活力，可能因为这里是<strong>内存</strong>吧。</p><p>正当我们不知所措的时候，天地骤变，我们来到了一个完全陌生的环境，这个叫做<strong>DRAM或是显存</strong>的地方。而危险，才刚刚开始。</p><h3 id="从图形API到GPU指令：一切绝非偶然"><a href="#从图形API到GPU指令：一切绝非偶然" class="headerlink" title="从图形API到GPU指令：一切绝非偶然"></a>从图形API到GPU指令：一切绝非偶然</h3><p>我也是事后听前辈们叙述，才隐约知晓，原来这场突如其来的异世界之旅——并非偶然。这一切，都要从那些高居庙堂的图形API说起。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1207f575b64a008e909658c8cf391488_720w.jpg" alt="img"></p><p>所有的不幸都来源于这些图形API<strong>，</strong>它们<strong>被驱动程序翻译成GPU可读编码，存放在Pushbuffer中</strong>。就像子弹上了膛，装满了或者来自高层的一声令下，就会被发射出去。最终GPU的<strong>Host Interface</strong>承接了这些指令，并把它们丢给了<strong>Front End</strong>处理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-6cbf847e12f18647edf329a866ac2700_720w.jpg" alt="img"></p><p>Front End将这些指令解码分类，我们从内存来到DRAM属于State类的操作：有一些会被立即执行，有一些会等到光栅化后再执行；有一些重复多余的状态设置则会被丢弃。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-377b734519bbf9484369d25a88dff10c_720w.jpg" alt="img"></p><p>而万恶之源的Drawcall，则开启了我们不幸的旅途。</p><h3 id="图元分发（Primitive-Distributor）：大家族的瓦解"><a href="#图元分发（Primitive-Distributor）：大家族的瓦解" class="headerlink" title="图元分发（Primitive Distributor）：大家族的瓦解"></a>图元分发（Primitive Distributor）：大家族的瓦解</h3><p>这个世界有它自己的规则，它<strong>厌恶一切巨大和完整，但却对细碎和海量情有独钟</strong>。于是，我们这个紧密团结的三角形大家族，在一开始就将面对必然解体的命运。</p><p>我们被无情地撕碎，<strong>最多32个顶点或32个图元</strong>（在这个故事中，也就是我，三角形），被称为<strong>Batch</strong>，这是我们最后的体面了。</p><p>先代表我们的顶点索引也被极限压缩，<strong>重复的索引被剔除</strong>，那我们岂不是要魂飞魄散了？幸好，我们还有利用价值，我们得到了<strong>更精简的顶点索引的索引</strong>来标识自己。因为原先的大家族已经不复存在了，原先那么长的索引也便失去了存在的意义，往后的路，我们几个可怜的三角形就要作为一个Batch，独自走下去了。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-e4849ee7e591fd7821bc70b79f771dd0_720w.jpg" alt="img"></p><p>其他三角形们会去哪里呢？我不知道，可能再也没有相见的机会了吧。或许有幸落入同一个SM，那么我们可能会在某次的Warp切换中擦肩而过；但更可能的情况是，我们会在不同的SM里甚至不同的GPC中，经历着相似但毫无联系的人生。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-ec9602e257abaf1a67d10a20c16b7e2e_720w.jpg" alt="img"></p><p>那些在Batch边缘的顶点，在之前很可能是被不同三角形共用的，而现在被撕碎后天各一方，意味着<strong>这些顶点需要被重复计算</strong>，但是我想，对于这个并行高于一切的世界而言，这一切都是值得的。</p><h3 id="顶点获取（Vertex-Fetch）：灵魂需要安息之所"><a href="#顶点获取（Vertex-Fetch）：灵魂需要安息之所" class="headerlink" title="顶点获取（Vertex Fetch）：灵魂需要安息之所"></a>顶点获取（<strong>Vertex Fetch</strong>）：灵魂需要安息之所</h3><p>我所在的Batch被分配到了某一个GPC的某一个SM中，看着密密麻麻的格子间，我预感，我将会在这个地方经历许多。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-85750a54bd8654c5a4778c6403484c4c_720w.jpg" alt="img"></p><p>我的灵魂（顶点索引）在Primitive Distributor中被重组，并被发配到了这种地方；而我的肉体（顶点数据）总不能一直躺在DRAM中。好在这个世界在效率方面总是不会令人失望，当我被决定了目的地的时候，<strong>顶点数据也同步被Polymorph Engine的Vertex Fetch单元运到了SM中的L1 cache中</strong>。</p><h2 id="Ⅱ-几何阶段：大灾变前的狂欢"><a href="#Ⅱ-几何阶段：大灾变前的狂欢" class="headerlink" title="Ⅱ 几何阶段：大灾变前的狂欢"></a>Ⅱ 几何阶段：大灾变前的狂欢</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-9748f581381396a4b061eab364f4d41e_720w.jpg" alt="img"></p><p>据说我来到的这个SM，相比<a href="https://zhuanlan.zhihu.com/p/416334635">上一代</a>，有着诸多改进。格子间明显多了不少（不论是计算核心还是纹理单元），计算单元也变强了许多（<strong>FMA改进了MAD，支持双精度</strong>），<strong>Warp调度机制也变成了双调度以满足如此繁多的元器件指令需求</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1ff785a541a2692cba1c53938c5d1d34_720w.jpg" alt="img"></p><p>每个周期中，Warp Scheduler可以将<strong>一个或两个</strong>Warp，发送到四个执行块中的任何两个：16CUDA核的块<em>2、4SFUs</em>2、16加载/存储单元*1。从图中可以发现，Fermi架构和Tesla架构一样，<strong>Warp的切换周期仍然是两个处理器周期</strong>。</p><p>除了调度机制，最大的改变我想还是这个PolyMorph Engine，毕竟，就是它的Vertex Fetch把我们的顶点运送到这的。我对它颇有好感，我觉得我们之间还有许多故事要发生。</p><h3 id="顶点着色器：共进退但无法联系的伙伴"><a href="#顶点着色器：共进退但无法联系的伙伴" class="headerlink" title="顶点着色器：共进退但无法联系的伙伴"></a>顶点着色器：共进退但无法联系的伙伴</h3><p>顶点数据已经就位，周围的环境也已经熟悉，紧接着，就进入了我们<strong>必经的</strong>顶点着色器阶段。我们一个Batch，满载的话是32个顶点，刚好是一个Warp。</p><p>在这个Warp里，我将暂时忘记自己三角形的身份，作为顶点和其他31个顶点同生共死。虽然我们每次执行顶点着色器指令的时候，<strong>身处不同的Core中，彼此无法联系</strong>，但我知道它们也一定在和我做着相同的事。</p><p>我们不会一次执行完所有的指令，<strong>大多数时候我们都是走走停停</strong>，因为我们所处的这个SM中还有许多其他的Warp：它们可能是跟我们一样正在执行顶点着色器的顶点，也可能是正在执行片元着色器的片元，甚至可能是CUDA核程序的32个线程……虽然我们出身不同，但在SM中并没有什么高低贵贱之分，都只是<strong>由Warp调度器拿捏</strong>的Warp罢了。</p><p>Warp调度器一声令下，我们就由Dispatch单元指挥着，从寄存器文件中拿上我们之前暂存的数据，继续到各自的Core中执行下一条顶点着色器指令。执行了一条或者若干条指令后，Warp调度器可能又是一声令下，我们就得立刻放下手头的工作，把数据在寄存器文件中存好，乖乖回去睡觉，让其他Warp上场。</p><p>我们在执行所有着色器指令的时候，都是这样一个流程，好在<strong>如何调度其实并不需要我们操心</strong>。我们只需要听从指令，行尸走肉般，在一个个格子间——Core中，做完着色器分配给我们的工作。</p><p>如今的顶点着色器大多没有太过繁杂的指令，最主要的任务还是<strong>将我们这种在世界空间中自由自在惯了的顶点约束到一个裁剪空间中</strong>。不过，如果有细分和几何着色器的存在，那么这一重大任务交给它们来做也不是不行，因为只要在光栅化前转换到裁剪空间，之前的位置都只是中间过程罢了。</p><p>很不幸的是，我的这趟旅程，是如此的完整，即使是可选的细分和几何着色器阶段，也逃不了了。</p><h3 id="TCS-Hull：裂变前的最后抉择"><a href="#TCS-Hull：裂变前的最后抉择" class="headerlink" title="TCS/Hull：裂变前的最后抉择"></a>TCS/Hull：裂变前的最后抉择</h3><p>在经过了顶点着色器的一番热身之后，除了顶点被修整一番，我仍然是快乐的三角形。但接下来，可能就没那么轻松了。紧接着需要执行的是<strong>细分控制着色器</strong>，很幸运的是，我们不需要长途跋涉，在<strong>同一个SM</strong>中就可以执行。</p><p>这次，我又可以换回自己三角形的身份了，准确的说，是patch。<strong>patch</strong>是类似primitive但只能用于细分的概念，在drawcall的时候指定，每个patch可以包含最多32个顶点（具体上限取决于实现，但肯定不超过32，毕竟我们一个batch也就32个顶点）。那既然我作为三角形一路走到了这里，那么这个drawcall指定的patch顶点数自然是3咯。</p><p>TCS可以在着色器中通过layout指定要输出的顶点数，而<strong>这个输出的顶点数就是一个patch要开的线程数</strong>，每个线程分配一个gl_InvocationID。</p><p>与顶点着色器每个线程对应一个顶点，输入输出彼此隔绝十分自闭不同，TCS自由得多，<strong>一个patch内的所有线程可以访问这个patch的所有输入（来自顶点着色器）和输出</strong>。这意味着可能会出现同步问题，需要用<strong>barrier()<strong>同步。因此，</strong>TCS更像一个有特殊任务在身的计算着色器</strong>。</p><p>不过，不要被迷惑了，<strong>TCS输出的顶点只是数据</strong>，是作为之后TES里的输入，供TES插值用的，并不代表最终的顶点数。事实上，常见的TCS没那么多戏，只是当个工具人，把顶点着色器输入的顶点属性一一对应地传给TES罢了。</p><p>身为细分控制着色器，它最重要的职责，是通过填写gl_TessLevelInner和gl_TessLevelOuter两组细分因子，<strong>告诉接下来的Tessellator该如何细分每一个patch</strong>。</p><p>现在，让我们来整理一下心情，看看现在我们这些可怜的三角形（patch）究竟变成什么样了：我们目前仍然是一堆patch，patch数没有发生变化，然而顶点可能已经面目全非。事实上，这些顶点目前只是一堆数据，<strong>每个patch之后会被细分成多少个真正的顶点，只取决于细分因子，与TCS输出的顶点数据没有任何关系</strong>。如果把细分因子通过API提前设置好，TCS甚至都不是细分所必须的。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d10d5ac52530495a36fb46e3e7c972d0_720w.jpg" alt="img"></p><p>原本以为会在一个SM上孤独终老，没想到这么快就要重新踏上旅程了。我们会通过Work Distribution Crossbar在不同的SM之间穿梭，因为<strong>接下来我们的顶点数很可能急剧膨胀，当前的SM很可能承接不了</strong>。提前根据细分因子选择一个较为空闲的SM，是个明智之举。</p><h3 id="Tessellator：裂变之所"><a href="#Tessellator：裂变之所" class="headerlink" title="Tessellator：裂变之所"></a><strong>Tessellator：裂变之所</strong></h3><p>我们刚一来到这个新SM，就进入了polymorph引擎中的Tessellator。</p><p>Tessellator的工作除了需要之前TCS输出的至关重要的细分因子外，还需之后的TES中指定的各种参数：<strong>图元生成域、细分的顶点空间划分规则、图元面部朝向、是否开启点模式</strong>。</p><p>而其中最重要的是图元生成域，它决定了Tessellator将在什么样的<strong>抽象patch</strong>中插入新的点，并生成对应的图元。有三种图元生成域：<strong>triangles、quads或isolines</strong>。前两种最终生成三角形，后一种生成线，开启点模式，全都能画成点。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-f7f622e9b67a913784cb936397331811_720w.jpg" alt="img"></p><p>这个抽象patch，意味着TCS原来处理的patch有多少顶点、最后输出多少顶点，它们长啥样，全都不重要。Tessellator只会在一个抽象的三角形/正方形/等值线上，根据前面所需的那些信息去插入新的顶点，最终输出的是一些0到1之间的，标记<strong>其在抽象patch中相对位置的归一化坐标</strong>。</p><h3 id="TES-Domain：裂变后的新生"><a href="#TES-Domain：裂变后的新生" class="headerlink" title="TES/Domain：裂变后的新生"></a><strong>TES/Domain：裂变后的新生</strong></h3><p>事实上，我们在Tessellator中并未提供任何顶点数据，我们现在仍然是之前的那副躯体。Tessellator只吐出来了一堆细分坐标gl_TessCoord，而这些就是<strong>新顶点的种子</strong>，它们会在我们旧的躯体上生根发芽。</p><p>随着新顶点的诞生，我<strong>旧的躯体和灵魂（patch）也随之灰飞烟灭</strong>了。我的新灵魂在<strong>Task Distributor</strong>中，由最终确定的图元类型（在这趟旅途中新图元仍然是三角形）和图元面部朝向，重新构筑成了一个全新的三角形——我的一些顶点有可能和原来的顶点位置一样，而更可能的情况是，我所有的顶点全是无中生有凭空产生的。</p><p>TES的每个线程负责一个新顶点的茁壮成长：它们可以拿到由TCS输出的，属于这个patch的所有顶点数据，<strong>通过gl_TessCoord插值后得到新的顶点数据</strong>。</p><p>虽然都是三角形，但，我还是原来的我吗？一切都是那么的匆匆，已没有时间让我多加思考，因为很快，我将陷入更深的迷茫和混乱之中。</p><h3 id="几何着色器：自由的代价"><a href="#几何着色器：自由的代价" class="headerlink" title="几何着色器：自由的代价"></a>几何着色器：自由的代价</h3><p>刚刚获得全新生命的我，就被<strong>Task Distributor</strong>分配了几何着色器的奇怪指令。</p><p>这一次，我将以三角形图元的身份，和其他31个三角形，组成Warp，完成几何着色器的任务。这意味着，几何着色器的每一个线程对应的是一个图元，它可以拿到我的所有顶点数据。</p><p>几何着色器可以做什么呢？它可以做的事过于疯狂：只需要提前定义好一个最大的顶点数，它就<strong>可以以任何顺序输出任意数量、任意类型的图元（点、线、三角形），并输出这些图元的顶点的各种属性</strong>。</p><p>我很震惊，这样潇洒自由的操作，这样一条条的绘图指令，竟是存在于一个着色器之中的，看起来更像是一个CPU端一大串的API调用程序。我还很困惑，我一个渺小的三角形，经过这么一番折腾之后会变成什么？</p><p>我可能还是一个三角形，也可能直接人间蒸发，又或是变成了多个三角形，甚至变成线、变成点，我有无数种可能。我甚至还可能<strong>实例化</strong>成多份：我的每一个分身，都运行一次几何着色器经历一番不同的捶打后，<strong>分层渲染</strong>到不同的帧缓冲，或者输出到多个流中。</p><p>我不禁心生疑虑，这样自由的代价，究竟是什么？<strong>在一个以细碎和海量为生存原则的并行世界里，塞入这么多串行的绘制指令，本身就是大逆不道的</strong>。</p><p>是的，几何着色器从出生开始，就是被诅咒的。为了<strong>维持图元绘制指令和其输出到帧缓冲的顺序一致性</strong>，必须缓存输出的所有顶点数据，以确保后续图形能按顺序进入光栅化器和ROP中。而<strong>几何着色器每个线程需要缓存的数据远高于顶点着色器和两个细分着色器</strong>！细分阶段虽然也会细分出大量的三角形和点，但是人家始终都是一个线程处理一个顶点的，不像几何着色器一样想着一口吃成胖子，结果吃撑了。</p><p>需要超大的缓存，该怎么办呢？NVIDIA的方案：把缓存强行存在片内，片内寸土寸金的地自然存不下多少，很快就塞满了，塞满后SM能够塞下的Warp就会受限，仓库堵了，工厂不就得跟着堵么？而AMD换了一种思路：它咬咬牙把缓存写到DRAM里，仓库是不堵了，但是仓库在十万八千里远的地方，那工厂很快就会因为货物迟迟未到全部歇业摸鱼了。</p><p>我把这个世界的原则铭记在心：对并行性的巨大破坏，终将受到惩罚。经历九九八十一难后的我，淡定地来到了我们熟悉的Polymorph Engine中。</p><h3 id="流输出：提前跑路"><a href="#流输出：提前跑路" class="headerlink" title="流输出：提前跑路"></a>流输出：提前跑路</h3><p>一波三折之后，我已经不复当年模样。据说在另一个平行世界中，我的这趟旅行就此终止了，我回到了显存的缓冲区中。之后的命运是被回读到冰冷的硬盘冰封起来，还是继续流转到GPU中再次进入渲染管线来一次痛苦的轮回，这我就不得而知了。</p><h3 id="顶点后处理：最后的筛选"><a href="#顶点后处理：最后的筛选" class="headerlink" title="顶点后处理：最后的筛选"></a>顶点后处理：最后的筛选</h3><p>在当前这条世界线中，我在Polymorph Engine中还得经历一道筛选流程：<strong>不在视锥范围内的三角形是不配继续在这个残酷的世界中存在的</strong>。</p><p>在此之前，我们需要先进行<strong>图元装配</strong>，让灵魂归位，从此以后我将是一个被盖棺认定的独立自主的三角形了。虽然在细分和几何着色器之前，我早就进行过简单的图元装配了。</p><p>作为一个独立的三角形，我将面临来自视锥的考验：</p><ul><li>如果我完全在视锥内：我得以通过测试，幸存下来</li><li>如果我完全在视锥外：那毫无争议的，我将被<strong>剔除</strong>，我的旅途便到此结束了</li><li>那么当我一半在视锥内一半在视锥外时：情况就比较尴尬了，我会被毫不留情地裁剪吗？</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-47f66da373b0c96ec79e494671c82ef5_720w.jpg" alt="img">guard-band clipping</p><p>那得根据情况而定了：</p><ol><li><strong>如果我是和近平面相交：那么是一定要被裁剪的</strong>。理由有二：好算；不裁剪直接进行后续的透视除法会出错，整个三角形会被翻转。</li><li>如果我和其他面（透视投影的Frustum并不是横平竖直的）相交：裁剪则并不好算，那么原则就是，<strong>能不裁剪就不裁剪</strong>，反正不裁剪也不会有什么问题，超出视口的区域也不会被光栅化。</li><li>但是如果我大得离谱，导致顶点坐标大得离谱，超过了硬件的处理范围（硬件那肯定是抠抠搜搜的，坐标可不是用float来存的，也就上万，现实中的屏幕能多大它就给你设计多大，很会过日子）：那就不得不裁剪了。</li></ol><p>侥幸逃脱被剔除命运的我，苟延残喘至今，等待我的是什么呢？我先是进行了<strong>透视除法</strong>仪式：我的xyz坐标被除以w坐标；然后这个新坐标将进入Polymorph Engine的Viewport Transform模块中完成最后的<strong>视口变换</strong>仪式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/equation" alt="[公式]"></p><p>回望一路上的种种：先是大家族分崩离析的惨剧，紧接着不痛不痒的顶点着色器逐顶点变换后，经历过细分和几何着色器的各种折腾的我，获得了完全崭新的生命——作为一个全新的三角形，我最终闯过了剔除和裁剪的筛选，磕磕绊绊走到如今。我的<strong>三个顶点坐标被转化到NDC后，又立刻被转化到屏幕坐标</strong>，我预感到，我作为三角形的时间可能已经不多了。</p><hr><h2 id="Ⅲ-光栅阶段：黑暗降临"><a href="#Ⅲ-光栅阶段：黑暗降临" class="headerlink" title="Ⅲ 光栅阶段：黑暗降临"></a>Ⅲ 光栅阶段：黑暗降临</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-8684905909ad2dd3f28df3fe9df02ad1_720w.jpg" alt="img"></p><h3 id="Work-Distribution-Crossbar：光栅化前的洗礼"><a href="#Work-Distribution-Crossbar：光栅化前的洗礼" class="headerlink" title="Work Distribution Crossbar：光栅化前的洗礼"></a>Work Distribution Crossbar：光栅化前的洗礼</h3><p>接下来又是一段艰难的长途跋涉了，上一次离开SM的旅途还是在TCS之后，而这次我旅途的终点是——<strong>每个GPC中都有一个的Raster Engine</strong>。我们会就近被分配到当前GPC的Raster Engine吗？并不会。</p><p><strong>OWDX：将三角形包围盒切块，分发到对应光栅化器中</strong></p><p>是的，不止移动端在分块，Fermi的GPU既然有了多个Raster Engine，开始<strong>分块实现并行</strong>也是很自然的想法。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-b63ee123780bbd1875cdcbc7665f74d0_720w.jpg" alt="img"></p><p>不过，与移动端不同的是，并行处理这些块的只是Raster Engine，而不是SM，SM并不对应任何特定的块，自然也没有专属的帧缓冲，来达到移动端减少带宽的目的；当然也不延迟，来一个三角形处理一个三角形。</p><p>分块的大小还是有讲究的：切得太大，那并行性就差了；切得太小，三角形更容易横跨多块，而<strong>每一块都要做一次三角形设置</strong>，浪费会严重到得不偿失。</p><p>我一到这，它们就开始用<strong>包围盒</strong>（应该只是矩形）把我紧紧包裹住，然后开始切块。没想到，在还没到达Raster Engine之前，我就已经四分五裂了。我的每一块被打上具体Raster Engine的索引，被发往对应的Raster Engine。</p><blockquote><p>面剔除未明确是在哪个阶段发生，有资料表明是在光栅化时，我个人觉得这个阶段就直接剔除最合理。</p></blockquote><p><strong>SWDX：排序</strong></p><p>因为要<strong>保证按三角形提交顺序进入Raster Engine</strong>，所以在正式启程前，我还得先排队。为什么要排队呢，我很是不解，先到先得不好吗，ROP那里不是还会排序一次来保证三角形按照提交顺序输出到帧缓冲的吗？现在又是为什么呢？</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-5382bb711de5d04142963797cb4e55bc_720w.jpg" alt="img"></p><p>这是为了避免三角形重叠时的闪烁问题：如果不排序先到先得，那么最终出现在屏幕上的是哪个三角形就无法唯一确定了。当然如果有十足的把握不会有重叠的三角形出现，现在<a href="https://link.zhihu.com/?target=https://gpuopen.com/learn/unlock-the-rasterizer-with-out-of-order-rasterization/">新的硬件</a>可以手动关掉排序，以提高效率。</p><h3 id="边设置（三角形设置1）：被打上烙印"><a href="#边设置（三角形设置1）：被打上烙印" class="headerlink" title="边设置（三角形设置1）：被打上烙印"></a>边设置（三角形设置1）：被打上烙印</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1ddda400bedd04459378f2b162f352d0_720w.jpg" alt="img"></p><p>终于轮到我了，我跟在上一个三角形后面进入了Raster Engine。准确地说，<strong>我只是三角形覆盖屏幕一定区域的某一块</strong>，其他块很可能在其他Raster Engine中排着队，或已经完成光栅化甚至渲染到了屏幕上，这就不得而知了。</p><p>首先，我来到的是Raster Engine负责<strong>边设置</strong>的第一个小房间，在这里，它们给我打上了属于我这个三角形的烙印。因为<strong>在光栅化进行三角形遍历时，想知道我具体覆盖了哪些像素，总得知道我是个什么样的三角形吧</strong>。</p><p>它们先为我的每一条边<strong>生成边方程</strong>：<img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710164101565.png" alt="image-20220710164101565"></p><p>边上的某一点容易，我有顶点的嘛；而边法线则要麻烦一点，它们让我的两个顶点互减得到这条边的向量，然后将这个向量旋转90度，最后得到的法线为： </p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710164135665.png" alt="image-20220710164135665"></p><p>代入边方程，稍作整理： <img src="https://www.zhihu.com/equation?tex=-+%5Cleft(+p_%7B1y%7D+-+p_%7B0y%7D++%5Cright)x+++%5Cleft(p_%7B1x%7D+-+p_%7B0x%7D+%5Cright)y+-+%5Cleft(+p_%7B1y%7D+++p_%7B0y%7D++%5Cright)p_%7B0x%7D+-+%5Cleft(p_%7B1x%7D+-+p_%7B0x%7D+%5Cright)p_%7B0y%7D=+0" alt="[公式]"></p><p>而如果把方程的左边看成一个边函数： <img src="https://www.zhihu.com/equation?tex=e_%7B2%7D%5Cleft(+x,y+%5Cright)+=+a_%7B2%7Dx+++b_%7B2%7Dy++++c_%7B2%7D" alt="[公式]"> ，那么方程则可以看成是函数值 <img src="https://www.zhihu.com/equation?tex=e_%7B2%7D%5Cleft(+x,y+%5Cright)+=+0" alt="[公式]"> 时的式子，使<strong>函数值为0的点正是在边上的点。那么函数值大于0的点呢？则是与边法线同侧的点。函数值小于0的点则相反。</strong>这正是之后判断像素是否处于三角形之内的核心奥秘。</p><p>而<strong>每个边函数所需要的这三个系数</strong>：a、b、c，它们全可以由顶点的屏幕空间坐标计算得到——这便是边设置阶段给我打上的烙印。</p><h3 id="光栅化（三角形遍历）：粉身碎骨浑不怕"><a href="#光栅化（三角形遍历）：粉身碎骨浑不怕" class="headerlink" title="光栅化（三角形遍历）：粉身碎骨浑不怕"></a>光栅化（三角形遍历）：粉身碎骨浑不怕</h3><p><strong>Inside Test</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-e634c3130f1fb6508e769d051763a914_720w.jpg" alt="img"></p><p>根据烙印，它们可以轻松地判断出屏幕上任何一点是否在我这个三角形内，<strong>只要这点代入我的三个边函数值都大于0，则证明该点在我体内</strong>。</p><p>代入<strong>屏幕像素中心的坐标</strong>去验证整个像素是否被我覆盖，是十分自然的想法。不过下下代架构的<strong>保守光栅化</strong>还有其他不同的选择，这就是后话了。</p><p>为了之后片元阶段能通过与邻居像素属性值求差来获得导数，像素都是4个一小队组成一个<strong>quad</strong>来工作的。它们<strong>一荣俱荣，只要一个像素被我覆盖，其他像素全部被拖下水</strong>，也会被光栅化成片元并占用之后warp的一个线程。</p><p>有一个跟DDA画线算法一样，很常见的加速套路：<strong>每次只要在前一个像素结果上加一个值就行，而不用真的代入原始的边函数去重新算一堆乘法</strong>：</p><p><img src="https://www.zhihu.com/equation?tex=e%5Cleft(+x+1,y+%5Cright)=a(x+1)+++by+++c+=+a+ax++by+++c=a++e%5Cleft(+x,y+%5Cright)" alt="[公式]"></p><p>还有一个少见但却不得不考虑的特殊情况：像素坐标刚好落在我边上，即像素坐标代入后边函数恰好等于0的情况。这会有什么问题呢？<strong>需要有一个机制判断这个像素是否属于这个三角形</strong>。属不属于有那么重要吗？有的，就跟之前光栅化需要排序一个道理，当两个三角形共用一条边时：如果这个像素不属于任何一个三角形，那么就会出现缝隙；如果都属于，那前一个片元可能会被后一个片元覆盖，挺浪费的不够高效。</p><p>总是需要一个tie-breaker规则来打破僵局，方法其实有很多：有DirectX的<strong>top-left规则</strong>（DirectX），归边为左侧边或水平上边界的三角形所有；或使用<strong>离屏点规则</strong>，归与离屏点同一侧的三角形所有。</p><p>还有最后一个小问题，虽然我是一个三角形，可图元还可以是点和线呀，它们该如何被光栅化呢？事实上<strong>点和线被当成矩形</strong>，也就是两个三角形来对待了！给它们单独做一套算法和硬件当然会更快，但是整套硬件就变复杂了，在这个由各种昂贵元器件堆出来的世界里，<strong>没有什么十全十美，有的只是各种权衡</strong>：在三角形占据应用主流的情况下，<strong>所有图元共用一套三角形光栅化流水线</strong>，是明智的选择。</p><p><strong>多重采样</strong></p><p>基于抗锯齿的需要，一个像素只能非黑即白（要么被我覆盖要么不被我覆盖）的现状终究无法令人满意。因此一个像素多加几个采样点来最终判断这个像素的覆盖率的想法便出现了。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-1b68a07a9d1af32bb6ff04ebd71daaea_720w.jpg" alt="img"></p><p><strong>MSAA</strong>：每个像素需要多个样本被光栅化，但无论有多少样本被我覆盖，<strong>片元着色器都只会运行一次</strong>，深度值和最终的颜色值会被写到多个被我覆盖的样本对应的帧缓冲内存上。是的，唯一的代价就在于，需要更大的帧缓冲，多加多少采样点，就得多加多少帧缓冲内存去存放着色结果。</p><p><strong>EQAA</strong>（AMD的方案）：以一层间接索引为代价，换来了帧缓冲内存的减少。</p><p><strong>CSAA</strong>（NVIDIA的方案，没想象中那么牛，后来给砍了）：需要光栅化的点再*4，但只是用来估算权重，帧缓冲相比MSAA没有扩大。每个像素只需要多加16bit的覆盖信息，用以记录四个子像素最终的权重。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-21f937a7c38881bf23431407fa80619c_720w.jpg" alt="img"></p><p><strong>分层遍历</strong></p><p>实际上，它们在遍历每个像素（或子像素）是否被我覆盖时，比我想象中聪明得多。它们会将装我的盒子继续分块。我们称这每一块为tile吧（如果想，多分几级也是可以的，tile里还可以有更小粒度的tile）。</p><p>每条边，<strong>只需要先遍历每个tile四个角中的一个点就行</strong>（具体是哪个点取决于边法线），在相当于一种<strong>加速结构</strong>：一个点可以代表该tile中所有64个点，它在边外其他点必然在边外，整个tile都不需要再遍历了。一样可以用<strong>增量</strong>的方式逐渐更新各个tile的顶点。</p><p>tile也<strong>按Z顺序遍历</strong>，讲究！按tile遍历而不是按扫描线遍历还有个好处：<strong>提高了cache命中率</strong>。因为相邻的像素需要同一个纹素的概率更大，而且纹理在GPU中本身也是按块存储的。在同一个块内的片元被打包成Warp，在之后读写的纹理、深度、颜色缓冲更容易抱团取暖，拿到同一块内的纹素。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d35a659a860aacecba7aa02ecf459d60_720w.jpg" alt="img"></p><h3 id="Z-Cull：被抹去的存在"><a href="#Z-Cull：被抹去的存在" class="headerlink" title="Z-Cull：被抹去的存在"></a>Z-Cull：被抹去的存在</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-6366c72ad7da0102d4d0eedf04ad5fdb_720w.jpg" alt="img"></p><p>实际上真正的逐像素（子像素）光栅化前，还会先进行一个对块的<strong>粗糙光栅化</strong>过程。（这个块和遍历时分的块不是一个概念）</p><p>Z-Cull单元会维护每一块的深度最大值，如果我在这一块里，光栅化出来的像素最小值大于它，那意味着我必然被之前的三角形遮挡了，那这一块也就没有继续逐像素光栅化的必要了。</p><p>保守评估我在每一块上的深度最小值的两种方法：</p><ol><li>我三个顶点的最小值</li><li>我在该块四个顶点处插值出来的深度值的最小值</li></ol><p>组合上面的两种方法，取各自最小值的最大值，可以得到更加高效的剔除效果。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-f7c2e3e65d090dccc3b25f77f673bdcf_720w.jpg" alt="img"></p><p>不过，Z-Cull只是用来节省逐像素深度测试的方法，而并不会节省后面的片元着色器，因为还有<strong>early-z</strong>挡着呢。</p><blockquote><p><strong>early-z</strong>：整套剔除要有比较好的效果，还是需要依赖从前往后的顺序提交三角形，移动端tdbr或者z-prepass算法才能无需排序。</p><p>关于early-z，z-culling，z-perpass，hi-z</p><p><a href="https://blog.csdn.net/a1047120490/article/details/106761430">https://blog.csdn.net/a1047120490/article/details/106761430</a></p><p><a href="https://blog.csdn.net/whitebreeze/article/details/118688150">https://blog.csdn.net/whitebreeze/article/details/118688150</a></p></blockquote><p>还可以反过来再做一次Z-Cull：存最小值，拿最大值，如果通过了，说明不会有任何遮挡，也能节省逐像素的深度测试时的读取（只要能提前确定，<strong>百分百被遮挡和百分百不被遮挡都可以节省无谓的深度测试</strong>）</p><p>整个块被我覆盖的可以直接更新其维护的最值，否则还得之后根据该块内逐像素深度的最值来更新（这会带来一定的延迟）</p><p>可以这么理解与分层遍历的区别：<strong>分层遍历是在屏幕空间上的加速，而Z-Cull则是在深度方向上的加速，它们二者都是基于块的思想，用一个块的比较来快速跳过块内每个像素的比较</strong>。</p><hr><h2 id="Ⅳ-片元阶段：美丽新世界"><a href="#Ⅳ-片元阶段：美丽新世界" class="headerlink" title="Ⅳ 片元阶段：美丽新世界"></a>Ⅳ 片元阶段：美丽新世界</h2><p>往日里，人们提到光栅化，脑子里也就只有那么一张简单的图：一个三角形被切成一个个像素。可是，当我亲身经历后，才发现压根就没有那么简单，<strong>硬件为了高效地将我四分五裂，穷尽各种可能来提高效率</strong>，以至于流程复杂得让我晕眩。</p><h3 id="属性设置-（三角形设置2）：落地生根"><a href="#属性设置-（三角形设置2）：落地生根" class="headerlink" title="属性设置 （三角形设置2）：落地生根"></a>属性设置 （三角形设置2）：落地生根</h3><p>现在有哪些像素（子像素）会被我覆盖已经一清二楚，但在真正发往片元着色器之前，还有一件很重要的事情需要完成。这些被覆盖的像素所需要的属性，还都没有着落呢，它们需要<strong>由我的三个顶点插值得到</strong>。</p><p>与三角形边设置一样，属性插值也需要提前计算一些值，这个过程发生在Polymorph Engine的<strong>属性设置</strong>单元中。我都已经记不清这是第几次踏入Polymorph Engine了，而且每一次踏入的还不一定是同一个，不过我想，这应该是最后一个了。</p><p>在Tesla架构中由一个单元全盘负责的三角形设置，在Fermi架构中被拆成了边设置和属性设置，一个位于Raster Engine中，一个位于Polymorph Engine中。</p><p>边设置有边方程，属性设置自然需要属性平面方程： <img src="https://www.zhihu.com/equation?tex=a%5Cleft(+u,v+%5Cright)+=+%5Cleft(1-+u+-+v+%5Cright)a_0+ua_1+va_2" alt="[公式]"></p><p>其中最重要的，是<strong>求得每个像素的质心坐标（u, v, w）</strong>，因为三者和为1，只需要求得两个即可。只要有了质心坐标，插值就是轻而易举的事了（在片元着色器阶段，由SM中的SFU负责）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-0d9ef4134bfc2fd32fd2791a6fbbb417_720w.jpg" alt="img"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710174245566.png" alt="image-20220710174245566"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-a0ee912e6a9b1af49f113d3c9543c332_720w.jpg" alt="img"></p><p>可是，该死的透视变换，让一切变得复杂了起来，我们需要对属性做<strong>透视校正</strong>：分别插值 属性/w 和 1/w，然后将两者的结果相除。</p><p>因此，我们需要对质心坐标进行调整，而调整后的面积和也就不再是常数了，需要逐像素老老实实计算三个质心坐标了：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710174335142.png" alt="image-20220710174335142"></p><p>不过，深度值除外，它不需要透视校正。因为<strong>被扭曲过的深度值（在透视除法中已经被w除了），其在屏幕空间上刚好是线性的</strong>（<strong>还方便之后压缩</strong>），因此直接线性插值就可以。</p><blockquote><p>之所以深度特殊，是因为它要存的值本身就是要除以w的，之后自然线性插值即可；而其他属性除以w再插值则只是为了让属性过渡能符合近大远小的规律，但是顶点处要存的值仍然是原来的属性值，因此还得映射回去。</p></blockquote><h3 id="片元着色器：任劳任怨"><a href="#片元着色器：任劳任怨" class="headerlink" title="片元着色器：任劳任怨"></a><strong>片元着色器：任劳任怨</strong></h3><p>现在每个片元所需要的所有属性值已经准备齐全了，我已经从一个三角形彻底变成了一个单纯的小片元。我和其他三个片元一起组成了一个<strong>quad</strong>，我们是彼此需要互相利用求差取得导数的塑料姐妹花，因为除此之外，我们并不能做其他任何的交流。最后我们和其他quad被打包成一个warp，发往了片元着色器。</p><p>图形的大部分任务据说都是在这里完成的，这可能也是我这一趟旅途中<strong>最繁忙</strong>的一个阶段了。不过正因为它的复杂性完全来自于程序员们在shader中的天马行空，对于硬件而言，反倒没有什么过多可以赘述之事。因为无论多复杂，于我而言，无非都是听从Warp调度器行尸走肉般的节拍器生活罢了。</p><h3 id="ROP：飞蛾扑火"><a href="#ROP：飞蛾扑火" class="headerlink" title="ROP：飞蛾扑火"></a>ROP：飞蛾扑火</h3><p>结束了片元着色器工厂流水线的繁重作业后，我终于来到了旅途的真正终点。分布在GPC外的L2 Cache附近，密密麻麻的ROP中的某一个，将会是我的最终归宿。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d9789027b8ac208100e0b2ae8cfb6254_720w.jpg" alt="img"></p><p>和Raster Engine一样，每一个ROP单元分管屏幕像素的某些块，而我落在哪一块中，就会被发往哪一个ROP中。分块带来的好处显而易见，每个ROP只需要在负责的block里维持三角形的顺序就行了。</p><p>它们负责<strong>late depth test、模板测试、混合</strong>等，可谓是十分忙碌。如果开启了多重采样，它们还负责最终每个像素的<strong>resolve</strong>，混合多个子样本的颜色得到最终的像素值。</p><p>一路上见过了太多生离死别，能一直走到现在我已经看淡了许多。原本只是在硬盘中了无生趣的几个数据，能够拥有这么一段跌宕起伏的人生我已然足够幸运。</p><p>即便跨越重重险阻，颠沛流离至今，到最后也可能只是<strong>影响了数百万像素中某一个像素的些许光亮</strong>。但为了这十几毫秒的些许光亮，就足以让我们这些懵懂无知的三角形，一次又一次地踏上旅途——因为如果三角形没有梦想，那和咸鱼还有什么区别呢？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU渲染管线详解&quot;&gt;&lt;a href=&quot;#GPU渲染管线详解&quot; class=&quot;headerlink&quot; title=&quot;GPU渲染管线详解&quot;&gt;&lt;/a&gt;GPU渲染管线详解&lt;/h1&gt;&lt;p&gt;顶点和片元着色器想必大家已然十分熟悉，但它们之间&lt;strong&gt;各种弯弯绕绕的固定管</summary>
      
    
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/categories/GPU%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="GPU渲染管线" scheme="http://icecorn.github.io/tags/GPU%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>算法系列|LeetCode Hot100总结</title>
    <link href="http://icecorn.github.io/2022/07/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20LeetCode%20Hot100%E6%80%BB%E7%BB%93/"/>
    <id>http://icecorn.github.io/2022/07/03/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%20LeetCode%20Hot100%E6%80%BB%E7%BB%93/</id>
    <published>2022-07-03T09:25:10.000Z</published>
    <updated>2022-07-29T05:27:29.316Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LC-Hot100总结"><a href="#LC-Hot100总结" class="headerlink" title="LC Hot100总结"></a>LC Hot100总结</h1><h2 id="3-无重复最长子串"><a href="#3-无重复最长子串" class="headerlink" title="3 无重复最长子串"></a>3 无重复最长子串</h2><p>滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>,n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(map[s[r]]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map[s[r]] = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                map[s[r]]++;</span><br><span class="line">                <span class="keyword">while</span>(map[s[r]]&gt;<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map[s[l]]--;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,r-l+<span class="number">1</span>);</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="10-正则表达式匹配"><a href="#10-正则表达式匹配" class="headerlink" title="10 正则表达式匹配"></a>10 正则表达式匹配</h2><p>hard</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = p.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> matches = [&amp;](<span class="type">int</span> i, <span class="type">int</span> j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> s[i - <span class="number">1</span>] == p[j - <span class="number">1</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">f</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] |= f[i][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j - <span class="number">1</span>)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">matches</span>(i, j)) &#123;</span><br><span class="line">                        f[i][j] |= f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="15-三数之和等于0"><a href="#15-三数之和等于0" class="headerlink" title="15 三数之和等于0"></a>15 三数之和等于0</h2><p>固定第一个数，双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">3</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> l=i+<span class="number">1</span>,r=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(-nums[i]==nums[l]+nums[r])</span><br><span class="line">                &#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i],nums[l],nums[r]&#125;);</span><br><span class="line">                    l++;r--;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[l]==nums[l<span class="number">-1</span>]) l++;</span><br><span class="line">                    <span class="keyword">while</span>(l&lt;r&amp;&amp;nums[r]==nums[r+<span class="number">1</span>]) r--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(-nums[i]&lt;nums[l]+nums[r])</span><br><span class="line">                &#123;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21 合并两个有序链表"></a>21 合并两个有序链表</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list1) <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!list2) <span class="keyword">return</span> list1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list1-&gt;val &lt;= list2-&gt;val) &#123;list1-&gt;next=<span class="built_in">mergeTwoLists</span>(list1-&gt;next,list2); <span class="keyword">return</span> list1;&#125;</span><br><span class="line">        <span class="keyword">else</span> list2-&gt;next=<span class="built_in">mergeTwoLists</span>(list1,list2-&gt;next); <span class="keyword">return</span> list2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22 括号生成"></a>22 括号生成</h2><p>回溯</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l+r==n*<span class="number">2</span>) res.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">if</span>(l&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(l+<span class="number">1</span>,r,n);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;l)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="built_in">dfs</span>(l,r+<span class="number">1</span>,n);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="23-合并k个链表"><a href="#23-合并k个链表" class="headerlink" title="23 合并k个链表"></a>23 合并k个链表</h2><p>优先队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">comp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode* L1,ListNode* L2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> L1-&gt;val &gt; L2-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(),*cur = dummy;</span><br><span class="line">        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,comp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; list : lists)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(list);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ListNode* tmp = q.<span class="built_in">top</span>(); </span><br><span class="line">            cur-&gt;next = tmp;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(tmp-&gt;next)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(tmp-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31 下一个排列"></a>31 下一个排列</h2><p>从后往前找第一个大于后边的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> i=n<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;nums[i]&gt;=nums[i+<span class="number">1</span>]) --i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;i&amp;&amp;nums[i]&gt;=nums[j]) --j;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>()+i+<span class="number">1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32 最长有效括号"></a>32 最长有效括号</h2><p>hard</p><hr><h2 id="33-旋转排序数组"><a href="#33-旋转排序数组" class="headerlink" title="33 旋转排序数组"></a>33 旋转排序数组</h2><p>二分法，中间切开一定有一边是有序的，然后比较就好，注意下标细节</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[l]&lt;=nums[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;=nums[l]&amp;&amp;target&lt;nums[mid]) r=mid<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> l=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;nums[mid]&amp;&amp;target&lt;=nums[r]) l=mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="34-手写lower-bound和upper-bound"><a href="#34-手写lower-bound和upper-bound" class="headerlink" title="34 手写lower_bound和upper_bound"></a>34 手写lower_bound和upper_bound</h2><p>二分法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="type">int</span> up = <span class="built_in">up_bound</span>(nums,target);</span><br><span class="line">        <span class="type">int</span> low = <span class="built_in">low_bound</span>(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(low == nums.<span class="built_in">size</span>()||nums[low] != target) <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;low,up&#125;; </span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">up_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="type">int</span> <span class="title">low_bound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="type">int</span> left=<span class="number">0</span>,right=nums.<span class="built_in">size</span>()<span class="number">-1</span>,mid=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;=right)</span><br><span class="line">            &#123;</span><br><span class="line">                mid = left+(right-left)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &gt;=target) right=mid<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="39-组合问题，可重复选"><a href="#39-组合问题，可重复选" class="headerlink" title="39 组合问题，可重复选"></a>39 组合问题，可重复选</h2><p>简单回溯，注意start标志位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target==sum) &#123;res.<span class="built_in">push_back</span>(path);<span class="keyword">return</span>;&#125;<span class="comment">//别忘记return</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;candidates.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            <span class="built_in">backTrace</span>(candidates,target,sum,i);<span class="comment">//传的是i不是start</span></span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42 接雨水"></a>42 接雨水</h2><p>hard题，单调栈</p><hr><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46 全排列"></a>46 全排列</h2><p>简单回溯，使用visit数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visit</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">backTrace</span>(nums,visit,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,vector&lt;<span class="type">int</span>&gt;&amp; visit,<span class="type">int</span> pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==nums.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                visit[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">backTrace</span>(nums,visit,pos+<span class="number">1</span>);</span><br><span class="line">                visit[i] = <span class="number">0</span>;</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a>48 旋转图像</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">上下对称：matrix[i][j] -&gt; matrix[n-i<span class="number">-1</span>][j]，（列不变）</span><br><span class="line">左右对称：matrix[i][j] -&gt; matrix[i][n-j<span class="number">-1</span>]，（行不变）</span><br><span class="line">主对角线对称：matrix[i][j] -&gt; matrix[j][i]，（行列互换）</span><br><span class="line">副对角线对称：matrix[i][j] -&gt; matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>] （行列均变，且互换）</span><br></pre></td></tr></table></figure><p>旋转90度：可以拆成<strong>上下对称+主对角线对称</strong><br>旋转180度：可以拆成<strong>上写对称+左右对称</strong><br>旋转270度：可以拆成<strong>左右对称+主对角线对称</strong><br>逆时针就是360-顺时针度数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        n = matrix.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上下对称 + 主对角线对称</span></span><br><span class="line">        <span class="built_in">upDownSymmetry</span>(matrix);</span><br><span class="line">        <span class="built_in">mainDiagSymmetry</span>(matrix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主对角线对称 + 左右对称</span></span><br><span class="line">        <span class="comment">// mainDiagSymmetry(matrix);</span></span><br><span class="line">        <span class="comment">// leftRightSymmetry(matrix);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左右对称 + 副对角线对称</span></span><br><span class="line">        <span class="comment">// leftRightSymmetry(matrix);</span></span><br><span class="line">        <span class="comment">// subdiagSymmetry(matrix);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 副对角线对称 + 上下对称</span></span><br><span class="line">        <span class="comment">// subdiagSymmetry(matrix);</span></span><br><span class="line">        <span class="comment">// upDownSymmetry(matrix);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下对称</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">upDownSymmetry</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n/<span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n-i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左右对称</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leftRightSymmetry</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n/<span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[i][n-j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主对角线对称</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mainDiagSymmetry</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[j][i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 副对角线对称</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">subdiagSymmetry</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n-i<span class="number">-1</span>; ++j) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(matrix[i][j], matrix[n-j<span class="number">-1</span>][n-i<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49 字母异位词分组"></a>49 字母异位词分组</h2><p>排序+哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string,vector&lt;string&gt;&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:strs)</span><br><span class="line">        &#123;</span><br><span class="line">            string s = str;</span><br><span class="line">            <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">            map[s].<span class="built_in">push_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; m:map)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(m.second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53 最大子数组和"></a>53 最大子数组和</h2><p>动态规划，注意数组下标，可用一个int来优化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> res=INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>()+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>],nums[i<span class="number">-1</span>]);</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55 跳跃游戏"></a>55 跳跃游戏</h2><p>贪心，直接跳就完事了，维护一个还能跳多少步的值，如果还能跳0步则return false</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> remainStep = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//数组只有一个元素且为0的情况</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(remainStep==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            remainStep = <span class="built_in">max</span>(remainStep<span class="number">-1</span>,nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56 合并区间"></a>56 合并区间</h2><p>排序，然后前边值和后边值比较</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="type">int</span> m=intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="type">int</span> n=intervals[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(),intervals.<span class="built_in">end</span>(),[](vector&lt;<span class="type">int</span>&gt; a,vector&lt;<span class="type">int</span>&gt; b)&#123;<span class="keyword">return</span> a[<span class="number">0</span>]&lt;b[<span class="number">0</span>];&#125;);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> left=intervals[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> right=intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(right&gt;=intervals[i][<span class="number">0</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                right=<span class="built_in">max</span>(right,intervals[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;left,right&#125;);</span><br><span class="line">                right=intervals[i][<span class="number">1</span>];</span><br><span class="line">                left=intervals[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(&#123;left,right&#125;);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="62-机器人走到右下角多少路径"><a href="#62-机器人走到右下角多少路径" class="headerlink" title="62 机器人走到右下角多少路径"></a>62 机器人走到右下角多少路径</h2><p>简单二维dp，优化到一维</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">top</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        top[<span class="number">1</span>]=<span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                top[j]+=left;</span><br><span class="line">                left=top[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> top[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="64-到矩阵右下角最小路径和"><a href="#64-到矩阵右下角最小路径和" class="headerlink" title="64 到矩阵右下角最小路径和"></a>64 到矩阵右下角最小路径和</h2><p>二维dp，注意原数组grid下标，以及初始条件INT_MAX即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(grid.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m=grid.<span class="built_in">size</span>(),n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,INT_MAX));</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">1</span>&amp;&amp;j==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>])+grid[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70 爬楼梯"></a>70 爬楼梯</h2><p>简单一维dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>,dp[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="72-两个字符串转换最小操作数"><a href="#72-两个字符串转换最小操作数" class="headerlink" title="72 两个字符串转换最小操作数"></a>72 两个字符串转换最小操作数</h2><p>hard题，三种操作，插入，删除，替换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">动态规划</span><br><span class="line">定义 dp[i][j]</span><br><span class="line"><span class="number">1.</span> dp[i][j] 代表 word1 中前 i 个字符，变换到 word2 中前 j 个字符，最短需要操作的次数</span><br><span class="line"><span class="number">2.</span> 需要考虑 word1 或 word2 一个字母都没有，即全增加/删除的情况，所以预留 dp[<span class="number">0</span>][j] 和 dp[i][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">状态转移</span><br><span class="line"><span class="number">1.</span> 增，dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="number">2.</span> 删，dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> 改，dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line"><span class="number">4.</span> 按顺序计算，当计算 dp[i][j] 时，dp[i - <span class="number">1</span>][j] ， dp[i][j - <span class="number">1</span>] ， dp[i - <span class="number">1</span>][j - <span class="number">1</span>] 均已经确定了</span><br><span class="line"><span class="number">5.</span> 配合增删改这三种操作，需要对应的 dp 把操作次数加一，取三种的最小</span><br><span class="line"><span class="number">6.</span> 如果刚好这两个字母相同 word1[i - <span class="number">1</span>] = word2[j - <span class="number">1</span>] ，那么可以直接参考 dp[i - <span class="number">1</span>][j - <span class="number">1</span>] ，操作不用加一</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=word1.<span class="built_in">size</span>(),n=word2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//字符串1长度为i，字符串2长度为0，需要删除i次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m+<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n+<span class="number">1</span>; j++) &#123;</span><br><span class="line">  <span class="comment">//当前字母相等，直接转移上一个的状态</span></span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//否则转移增，删，改的最小值 + 1</span></span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75 颜色分类"></a>75 颜色分类</h2><p>不能排序，直接用指针交换</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76 最小覆盖子串"></a>76 最小覆盖子串</h2><p>hard 滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=s.<span class="built_in">size</span>(),n=t.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) &#123;flag[t[i]]++;f[t[i]]=<span class="number">1</span>;&#125;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        string res =<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> minLen=m+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> min_L=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(f[s[r]])<span class="comment">//命中t中字符了</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--flag[s[r]]&gt;=<span class="number">0</span>) cnt++;<span class="comment">//cnt记录的就是t中的字符个数</span></span><br><span class="line">                <span class="keyword">while</span>(cnt==n)</span><br><span class="line">                &#123;<span class="comment">//记录下所求值</span></span><br><span class="line">                        <span class="keyword">if</span>(r-l+<span class="number">1</span>&lt;minLen)&#123;</span><br><span class="line">                            minLen = r-l+<span class="number">1</span>;</span><br><span class="line">                            min_L=l;</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="comment">//如果l指针是目标字符的话，++它使得cnt--跳出while循环</span></span><br><span class="line">                    <span class="keyword">if</span>(f[s[l]]&amp;&amp;++flag[s[l]]&gt;<span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        cnt--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen&gt;m?<span class="string">&quot;&quot;</span>:s.<span class="built_in">substr</span>(min_L,minLen);<span class="comment">//别忘了可能没找到</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="78-子集-组合问题"><a href="#78-子集-组合问题" class="headerlink" title="78 子集 组合问题"></a>78 子集 组合问题</h2><p>简单回溯，start标志位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> start)</span></span>&#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">dfs</span>(nums,i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79 单词搜索"></a>79 单词搜索</h2><p>回溯，注意dfs返回bool，各个分支要return</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; dir&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=board.<span class="built_in">size</span>(),n=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//if(m*n&lt;word.size())return false;</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visit</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,word,<span class="number">0</span>,i,j,visit))&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board,string word,<span class="type">int</span> pos,<span class="type">int</span> x,<span class="type">int</span> y,vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; visit)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[x][y]!=word[pos]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m=board.<span class="built_in">size</span>(),n=board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(pos==word.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        visit[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r=x+dir[i],c=y+dir[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(r&gt;=<span class="number">0</span>&amp;&amp;r&lt;m&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;n&amp;&amp;!visit[r][c]&amp;&amp;word[pos+<span class="number">1</span>]==board[r][c])</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">dfs</span>(board,word,pos+<span class="number">1</span>,r,c,visit)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visit[x][y]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="84-柱状图中最大矩形"><a href="#84-柱状图中最大矩形" class="headerlink" title="84 柱状图中最大矩形"></a>84 柱状图中最大矩形</h2><p>hard</p><hr><h2 id="85-最大矩形"><a href="#85-最大矩形" class="headerlink" title="85 最大矩形"></a>85 最大矩形</h2><p>hard</p><hr><h2 id="94-二叉树中序遍历-迭代版"><a href="#94-二叉树中序遍历-迭代版" class="headerlink" title="94 二叉树中序遍历-迭代版"></a>94 二叉树中序遍历-迭代版</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; s;</span><br><span class="line">        <span class="keyword">while</span>(root||!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(root)</span><br><span class="line">            &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">                root=root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            TreeNode* node = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            root=node-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="96-二叉搜素树多少种"><a href="#96-二叉搜素树多少种" class="headerlink" title="96 二叉搜素树多少种"></a>96 二叉搜素树多少种</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">G</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        G[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        G[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++j) &#123;</span><br><span class="line">                G[i] += G[j - <span class="number">1</span>] * G[i - j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> G[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98 验证二叉搜索树"></a>98 验证二叉搜索树</h2><p>二叉搜索树的中序遍历是有序的，中序遍历即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> pre=LONG_MIN;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">isValidBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val&lt;=pre) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        pre = root-&gt;val;</span><br><span class="line">        <span class="type">bool</span> right=<span class="built_in">isValidBST</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101 对称二叉树"></a>101 对称二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">helper</span>(root,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root1,TreeNode* root2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1&amp;&amp;!root2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root1||!root2) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> root1-&gt;val==root2-&gt;val &amp;&amp; <span class="built_in">helper</span>(root1-&gt;left,root2-&gt;right) &amp;&amp; <span class="built_in">helper</span>(root1-&gt;right,root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="102-二叉树层序遍历"><a href="#102-二叉树层序遍历" class="headerlink" title="102 二叉树层序遍历"></a>102 二叉树层序遍历</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>&#123;&#125;;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(n--)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="104-二叉树最大深度"><a href="#104-二叉树最大深度" class="headerlink" title="104 二叉树最大深度"></a>104 二叉树最大深度</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="105-前序和中序构造二叉树"><a href="#105-前序和中序构造二叉树" class="headerlink" title="105 前序和中序构造二叉树"></a>105 前序和中序构造二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">myBuildTree</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; preorder, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preorder_left, <span class="type">int</span> preorder_right, <span class="type">int</span> inorder_left, <span class="type">int</span> inorder_right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preorder_left &gt; preorder_right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 前序遍历中的第一个节点就是根节点</span></span><br><span class="line">        <span class="type">int</span> preorder_root = preorder_left;</span><br><span class="line">        <span class="comment">// 在中序遍历中定位根节点</span></span><br><span class="line">        <span class="type">int</span> inorder_root = index[preorder[preorder_root]];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先把根节点建立出来</span></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preorder_root]);</span><br><span class="line">        <span class="comment">// 得到左子树中的节点数目</span></span><br><span class="line">        <span class="type">int</span> size_left_subtree = inorder_root - inorder_left;</span><br><span class="line">        <span class="comment">// 递归地构造左子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素</span></span><br><span class="line">        root-&gt;left = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + <span class="number">1</span>, preorder_left + size_left_subtree, inorder_left, inorder_root - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归地构造右子树，并连接到根节点</span></span><br><span class="line">        <span class="comment">// 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素</span></span><br><span class="line">        root-&gt;right = <span class="built_in">myBuildTree</span>(preorder, inorder, preorder_left + size_left_subtree + <span class="number">1</span>, preorder_right, inorder_root + <span class="number">1</span>, inorder_right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = preorder.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 构造哈希映射，帮助我们快速定位根节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">myBuildTree</span>(preorder, inorder, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="114-二叉树展开成链表"><a href="#114-二叉树展开成链表" class="headerlink" title="114 二叉树展开成链表"></a>114 二叉树展开成链表</h2><p>使用栈，先进右孩子，再进左孩子，出栈存到vector里，再组装链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;TreeNode*&gt; vec;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* node = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            vec.<span class="built_in">push_back</span>(node);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) stk.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) stk.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> n=vec.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            TreeNode* prey = vec[i<span class="number">-1</span>];</span><br><span class="line">            TreeNode* cur = vec[i];</span><br><span class="line">            prey-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            prey-&gt;right = cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="121-买卖股票最佳时机"><a href="#121-买卖股票最佳时机" class="headerlink" title="121 买卖股票最佳时机"></a>121 买卖股票最佳时机</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=INT_MIN,minP = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> p:prices)</span><br><span class="line">        &#123;</span><br><span class="line">            minP = <span class="built_in">min</span>(minP,p);<span class="comment">//每一个都保存最低价</span></span><br><span class="line">            res = <span class="built_in">max</span>(res,p-minP);<span class="comment">//当前价格-最低价</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="124-二叉树最大路径和"><a href="#124-二叉树最大路径和" class="headerlink" title="124 二叉树最大路径和"></a>124 二叉树最大路径和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxSum = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">maxValue</span>(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum; </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归每个节点，算他们的左子树和右子树最大和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(TreeNode* root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftPathSum = <span class="built_in">max</span>(<span class="built_in">maxValue</span>(root-&gt;left),<span class="number">0</span>);<span class="comment">//算左子树最大和，避免负数</span></span><br><span class="line">        <span class="type">int</span> rightPathSum = <span class="built_in">max</span>(<span class="built_in">maxValue</span>(root-&gt;right),<span class="number">0</span>);<span class="comment">//算右子树最大和，避免负数</span></span><br><span class="line">        <span class="type">int</span> curPathSum = root-&gt;val + leftPathSum + rightPathSum;<span class="comment">//当前节点路径和</span></span><br><span class="line">        maxSum = <span class="built_in">max</span>(maxSum,curPathSum);<span class="comment">//维护最大和</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(leftPathSum,rightPathSum);<span class="comment">//向上返回最大和，选大的那边</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="128-最长连续序列，无序-set"><a href="#128-最长连续序列，无序-set" class="headerlink" title="128 最长连续序列，无序 set"></a>128 最长连续序列，无序 set</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; set;</span><br><span class="line">        <span class="type">int</span> longestLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            set.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; x:set)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.<span class="built_in">count</span>(x<span class="number">-1</span>))<span class="comment">//如果左边值没有，说明它是头，开始统计</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> curLen = <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> num = x;</span><br><span class="line">                <span class="keyword">while</span>(set.<span class="built_in">count</span>(num+<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    curLen++;</span><br><span class="line">                    num++;</span><br><span class="line">                &#125;</span><br><span class="line">                longestLen = <span class="built_in">max</span>(longestLen,curLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longestLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="136-只出现一次的数字-异或运算"><a href="#136-只出现一次的数字-异或运算" class="headerlink" title="136 只出现一次的数字 异或运算"></a>136 只出现一次的数字 异或运算</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res ^= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="139-单词组成"><a href="#139-单词组成" class="headerlink" title="139 单词组成"></a>139 单词组成</h2><p>动态规划</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(s.size()+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> n= s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; str:wordDict)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;str.<span class="built_in">size</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i] = dp[i]||dp[i-str.<span class="built_in">size</span>()]&amp;&amp;s.<span class="built_in">substr</span>(i-str.<span class="built_in">size</span>(),str.<span class="built_in">size</span>())==str;</span><br><span class="line">                <span class="comment">//if(dp[i]) break;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141 环形链表"></a>141 环形链表</h2><p>快慢指针，追两次</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)<span class="comment">//为nullptr跳出说明无环</span></span><br><span class="line">        &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)<span class="comment">//追上跳出 true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="142-环形链表返回节点"><a href="#142-环形链表返回节点" class="headerlink" title="142 环形链表返回节点"></a>142 环形链表返回节点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast&amp;&amp;fast-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=fast-&gt;next-&gt;next;</span><br><span class="line">            slow=slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)</span><br><span class="line">            &#123;</span><br><span class="line">                fast=head;</span><br><span class="line">                <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">                &#123;</span><br><span class="line">                    slow=slow-&gt;next;</span><br><span class="line">                    fast=fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="146-LRU缓存"><a href="#146-LRU缓存" class="headerlink" title="146 LRU缓存"></a>146 LRU缓存</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m_key;</span><br><span class="line">    <span class="type">int</span> m_value;</span><br><span class="line">    LinkNode* m_prey,*m_next;</span><br><span class="line">    <span class="built_in">LinkNode</span>()&#123;&#125;</span><br><span class="line">    <span class="built_in">LinkNode</span>(<span class="type">int</span> key,<span class="type">int</span> value):<span class="built_in">m_key</span>(key),<span class="built_in">m_value</span>(value),<span class="built_in">m_prey</span>(<span class="literal">nullptr</span>),<span class="built_in">m_next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>,LinkNode*&gt; m_cathe;</span><br><span class="line">    LinkNode* m_head;</span><br><span class="line">    LinkNode* m_tail;</span><br><span class="line">    <span class="type">int</span> m_capacity;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity) &#123;</span><br><span class="line">        m_capacity = capacity;</span><br><span class="line">        m_size = <span class="number">0</span>;</span><br><span class="line">        m_head = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">        m_tail = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">        m_head-&gt;m_next = m_tail;</span><br><span class="line">        m_tail-&gt;m_prey = m_head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_cathe.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            LinkNode* node = m_cathe[key];</span><br><span class="line">            <span class="built_in">removeNode</span>(node);</span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            <span class="keyword">return</span> node-&gt;m_value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_cathe.<span class="built_in">count</span>(key))</span><br><span class="line">        &#123;</span><br><span class="line">            LinkNode* node = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(key,value);</span><br><span class="line">            m_cathe[key] = node;<span class="comment">//别忘记维护map</span></span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            m_size++;</span><br><span class="line">            <span class="keyword">if</span>(m_size&gt;m_capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                LinkNode* tailnode = <span class="built_in">removeTail</span>();</span><br><span class="line">                m_cathe.<span class="built_in">erase</span>(tailnode-&gt;m_key);<span class="comment">//同样别忘记维护map</span></span><br><span class="line">                <span class="keyword">delete</span> tailnode;<span class="comment">//防止内存泄露</span></span><br><span class="line">                m_size--;<span class="comment">//size要还原回来</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LinkNode* node = m_cathe[key];</span><br><span class="line">            node-&gt;m_value = value;</span><br><span class="line">            <span class="built_in">removeNode</span>(node);</span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(LinkNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_head-&gt;m_next-&gt;m_prey = node;</span><br><span class="line">        node-&gt;m_next = m_head-&gt;m_next;</span><br><span class="line">        m_head-&gt;m_next = node;</span><br><span class="line">        node-&gt;m_prey = m_head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">LinkNode* <span class="title">removeTail</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LinkNode* tailnode = m_tail-&gt;m_prey;</span><br><span class="line">        tailnode-&gt;m_prey-&gt;m_next = m_tail;</span><br><span class="line">        m_tail-&gt;m_prey = tailnode-&gt;m_prey;</span><br><span class="line">        <span class="keyword">return</span> tailnode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(LinkNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        node-&gt;m_prey-&gt;m_next = node-&gt;m_next;</span><br><span class="line">        node-&gt;m_next-&gt;m_prey = node-&gt;m_prey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148 排序链表"></a>148 排序链表</h2><p>使用multimap，map和multimap自带排序，全插进去后遍历建立链表就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        multimap&lt;<span class="type">int</span>,ListNode*&gt; map;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(head-&gt;val,head));</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head=dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> iter=map.<span class="built_in">begin</span>();iter!=map.<span class="built_in">end</span>();++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            head-&gt;next=iter-&gt;second;</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="152-乘积最大的子数组-dp"><a href="#152-乘积最大的子数组-dp" class="headerlink" title="152 乘积最大的子数组 dp"></a>152 乘积最大的子数组 dp</h2><p>开始想一维dp，发现如果连续两个负数的话需要前边舍去的状态值，很自然的想到需要记录正，负两个状态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpMax</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dpMin</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dpMax[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        dpMin[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = dpMax[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;++i)<span class="comment">//注意范围时n+1</span></span><br><span class="line">        &#123;</span><br><span class="line">            dpMax[i] = <span class="built_in">max</span>(nums[i<span class="number">-1</span>],<span class="built_in">max</span>(dpMax[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>],dpMin[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>]));</span><br><span class="line">            dpMin[i] = <span class="built_in">min</span>(nums[i<span class="number">-1</span>],<span class="built_in">min</span>(dpMax[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>],dpMin[i<span class="number">-1</span>]*nums[i<span class="number">-1</span>]));</span><br><span class="line">            res = <span class="built_in">max</span>(res,dpMax[i]);<span class="comment">//注意dp存的是以当前结尾的最大最小积，要遍历求最终最大的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155 最小栈"></a>155 最小栈</h2><p>双栈实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minstk;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            stk.<span class="built_in">push</span>(val);</span><br><span class="line">            minstk.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            minstk.<span class="built_in">push</span>(<span class="built_in">min</span>(minstk.<span class="built_in">top</span>(),val));</span><br><span class="line">            stk.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        minstk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minstk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>单栈实现，保存最小值和差值</p><p>单栈方法栈中存放 val-min ,再用一个min变量存放最小值 val - min = stk.top();</p><p>这样递推就好了，top</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">long</span> <span class="type">long</span>&gt; m_stk;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> m_min;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            m_min=val;</span><br><span class="line">            m_stk.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            m_stk.<span class="built_in">push</span>(val-m_min);</span><br><span class="line">            <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>) m_min=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            m_min -= m_stk.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m_stk.<span class="built_in">top</span>()&lt;<span class="number">0</span>) <span class="keyword">return</span> m_min;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> m_stk.<span class="built_in">top</span>()+m_min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160 相交链表"></a>160 相交链表</h2><p>hashmap处理 时间O(m+n)，空间O(m)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;ListNode*,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">while</span>(headA)&#123;</span><br><span class="line">            map[headA]++;</span><br><span class="line">            headA =headA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(headB)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(headB)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB=headB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>双指针  时间O(m+n)，空间O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *pA = headA, *pB = headB;</span><br><span class="line">        <span class="comment">//如果链表有交点的话，pA走完a+c距离，指向pB的head再走b距离到第二次到交点</span></span><br><span class="line">        <span class="comment">//pB也是走完b+c的距离再走a到交点，他俩都走a+b+c后相等，就是交点</span></span><br><span class="line">        <span class="comment">//如果没交点，都走完a+b的距离就都到了nullptr，不会无限循环</span></span><br><span class="line">        <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">            pA = pA == <span class="literal">nullptr</span> ? headB : pA-&gt;next;</span><br><span class="line">            pB = pB == <span class="literal">nullptr</span> ? headA : pB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="169-找众数"><a href="#169-找众数" class="headerlink" title="169 找众数"></a>169 找众数</h2><p>思想是不相同的”对掉“，最后剩下的一定是众数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> candicate=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> count =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num==candicate)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(--count&lt;<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    candicate=num;</span><br><span class="line">                    count=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> candicate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198 打家劫舍"></a>198 打家劫舍</h2><p>简单dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>]=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>],dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200 岛屿数量"></a>200 岛屿数量</h2><p>BFS</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n=grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dir&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">flag</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">visit</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(flag[i][j]==<span class="number">0</span>&amp;&amp;grid[i][j]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    visit[i][j]=<span class="number">1</span>;</span><br><span class="line">                    flag[i][j]=<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">auto</span>[x,y] = q.<span class="built_in">front</span>();</span><br><span class="line">                        q.<span class="built_in">pop</span>();</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">4</span>;++k)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="type">int</span> r=x+dir[k],c=y+dir[k+<span class="number">1</span>];</span><br><span class="line">                            <span class="keyword">if</span>(r&gt;=<span class="number">0</span>&amp;&amp;r&lt;m&amp;&amp;c&gt;=<span class="number">0</span>&amp;&amp;c&lt;n&amp;&amp;visit[r][c]==<span class="number">0</span>&amp;&amp;grid[r][c]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                q.<span class="built_in">push</span>(&#123;r,c&#125;);</span><br><span class="line">                                visit[r][c]=<span class="number">1</span>;</span><br><span class="line">                                flag[r][c]=<span class="number">1</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206 反转链表"></a>206 反转链表</h2><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head||!head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode* p = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next=<span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy=<span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        <span class="keyword">while</span>(head)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* tmp=head-&gt;next;</span><br><span class="line">            head-&gt;next = dummy-&gt;next;</span><br><span class="line">            dummy-&gt;next = head;</span><br><span class="line">            head = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="207-拓扑排序–课程表"><a href="#207-拓扑排序–课程表" class="headerlink" title="207 拓扑排序–课程表"></a>207 拓扑排序–课程表</h2><p>同类题目lc-210</p><p><strong>BFS:</strong></p><p>bfs的思路是先建立邻接矩阵，统计好所有节点的度，把所有度为0的节点入队，然后每次出队把当前节点连接的节点的度-1，如果为0的话就入队。每有一个出队就visit++，最终如果无环的环应该刚好每个节点visit一遍，也就是visit的值等于节点数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; indeg;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        indeg.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; pre:prerequisites)</span><br><span class="line">        &#123;</span><br><span class="line">            edges[pre[<span class="number">1</span>]].<span class="built_in">push_back</span>(pre[<span class="number">0</span>]);</span><br><span class="line">            indeg[pre[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;numCourses;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(indeg[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> visit=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            visit++;</span><br><span class="line">            <span class="type">int</span> x= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; c:edges[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[c]==<span class="number">0</span>) q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visit==numCourses;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>bfs比较好想且代码好写，并且稍微出队顺序就是拓扑排序的顺序</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            visit++;</span><br><span class="line">            <span class="type">int</span> x= q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(x);<span class="comment">//出队时加入节点就行</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>&amp; c:edges[x])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(--indeg[c]==<span class="number">0</span>) q.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> res.<span class="built_in">size</span>()==numCourses?res:vector&lt;<span class="type">int</span>&gt;&#123;&#125;;<span class="comment">//有环的话输出空数组</span></span><br></pre></td></tr></table></figure><p>DFS：</p><p>dfs的思路其实就是暴力递归，把所有节点视为起点进行遍历，节点分为三种状态，状态0代表未访问过，状态1代表当前dfs路径中访问过的，状态2表示已经访问完的。如果在同一个dfs路径中又经过了状态1的节点，说明有环。</p><p>关于为什么要分状态1和状态2，比如1-&gt;2-&gt;3-&gt;4; 5-&gt;3;这种情况第一次dfs路径1234如果不把他们标记成状态2还是状态1的话，下一条路径53是就会错误的识别成有环状态</p><p>另外我们可以用valid进行剪枝，已经有环了就不用继续dfs下去了，同时其他路径也不用在开始dfs了</p><p>dfs方法最后拓扑排序我们在每次节点变成状态2时存，必然是递归到最后出度为0的点，这样的结果是倒序的，需要最后reverse或者用stack来存取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;<span class="comment">//存储结果用的res，是倒序的，也可以用stack来存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;<span class="comment">//剪枝1</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;<span class="comment">//识别有环</span></span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;<span class="comment">//这里valid剪枝2</span></span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(),res.<span class="built_in">end</span>());<span class="comment">//逆序输出</span></span><br><span class="line">        <span class="keyword">return</span> valid?res:vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="208-前缀树"><a href="#208-前缀树" class="headerlink" title="208 前缀树"></a>208 前缀树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; chirdren;</span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp; c:prefix)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ch = c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;chirdren[ch]==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">else</span> node=node-&gt;chirdren[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() :<span class="built_in">chirdren</span>(<span class="number">26</span>),<span class="built_in">isEnd</span>(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>&amp; c:word)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ch = c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;chirdren[ch]==<span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                Trie* child = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">                node-&gt;chirdren[ch]=child;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;chirdren[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="built_in">searchPrefix</span>(prefix);</span><br><span class="line">        <span class="keyword">return</span> node!=<span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="215-第K大元素"><a href="#215-第K大元素" class="headerlink" title="215 第K大元素"></a>215 第K大元素</h2><p>优先队列，小根堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x&gt;y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;++i) q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(q.<span class="built_in">top</span>()&lt;nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                q.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>自建堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 对前k个元素建成小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="built_in">swim</span>(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">                <span class="built_in">sink</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束后第k个大的数就是小根堆的堆顶</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若v1比v2优先度高，返回true</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">priorityThan</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123; <span class="keyword">return</span> v1 &lt; v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮 从下到上调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">priorityThan</span>(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉 从下到上调整堆</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N &amp;&amp; <span class="built_in">priorityThan</span>(heap[j + <span class="number">1</span>], heap[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">priorityThan</span>(heap[i], heap[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快速选择</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">方法一：利用快排特性来做</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> index = <span class="built_in">quickSelect</span>(nums,left,right);</span><br><span class="line">            <span class="keyword">if</span>(index == k - <span class="number">1</span>)&#123;<span class="keyword">return</span> nums[index];&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; k - <span class="number">1</span>)&#123;right = index <span class="number">-1</span>;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;left = index +<span class="number">1</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//防止特殊测试用例，使时间复杂度退化为n2</span></span><br><span class="line">        <span class="type">int</span> idx = <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left],nums[idx]);</span><br><span class="line">        <span class="type">int</span> pivot = nums[left];<span class="comment">//设置枢轴</span></span><br><span class="line">        <span class="type">int</span> preleft = left;<span class="comment">//left接下来会变，所以要留下指针最后用于交换</span></span><br><span class="line">        <span class="keyword">while</span>(left != right)</span><br><span class="line">        &#123; <span class="comment">//因为每次以最左边元素为枢轴，所以必须先从右边找，顺序不能变，才能保证每次找到一个枢轴，使之左边都大于它，右边都小于它；</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] &lt;= pivot)&#123;right--;&#125;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] &gt;= pivot)&#123;left++;&#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[left],nums[right]);   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left],nums[preleft]);</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221 最大正方形"></a>221 最大正方形</h2><p>二维dp，每个dp元素代表正方形边长，转移方程是左边，上边，和左上最小的边长+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maximalSquare</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m= matrix.<span class="built_in">size</span>(),n= matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxE = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;++i)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(<span class="built_in">min</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]),dp[i<span class="number">-1</span>][j<span class="number">-1</span>]) +<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    maxE = <span class="built_in">max</span>(maxE,dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> maxE*maxE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226 翻转二叉树"></a>226 翻转二叉树</h2><p>直接交换左右节点，然后递归翻转</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234 回文链表"></a>234 回文链表</h2><p>放进vector，用双指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vals.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = (<span class="type">int</span>)vals.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vals[i] != vals[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="236-二叉树最近公共祖先"><a href="#236-二叉树最近公共祖先" class="headerlink" title="236 二叉树最近公共祖先"></a>236 二叉树最近公共祖先</h2><p>解题思路：</p><ul><li>思考递归的返回值的含义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 若树里面存在p，也存在q，则返回他们的公共祖先。</span><br><span class="line">2. 若树里面只存在p，或只存在q，则返回存在的那一个。</span><br><span class="line">3. 若树里面即不存在p，也不存在q，则返回null。</span><br></pre></td></tr></table></figure><p>对每一个递归的元素先判断是否为null，为null返回null，如果为p或q，直接返回p或q</p><p>之后递归左右孩子，对左右孩子可能出现的情况进行讨论，分三种情况：<br>1.左右都为null，则说明左右子树都不包含p或q<br>2.如果左右一个为null，一个不为null，则返回不为null的那个<br>3.如果都不为null，说明左右子树分别包含了p和q，那么祖先自然就是root了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root||root==p||root==q) <span class="keyword">return</span> root;</span><br><span class="line">        root-&gt;left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        root-&gt;right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>&amp;&amp; root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left==<span class="literal">nullptr</span>) <span class="keyword">return</span>  root-&gt;right;</span><br><span class="line">        <span class="keyword">if</span>( root-&gt;right==<span class="literal">nullptr</span>) <span class="keyword">return</span> root-&gt;left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238 除自身以外数组的乘积"></a>238 除自身以外数组的乘积</h2><p>使用一个数组，从前往后乘一遍，再从后往前乘一遍</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(),<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = nums[i<span class="number">-1</span>]*pre;</span><br><span class="line">            pre = res[i];</span><br><span class="line">        &#125;</span><br><span class="line">        pre=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-2</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">        &#123;</span><br><span class="line">            pre = nums[i+<span class="number">1</span>]*pre;</span><br><span class="line">            res[i] *= pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239 滑动窗口最大值"></a>239 滑动窗口最大值</h2><p>hard  单调队列，用deque 时间O(n)，空间O(k)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="comment">//1.先判断最左边下边是否超出范围了，超出就pop</span></span><br><span class="line">            <span class="keyword">if</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() == i-k)&#123;</span><br><span class="line">                q.<span class="built_in">pop_front</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.保持q永远是从大到小的单调队列，并且里边存的都是当前的最大值</span></span><br><span class="line">            <span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; nums[q.<span class="built_in">back</span>()] &lt; nums[i] )&#123;</span><br><span class="line">                q.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            q.<span class="built_in">push_back</span>(i);<span class="comment">//注意存进去的是下标</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)&#123; <span class="comment">//从第k-1个下标开始就要输出最大值了</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[q.<span class="built_in">front</span>()]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="240-搜索二维矩阵"><a href="#240-搜索二维矩阵" class="headerlink" title="240 搜索二维矩阵"></a>240 搜索二维矩阵</h2><p>Z字搜索，从右上角开始</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>(), i = <span class="number">0</span>,j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;m&amp;&amp;j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[i][j] &gt; target)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="253-会议室二"><a href="#253-会议室二" class="headerlink" title="253 会议室二"></a>253 会议室二</h2><p>要开会员</p><hr><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279 完全平方数"></a>279 完全平方数</h2><p>dp，两层for</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,INT_MAX)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j*j&lt;=i;++j)&#123;</span><br><span class="line">                dp[i] = <span class="built_in">min</span>(dp[i],dp[i-j*j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283 移动零"></a>283 移动零</h2><p>指针复制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="type">int</span> x : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[k++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">while</span>(k&lt; nums.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        nums[k++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="287-寻找重复数（快慢指针）"><a href="#287-寻找重复数（快慢指针）" class="headerlink" title="287 寻找重复数（快慢指针）"></a>287 寻找重复数（快慢指针）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDuplicate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow =<span class="number">0</span>,fast=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;<span class="keyword">while</span>(slow!=fast);</span><br><span class="line"></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow)</span><br><span class="line">        &#123;</span><br><span class="line">            fast=nums[fast];</span><br><span class="line">            slow=nums[slow];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="297-二叉树的序列化与反序列化"><a href="#297-二叉树的序列化与反序列化" class="headerlink" title="297 二叉树的序列化与反序列化"></a>297 二叉树的序列化与反序列化</h2><hr><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300 最长递增子序列"></a>300 最长递增子序列</h2><p>dp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i]) dp[i] = <span class="built_in">max</span>(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res,dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="301-删除无效的括号"><a href="#301-删除无效的括号" class="headerlink" title="301 删除无效的括号"></a>301 删除无效的括号</h2><p>hard</p><hr><h2 id="309-股票买卖含冷冻期"><a href="#309-股票买卖含冷冻期" class="headerlink" title="309 股票买卖含冷冻期"></a>309 股票买卖含冷冻期</h2><p>每个dp元素有三种状态，有股票，无股票在冷冻期，无股票不在冷冻期</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i]);<span class="comment">//有股票</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + prices[i];<span class="comment">//无股票 在冷冻期</span></span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]);<span class="comment">//无股票 不在冷冻期</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[n<span class="number">-1</span>][<span class="number">1</span>],dp[n<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="312-戳气球"><a href="#312-戳气球" class="headerlink" title="312 戳气球"></a>312 戳气球</h2><p>hard</p><hr><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322 零钱兑换"></a>322 零钱兑换</h2><p>完全背包，硬币为列，价值为行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//因为后边要取min，这里要用INT_MAX，防止溢出-1</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(amount+<span class="number">1</span>,INT_MAX<span class="number">-1</span>)</span></span>;</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;coins.<span class="built_in">size</span>();++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;amount+<span class="number">1</span>;j++) <span class="comment">//完全背包正序</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=coins[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    f[j] = <span class="built_in">min</span>(f[j],f[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[amount]==INT_MAX<span class="number">-1</span>?<span class="number">-1</span>:f[amount];        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="337-树状dp-打家劫舍三"><a href="#337-树状dp-打家劫舍三" class="headerlink" title="337 树状dp-打家劫舍三"></a>337 树状dp-打家劫舍三</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;TreeNode*, <span class="type">int</span>&gt; f, g;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left);</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">        g[node] = <span class="built_in">max</span>(f[node-&gt;left], g[node-&gt;left]) + <span class="built_in">max</span>(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[root], g[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="338-比特位计数"><a href="#338-比特位计数" class="headerlink" title="338 比特位计数"></a>338 比特位计数</h2><hr><h2 id="347-前k个高频元素"><a href="#347-前k个高频元素" class="headerlink" title="347 前k个高频元素"></a>347 前k个高频元素</h2><p>优先队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; m, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; n)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> m.second &gt; n.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// static bool cmp(pair&lt;int, int&gt;&amp; m, pair&lt;int, int&gt;&amp; n) &#123;</span></span><br><span class="line">    <span class="comment">//     return m.second &gt; n.second;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; occurrences;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : nums) &#123;</span><br><span class="line">            occurrences[v]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [num, count] : occurrences) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">top</span>().second &lt; count) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(num, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ret.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394 字符串解码"></a>394 字符串解码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">getDigits</span><span class="params">(string &amp;s, <span class="type">size_t</span> &amp;ptr)</span> </span>&#123;</span><br><span class="line">        string ret = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">isdigit</span>(s[ptr])) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(s[ptr++]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getString</span><span class="params">(vector &lt;string&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        string ret;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;s: v) &#123;</span><br><span class="line">            ret += s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector &lt;string&gt; stk;</span><br><span class="line">        <span class="type">size_t</span> ptr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (ptr &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> cur = s[ptr];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(cur)) &#123;</span><br><span class="line">                <span class="comment">// 获取一个数字并进栈</span></span><br><span class="line">                string digits = <span class="built_in">getDigits</span>(s, ptr);</span><br><span class="line">                stk.<span class="built_in">push_back</span>(digits);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">isalpha</span>(cur) || cur == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取一个字母并进栈</span></span><br><span class="line">                stk.<span class="built_in">push_back</span>(<span class="built_in">string</span>(<span class="number">1</span>, s[ptr++])); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++ptr;</span><br><span class="line">                vector &lt;string&gt; sub;</span><br><span class="line">                <span class="keyword">while</span> (stk.<span class="built_in">back</span>() != <span class="string">&quot;[&quot;</span>) &#123;</span><br><span class="line">                    sub.<span class="built_in">push_back</span>(stk.<span class="built_in">back</span>());</span><br><span class="line">                    stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">reverse</span>(sub.<span class="built_in">begin</span>(), sub.<span class="built_in">end</span>());</span><br><span class="line">                <span class="comment">// 左括号出栈</span></span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                <span class="comment">// 此时栈顶为当前 sub 对应的字符串应该出现的次数</span></span><br><span class="line">                <span class="type">int</span> repTime = <span class="built_in">stoi</span>(stk.<span class="built_in">back</span>()); </span><br><span class="line">                stk.<span class="built_in">pop_back</span>();</span><br><span class="line">                string t, o = <span class="built_in">getString</span>(sub);</span><br><span class="line">                <span class="comment">// 构造字符串</span></span><br><span class="line">                <span class="keyword">while</span> (repTime--) t += o; </span><br><span class="line">                <span class="comment">// 将构造好的字符串入栈</span></span><br><span class="line">                stk.<span class="built_in">push_back</span>(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getString</span>(stk);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="399-除法求值"><a href="#399-除法求值" class="headerlink" title="399 除法求值"></a>399 除法求值</h2><hr><h2 id="406-根据身高重建队列"><a href="#406-根据身高重建队列" class="headerlink" title="406 根据身高重建队列"></a>406 根据身高重建队列</h2><p>排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),[](<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a,<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>] ||(a[<span class="number">0</span>] == b[<span class="number">0</span>]&amp;&amp;a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="type">int</span> n = people.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>()+people[i][<span class="number">1</span>],people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416 分割等和子集"></a>416 分割等和子集</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> w = <span class="built_in">accumulate</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> max_value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(x&gt;max_value) max_value = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(max_value&gt;w/<span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>||w%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//vector&lt;vector&lt;bool&gt;&gt; dp(n+1,vector&lt;bool&gt;(w/2+1,false));</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(w/<span class="number">2</span>+<span class="number">1</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=w/<span class="number">2</span>;j&gt;=nums[i<span class="number">-1</span>];--j)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j] = dp[j] || dp[j-nums[i<span class="number">-1</span>]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[w/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="437-路经总和三"><a href="#437-路经总和三" class="headerlink" title="437 路经总和三"></a>437 路经总和三</h2><p>dfs:<br>1.遍历每个节点算路径数，再加起来<br>2.对于每个节点，递归去求</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">curNodePath</span>(root,targetSum);</span><br><span class="line">        res += <span class="built_in">pathSum</span>(root-&gt;left,targetSum);</span><br><span class="line">        res += <span class="built_in">pathSum</span>(root-&gt;right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">curNodePath</span><span class="params">(TreeNode* root,<span class="type">int</span> targetSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span>  pathNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == targetSum) pathNum++;</span><br><span class="line">        pathNum += <span class="built_in">curNodePath</span>(root-&gt;left,targetSum-root-&gt;val);<span class="comment">//target-当前值</span></span><br><span class="line">        pathNum += <span class="built_in">curNodePath</span>(root-&gt;right,targetSum-root-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> pathNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="438-字符串匹配-滑动窗口"><a href="#438-字符串匹配-滑动窗口" class="headerlink" title="438 字符串匹配 滑动窗口"></a>438 字符串匹配 滑动窗口</h2><p>滑动窗口，存少子串的字母，然后滑动，r-l+1==n的时候存结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m=s.<span class="built_in">size</span>(),n=p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(m&lt;n) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">flag</span><span class="params">(<span class="number">128</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i) flag[p[i]]++; <span class="comment">//类似hash</span></span><br><span class="line">        <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            flag[s[r]]--;</span><br><span class="line">            <span class="keyword">while</span>(flag[s[r]]&lt;<span class="number">0</span>) <span class="comment">//&lt;0说明当前是非目标元素或者目标元素多了</span></span><br><span class="line">            &#123;</span><br><span class="line">                flag[s[l]]++;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(r-l+<span class="number">1</span> == n) res.<span class="built_in">push_back</span>(l);</span><br><span class="line">            r++; <span class="comment">//别忘了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="448-鸽笼原理"><a href="#448-鸽笼原理" class="headerlink" title="448 鸽笼原理"></a>448 鸽笼原理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findDisappearedNumbers</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//鸽笼原理</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>&amp; x:nums)</span><br><span class="line">        &#123;   <span class="comment">//遍历每个数，把他们对应的鸽笼变为负数（只要能区分访问过就行）</span></span><br><span class="line">            nums[<span class="built_in">abs</span>(x)<span class="number">-1</span>] = -<span class="built_in">abs</span>(nums[<span class="built_in">abs</span>(x)<span class="number">-1</span>]);<span class="comment">//注意下标要-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) res.<span class="built_in">push_back</span>(i+<span class="number">1</span>);<span class="comment">//&gt;0说明没访问过</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="461-汉明距离"><a href="#461-汉明距离" class="headerlink" title="461 汉明距离"></a>461 汉明距离</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> z = x^y;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(z) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z&amp;<span class="number">1</span>) res++; <span class="comment">//&amp;1返回0或1</span></span><br><span class="line">        z&gt;&gt;=<span class="number">1</span>; <span class="comment">//循环右移1位，注意&gt;&gt;=,有=号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><hr><h2 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494 目标和"></a>494 目标和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backTrace</span>(nums,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> target,<span class="type">int</span> pos,<span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos==nums.<span class="built_in">size</span>()) <span class="comment">//回溯到数组长度要return</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;<span class="comment">//此时等于结果，记录下来</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">backTrace</span>(nums,target,pos+<span class="number">1</span>,sum+nums[pos]);</span><br><span class="line">        <span class="built_in">backTrace</span>(nums,target,pos+<span class="number">1</span>,sum-nums[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="538-二叉搜索树转换成累加树"><a href="#538-二叉搜索树转换成累加树" class="headerlink" title="538 二叉搜索树转换成累加树"></a>538 二叉搜索树转换成累加树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">//逆向中序遍历即可</span></span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;right);</span><br><span class="line">        sum += root-&gt;val;</span><br><span class="line">        root-&gt;val = sum;</span><br><span class="line">        <span class="built_in">convertBST</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543 二叉树的直径"></a>543 二叉树的直径</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">helper</span>(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回的是树的高度</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">helper</span><span class="params">(TreeNode* root, <span class="type">int</span>&amp; res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">helper</span>(root-&gt;left,res);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">helper</span>(root-&gt;right,res);</span><br><span class="line">        res = <span class="built_in">max</span>(res,left+right);<span class="comment">//要求的是两个节点路径，所以要-1，和+1抵消了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="560-和为k的子数组-前缀和"><a href="#560-和为k的子数组-前缀和" class="headerlink" title="560 和为k的子数组  前缀和"></a>560 和为k的子数组  前缀和</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        map[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pnums = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();++i)&#123;</span><br><span class="line">            pnums += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.<span class="built_in">count</span>(pnums-k))&#123;</span><br><span class="line">                cnt += map[pnums-k];<span class="comment">//注意cnt可能不为1</span></span><br><span class="line">            &#125;</span><br><span class="line">            map[pnums]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581 最短无序连续子数组"></a>581 最短无序连续子数组</h2><p>方法一：排序后左右遍历两遍，找到第一个不相等的左右下标相减</p><p>方法二：一次遍历，动态维护一个最大值和最小值，注意左右下标初始值为-1,因为可能初始就有序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findUnsortedSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxn = INT_MIN, right = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> minn = INT_MAX, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxn &gt; nums[i]) &#123;</span><br><span class="line">                right = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minn &lt; nums[n - i - <span class="number">1</span>]) &#123;</span><br><span class="line">                left = n - i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                minn = nums[n - i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right == <span class="number">-1</span> ? <span class="number">0</span> : right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617 合并二叉树"></a>617 合并二叉树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root1&amp;&amp;!root2) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root1) <span class="keyword">return</span> root2;</span><br><span class="line">        <span class="keyword">if</span>(!root2) <span class="keyword">return</span> root1;</span><br><span class="line">        root1-&gt;val += root2-&gt;val;</span><br><span class="line">        root1-&gt;left = <span class="built_in">mergeTrees</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        root1-&gt;right = <span class="built_in">mergeTrees</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="621-任务调度器"><a href="#621-任务调度器" class="headerlink" title="621 任务调度器"></a>621 任务调度器</h2><hr><h2 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647 回文子串"></a>647 回文子串</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();++i)&#123;</span><br><span class="line">            count += <span class="built_in">exSub</span>(s,i,i);</span><br><span class="line">            count += <span class="built_in">exSub</span>(s,i,i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">exSub</span><span class="params">(string&amp; s,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span> &amp;&amp; r&lt; s.<span class="built_in">length</span>() &amp;&amp; s[l] == s[r])&#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            l--;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739 每日温度"></a>739 每日温度</h2><p>单调栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);<span class="comment">//维护一个单调递减栈，栈里边是下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LC-Hot100总结&quot;&gt;&lt;a href=&quot;#LC-Hot100总结&quot; class=&quot;headerlink&quot; title=&quot;LC Hot100总结&quot;&gt;&lt;/a&gt;LC Hot100总结&lt;/h1&gt;&lt;h2 id=&quot;3-无重复最长子串&quot;&gt;&lt;a href=&quot;#3-无重复最长子</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构（二）|Fermi架构</title>
    <link href="http://icecorn.github.io/2022/07/02/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%BA%8C%EF%BC%89Fermi%E6%9E%B6%E6%9E%84/"/>
    <id>http://icecorn.github.io/2022/07/02/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%BA%8C%EF%BC%89Fermi%E6%9E%B6%E6%9E%84/</id>
    <published>2022-07-02T09:25:10.000Z</published>
    <updated>2022-07-23T02:35:42.395Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU架构系列-二）-Fermi架构"><a href="#GPU架构系列-二）-Fermi架构" class="headerlink" title="GPU架构系列(二）| Fermi架构"></a>GPU架构系列(二）| Fermi架构</h1><p>当Tesla架构在硬件上统一了各种着色器后，统一的可编程着色技术让我们得以驾轻就熟地逐像素做光照、实现各种后处理效果，似乎一切都很完美？但为什么还是与电影画面相去甚远？在2010的时间点上，电影每帧可以使用到的三角形可以达到数亿个，而游戏则只有一两百万个。<strong>三角形数量级上的差距，导致模型精细度上的巨大差异，光照再华丽又有什么意义呢？</strong></p><p>那到底是什么拖了实时渲染几何处理上的后腿呢？要回答这个问题，我们需要先来回顾一下Tesla架构：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-65a203eef8b3e730d2238f597f8b16f0_720w.jpg" alt="img"></p><p>看负责运算的百万民工（SM里的各种运算单元）浩浩荡荡整齐排列，而负责视口变换、裁剪、属性设置、光栅化、剔除等一系列<strong>固定管线的几何操作</strong>，却只能一起挤在角落瑟瑟发抖。从这，我们就不难猜出瓶颈出在何处了</p><p><strong>巧妇难为无米之炊：</strong></p><ol><li>一方面，由于<strong>CPU和GPU的带宽限制</strong>，GPU能够获取到的顶点数量本就有限，使得即使SM再多也只是暴殄天物；</li><li>另一方面，顶点着色器处理完后的顶点，要转化成片元最终传递到片元着色器上，<strong>都必须先经过固定管线的一系列几何操作</strong>，如果顶点太多，也会导致堵塞。</li></ol><p>我们知道，<strong>各类硬件的发展速度并不是齐头并进的</strong>。随着晶体管越来越小，计算单元的运算速度随着摩尔定律不断翻番，相比之下，内存带宽的进步就显得微不足道了，因此<strong>带宽这个瓶颈也就越来越突出</strong>。那么第一方面的瓶颈该如何解决呢？解决不了我们可以绕开嘛！<strong>来不及获取这么多顶点，那我就自己生成！</strong>这就是细分着色器登场的时代背景。</p><p>晶体管越来越小，也意味着我们<strong>可以在GPU里堆更多的SM，甚至可以往每个SM里塞入更多运算单元</strong>。以前，Tesla架构的SM其实并不算多，搭配一个负责这些几何操作的模块就能勉强达到平衡；而现在，塞满运算单元的Fermi架构，如果还是只有一个单元负责处理几何操作，生活就难以为继了。</p><p>那么，接下来就让我们走进Fermi这座全新工厂，看看它为解决第二方面的瓶颈，究竟做出了哪些架构调整。</p><h2 id="鸟枪换炮的独立王国"><a href="#鸟枪换炮的独立王国" class="headerlink" title="鸟枪换炮的独立王国"></a>鸟枪换炮的独立王国</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-82dc52b2af5388225e04fcba70d6ac9c_720w.jpg" alt="img"></p><p>跟上一张Tesla架构图一对比，我们仿佛从近代来到了现代。除了五彩斑斓的全新版本（误），我们可以发现主要的变化有：</p><h3 id="变富有了，什么东西都多了"><a href="#变富有了，什么东西都多了" class="headerlink" title="变富有了，什么东西都多了"></a>变富有了，什么东西都多了</h3><p>因为架构从90nm来到了40nm，自然就财大气粗了起来：</p><ul><li><strong>每个SM里都塞了满满当当一堆计算单元</strong>，一个SM里就八个计算单元搭伙过日子的窘迫生活一去不复返了</li><li>仓库DRAM和码头Memory Controller的组合还是只有6座，但是<strong>每个码头搭配的码头工人ROP（Raster Operation Processor）从1个扩招到了8个</strong>，住在L2 cache附近的ROP分区里（码头肯定要靠近内部的高速公路，才能跟SM们进行快速的货物运输）</li></ul><h3 id="TPC华丽转型为GPC"><a href="#TPC华丽转型为GPC" class="headerlink" title="TPC华丽转型为GPC"></a>TPC华丽转型为GPC</h3><p>Tesla中的主角——各大子公司TPC（Texture Processing Clusters），鸟枪换大炮<strong>变成了更加自给自足的独立王国 GPC（Graphics Processing Clusters）</strong>，只要能通过L2 cache跟外界接触，<strong>GPC自己就能完成整个GPU的绝大多数功能</strong>，这样不同价位的设备阉割起来就更加灵活了。</p><ul><li>Tesla一个纹理单元服务两个SM的安排，已经无法满足日益膨胀的SM了，<strong>纹理单元也因此被移入了SM</strong>（实际上在下一章中我们会发现，光一个SM就有四个纹理单元）</li><li>被移入SM的，还有<strong>打包了所有几何操作的PolyMorph Engine</strong>，这是<strong>解决我们前面所讨论的几何瓶颈的关键一招</strong>。有了它的加入，下面这些管线固定功能的部分也都可以<strong>随着大量SM并行</strong>了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-941edc12d44b710c7904bddbc9140219_720w.jpg" alt="img"></p><ul><li>GPC之所以能成为独立王国，自然不能少了Raster Engine。<strong>每个GPC都拥有一个Raster Engine</strong>，服务内部4个SM（所有这些硬件单元的配比，我们都不必太过在意。不同架构都在不停调整，是<strong>反复测试权衡后，最适应当时那个年代的独特配方</strong>）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-66da128e7f05518663d1946e4a8eac89_720w.jpg" alt="img"></p><p>至于PolyMorph Engine和Raster Engine里的各项功能，我们会在下一章跟随三角形进行惊心动魄的冒险之旅时，一一接触到。现在就先让我们来看看，英伟达究竟用这套配方，为我们熬制出了什么神奇的解药，以<strong>突破几何瓶颈的魔咒</strong>。</p><h2 id="双管齐下，以假乱真"><a href="#双管齐下，以假乱真" class="headerlink" title="双管齐下，以假乱真"></a>双管齐下，以假乱真</h2><h3 id="细分"><a href="#细分" class="headerlink" title="细分"></a>细分</h3><p>首先，前面我们分析过，CPU和GPU之间通过总线传递数据，是当时（甚至现在也是）令人无可奈何的短板，就像我们可以在地球上把高铁修到世界的每一个角落，却仍然难以自由地开展星际航行一样。但是办法总比困难多，<strong>供不应求那我GPU就自己生成顶点呗</strong>。</p><p>这就到了细分大显身手的时候了，细分的大致流程跟其他着色器不同，主要分为三步（OpenGL和dx两边名字不一样，但硬件都是这么一套，所以本质没区别）：</p><ol><li>Tessellation Control Shader（hull shader）：决定每个patch要<strong>细分到什么程度</strong></li><li>Tessellation Primitive Generation（tessellator）：根据Tessellation Control Shader传出的两个参数，<strong>执行内置的一套细分规则</strong></li><li>Tessellation Evaluation Shader（domain shader）：本质上和顶点着色器一样，只不过处理的是细分后的所有顶点（<strong>包含无中生有出来的顶点</strong>）</li></ol><blockquote><p>限于篇幅，这里没有展开，想要弄清整条管线的每个细节，可以看下一章哦~</p></blockquote><p>带Shader的1和3，自然和顶点、片元着色器一样，是可以随心所欲可编程的着色器啦，既然是统一着色器架构，那么它们理所当然都是<strong>由SM里密密麻麻的CUDA core负责执行</strong>的；而中间那步则是固定功能操作，是由谁负责的呢？想必大家也能猜到，那就是PolyMorph里的Tessellator。</p><p>我们现在或许可以理解，为什么每个SM里都有这么一个PolyMorph了，多了细分这么个整活的玩意儿，在顶点和片元之间又硬生生加了这么一段（几何着色器，因为众所周知的原因，我们就忽略吧(^_−)☆），如果把它扔外头，来自多个SM的海量细分请求，不仅处理上应接不暇，数据传输上也会爆炸。</p><p>Raster Engine也变多的原因也很容易理解，<strong>不管是CPU传过来的真实三角形，还是细分阶段凭空捏造的假三角形，它们都是要被光栅化的</strong>。三角形变多了，Raster Engine数量也水涨船高是合情合理的。</p><p>我们可以发现，每一个看似微小功能的增加，背后都会有大量基础设施的投入和调整，而每一次调整牵一发而动全身。这也是架构的精妙所在，它<strong>在这种微妙的动态平衡中，为图形和并行计算开辟崭新的道路</strong>。</p><h3 id="置换贴图"><a href="#置换贴图" class="headerlink" title="置换贴图"></a>置换贴图</h3><p>光是一个细分，就能逆转狂澜了吗？很难。因为细分也要讲究基本法，虽说是无中生有，但也是要在原有三角形上细分的，这就注定了，这顶多只是平滑，要想丰富更加精细的细节，困难重重。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-b16667b63bead0b36d1d68c91a56fa94_720w.jpg" alt="img"></p><p>如上图所示，细分只能帮忙把第一幅图，盘成第二幅图，想要雕刻成第三幅图就无能为力了。那要怎么办才好呢？着急，在线等。</p><p>遇事不决，贴图解决。在Tessellation Evaluation Shader后再贴上置换贴图，双管齐下无懈可击。同法线贴图、视差贴图等只影响最终光照的trick不同，置换贴图在光栅化前直接改变顶点位置，是一种更高级的trick~</p><p>把顶点“存到”贴图上，有诸多好处：</p><ol><li>相比直接读取顶点buffer，<strong>内存更加紧凑，带宽占用少</strong>，因此也能做更复杂的动画</li><li><strong>Mipmap天然就是LOD</strong>，一个模型吃遍天，不同设备、不同视距都不需要费力去生成一堆模型的LOD了</li><li>作为一张贴图，在游戏中实时修改要比直接去改网格容易得多，因此还能被用来做<strong>贴花（Decals）</strong></li></ol><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-22372c748d79cdc8f4d819b394de2f98_720w.jpg" alt="img"></p><p>总之，作为模型的一种紧凑的“压缩格式”，置换贴图好处多多。但其实这在影视行业已经是一种很古老的技术了，<strong>英伟达既然相中了它，势必要为它在游戏中的大规模应用铺好台阶</strong>。那么英伟达做了什么呢？一下子翻了八倍的ROP、每个SM里塞了四个纹理单元，我想已经很能说明用意了吧。</p><p>当然，大量纹理单元的引入，我们这批搞图形的，可不满足于只是拿来贴个置换贴图。整套PBR管线、延迟渲染等在游戏引擎里普及成为烂大街的技术，背后离不开大量纹理单元的支持。这种<strong>技术和硬件互相成就</strong>的历史，在之后的文章里还会反复上演。</p><p>不过在十年后，随着大众对品质的追求来到一个新的量级，这套靠一堆贴图维生的工作流，逐渐出现了新的瓶颈。然后UE5跳出来说：“我要扔掉纹理这个包袱，要自己做LOD，自己做光栅化”，这就是后话了。</p><hr><h2 id="三角形的异世界之旅（图形管线）"><a href="#三角形的异世界之旅（图形管线）" class="headerlink" title="三角形的异世界之旅（图形管线）"></a>三角形的异世界之旅（图形管线）</h2><p>本篇单开一篇博客记录：</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU架构系列-二）-Fermi架构&quot;&gt;&lt;a href=&quot;#GPU架构系列-二）-Fermi架构&quot; class=&quot;headerlink&quot; title=&quot;GPU架构系列(二）| Fermi架构&quot;&gt;&lt;/a&gt;GPU架构系列(二）| Fermi架构&lt;/h1&gt;&lt;p&gt;当Tes</summary>
      
    
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/categories/GPU%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/tags/GPU%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>GPU架构（一）|Tesla架构</title>
    <link href="http://icecorn.github.io/2022/07/01/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%B8%80)%20Tesla%E6%9E%B6%E6%9E%84/"/>
    <id>http://icecorn.github.io/2022/07/01/GPU%E6%9E%B6%E6%9E%84/GPU%E6%9E%B6%E6%9E%84%E7%B3%BB%E5%88%97(%E4%B8%80)%20Tesla%E6%9E%B6%E6%9E%84/</id>
    <published>2022-07-01T09:25:10.000Z</published>
    <updated>2022-07-23T02:34:59.125Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GPU架构-一-Tesla架构"><a href="#GPU架构-一-Tesla架构" class="headerlink" title="GPU架构(一) | Tesla架构"></a>GPU架构(一) | Tesla架构</h1><h2 id="SIMT"><a href="#SIMT" class="headerlink" title="SIMT"></a>SIMT</h2><p>SIMT：single instruction，multiple threads</p><p>SIMT类似CPU上的多线程。最简单的理解SIMT的是想象有这样一个多核系统，每一个core有自己的寄存器文件、自己的ALU、自己的data cache，但是没有独立的instruction cache、没有独立的解码器、没有独立的Program Counter register，命令是从单一的instruction cache同时被广播给多个SIMT core的。<strong>即所有的core是各有各的执行单元，数据不同，执行的命令确是相同的。多个线程各有各的处理单元，和SIMD公用一个ALU不同。</strong></p><p>因为大量的并行计算需求，从而导致了GPU的产生</p><h2 id="Tesla架构一览"><a href="#Tesla架构一览" class="headerlink" title="Tesla架构一览"></a>Tesla架构一览</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710133404872.png" alt="image-20220710133404872"></p><ul><li>最上面的是尊敬的甲方CPU；整个GPU是一个巨大的外包公司，负责干各种又脏又累的活</li><li>外包公司内，最上层的是各种大小包工头；中间是一堆负责干活的社畜；最下方是堆放原料和产品的码头和仓库</li><li>我们可能会发现一个特点，除了负责指挥的包工头，下面干活的社畜以及吞吐数据的码头和仓库，似乎有好几个，长得还一模一样，这就是<strong>GPU并行性在具体硬件结构上的体现</strong>。</li></ul><h3 id="各模块的作用"><a href="#各模块的作用" class="headerlink" title="各模块的作用"></a>各模块的作用</h3><ul><li><strong>Host Interface</strong>：外包公司的大包工头，负责收发来自甲方CPU的各种订单（多是枯燥无味重复单调，需要大量廉价劳动力，CPU自己不屑于干、做不来的活）并处理GPU在各种订单间的上下文切换；还负责获取来自内存等待加工的原材料（顶点数据、纹理数据、各种buffer等），将其存放到仓库（显存）中。</li><li><strong>Input Assembler</strong>：负责将甲方给的顶点数据进行简单组装（根据顶点索引与图元类型装配），并搭配上属于它们的顶点属性，才能传给Vertex Work Distribution。</li><li><strong>Vertex、Pixel、Compute Work Distribution</strong>：三个小包工头，负责将自己领域更加具体的工作分发给底下一大堆流水线工人们去做（从名字就可以看出，他们分别分发顶点、片元和计算着色器的任务）。</li><li><strong>TPC（Texture Processing Clusters）</strong>：这个名字比较令人困惑，里面有<strong>一个纹理单元和两个负责计算的SM（Streaming Multiprocessor）</strong>。都是干活的生力军，上面三个小包工头的活全都是它们完成的，从这里就可以看出所谓的统一的硬件结构是指什么了。这个结构下一章会具体展开，先让我们记住这个啥都能做的“全栈工程师”。</li><li><strong>Viewport/clip/setup/raster/zcull block</strong>：顶点着色器处理完，只是输出一堆裁剪坐标（还未透视除法）和一堆与其一起等待光栅化插值的属性，这个模块就是负责这些，流水线中到目前为止都未开放编程的固定功能部分。</li><li><strong>ROP（Raster Operations Processor）</strong>：除了格子间里流水线上的工人，身为码头工人的ROP也是任劳任怨的好员工。他们负责对片元着色器处理后的像素进行测试和装箱：同一个像素位置的<strong>深度/模板测试和写入、颜色混合、抗锯齿</strong>都由它完成。因为片元着色器处理一个位置的片元时，并不知道该位置其他片元的信息，所以需要有这么一位码头工人在最终将产品（像素颜色）发往仓库前，做最后的统筹合并修缮工作。</li><li><strong>L2 Cache、Memory Controller和DRAM</strong>：从图上可以看到，每个仓库（DRAM）搭配一个码头（图中未标的Memory Controller）、码头临时库存（L2 Cache）和一个码头工人（ROP），共有6组这样的搭配，每个搭配对应着显存六分之一的物理地址。格子间TPC里并行工作着的SM们发来了一条又一条的数据吞吐请求，会在码头集中处理，这些请求可能会被合并，并根据优先级从仓库获取数据<strong>以实现数据传输效率的最大化</strong>；被码头工人最终装箱完（颜色混合、硬件抗锯齿）的像素数据也会被码头发往仓库中的帧缓冲。</li></ul><hr><h3 id="干活主力TPC"><a href="#干活主力TPC" class="headerlink" title="干活主力TPC"></a>干活主力TPC</h3><p><strong>TPC（Texture Processing Clusters）</strong>，是统一的硬件架构，可以处理顶点，片元，计算着色器的任务。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710134553236.png" alt="image-20220710134553236"></p><p>我们可以将TPC看成一个个子公司，这家黑心企业里一共有8个，我们任意挑选一间来看看。</p><blockquote><p>跟<strong>数量</strong>相关的参数我们都不需要太过关注，因为不同架构各不一样，同一架构不同价位的GPU也不尽相同（毕竟老黄刀法了得），理解其工作原理更为重要，如果要为特定GPU做优化，可以去官网查看更为具体的参数信息。</p></blockquote><p><strong>Geometry Controller</strong>：从名称上看，它是光栅化前几何阶段的大管家，负责<strong>顶点属性</strong>在<strong>芯片内</strong>的输入输出事宜，几何着色器这种增减顶点改变拓扑结构的骚操作也得麻烦它。不过，<strong>顶点着色器和几何着色器的运算指令仍然是由SM执行的</strong>，Geometry Controller会把最终结果送到<strong>Viewport/clip/setup/raster/zcull block模块</strong>去进行光栅化等步骤，或者<strong>Stream Out</strong>回内存交给程序员们揉搓。（该部件在Fermi架构中被升级成了<strong>PolyMorph Engine</strong>，我们会在Fermi架构章节里进一步研究）</p><p><strong>SMC（SM controller）</strong>：正如上一章讨论的，Tesla是统一的图形和并行计算架构，顶点、几何、片元着色器，甚至与图形无关的并行运算任务（CUDA），都由同样的硬件SM来运算。SMC负责将来自总部的各种任务，<strong>拆分打包成Warp</strong>（下一节会详细介绍）交给其中一个部门（SM）处理。除此外，SMC还<strong>负责协调SM与共用部门Texture unit之间的工作</strong>，以实现对外部纹理资源的获取，而显存中其他非纹理资源的读写甚至原子操作则会<strong>通过ROP与外界打交道</strong>。整体来看，SMC又负责对接外界资源，又负责内部任务分配，以实现复杂但至关重要的<strong>负载平衡</strong>，是名副其实的子公司高管。</p><p><strong>Texture Unit</strong>：包含4个纹理地址生成器和8个滤波单元（支持全速的2:1各项向异性过滤）。与SM内的指令全是标量运算不同，纹理单元的指令源是<strong>纹理坐标</strong>，输出是经过<strong>插值</strong>的纹理值（最常见的如RGBA），都是向量。拿到的纹理数据会存Tex L1 cache里，因为千辛万苦从外面搬进来的数据以后没准还有用呢。</p><h3 id="一条船上的蚂蚱"><a href="#一条船上的蚂蚱" class="headerlink" title="一条船上的蚂蚱"></a>一条船上的蚂蚱</h3><p>采访完干活的人，咱们接下来就得看看他们所要做的事情了。那么，我们得从最源头找起，他们干的活，最初可能是一段着色器代码，也可能是一段CUDA Kernel程序，都是高级语言，它们会被编译成中间指令，然后被优化器转化为二进制GPU指令。<strong>中间指令如果是矢量指令（SIMD），也会被转换为多条 Tesla SM 标量指令</strong>，比如4维向量相加，会被拆成4个标量相加，因为英伟达已经在Tesla里干掉了运算SIMD指令的计算单元。</p><p><strong>ISA（Instruction Set Architecture）</strong>：那么都会生成哪些指令呢？主要有三类：</p><ol><li><strong>运算</strong>：浮点整数等加法乘法、最小最大、比较、类型转换等基础运算以及超越函数等复杂运算。</li><li><strong>流控制</strong>：分支、调用、返回、中断、同步</li><li><strong>内存访问</strong>：包括对各类内存的读写、原子操作</li></ol><p>说了这么多，其实只要知道，<strong>不管多复杂的程序，层层传递到SM里，最终交到社畜们手中的就是一条条的指令</strong>。那这些活到底有什么特殊的呢？交给CPU不也能做吗？之所以交给GPU做，就是因为这些指令不只需要做一遍。比如一个顶点着色器，每有一个顶点数据，就得开一个线程把这个指令做一遍。</p><p>而实际上，SMC拿到一个着色器的所有指令后，每次会把这些指令<strong>以32个线程为单位</strong>分发给SM，而<strong>负责执行完这个着色器所有指令的32线程，就称为一个Warp</strong>。指令存在了指令cache里，MT（multi-threaded） Issue<strong>每次拿出一条指令</strong>发给手底下的SP或SFU们执行。诶？可是一个SM里SP只有8个，怎么运行32个线程呀，答案是每个SP连续干四次不就行了嘛？（卧槽，真不要脸）。<strong>SP是负责干活的硬件，线程是逻辑上负责完整运行完一个着色器所有指令的概念</strong>，确实没必要一一对应。SFU也是同理。</p><p>一个MT Issue发号施令一次，手底下的SP或SFU就吭哧吭哧将一条指令合计执行32次，这就是<strong>SIMT（Single-instruction, multiplethread）</strong>，GPU正是基于SIMT而设计的。</p><p>但是仔细想想，每个线程真的一定执行相同的指令吗？程序可不是简简单单一条一条往下走，还有分支和循环等指令会改变程序流向，<strong>由于每个线程输入的数据不同，很有可能会进入不同的分支</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710135929296.png" alt="image-20220710135929296"></p><p>那该怎么办才好呢？</p><ul><li><strong>编译器可以进行特殊情况下的分支预测</strong>，来判断Warp中所有线程是否必然进入同一分支（比如条件是传入的定值，并非经过实际运算的值）</li><li>如果无法预测，则不得不在执行时付出点指令开销来进行<strong>Warp Voting</strong>，如果投票出来该Warp的所有线程还是只走一条分支，那么就还好，大家可以一起跳过其他所有分支，否则<strong>不同分支就只能串行，不进入某一分支的线程将被mask。</strong>即使只有一个线程进入了某一个分支，其他31个线程也得等着它执行完，这就是<strong>锁步运行。</strong></li></ul><p><strong>就像被绑到同一条船上的蚂蚱，同进退共生死，想要一条指令同时指挥32个线程，那么灵活性自然也在获得效率的时候被一并献祭了，因为凡事皆有代价。</strong></p><h3 id="活儿可以等，打工人不能等"><a href="#活儿可以等，打工人不能等" class="headerlink" title="活儿可以等，打工人不能等"></a>活儿可以等，打工人不能等</h3><p>看到这，总感觉也没有那么神奇，GPU无非就是仗着自己运算单元多一点儿所以算得快呗，创造大量就业的公司也能算黑心公司吗？别着急，对大量元器件的探访，对Warp概念的摸查，都是对最终Warp调度机制大揭秘的铺垫，真相即将浮出水面。</p><p>我们来看这么一个现状：当前硬件的计算速度比访问内存的速度快几个数量级，<strong>瓶颈往往在内存访问上</strong>。当SP遇到内存访问指令，会由SMC向外界请求数据（要么通过纹理单元要么通过ROP），那在漫长的等待过程中，SP是不是只能摸鱼了？</p><blockquote><p>社畜SP：“没办法呀，我也不是真的想摸鱼，但是没数据我干不了接下来的活呀 :）”<br>主管MT Issue：“是的，这个Warp只能等了，毕竟不同指令间有数据依赖，着色器里的代码总不能跳着执行。”<br>社畜SP：“是呀是呀，这活总得按部就班，才不会忙中出错嘛”<br>子公司高管SMC：“总部摊派给我们的活多着呢，我特意拆分成了好多个Warp让你们执行，就是想避免你们带薪拉屎。一个Warp要拿数据，我去帮你们联系就行，你们赶紧先去做其他Warp！”<br>于是，整个部门007的日常开始了。</p></blockquote><p>这就是<strong>延迟隐藏</strong>的真相了。是的，公司特意搞了一个指令cache，就是<strong>让SM能够存下足够多的Warp</strong>（Tesla架构最多24个，这些Warp可以是不同类型的，比如顶点着色器、片元着色器甚至是CUDA程序），以在出现内存阻塞时快速切换到其他可以执行的Warp上，等拿到数据了再切回原来的Warp就行。毕竟，读写数据并不需要SP们费心，有足够多的Warp让SP们007，这家公司才有可能蒸蒸日上。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-29d8a02a890d4174d8d30f9241b46d88_r.jpg" alt="preview"></p><p>原来这就是并行的真相：可不是简单的计算单元并行就可以了，而是<strong>所有元器件尽可能都不要停下来</strong>。说到所有元器件，自然MT Issue主管也跑不了，大家都是打工人，谁也不比谁高贵。</p><p>MT Issue从原来分发一个Warp的一条指令，变成了从多个Warp里挑出一个Warp执行其之前执行到的接下来的指令。至于如何调度，有<strong>复杂的计分板根据Warp类型、指令类型和公平性原则等来量化每一个待选的Warp</strong>，每两个处理器周期，MT Issue就从中挑出一个得分最高的Warp分配给对应的元器件去执行。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-07c156f620b46a6287e759dcf00f93cf_r.jpg" alt="preview"></p><p>每个SP只有8个，做完Warp一条指令需要4个周期，那么MT Issue为什么是两个处理器周期就分发一次指令呢？因为还有SFU啊！SP在运行的时候，SFU可不能闲着，2个周期分发一次指令的频率，就可以保证MT Issue有充足的时间给SFU挑选一个需要其运行的Warp，这样一来，<strong>所有员工就都能满负荷运转了，只要手里还有Warp没执行完，谁也别想停</strong>。</p><p>原来这就是高性能并行运算，原来这就是血汗工厂<strong>，一切都经过精心设计，势必要榨干每一个元器件的性能</strong>，背后的原因令人暖心。</p><p>最后还剩下一个小问题可以探讨，一个Warp线程的多少对性能有什么影响呢？如果粒度太粗，则可供调度的 Warp就会太少，不利于延迟隐藏； 如果粒度太小，则每次切换所执行的线程就太少， 切换 Warp的相对成本就变高了。</p><p>Warp调度是整个GPU架构最核心的内容了，<strong>不同的架构，元器件的名字可能会变，数量可能会变，会拆分或合并，但是延迟隐藏的这一特性却始终未变</strong>。</p><h2 id="从图形到通用计算"><a href="#从图形到通用计算" class="headerlink" title="从图形到通用计算"></a>从图形到通用计算</h2><p>如果我们仔细观察，可以发现，全称为图形处理单元的GPU，<strong>其最基本的计算部门——SM，已经跟图形没有半毛钱关系了</strong>。这一切都是NVIDIA有意为之，把各种图形相关的操作剥离成独立的硬件单元（Geometry Controller、Raster等），把计算单元SM解耦出来，以<strong>开启和拥抱更加广阔的并行计算市场</strong>。</p><p>因为图形任务的整体流程是固定的已知的，所以形成了<strong>相对固定的图形管线</strong>，只抠出几个重要的环节（如顶点着色器、片元着色器等）可供编程，GPU就可以弄出专门的硬件去做那些必定要做的不可编程的模块（比如光栅化）以提高效率。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-458a6b35cd6a371dc3838594422d9e4f_r.jpg" alt="preview"></p><p>然而，<strong>效率的提高意味着自由的丧失</strong>，在这条相对固定的图形管线，我们设置完最开始的<strong>顶点输入数据</strong>后，这些输入该如何分配线程运行，以及完成顶点计算后如何光栅化成片元，再继续分配多少线程去运行片元计算，这些事情其实都是<strong>对程序员隐藏</strong>的。</p><p>而在通用计算管线里，所有线程都不可避免要由程序员去分配与调用，因为既然“通用”，那就可能用来处理任何工作，<strong>每个线程要对应的任务就不再是固定的顶点或片元，而可能是任何我们想做的事</strong>。那么<strong>要分配多少线程，每个线程要负责处理什么工作</strong>（不仅是如何计算，还有要获取多少数据，要输出什么），所有的一切，事无巨细全都由程序员说了算。</p><p>除此之外，通用计算管线与图形管线相比，还有一个最大的不同：我们分配的这些线程是<strong>协作式</strong>的，我们<strong>可以根据它们的线程ID分配它们干不同的活，它们之间还需要数据传递</strong>。也不是说图形管线发出来的线程完全不需要协作和数据传递，只是所有的协作模式已经被定死了，不需要我们操心，比如：<strong>执行片元任务的时候是以每四个线程为单位的</strong>，以方便计算它们之间数据的差值（ddx、ddy）。</p><p>正因为通用管线释放了这么多的自由度，使得其性能的上限被提高了，我们可以<strong>根据具体任务，分配线程，并设计它们的协作模型以及数据依赖关系</strong>。不过，性能的上限是需要我们自己去探索达到的，如果缺乏对硬件的基本理解与优化技巧，深不可测的性能下限也在那等着我们。</p><h2 id="CUDA和计算着色器"><a href="#CUDA和计算着色器" class="headerlink" title="CUDA和计算着色器"></a>CUDA和计算着色器</h2><p>卖弄这么久的通用管线，是时候来看看它们到底是什么了。<strong>CUDA（Compute Unified Device Architecture）</strong>是最先被推出的，它轻装上阵彻底和图形划清了界限，成为了许多非图形学背景科研人员的并行计算平台。</p><p>后来，随着各种图形算法日益复杂，搞图形的人发现CUDA真香，也眼馋着想用上通用计算大杀器，所以各个API就相继推出了计算着色器。反正<strong>支持这套东西的底层硬件都是一样的</strong>，无非就是换了一堆名词来包装出这套一模一样的通用计算模型而已。</p><h3 id="线程组织结构"><a href="#线程组织结构" class="headerlink" title="线程组织结构"></a>线程组织结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-d9689b21d2fcac3045886bdfcee3f565_720w.jpg" alt="img"></p><p>CUDA线程的三级组织结构为：<strong>Grid-Block-Thread</strong>，每个Block包含多少线程在核函数中写死，<strong>Block是协作发生的组织单位（因此也被称为CTA，cooperative thread array）</strong>，里面的线程可以<strong>通过共享内存传递数据</strong>。每个Grid包含多少Block，由应用程序在每次调用时指定，同一个Grid的所有Block之间则是完全独立的，没有数据依赖。</p><p>因为<strong>线程与任务之间的映射</strong>是由我们决定的，那么我们自然需要知道每一个线程的ID，才能通过它获取到对应的数据，执行对应的计算任务，将计算结果写到对应的内存中。不过因为其三级组织结构，而且每一级结构可以支持三维的索引（上图只显示了2维），光有一个ID可能不能满足我们的需求。当然我们都可以自己算出来，但鉴于其需要被高频使用，因此不同API全都提供了一堆内置变量，来描述ID的不同表示，以避免我们自己计算浪费性能。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-36f03e7fa80a9530c71ad87faca8034a_720w.jpg" alt="img"></p><h3 id="真正的并行单元是Warp"><a href="#真正的并行单元是Warp" class="headerlink" title="真正的并行单元是Warp"></a>真正的并行单元是Warp</h3><p>又是三级线程组织结构，又是三维的线程ID映射，初学起来让人头晕脑胀，但是我们别忘了，无论上层的概念如何复杂，<strong>底层的硬件执行单元都是SM，真正的并行单位始终是Warp</strong>。因此优化的基础大多是以Warp为主角的，比如：</p><ul><li><strong>最好为每个Block分配Warp线程数（32）的整数倍线程数</strong>。因为不管多少线程都要拆分成Warp单位去执行，33个线程与64个线程同样需要执行两个Warp。</li><li><strong>同一分支要尽可能挤到同一Warp里。</strong>如果设计的算法中，不同的线程不得不执行不同的分支，比如Warp1要执行分支A和B，Warp2也要执行分支A和B，如果能让Warp1只执行分支A，而Warp2只执行分支B，就能获得性能的提升。（因为每个线程要做什么都是我们说了算，因此给了我们这样的优化空间）</li><li><strong>如果内存读写指令都只由一个Warp执行，那么无需同步</strong>。因为一个Warp内的线程本身就是锁步运行的，因此肯定不需要同步。<strong>但如果是不同Warp之间存在数据依赖，则不得不同步</strong>。比如一个先写后读的常见例子：Warp1的线程要读取由Warp1其他线程写入到共享内存的数据，则无需同步，因为该数据必定已经被写入；而Warp1的线程要读取由Warp2线程写入到共享内存的数据，则必须同步，因为<strong>Warp1开始执行读取指令的时候，Warp2执行到哪里了则无法预料，因为Warp的调度是硬件决定的，对程序员是不透明的</strong>。</li></ul><h2 id="分级“物流”系统"><a href="#分级“物流”系统" class="headerlink" title="分级“物流”系统"></a>分级“物流”系统</h2><p>到目前为止，我们对GPU架构的理解，还差最后一块拼图：<strong>内存——支撑GPU这整座血汗工厂高速运转的物流系统</strong>。计算得再快，如果物流系统跟不上，那也白搭。（特别是当今硬件算力过剩，带宽吃紧的局面）</p><p>就像有国道省道，也会有村间小路，有主动脉肺动脉，也会有毛细血管一样，GPU中分级的“物流”系统，也是非常自然的设计。让我们以CUDA与各个内存如何打交道为例，一一介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/v2-b3501fecde229b3f4223f609d67bda03_720w.jpg" alt="img"></p><h3 id="Global-Memory与L2-cache"><a href="#Global-Memory与L2-cache" class="headerlink" title="Global Memory与L2 cache"></a>Global Memory与L2 cache</h3><p>如果大家还有印象，第一章我们介绍过这两个东西。Global Memory（DRAM），就是位于显卡上（GPU外）的显存，<strong>每一块显存都会与GPU内的对应的一个L2 cache相连</strong>。L2 cache是在SM之外的，因此可以供所有SM共同使用。</p><p>不同Grid的执行是串行的，如果他们存在对同一块显存的数据依赖，则由硬件负责同步。<strong>一个Warp中的连续线程访问连续的内存，可以被合并为一条内存读取指令</strong>，能显著提高效率。</p><h3 id="Shared-Memory与L1-cache"><a href="#Shared-Memory与L1-cache" class="headerlink" title="Shared Memory与L1 cache"></a>Shared Memory与L1 cache</h3><p>共享内存和L1 cache位于SM中，Tesla架构的L1 cache只用于缓存纹理数据，之后的架构则和共享内存占据相同的硬件单元，并<strong>可以由用户配置两者的大小</strong>。</p><p>通用管线的协作线程模型能够高效运行的秘密全在共享内存上，<strong>因为其位于SM中，读写速度肯定远高于主存与L2 cache</strong></p><p>而共享内存是对一个block内的所有线程可见的，这意味着<strong>一个block内所有线程必定位于同一个SM中</strong>。而同一个grid的不同block则不一定，因此不同block之间是老死不相往来无法通信的（如果想实现更高自由度更多粒度的同步，可以使用<a href="https://link.zhihu.com/?target=https://developer.nvidia.com/blog/cooperative-groups/">合作组</a>）。这也是为什么一个block的最大线程数有所限制，因为一个SM能容纳的Warp是有限的。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220710142551173.png" alt="image-20220710142551173"></p><p>一个warp32线程可能需要同时对共享内存进行读写，因此需要考虑<strong>bank冲突</strong>的问题。</p><p>简单讲，共享内存的带宽是有限制的，<strong>支持同时32个bank的读写，但是每个bank只能读写32位数据</strong>。多个地址会被映射到同一个bank，如果有多个线程想要同时读写同一个bank的数据，则不得不变成<strong>串行</strong>执行。</p><p>读内存现在的硬件都有<strong>广播</strong>的功能，不会出现bank冲突，但是写内存则需要小心的安排每个线程要写入的内存地址，<strong>尽量保持每个线程都映射到不同的bank中</strong>，以保持warp指令的并行性。</p><h3 id="Local-Memory与Register-Files"><a href="#Local-Memory与Register-Files" class="headerlink" title="Local Memory与Register Files"></a><strong>Local Memory与Register Files</strong></h3><p>每一个线程都有自己运行所需的局部变量，存放在<strong>寄存器文件</strong>中，如果存不下会溢出到L1 cache中，如果还存不下会被一路驱逐出去，贬谪到L2甚至到主存中。（性能会受到毁灭性打击）</p><p>最初的局部变量其他线程是无法访问的，但是较新的硬件支持了<strong>Shuffle操作</strong>，可以在一个Warp的线程间直接传递数据，比通过共享内存来回读写数据还快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GPU架构-一-Tesla架构&quot;&gt;&lt;a href=&quot;#GPU架构-一-Tesla架构&quot; class=&quot;headerlink&quot; title=&quot;GPU架构(一) | Tesla架构&quot;&gt;&lt;/a&gt;GPU架构(一) | Tesla架构&lt;/h1&gt;&lt;h2 id=&quot;SIMT&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/categories/GPU%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="GPU架构" scheme="http://icecorn.github.io/tags/GPU%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>单例模式|一文搞懂单例模式！</title>
    <link href="http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-29T09:25:10.000Z</published>
    <updated>2022-07-01T06:17:38.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一文搞定单例模式"><a href="#一文搞定单例模式" class="headerlink" title="一文搞定单例模式"></a>一文搞定单例模式</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>通过单例模式， 可以做到：确保一个类只有一个实例被建立 ，也就是C++中定义全局的东西的一个通用做法。</p><p>在实现单例的过程中要注意如下问题：</p><ul><li>构造函数应该声明为非公有，从而禁止外界创建实例</li><li>拷贝操作和移动操作也该禁止</li><li>只能通过singleton的共有特定类操作访问它的唯一实例（c++中的一个公有静态成员函数）</li></ul><p>本文实现常见的饿汉式及懒汉式，以及多线程懒汉式的单例模式</p><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><p>饿汉式顾名思义，就是我先准备好一个全局的实例，等到你需要getInstance的时候就直接获取就行了，普通的饿汉式的缺点就是以”空间换时间”，就是说在编译阶段已经给这个类在<strong>全局数据区</strong>分配好了内存并初始化了。</p><h3 id="C98的饿汉模式"><a href="#C98的饿汉模式" class="headerlink" title="C98的饿汉模式"></a>C98的饿汉模式</h3><p>在C++98版本，为了实现线程安全，要把istance实现成一个类内的成员变量，并且要在类外初始化它，不然编译器会报错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-------------C98饿汉模式单例-----------------------------------</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton98</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="built_in">CSingleton98</span>()      </span><br><span class="line">    &#123;   </span><br><span class="line">a = <span class="number">98</span>; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c98饿汉模式单例使用全局静态对象，在编译时已经调用单例类构造函数分配内存并实例化出来了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton98 * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;      </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> CSingleton98 instance;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> a; <span class="comment">//类中其他变量,这里懒得写get/set方法</span></span><br><span class="line">&#125;; </span><br><span class="line">CSingleton98 CSingleton98:: instance;<span class="comment">//在类外初始化</span></span><br></pre></td></tr></table></figure><p>我们在main函数中什么都不做打印试试看：</p><p>可以看到执行了单例类的构造函数，说明这种饿汉模式是在编译阶段已经在全局数据区分配了内存并初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701124104249.png" alt="image-20220701124104249"></p><p>接着我们用如下代码测试，可以看到两次获取实例对象的地址是一致的，单例ok！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CSingleton98* inst98= CSingleton98::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingleton98* inst981= CSingleton98::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst98-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;(*inst98) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;(*inst981) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701124532493.png" alt="image-20220701124532493"></p><h3 id="C11的饿汉模式"><a href="#C11的饿汉模式" class="headerlink" title="C11的饿汉模式"></a>C11的饿汉模式</h3><p>C11的饿汉模式表现在我们是将单例的instance作为一个局部static变量处理的（在函数内）</p><p><strong>优点：</strong></p><ul><li><strong>只有在程序第一次执行到GetInstance()函数的时候才会在全局数据区开辟内存并且初始化，也就是说我们没有在编译的时候就开辟内存，节省了不必要的空间开销！</strong></li><li><strong>解决了static变量初始化的问题</strong></li></ul><blockquote><p>C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。</p><p>然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局唯一的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。</p><p>这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。</p><p>而<code>Meyers&#39; Singleton</code>写法中，单例对象是第一次访问的时候（也就是第一次调用<code>getInstance()</code>函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先<code>getInstance()</code>再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！</p><p>讲到这，我们对<code>Meyers&#39; Singleton</code>的盲目鼓吹也需冷静一下，因为C++同样能保证所有文件内（非函数内）的static变量在main()函数开始运行之后肯定是都能做完初始化的。所以如果你是在main()函数运行之后，用日志管理器的单例访问配置文件的单例，那么其实也是没有问题的… 这就引出<code>Meyers&#39; Singleton</code>的第二个优势，那就是当产生继承的时候。</p></blockquote><p><strong>这里有一个遗留问题：就是编译器在编译阶段如何决定先编译哪一个单例文件呢，由此产生的文件依赖问题怎么解决呢？</strong></p><ul><li>解决了单例的继承问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;Singleton::isOn = <span class="literal">true</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;Singleton::isOn = <span class="literal">false</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">state</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> Singleton::isOn;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> isOn;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monitor</span>: <span class="keyword">public</span> Singleton &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">addBrightness</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; brightness += val;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">subBrightness</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123; brightness -= val;&#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getBrightness</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> brightness;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> brightness;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果有子类继承这一父类，来拓展成新的子类，比如Monitor显示器类有开关状态，同时扩展了一个亮度的成员。但是父子类的static成员变量是共享的，其isOn成员会有问题。</p><p>场景：比如一个显示器类，一个灯类。他们都是singleton的子类。但是灯是否打开，不应该影响显示器是否打开</p><p><strong>静态局部对象：</strong></p><ul><li>在程序执行到该对象的定义处时，创建对象并调用相应的构造函数！</li><li>如果在定义对象时没有提供初始指，则会暗中调用默认构造函数，如果没有默认构造函数，则自动初始化为0。</li><li>如果在定义对象时提供了初始值，则会暗中调用类型匹配的带参的构造函数（包括拷贝构造函数），如果没有定义这样的构造函数，编译器可能报错！</li><li>直到main（）结束后才会调用析构函数！</li><li>静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化！</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingleton11</span>    </span><br><span class="line">&#123;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">    <span class="built_in">CSingleton11</span>()      </span><br><span class="line">    &#123;    </span><br><span class="line">a = <span class="number">11</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;C11饿汉模式使用的是局部static变量，是在调用的时候分配到全局存储区的，不是在编译时就分配哦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;这是因为C11的编译器可以帮我们保证线程安全，俺们就不用操心啦！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="type">static</span> CSingleton11 * <span class="title">GetInstance</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line"><span class="comment">//静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化；</span></span><br><span class="line">        <span class="type">static</span> CSingleton11 instance;     </span><br><span class="line">        <span class="keyword">return</span> &amp;instance;    </span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><p>以下是测试：</p><p>首先是main函数什么都不做：</p><p>结果就是什么都不会发生（笑，想起了莫里亚篇索隆对山治说的话，和最近的CP0段子哈哈哈）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701125704906.png" alt="image-20220701125704906"></p><p>调用GetInstance：</p><p>此时会在全局数据区开辟内存，并调用构造函数初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSingleton11* inst11= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701125910795.png" alt="image-20220701125910795"></p><p>调用两次GetInstance：</p><p>此时只会调用一次构造函数，这正是局部static变量的特性（静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSingleton11* inst11= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingleton11* inst112= CSingleton11::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp;(*inst11) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp;(*inst112) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701130227454.png" alt="image-20220701130227454"></p><p><strong>这里顺便加深下记忆：</strong></p><p>如果是全局static变量声明两次的话，编译器会报错的！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> a;</span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;                   <span class="comment">//打咩！</span></span><br><span class="line">std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;  </span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701130526478.png" alt="image-20220701130526478"></p><p>这是C11下优化的饿汉模式单例，至于怎么保证线程安全的（不用加锁），这是C11编译器保证的！以后有时间再看！</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><p>懒汉式的特点就是延迟加载，只有到用到的时候才实例化instance</p><p><strong>这里又有一个疑问：这么考虑的话上文的C11饿汉模式不应该是懒汉模式嘛？</strong></p><p>注意这里最下边一行实际上在编译之前实例化一个指针变量，但是相比于类变量，一个指针才4个字节而已，who cares！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CSingletonL</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line"><span class="function"><span class="type">static</span> CSingletonL* <span class="title">GetInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line"><span class="keyword">if</span> ( m_pInstance == <span class="literal">nullptr</span> )    </span><br><span class="line">m_pInstance = <span class="keyword">new</span> <span class="built_in">CSingletonL</span>();  </span><br><span class="line"><span class="keyword">return</span> m_pInstance;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="built_in">CSingletonL</span>()&#123;lazy = <span class="number">3</span>;&#125;  </span><br><span class="line">    <span class="type">static</span> CSingletonL* m_pInstance;  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> lazy;</span><br><span class="line">&#125;;</span><br><span class="line">CSingletonL* CSingletonL::m_pInstance;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CSingletonL* instlazy = CSingletonL::<span class="built_in">GetInstance</span>();</span><br><span class="line">CSingletonL* instlazy1 = CSingletonL::<span class="built_in">GetInstance</span>();</span><br><span class="line">cout &lt;&lt; instlazy-&gt;lazy &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; &amp; (*instlazy) &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; &amp; (*instlazy1) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220701132606657.png" alt="image-20220701132606657"></p><h3 id="懒汉模式存在的问题"><a href="#懒汉模式存在的问题" class="headerlink" title="懒汉模式存在的问题"></a>懒汉模式存在的问题</h3><p>在懒汉式的单例类中，其实有两个状态，单例未初始化和单例已经初始化。假设单例还未初始化，有两个线程同时调用GetInstance方法，这时执行 m_pInstance == NULL 肯定为真，然后两个线程都初始化一个单例，最后得到的指针并不是指向同一个地方，不满足单例类的定义了，所以懒汉式的写法会出现线程安全的问题！在多线程环境下，要对其进行修改。</p><h2 id="深入的理解懒汉和饿汉"><a href="#深入的理解懒汉和饿汉" class="headerlink" title="深入的理解懒汉和饿汉"></a>深入的理解懒汉和饿汉</h2><p>其实就是看定义的事静态成员对象变量还是静态成员对象指针变量，因为如果定义了静态成员对象变量，程序在运行之初已经分配了空间，就要调用构造函数了，而你在调用getinstance的时候，不会再调用构造函数了，因为之前已经调用过了，你就是用的现成的，就是所谓的饿汉模式，上来先把吃的准备好了，因为饿怕了，怕后期准备会挨饿。</p><p>而定义了静态成员对象指针变量，程序运行之初也会分配空间，但是那个是指针的空间，而不是对象的空间，所以不会调用对象的构造函数，而只有调用getinstance进行new操作的时候，才会对其调用构造函数，就是现上轿现扎耳朵眼，比较懒惰，所以叫懒汉模式。</p><h2 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h2><p>使用double-check来保证不会每次进来都去获取锁，来提高性能，先判断不为空的话，直接返回了数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="type">static</span> Singleton* m_instance;  </span><br><span class="line">    <span class="built_in">Singleton</span>()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">Lock</span>();<span class="comment">//借用其它类来实现，如boost  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">UnLock</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> m_instance;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><h2 id="面试单例代码"><a href="#面试单例代码" class="headerlink" title="面试单例代码"></a>面试单例代码</h2><p>最后是面试的简单单例代码，用C11饿汉实现哦！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">singletonPractice</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> singletonPractice* <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> singletonPractice m_instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;m_instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">singletonPractice</span>(<span class="type">const</span> singletonPractice&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    singletonPractice&amp; <span class="keyword">operator</span>=(<span class="type">const</span> singletonPractice&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">singletonPractice</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    singletonPractice* in1 = singletonPractice:: <span class="built_in">getInstance</span>();</span><br><span class="line">    singletonPractice* in2 = singletonPractice:: <span class="built_in">getInstance</span>();</span><br><span class="line">    cout &lt;&lt; &amp;(*in1) &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; &amp;(*in2) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<br><a href="https://blog.csdn.net/zhanghuaichao/article/details/79459130">https://blog.csdn.net/zhanghuaichao/article/details/79459130</a><br><a href="https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA">https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一文搞定单例模式&quot;&gt;&lt;a href=&quot;#一文搞定单例模式&quot; class=&quot;headerlink&quot; title=&quot;一文搞定单例模式&quot;&gt;&lt;/a&gt;一文搞定单例模式&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="C++" scheme="http://icecorn.github.io/categories/C/"/>
    
    <category term="设计模式" scheme="http://icecorn.github.io/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="单例模式" scheme="http://icecorn.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（四）|排序合集</title>
    <link href="http://icecorn.github.io/2022/06/28/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://icecorn.github.io/2022/06/28/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2022-06-28T09:25:10.000Z</published>
    <updated>2022-07-09T08:02:01.512Z</updated>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220708130351003.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220708130434985.png" alt="image-20220708130434985"></p><p><a href="https://blog.csdn.net/qq_54850622/article/details/115729733">https://blog.csdn.net/qq_54850622/article/details/115729733</a></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><strong>快速排序的基本思想：</strong><br>快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</p><p><strong>快速排序的三个步骤：</strong><br>(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）<br>(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大<br>(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。</p><p><strong>选择基准的方式：</strong><br>对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。</p><p>最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列<br>这里选择基准可以采用<strong>固定位置</strong>，<strong>随机选取</strong>，<strong>选三个数取中间的</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> left = l,right = r;</span><br><span class="line">    <span class="type">int</span> pivot = nums[l];</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//这里必须从右边开始，因为我们选择的pivot是左边第一个</span></span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[right]&gt;=pivot) right--;</span><br><span class="line">nums[left] = nums[right];</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left]&lt;=pivot) left++;</span><br><span class="line">        nums[right] = nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[left] = pivot;</span><br><span class="line">    <span class="built_in">QuickSort</span>(nums,l,left<span class="number">-1</span>);<span class="comment">//左闭右闭的方式，要排除已经排序好的元素</span></span><br><span class="line">    <span class="built_in">QuickSort</span>(nums,left+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快排的空间复杂度是O(1)的，在原来的vector上排序就行，不需要新开空间<br>平均时间复杂度是O（nlogn）<br>最坏时间复杂度是O（n2）|<br>举例：{1,2,3,4,5,6,7,8,9,10} 就要n2，原因在于每次分治划分不均匀，当然和pivot的选取也有关系。</p><h3 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h3><p>对于要找数组中第k大或第k小的问题，不需要完整的快排，只需要快速选择的方法即可</p><p> 方法1：快速排序的分区思想，快排的思想是一次找出一个数的正确位置，并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。</p><p>方法二：堆排序，在pop k个</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 随机取一个数作为基准</span></span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">        <span class="type">int</span> random = <span class="built_in">rand</span>() % (end - start + <span class="number">1</span>) + start;</span><br><span class="line">        <span class="type">int</span> base = nums[random];</span><br><span class="line">        <span class="comment">// 将该数放到待快排区间开头第一个元素</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[start], nums[random]);</span><br><span class="line">        <span class="type">int</span> index = start;</span><br><span class="line">        <span class="comment">// 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素</span></span><br><span class="line">        <span class="comment">// 交换到index + 1位置，index++，使得最终index前面的元素都比base大。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start + <span class="number">1</span>; i &lt;= end; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= base) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[index + <span class="number">1</span>], nums[i]);</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[index], nums[start]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找，</span></span><br><span class="line">        <span class="comment">// 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">            <span class="built_in">quickPartition</span>(nums, index + <span class="number">1</span>, end, target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (index &gt; target) &#123;</span><br><span class="line">            <span class="built_in">quickPartition</span>(nums, start, index - <span class="number">1</span>, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置，</span></span><br><span class="line">        <span class="comment">// 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k</span></span><br><span class="line"><span class="comment">// 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">quickPartition</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums[k - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>同样是分治的思想，利用分治+二分，将整个数组分到最小粒度再进行处理</p><p><strong>重点是归并需要新开一个与原来数组等长的数组，空间复杂度为O(n),时间复杂度O(logn)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line"><span class="comment">// conquer</span></span><br><span class="line"><span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">temp[i++] = nums[p++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[i++] = nums[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">nums[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>复杂度O（n2)，就类似抓扑克牌 ：）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; --j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>复杂度O(n2)，相邻的比较交换，是稳定的排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n - i + <span class="number">1</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[j - <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(nums[j], nums[j - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>每次选出最小的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//選擇排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">mid = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (nums[j] &lt; nums[mid])</span><br><span class="line">&#123;</span><br><span class="line">mid = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(nums[mid], nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p><strong>大顶堆</strong>：根节点大于等于自己的两个孩子节点。<br><strong>小顶堆</strong>：根节点小于等于自己的两个孩子节点。</p><p>堆排序总共分为两步：<br>1、初始化建堆：<br>找到一个树的最后一个非叶节点， 计算公式为 (n-1)/2 -1， 然后遍历树的每个非叶节点，使其符合堆的规则。</p><p>2、排序重建堆：<br>将堆的顶部，与最后一个元素交换，然后将数组长度减一，将剩下的元素重新建成一个堆。</p><p>时间复杂度：初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为O(n+nlogn)=O(nlogn)。</p><p>空间复杂度：O(1)。</p><p><strong>堆排序 建堆，初始化二叉树，上浮和下沉操作维护堆的性质（小根堆：父节点要比子节点小，大根堆相反）</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjust_heap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums, <span class="type">int</span> root, <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span>*root + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span>*root + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> max = root;</span><br><span class="line">        <span class="keyword">if</span>( left &lt; length &amp;&amp; nums[left] &gt; nums[max])</span><br><span class="line">                max = left;</span><br><span class="line">        <span class="keyword">if</span>( right &lt; length &amp;&amp; nums[right] &gt; nums[max])</span><br><span class="line">                max = right;</span><br><span class="line">        <span class="keyword">if</span>(max != root)&#123;</span><br><span class="line">                <span class="built_in">swap</span>( nums[max], nums[root]);</span><br><span class="line">                <span class="built_in">adjust_heap</span>(nums, max, length);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; nums, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line"><span class="comment">//初始化建堆：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len/<span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">                <span class="built_in">adjust_heap</span>(nums, i, len);</span><br><span class="line">         <span class="comment">//排序重建堆     </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[i]);           <span class="comment">//堆顶元素和末尾元素进行交换</span></span><br><span class="line">                <span class="built_in">adjust_heap</span>(nums, <span class="number">0</span> , i);        <span class="comment">// 对顶点进行一次堆排序</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220708152514369.png" alt="image-20220708152514369"></p><p>顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属 性），然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶 [1,2,3,4]，它们的值分别 为 [4,2,1,1]，表示每个数字出现的次数。</p><p>紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种 排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说， 因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]， 表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line"><span class="type">int</span> max_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;num : nums)</span><br><span class="line">&#123;</span><br><span class="line">max_count = <span class="built_in">max</span>(max_count, ++counts[num]);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">buckets</span>(max_count + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p : counts)</span><br><span class="line">&#123;</span><br><span class="line">buckets[p.second].<span class="built_in">push_back</span>(p.first);</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = max_count; i &gt;= <span class="number">0</span> &amp;&amp; ans.<span class="built_in">size</span>() &lt; k; --i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp;num : buckets[i])</span><br><span class="line">&#123;</span><br><span class="line">ans.<span class="built_in">push_back</span>(num);</span><br><span class="line"><span class="keyword">if</span> (ans.<span class="built_in">size</span>() == k)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="排序的适用场景"><a href="#排序的适用场景" class="headerlink" title="排序的适用场景"></a>排序的适用场景</h2><p>（1）当数据规模较小时候，可以使用简单的直接插入排序或者直接选择排序。</p><p>（2）当文件的初态已经基本有序，可以用直接插入排序和冒泡排序。</p><p>（3）当数据规模较大时，应用速度最快的排序算法，可以考虑使用快速排序。当记录随机分布的时候，快速排序平均时间最短，但是出现最坏的情况，这个时候的时间复杂度是O(n^2)，且递归深度为n,所需的占空间为O(n)。</p><p>（4）堆排序不会出现快排那样最坏情况，且堆排序所需的辅助空间比快排要少，但是这两种算法都不是稳定的，要求排序时是稳定的，可以考虑用归并排序。</p><p>（5）归并排序可以用于内部排序，也可以使用于外部排序。在外部排序时，通常采用多路归并，并且通过解决长顺串的合并，缠上长的初始串，提高主机与外设并行能力等，以减少访问外存额外次数，提高外排的效率。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h1&gt;&lt;h2 id=&quot;常见排序算法&quot;&gt;&lt;a href=&quot;#常见排序算法&quot; class=&quot;headerlink&quot; title=&quot;常见排序算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="排序" scheme="http://icecorn.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（三）|分治法</title>
    <link href="http://icecorn.github.io/2022/06/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E6%B2%BB/"/>
    <id>http://icecorn.github.io/2022/06/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E6%B2%BB/</id>
    <published>2022-06-27T09:25:10.000Z</published>
    <updated>2022-07-07T14:56:51.500Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分治算法详解"><a href="#分治算法详解" class="headerlink" title="分治算法详解"></a>分治算法详解</h1><h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>分治发的基本思想是自上而下的去处理问题，将一个复杂问题分成一些子问题分解成规模较小的问题处理。<strong>本质就是先分，再治</strong>，至于算法的时间复杂度可以通过<strong>主定理</strong>求解，暂不叙述</p><ul><li><p>divide </p><p>解题时找到divide的方式后，不要考虑太多，比如说处理一个字符串s，我们第一步将它分成left和right两段，那么就相当于我们有了left和right两个字串的求解结果，直接用就行，这样依次divide直到划分到最小为止<strong>（常常可以结合二分和dfs）</strong></p></li><li><p>conquer</p><p>分完之后就要治了，考虑两个方面</p><ul><li>其一是有了左右两个结果，怎么通过这两个来得到当前（最终）的结果</li><li>其二是考虑边界情况，分到最小粒度了，有没有特殊处理</li></ul></li></ul><p><strong>总结起来就一句话，画图求解和dfs一样直接干，不要想太多，你的脑袋才能压几个栈啊！</strong></p><hr><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序就是经典的分治问题：</p><p><a href="https://blog.csdn.net/qq_35344198/article/details/106857042">https://blog.csdn.net/qq_35344198/article/details/106857042</a></p><p>利用二分进行divide，conquer时注意细节即可</p><p>需要注意的是归并排序空间复杂度是O（n）的，需要开辟一个与原数组等长的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; temp)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l + <span class="number">1</span> &gt;= r) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// divide</span></span><br><span class="line"><span class="type">int</span> m = l + (r - l) / <span class="number">2</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(nums, l, m, temp);</span><br><span class="line">    <span class="built_in">merge_sort</span>(nums, m, r, temp);</span><br><span class="line"><span class="comment">// conquer</span></span><br><span class="line"><span class="type">int</span> p = l, q = m, i = l;</span><br><span class="line"><span class="keyword">while</span> (i&lt;=r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123;</span><br><span class="line">temp[i++] = nums[p++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">temp[i++] = nums[q++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = l; i &lt; r; ++i) &#123;</span><br><span class="line">nums[i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="表达式问题"><a href="#表达式问题" class="headerlink" title="表达式问题"></a>表达式问题</h2><p>Lc-241</p><p>这种问题一般是给一个字符串，有各种算式，问你加括号的方式有多少种。我们可以以每个算符作为分割点进行divide，算出左右两边的值的个数，然后在conquer</p><p>这里要注意的是，分到最小粒度的时候我们直接把它作为结果存进去</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = expression.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;+&#x27;</span>||expression[i]==<span class="string">&#x27;-&#x27;</span>||expression[i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> l:left)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> r:right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> c = expression[i];</span><br><span class="line">                        <span class="keyword">switch</span>(c)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: res.<span class="built_in">push_back</span>(l+r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: res.<span class="built_in">push_back</span>(l-r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: res.<span class="built_in">push_back</span>(l*r);<span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(expression));</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当然因为在递归过程中我们有很多重复计算，可以使用记忆化搜索来优化一下：<br>实际上就是用一个hashmap来记录当前字符串s的返回结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,vector&lt;<span class="type">int</span>&gt;&gt; memo;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">diffWaysToCompute</span><span class="params">(string expression)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo.<span class="built_in">find</span>(expression)!=memo.<span class="built_in">end</span>()) <span class="keyword">return</span> memo[expression];</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = expression.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(expression[i]==<span class="string">&#x27;+&#x27;</span>||expression[i]==<span class="string">&#x27;-&#x27;</span>||expression[i]==<span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(<span class="number">0</span>,i));</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">diffWaysToCompute</span>(expression.<span class="built_in">substr</span>(i+<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> l:left)</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">auto</span> r:right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="type">char</span> c = expression[i];</span><br><span class="line">                        <span class="keyword">switch</span>(c)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: res.<span class="built_in">push_back</span>(l+r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: res.<span class="built_in">push_back</span>(l-r);<span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: res.<span class="built_in">push_back</span>(l*r);<span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(expression));</span><br><span class="line">        &#125;    </span><br><span class="line">        memo[expression] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="平面点集最短距离问题"><a href="#平面点集最短距离问题" class="headerlink" title="平面点集最短距离问题"></a>平面点集最短距离问题</h2><p><a href="https://blog.csdn.net/weixin_44772995/article/details/93749863">https://blog.csdn.net/weixin_44772995/article/details/93749863</a></p><blockquote><p>题目描述<br>有一天，小明得到了二维平面上的若干个点，他现在想知道这些点中距离最近的两个点之间的距离是多少？</p></blockquote><blockquote><p>输入<br>第一行输入一个整数T，共有T组测试数据（T&lt;=30)。<br>每组输入数据第一行输入一个n，表示有n个点。第二行有n*2的数字，相邻两个数代表一个点的x,y坐标。<br>1&lt;n&lt;=100, -100000000=&lt;x,y&lt;=100000000</p></blockquote><blockquote><p>输出<br>输出有T行，每行包括一个整数，代表所有距离的最小值（因为小明不在意小数，所以结果向下取整）。</p></blockquote><blockquote><p>样例输入 Copy<br>2<br>2<br>0 0 1 1<br>2<br>0 0 100000000 100000000<br>样例输出 Copy<br>1<br>141421356</p></blockquote><p>核心思路就是分治，divide使用二分法，conquer的技巧在于分割线两边的点之间的距离，另外还要注意的事划分到最小粒度是一边只有两个点或三个点</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分治算法详解&quot;&gt;&lt;a href=&quot;#分治算法详解&quot; class=&quot;headerlink&quot; title=&quot;分治算法详解&quot;&gt;&lt;/a&gt;分治算法详解&lt;/h1&gt;&lt;h2 id=&quot;算法思想&quot;&gt;&lt;a href=&quot;#算法思想&quot; class=&quot;headerlink&quot; title=&quot;算</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="divide&amp;conquer" scheme="http://icecorn.github.io/tags/divide-conquer/"/>
    
  </entry>
  
  <entry>
    <title>算法系列（二）|动态规划专题</title>
    <link href="http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2022-06-25T09:25:10.000Z</published>
    <updated>2022-07-25T01:57:13.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="详解动态规划"><a href="#详解动态规划" class="headerlink" title="详解动态规划"></a>详解动态规划</h1><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>动态规划是一种自下而上的思想，每一个问题，把它们转化成相同原理的更小的子问题，解题关键主要有两点：</p><ul><li>找到状态转移方程</li><li>初始值的设置，这里可以开辟一个大一些的数组，防止段错误</li></ul><p><strong>另外还有一个重点是，一定要细心，通常解题中会有dp数组和原始的数据数组，什么时候用什么下标一定要仔细考虑，比如dp数组大小设置成了n+1,那么i=1时，原始数据数组应该用nums[0],虽然很弱智，但不注意搞错了debug就会很难受</strong></p><hr><h2 id="基本DP：一维"><a href="#基本DP：一维" class="headerlink" title="基本DP：一维"></a>基本DP：一维</h2><p>典型的就是青蛙跳这种，比较简单，状态转移方程类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br></pre></td></tr></table></figure><p>另一种比较特殊的，我们不能用dp[i]来存储最终结果，我们要用dp[i]来存储<strong>以当前i节点结尾的满足题意的状态</strong>，然后对整个dp数组求和。</p><p>比如：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706152248411.png" alt="image-20220706152248411"></p><p>这里我们用dp[i]来表示以该位置结尾的等差数列个数，因为等差数列随时可能会断掉，断掉的位置i的dp[i]就设置为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] - nums[i<span class="number">-1</span>] == nums[i<span class="number">-1</span>] - nums[i<span class="number">-2</span>]) &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">accumulate</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="基本DP：二维"><a href="#基本DP：二维" class="headerlink" title="基本DP：二维"></a>基本DP：二维</h2><p>这里比较代表性的就是给一个二维矩阵，机器人从左上到右下经过的最短路径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + grid[i][j];</span><br></pre></td></tr></table></figure><p>特殊一些的比如lc-221题，算最大全是1的正方形面积，这种题就需要找到题目的一些规律性，寻找状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>], <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j])) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="分割类问题"><a href="#分割类问题" class="headerlink" title="分割类问题"></a>分割类问题</h2><p>代表例子lc-279，lc-139，核心思路就是在dp遍历里边套一层枚举，就是说dp的每一个元素有很多种可能，我们要枚举出来，然后根据题意选最大或最小之类的</p><p>lc-139<br>给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字 符串都可以在集合内找到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: s = <span class="string">&quot;applepenapple&quot;</span>, wordDict = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;pen&quot;</span>]</span><br><span class="line">Output: <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> string &amp; word: wordDict) &#123;</span><br><span class="line"><span class="type">int</span> len = word.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">if</span> (i &gt;= len &amp;&amp; s.<span class="built_in">substr</span>(i - len, len) == word) &#123;</span><br><span class="line">dp[i] = dp[i] || dp[i - len];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对每一个dp[i]，从后往前减去一段，把它变成一个子问题再处理，类似用硬币组成数字问题。</p><hr><h2 id="子序列问题"><a href="#子序列问题" class="headerlink" title="子序列问题"></a>子序列问题</h2><h3 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h3><p>还是一样的思路，dp[i]表示以i结尾的数组的最长递增子序列，里边枚举一下i之前的所有dp，如果nums[i] &gt; nums[j]就是长度+1，如果&lt;=则dp[i] = 0;</p><p><strong>要注意的是此题有很多种其他的问法<br>比如给一个数组，让你去掉k个数，使之变成单调递增的数组，其实就是求最长递增子序列，再用总数n-最长递增子序列=k</strong><br><strong>还有变成单调递减，先递增再递减</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> max_length = <span class="number">0</span>, n = nums.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">max_length = <span class="built_in">max</span>(max_length, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max_length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此题for循环内还可以改成二分法加快速度</p><p>就是在已经有的递增数组里边找dp[i]的位置，再替换即可</p><hr><h2 id="公共元素问题"><a href="#公共元素问题" class="headerlink" title="公共元素问题"></a>公共元素问题</h2><h3 id="最长公共子串问题"><a href="#最长公共子串问题" class="headerlink" title="最长公共子串问题"></a>最长公共子串问题</h3><p>这种题目思路就是我们要开一个二维数组，dp【i】【j】，代表以i，j结尾的两个a，b的子字符串从后往前有几个公共的字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;abcbced&quot;</span>;</span><br><span class="line">b = <span class="string">&quot;acbcbce&quot;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706150443331.png" alt="image-20220706150443331"></p><p>然后相同的地方设置为1，不同的地方设置为0，然后我们最后就是找最长的连续的对角线的长度就是最长的公共子串了</p><p>很容易得到状态转移方程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然题目可能是让你返回最长的长度，或者最长字符串，因题返回就好。</p><p><strong>注意这里的最长子串需要遍历dp才能得到，而不是直接返回最后的元素</strong></p><hr><h3 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h3><p>子序列和子字符串不同的地方在于它不那么严格，就是不连续的也可以，所以它的转移方程为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i] == b[j])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><h3 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706183545329.png" alt="image-20220706183545329"></p><p>如图所示，得到状态转移方程：<br>i是有多少种物品，j是背包的容积<br>核心思想就是对一个dp元素，我们有两种选择，一种是选当前的i物品，一种是不选。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(j&gt;=V[i<span class="number">-1</span>])</span><br><span class="line">&#123;</span><br><span class="line">     dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-V[i<span class="number">-1</span>]]+ W[i<span class="number">-1</span>]);</span><br><span class="line"> &#125;<span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">     dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>全部代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706183951928.png" alt="image-20220706183951928"></p><p>我们可以发现状态转移方程只和上一行有关，那么很自然的想到可以将二维dp矩阵优化成一位来进行处理。</p><p><strong>这里的问题是，如果我们还是从前往后处理的话，那么后边元素所依赖的“上一行”的结果就会被覆盖掉，所以要从后往前遍历</strong>，而且对于不选的情况，直接使用上一行的结果就行了，不用特殊处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line"><span class="type">int</span> w = weights[i<span class="number">-1</span>], v = values[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = W; j &gt;= w; --j) &#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j-w] + v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h3><p>可以在01背包的基础上考虑，01是每一行物品只有一个，要么拿，要么不拿，完全背包呢，是一个东西可以无限拿，那么自然的想到，在每个dp里加一个循环，枚举出拿几个当前物品，一直到拿爆为止。</p><p>首先写一个二维dp基础版本的：</p><p>这里要注意的是k取0的时候其实就把“不取”这个情况给做了。</p><p>需要注意的是这种没优化过的超级暴力代码，有三层循环，1000*1000的用例是没法过的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N][N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;v+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*V[i]&lt;=j;++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i][j],<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j-k*V[i]]+k*W[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[n][v]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来优化成用一维数组，同样要倒序进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k*V[i]&lt;=j;++k)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*V[i]]+k*W[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码只是空间上优化了一丢丢，本质上还是O（n3）的，要想办法在时间复杂度上进行优化。</p><p><strong>想一下，我们不从后往前进行，直接从前往后进行处理，这样后一个dp[j]状态转移获取dp[j-x]的时候，其实dp[i-x]已经“拿了一些该物品的状态“，也就是说dp[j-x]在它的那个位置已经达到了一个最优解，那么到dp[j]的位置的时候我们实际上只要考虑再拿一次物品i，或者不拿物品i</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;v+<span class="number">1</span>;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=V[i]) <span class="comment">//这里一定要注意要判断当前的空间j能不能装下物品V[i]</span></span><br><span class="line">                &#123;           </span><br><span class="line">                    dp[j] = <span class="built_in">max</span>(dp[j],dp[j-V[i]]+W[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现<strong>完全背包</strong>和<strong>01背包</strong>在优化到最后的形态其实只有<strong>正序处理</strong>和<strong>反序处理</strong>之分，这里我们清楚知道它的原理就行，笔试直接写优化后的简单形式，简单粗暴！</p><h3 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h3><p>多重背包实际上就是完全背包的拓展，或者说完全背包是多重背包的一种特殊情况，区别于完全背包，多重背包显示的告诉了我们一个物品最多拿几次，那么我们只需要枚举每种可能就好啦~</p><p>当然也是要逆向处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1050</span>;</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="type">int</span> V[N];</span><br><span class="line"><span class="type">int</span> W[N];</span><br><span class="line"><span class="type">int</span> num[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,v;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v1,w,t;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;   </span><br><span class="line">            cin&gt;&gt;v1&gt;&gt;w&gt;&gt;t;</span><br><span class="line">            V[i] = v1;</span><br><span class="line">            W[i] = w;</span><br><span class="line">            num[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n+<span class="number">1</span>;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=v;j&gt;=<span class="number">0</span>;--j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=num[i];++k)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(k*V[i]&lt;=j)<span class="comment">//需要我们判断不要拿爆了！</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[j] = <span class="built_in">max</span>(dp[j],dp[j-k*V[i]]+k*W[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;dp[v]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包的优化"><a href="#多重背包的优化" class="headerlink" title="多重背包的优化"></a>多重背包的优化</h3><ul><li>一种是用二进制优化，核心思路是把多重背包拆成很多个01背包</li><li>单调队列优化</li></ul><p>这里先不写了，毕竟是面向找工作学算法：），已经过了打ACM的年纪了55555</p><p>关于背包还有一些变种问题：</p><p>混合背包，二维费用背包，分组背包，有依赖的背包，背包求方案数等等，都先不考虑了，留个指针之后看：</p><p><a href="https://www.cnblogs.com/jbelial/articles/2116074.html">https://www.cnblogs.com/jbelial/articles/2116074.html</a></p><p><a href="https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317">https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317</a></p><p><a href="https://www.acwing.com/problem/">https://www.acwing.com/problem/</a></p><hr><h2 id="字符串编辑"><a href="#字符串编辑" class="headerlink" title="字符串编辑"></a>字符串编辑</h2><p>Lc-72：</p><p>给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可 以将两个字符串变成相同</p><p>想法就是用dp每一位代表的是当前word1串截止到i的长度和word2串截止到j的长度，它们转换的最小次数。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220706222023638.png" alt="image-20220706222023638"></p><hr><h2 id="打字问题"><a href="#打字问题" class="headerlink" title="打字问题"></a>打字问题</h2><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220707173533200.png" alt="image-20220707173533200"></p><p>这个题想法就是对于该字符串的任意长度，该位置都有两种情况（大写字母或者小写字母），在打这个字母之前的状态可能是caps的大写或小写，同时打完这个字母之后caps的状态也可以是大写或小写,需要分类讨论</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220707173853805.png" alt="image-20220707173853805"></p><h2 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h2><p>这个先放着，之后单独算一个专题来写吧</p><hr><h2 id="树形DP"><a href="#树形DP" class="headerlink" title="树形DP"></a>树形DP</h2><p>LC 337</p><p>思路就是变量二叉树，把每个节点选与不选的两个状态存起来（用哈希表），</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;TreeNode*, <span class="type">int</span>&gt; f, g;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;left);<span class="comment">//因为状态是从下往上转移的，所以必须后序遍历</span></span><br><span class="line">        <span class="built_in">dfs</span>(node-&gt;right);</span><br><span class="line">        <span class="comment">//选这个点，则不能选它的孩子，那么就选g状态的左右孩子，注意不是只能选一条路径</span></span><br><span class="line">        f[node] = node-&gt;val + g[node-&gt;left] + g[node-&gt;right];</span><br><span class="line">        <span class="comment">//不选这个点，则可以选也可以不选它的孩子，取最大值</span></span><br><span class="line">        g[node] = <span class="built_in">max</span>(f[node-&gt;left], g[node-&gt;left]) + <span class="built_in">max</span>(f[node-&gt;right], g[node-&gt;right]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(f[root], g[root]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;详解动态规划&quot;&gt;&lt;a href=&quot;#详解动态规划&quot; class=&quot;headerlink&quot; title=&quot;详解动态规划&quot;&gt;&lt;/a&gt;详解动态规划&lt;/h1&gt;&lt;h2 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="动态规划" scheme="http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第七课-渲染管线-后处理-其他渲染知识</title>
    <link href="http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/"/>
    <id>http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/</id>
    <published>2022-06-19T09:25:10.000Z</published>
    <updated>2022-06-29T16:26:46.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第七课-渲染管线-后处理–其他渲染知识"><a href="#第七课-渲染管线-后处理–其他渲染知识" class="headerlink" title="第七课 渲染管线-后处理–其他渲染知识"></a>第七课 渲染管线-后处理–其他渲染知识</h2><h3 id="环境光遮蔽-AO"><a href="#环境光遮蔽-AO" class="headerlink" title="环境光遮蔽 AO"></a>环境光遮蔽 AO</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181526.png"></p><p>预计算出AO贴图</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181837.png"></p><p>SSAO</p><p>在屏幕上存储深度信息，设置一些采样点，根据采样点和z-buffer的深度比较来计算最终的光强</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531181923.png"></p><p>SSAO+</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182321.png"></p><p>HBAO</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182427.png"></p><p>GTAO</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182556.png"></p><h3 id="雾效-Fog"><a href="#雾效-Fog" class="headerlink" title="雾效 Fog"></a>雾效 Fog</h3><p>简单的fog，根据深度Z从近到远透明度逐渐减小</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531182921.png"></p><p>考虑到高度信息时，简单的fog公式就不起作用了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183105.png"></p><hr><h3 id="抗锯齿"><a href="#抗锯齿" class="headerlink" title="抗锯齿"></a>抗锯齿</h3><p>采样率不够就会导致走样</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183444.png"></p><h4 id="SSAA和MSAA"><a href="#SSAA和MSAA" class="headerlink" title="SSAA和MSAA"></a>SSAA和MSAA</h4><p>SSAA就是最简单朴素的横竖都扩大一倍采样率，带来的性能代价是很高的。MSAA相比SSAA有一个改动就是在最后pixel shading的时候把一些不必要的shading’去掉了，减少最后shading的次数。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531183748.png"></p><h4 id="FXAA"><a href="#FXAA" class="headerlink" title="FXAA"></a>FXAA</h4><p>因为锯齿大多发生在边缘轮廓，所以从轮廓着手找到轮廓线再用一个滤波器去插值，已达到抗锯齿的效果。</p><p>注意这里阈值是0.05，这个卷积核和sobel卷积核不一样，不是常规意义上的提取轮廓。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531184456.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531185020.png"></p><p> 混合附近像素的颜色，算插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200105.png"></p><h4 id="TAA"><a href="#TAA" class="headerlink" title="TAA"></a>TAA</h4><p>时序反走样</p><p>同时可做鬼影，拖尾等效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200246.png"></p><hr><h3 id="后处理"><a href="#后处理" class="headerlink" title="后处理"></a>后处理</h3><p>Bloom，Tone mapping（曝光），ColornGrading（调色）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200631.png"></p><h4 id="Bloom"><a href="#Bloom" class="headerlink" title="Bloom"></a>Bloom</h4><p>首先把图片亮度高的地方提取出来（注意是RGB，不是灰度）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531200945.png"></p><p>加一个模糊效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201109.png"></p><p>这里针对光晕大但是不能使高斯核太大的情况，采用downsample几次再upsample的hack，大概和dualkawase模糊差不多？</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201307.png"></p><p>最后叠加在原图上</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201741.png"></p><h4 id="Tone-Mapping"><a href="#Tone-Mapping" class="headerlink" title="Tone Mapping"></a>Tone Mapping</h4><p>因为真实世界的光照强度range很宽，假设是0-50，那么要把0-50的range映射到0-1这就是Tone Mapping</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531201910.png"></p><p>一个映射曲线的shader</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202043.png"></p><p>电影工业界的颜色曝光曲线</p><p>这个东西其实都是人为根据经验来拟合出来的曲线</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202436.png"></p><h4 id="Color-Grading"><a href="#Color-Grading" class="headerlink" title="Color Grading"></a>Color Grading</h4><p>LUT映射</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202543.png"></p><p>一般lut不用存256*256那么大，因为颜色是连续的，可以只存32 * 32的采样，然后插值即可</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531202617.png"></p><h3 id="渲染管线"><a href="#渲染管线" class="headerlink" title="渲染管线"></a>渲染管线</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531203320.png"></p><h4 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h4><p>前向渲染两个问题</p><ul><li>处理透明物体的渲染顺序会出问题。一般是由远及近来渲染。</li><li>处理多光源很吃性能。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531203556.png"></p><h4 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h4><p>就是分两个pass，第一个pass渲染一遍所有的物体但是不考虑光照，把物体材质信息存储到G-buffer里</p><p>第二个pass在像素级别上处理光照就好</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531204017.png"></p><p>怎样减少读写G-buffer消耗的资源？</p><p>可以把屏幕分成一个个小块（Tiles），这样每个像素只要读对应的小块纹理而不用整张g-buffer都读进去。这样还有另一个好处是光源也不用每次都遍历所有的了，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531204627.png"></p><p>更进一步，可以做Early-Z，就是说在世界空间下，我们就能知道每个光源所能照到的深度信息，从而在渲染光的时候进行剪枝。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531205034.png"></p><h4 id="Visibility-Buffer"><a href="#Visibility-Buffer" class="headerlink" title="Visibility Buffer"></a>Visibility Buffer</h4><p>现代渲染中，很多时候模型的面片比像素还多，这时候可以存VisibilityBuffer存几何信息反向查找材质信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531205652.png"></p><h4 id="Frame-Graph"><a href="#Frame-Graph" class="headerlink" title="Frame Graph"></a>Frame Graph</h4><p>现代游戏pipline过于复杂，要借助Frame Graph工具将每个步骤算法所用的内存之类的管理起来，方便开发，定位bug</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220531210350.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第七课-渲染管线-后处理–其他渲染知识&quot;&gt;&lt;a href=&quot;#第七课-渲染管线-后处理–其他渲染知识&quot; class=&quot;headerlink&quot; title=&quot;第七课 渲染管线-后处理–其他渲染知识&quot;&gt;&lt;/a&gt;第七课 渲染管线-后处理–其他渲染知识&lt;/h2&gt;&lt;h3 i</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第六课-渲染系统-地形大气和云的渲染</title>
    <link href="http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/"/>
    <id>http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/</id>
    <published>2022-06-16T09:25:10.000Z</published>
    <updated>2022-06-29T16:26:59.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六课-地形大气和云的渲染"><a href="#第六课-地形大气和云的渲染" class="headerlink" title="第六课 地形大气和云的渲染"></a>第六课 地形大气和云的渲染</h2><h3 id="地形的几何"><a href="#地形的几何" class="headerlink" title="地形的几何"></a>地形的几何</h3><h4 id="Heightfield"><a href="#Heightfield" class="headerlink" title="Heightfield"></a>Heightfield</h4><p>数学上的分形方法</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529152911.png"></p><p>每隔1m画一个10000*1000的网格，然后根据高度场，轮廓场等进行映射就可以</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153037.png"></p><p><strong>LOD技术</strong></p><p>就是根据距离远近应用不同分辨率的网格，这里要根据FOV视角的范围进行各向异性的加密或简化网格。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153427.png"></p><p>细分方法</p><p>注意T-Junctions的问题</p><ul><li><p>三角形剖分<img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153733.png"></p></li><li><p>四叉树细分</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529153833.png"></p><p>解决T-Junction问题，就把剖分次数多的一边中间的节点平滑到另一边的角点上是两个点重合，这样实际上就产生了一个面积为0的三角形，也就是网格的退化，一般面积为0的三角形在渲染时直接不渲染。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529154514.png"></p></li></ul><h4 id="TIN方法"><a href="#TIN方法" class="headerlink" title="TIN方法"></a>TIN方法</h4><p>Triangulated Irregular Network</p><p>就是直接用不规则的三角形来表达地形，简化不必要的顶点，并加上需要的特征</p><p>好处是可以减少很多三角形，比之前的方法少了一个数量级</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529154829.png"></p><p>显卡架构，有细分着色器，domainshader等等，可以直接再gpu里边生成细分网格甚至能完成映射扰动的实现。</p><p>最新的显卡架构把以上这些着色器整合成了MeshShader更加方便，有了gpu的加持，甚至可以实现runtime的事实地形交互，比如炮弹打到地上使得网格发生形变出现个坑。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529155134.png"></p><h4 id="制作山洞的一个hack方法"><a href="#制作山洞的一个hack方法" class="headerlink" title="制作山洞的一个hack方法"></a>制作山洞的一个hack方法</h4><p>直接把山体网格要打洞的顶点那里给一个属性把他的position设置成NAN，这样再显卡中就会把所有包含这个顶点的三角形都忽略掉不渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160422.png"></p><h4 id="体素化表达"><a href="#体素化表达" class="headerlink" title="体素化表达"></a>体素化表达</h4><p>虽然目前游戏引擎还没有大规模应用，但是其实可以考虑直接用体素来表达地形模型，而不是二维流形网格，这样实际上就直接有了三维的信息，也就是说地形山体等都不是空心的了，可以跟直接的操作打洞等等。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160719.png"></p><hr><h3 id="地形的材质"><a href="#地形的材质" class="headerlink" title="地形的材质"></a>地形的材质</h3><p>就用之前的MR材质，存一些东西</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529160847.png"></p><p>Height贴图的作用，就是这种地形需要沙子和石头之间渐变的时候，根据高度信息进行混合。</p><p>当然这种渐变过程中因为数值精度可能会有一些抖动，这时可以设置一些扰动保证稳定性。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161010.png"></p><p>通过不同的权重和不同的材质来混合得到想要的效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161300.png"></p><h4 id="视差贴图"><a href="#视差贴图" class="headerlink" title="视差贴图"></a>视差贴图</h4><p>parallax mapping就是扰动法线贴图使视觉上具有更强的凹凸感，而displacement mapping则是更彻底的用高度信息直接更改地形网格面片</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161441.png"></p><p><strong>问题：性能代价</strong></p><p>因为纹理采样实际上是一个很费的操作，如果每一个像素都混合4张纹理，那么就需要重复采样很多次，性能爆炸</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529161924.png"></p><p><strong>解决办法：虚拟纹理</strong></p><p>这里就是和虚拟内存一样的概念，就是把纹理分块，实际用到哪块就读哪块进入内存而不是整个纹理都读进来，因为我们在游戏中视锥呈现的范围实际上只有纹理中的一小块。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162015.png"></p><h4 id="新的技术"><a href="#新的技术" class="headerlink" title="新的技术"></a>新的技术</h4><p>传统的读纹理都是cpu读进内存，然后解压，然后传给gpu。 </p><p>而DirectStorage技术就是cpu读进内存不解压直接传到gpu在gpu中完成解压，提高性能</p><p>而更牛逼的DMA技术就是直接从硬盘读到gpu显存里去了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162715.png"></p><h4 id="浮点数精度问题"><a href="#浮点数精度问题" class="headerlink" title="浮点数精度问题"></a>浮点数精度问题</h4><p>网格数量越大，越精细就会引起精度不够用的问题，因为float使用32个bit组成的，这样就会出现摩尔纹和锯齿问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529162824.png"></p><p>解决方法：</p><p>粗暴的方法就是扩展精度，比如用double来存</p><p>还可以用下图中把相机重置到gameobject坐标中，搞成相对距离解决这个问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163105.png"></p><h4 id="植被道路贴花"><a href="#植被道路贴花" class="headerlink" title="植被道路贴花"></a>植被道路贴花</h4><p>树专门的LOD方法，近处用网格，远处就插片，越远越稀疏</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163422.png"></p><p>Decorator Rendering</p><p>渲染小石头，草，灌木丛等等，一般用小面片，也有很专门的技术</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163512.png"></p><p>道路系统渲染</p><p>用样条曲线编辑道路</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529163641.png"></p><hr><h3 id="大气散射理论"><a href="#大气散射理论" class="headerlink" title="大气散射理论"></a>大气散射理论</h3><h4 id="简单的模型"><a href="#简单的模型" class="headerlink" title="简单的模型"></a>简单的模型</h4><p>根据物理规律拟合一个模型，需要两个参数一个是向上看的角度到天顶的夹角（一般是0-Π），另一个是现在看到高度和太阳的夹角。根据这两个夹角去查表LUT</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529190658.png"></p><h4 id="粒子媒介"><a href="#粒子媒介" class="headerlink" title="粒子媒介"></a>粒子媒介</h4><p>使用更加精细的模型渲染天空，大气由很多粒子，气溶胶组成</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529191019.png"></p><p>光在大气中的规律用四个参数描述：</p><p>从左到右依次为：吸收多少光，像四面八法散射多少，自发光强度，其他粒子对该粒子入射的光</p><p>实际上就是4中不同的梯度</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529191159.png"></p><p>VRE：对上边梯度进行积分</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529191739233.png" alt="image-20220529191739233"></p><p>Transmittance：通透度，意思就是在远处看到一个东西，它有多少能透视到当前点。</p><p>Scattering part：光路打到路径上的气体分子发生一些散射，这些散射路径返回了多少能量。</p><h4 id="大气物理学"><a href="#大气物理学" class="headerlink" title="大气物理学"></a>大气物理学</h4><p>真是的大气物理，主要的元素是太阳，向外辐射不同波长的光，然后大气中有气体分子（它们的大小一般小于阳光波长），还有气溶胶分子（它们的大小一般和阳光波长差不多）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529192645.png"></p><p>两种</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529192851.png"></p><p>//TODO  mark以下，下次再看这一块</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六课-地形大气和云的渲染&quot;&gt;&lt;a href=&quot;#第六课-地形大气和云的渲染&quot; class=&quot;headerlink&quot; title=&quot;第六课 地形大气和云的渲染&quot;&gt;&lt;/a&gt;第六课 地形大气和云的渲染&lt;/h2&gt;&lt;h3 id=&quot;地形的几何&quot;&gt;&lt;a href=&quot;#地形的几</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第五课-渲染系统-光照与材质</title>
    <link href="http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/"/>
    <id>http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/</id>
    <published>2022-06-10T09:25:10.000Z</published>
    <updated>2022-06-29T16:11:21.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五课-渲染系统–光照和材质"><a href="#第五课-渲染系统–光照和材质" class="headerlink" title="第五课 渲染系统–光照和材质"></a>第五课 渲染系统–光照和材质</h2><h3 id="渲染方程与挑战"><a href="#渲染方程与挑战" class="headerlink" title="渲染方程与挑战"></a>渲染方程与挑战</h3><h4 id="渲染方程"><a href="#渲染方程" class="headerlink" title="渲染方程"></a>渲染方程</h4><p>渲染方程就是一个解积分的过程，一个点最终的光照=它本身的发光强度+所有其他方向的入射光在对应角度的投影</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529091653.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529091714.png"></p><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><ul><li><p>阴影效果</p><p>一个点是否能看得见，是否被遮挡时很难判断处理的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092310.png"></p></li><li><p>光源本身很复杂</p><p>比如面光源</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529092529789.png" alt="image-20220529092529789"></p></li><li><p>积分怎么做</p><p>渲染方程里的积分部分怎么处理，光和材质的卷积如何计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092816.png"></p></li><li><p>光的不断反射形成复杂的光影效果</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529092932.png"></p></li></ul><hr><h3 id="基础光照解决方案"><a href="#基础光照解决方案" class="headerlink" title="基础光照解决方案"></a>基础光照解决方案</h3><p>使用点光源等简单光源当做主光，其他光源用低频环境光来模拟</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093254.png"></p><p>使用环境光贴图来模拟反射光等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093551.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529093716.png"></p><h4 id="布林-冯模型"><a href="#布林-冯模型" class="headerlink" title="布林-冯模型"></a>布林-冯模型</h4><p>环境光+漫反射+镜面反射 </p><p>一个问题是它的能量不守恒，渲染什么东西都像塑料：）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529094311.png"></p><h4 id="shadow处理"><a href="#shadow处理" class="headerlink" title="shadow处理"></a>shadow处理</h4><p>shadow map</p><p>思路就是从像素位置反向追踪到每个光源，看看到下一次反射的距离是否等于到光源的距离，从而判断出这个像素对这个光源来说是否可见</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529094812.png"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>通过以上方法将复杂的渲染抽象简化，解决几个挑战，当然效果不是特别理想</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529095257.png"></p><hr><h3 id="基于预计算的全局光照"><a href="#基于预计算的全局光照" class="headerlink" title="基于预计算的全局光照"></a>基于预计算的全局光照</h3><p><strong>预计算：就是空间换时间的一种手段，把一些场景中不动的地方全部预计算存储起来</strong></p><p><strong>全局光照：就是考虑间接光照对场景的影响，也就是说要算光的几次反射，迭代收敛</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529095728.png"></p><p>那么如果迭代计算几次光照，这样产生的计算量是指数增加的，所以要找一个高效的方法来计算</p><h4 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h4><p>把时域信息转到频域信息上去处理，这样可以大幅度压缩信息的数据</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529100142.png"></p><h4 id="球面调和函数"><a href="#球面调和函数" class="headerlink" title="球面调和函数"></a>球面调和函数</h4><p>是一组sin cos的函数集组成的基函数</p><p>这块和下边的部分没听懂，大概目的是为了把数据降维参数化到低维进行处理简化计算，具体的方法用到时再查吧</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529100252.png"></p><h4 id="Lightmap"><a href="#Lightmap" class="headerlink" title="Lightmap"></a>Lightmap</h4><p>预计算光照贴图，把整个场景的光照烘焙到一张纹理上</p><p>这里也有参数化（展UV）的问题</p><p>本质上就是离线baking然后存储下来，在runtime时直接拿纹理用 </p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529101123.png"></p><h4 id="Light-Probes-和-Reflection-Probes"><a href="#Light-Probes-和-Reflection-Probes" class="headerlink" title="Light Probes 和 Reflection Probes"></a>Light Probes 和 Reflection Probes</h4><p>对动态的物体采样光，没看懂存个指针==</p><hr><h3 id="基于物理的材质"><a href="#基于物理的材质" class="headerlink" title="基于物理的材质"></a>基于物理的材质</h3><h4 id="微平面理论"><a href="#微平面理论" class="headerlink" title="微平面理论"></a>微平面理论</h4><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529102141.png"></p><p>光打在表面后只有两种情况，一种时反射出去（镜面反射），一种是射到物体里面在里边弹弹弹然后随机方向射出去（漫反射）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529102211.png"></p><p>针对镜面反射来讲，有DFG理论，每一个字母代表一种光学现象</p><p>D == Normal Distribution Fuction</p><p>描述发现的发散程度，引入roughness粗糙度的参数</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529125633.png"></p><p>G == Geometric attenuation term（self-shadowing）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130248.png"></p><p>F == Fresnel Equation 菲涅尔项</p><p>描述不同材质的反射程度，大牛推出的5次方</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130528.png"></p><h4 id="迪士尼准则"><a href="#迪士尼准则" class="headerlink" title="迪士尼准则"></a>迪士尼准则</h4><ul><li>参数要由艺术家的直觉决定</li><li>参数越少越好</li><li>所有参数最好都是0-1</li><li>只有当参数超出门限是有实际意义的时候才可以超出0-1</li><li>所有的参数组合后需要足够鲁棒，不能有奇奇怪怪的结果</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529130817.png"></p><h4 id="主流PBR模型"><a href="#主流PBR模型" class="headerlink" title="主流PBR模型"></a>主流PBR模型</h4><h5 id="Specular-Glossiness模型"><a href="#Specular-Glossiness模型" class="headerlink" title="Specular Glossiness模型"></a>Specular Glossiness模型</h5><p>这个模型一切参数存在图里</p><ul><li>Diffuse 存在diffuse图里</li><li>菲涅尔项存在Specular图里</li><li>roughness项存在Glossiness图里</li></ul><p>然后就可以通过+-*/运算写shader进行渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529131312.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529131445.png"></p><h5 id="Metallic-Roughness模型"><a href="#Metallic-Roughness模型" class="headerlink" title="Metallic Roughness模型"></a>Metallic Roughness模型</h5><p>相当于在SG模型上包了一层，在外边加了一些判断防止使用错误，比如说有一个参数判断模型是金属还是非金属，如果是金属就把颜色传递，非金属就不传递颜色</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529132208.png"></p><hr><h3 id="基于图像的光照"><a href="#基于图像的光照" class="headerlink" title="基于图像的光照"></a>基于图像的光照</h3><p>IBL的基本思想就是通过预计算的方式提前将环境光照算出来然后直接和环境中的材质进行卷积算出结果，本质上也是空间换时间的。</p><p><strong>这个和全局光照的区别我理解就是全局光照只预计算到光照那一步，而IBL继续预计算到光照和材质卷积完的结果</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529132522.png"></p><p>这里也是分diffuse和specular两种情况，本质上就是预计算再LUT的情况，至于怎么搞的，用时再看把：（</p><hr><h3 id="经典阴影方法"><a href="#经典阴影方法" class="headerlink" title="经典阴影方法"></a>经典阴影方法</h3><p>cascade shadow</p><p>主要思想就是根据远近进行shadow map分级管理，就类似mipmap</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529145741.png"></p><h5 id="软阴影"><a href="#软阴影" class="headerlink" title="软阴影"></a>软阴影</h5><p>PCF   PCSS方法</p><p>具体去看Games 202</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>3A游戏的渲染</p><ul><li>Lightmap + Lightprobe</li><li>PBR + IBL</li><li>CascadeShadow + VSSM</li></ul><h3 id="前沿技术"><a href="#前沿技术" class="headerlink" title="前沿技术"></a>前沿技术</h3><p>实时光追</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220529150407.png"></p><h3 id="Shader管理"><a href="#Shader管理" class="headerlink" title="Shader管理"></a>Shader管理</h3><p>因为GPU是并发的，对于判断语句会执行等待然后一起结束，所以shader中最好没有判断，那么在游戏中就会有上万数量级的shader资产，而在软件工程中这些零散的东西显然是不好维护的，这是就可以开发一个UberShader工具，其实就可以理解为一类shader有一个父类，当我要修改时，会重新生成子类shader</p><p>同时面对不同图形API要做好处理</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220529151139636.png" alt="image-20220529151139636"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第五课-渲染系统–光照和材质&quot;&gt;&lt;a href=&quot;#第五课-渲染系统–光照和材质&quot; class=&quot;headerlink&quot; title=&quot;第五课 渲染系统–光照和材质&quot;&gt;&lt;/a&gt;第五课 渲染系统–光照和材质&lt;/h2&gt;&lt;h3 id=&quot;渲染方程与挑战&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Games-104|第四课-渲染数据组织</title>
    <link href="http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/"/>
    <id>http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/</id>
    <published>2022-06-07T09:25:10.000Z</published>
    <updated>2022-06-29T16:09:25.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四课-渲染数据组织"><a href="#第四课-渲染数据组织" class="headerlink" title="第四课 渲染数据组织"></a>第四课 渲染数据组织</h2><h3 id="游戏中的渲染"><a href="#游戏中的渲染" class="headerlink" title="游戏中的渲染"></a>游戏中的渲染</h3><p>面临的挑战：</p><ul><li>大量的GO渲染，所用到的渲染算法不一样，比如水体，人物，毛发</li><li>适配硬件，不同的CPU和GPU</li><li>帧率要稳定，比如塞尔达的呀哈哈森林疯狂掉帧体验感很差，所以渲染一帧必须在一个固定的非常短的时间里</li><li>渲染所分配的资源不能占全部cpu和内存，还要分给gameplay，logic</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528202409.png"></p><hr><h3 id="渲染系统的对象"><a href="#渲染系统的对象" class="headerlink" title="渲染系统的对象"></a>渲染系统的对象</h3><p>光栅化管线</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528202600.png"></p><p>将一系列的顶点进行MVP变换，并且裁剪，然后光栅化，最后进行着色。</p><p>纹理对象的渲染，涉及到采样频率小引发的摩尔纹，锯齿等现象，所以引出了抗锯齿技术等</p><hr><h3 id="GPU架构"><a href="#GPU架构" class="headerlink" title="GPU架构"></a>GPU架构</h3><p>SIMD：单指令多数据，一条指令可以发给很多单元同时处理数据，就是显卡里的SM</p><p>SIMT：单指令多线程，一条指令分给好多个线程并发执行</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528203240.png"></p><p>SM就是最基础的单元用于并行计算</p><p>Texture Units是处理纹理的单元</p><p>SMU：sin cos 向量运算等比较高阶的运算单元</p><p>Warp：warp是逻辑上的单位不是物理上的，一个warp可能包含32个线程，每个线程交给一个SM去执行，但是显卡中一组SM可能只有8个，那么就是说一个warp要控制这8个SM执行4次</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528203431.png"></p><p>CPU-&gt;GPU 数据的交互</p><p>cpu发送数据到gpu的显存上，这一步比较耗费时间，同时一般情况下最好只是单向的数据传递，也就是说尽量不要gpu处理完数据传回cpu</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204315.png"></p><p>高速缓存cache</p><p>cathe是很快的，比普通内存速度高出一个数量级，所以我们处理数据最后一次把要用到的所有数据同时放进cathe而不用再去内存中去取，这样可以提高速度</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204257.png"></p><hr><h3 id="可渲染物体"><a href="#可渲染物体" class="headerlink" title="可渲染物体"></a>可渲染物体</h3><p>GO上基础的可渲染的对象，比如人身体的网格，材质等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204819.png"></p><h4 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h4><p>mesh类的构造，这里有不同的数据结构，比如半边数据结构等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528204948.png"></p><p>为了节省cpu传到gpu显存上的数据量，一位一个三角形有三个点，相邻三角形会共用顶点，所以可以只存一次，然后再存一个索引值，这样来节省内存</p><p>要存的内容可能有：顶点位置，法向，颜色等等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528205145.png"></p><h4 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h4><p>视觉上的材质</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528205810.png"></p><p>phone Model，PBR Model</p><p>纹理，shaderCode</p><p>shader虽然是代码，但是也算是render需要数据的一种，是一些已经编译好的二进制文件，可以应用在不同的渲染对象上</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220528210138989.png" alt="image-20220528210138989"></p><hr><h4 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h4><p>把vertexBuffer,indexBuffer，纹理，shader传递给显卡，显卡就会渲染对应物体</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528210338.png"></p><p>由于将一个3维中的2维流形映射回2维参数化的过程（展uv）会有扭曲的情况发生，也就是说模型不同位置对应到二维的纹理上可能会重叠也可能一部分曲率大顶点多的地方映射的面积会很小，这样会导致精度不够的问题，所以目前业界一般会把一个模型分割成几个小部分，比如头，四肢这样。<strong>当然分成submesh还有另一个重要原因是因为一个模型通常有很多不同的材质，比如人的皮肤和衣服</strong></p><p>但是从cpu像gpu传递数据时还是一整个模型一起传递，只不过我们可以标记index，比如1-100是头，101-200是胳膊这种。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528210837.png"></p><p>在游戏中，会有很多一样的GO，比如小兵，这样每一个小兵GO的网格，纹理材质信息都是一样的，为了避免内存浪费，我们可能建立一个Pool，一个东西只存一遍，公用就行了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211100.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211132.png"></p><p>因为渲染流程实际上是一个状态机的模式，参考opengl，也就是说显卡一次处理一个东西，比如先渲染物体A它使用的是材质1，然后渲染物体B使用的是材质2，然后渲染物体C使用的也是材质1，这就会导致切换了两次材质造成性能下降，所以我们可以用材质来排序，一次性把材质1的GO（submesh）都渲染完，在切换材质2去渲染</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211556.png"></p><p>针对完全重复的同一个对象，比如一堆树，可以在GPU中加一个offerset，一次drawcall全部渲染完毕，节省了重新传递vbo，ibo，drawcall的时间</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211731.png"></p><h4 id="可见性裁剪culling"><a href="#可见性裁剪culling" class="headerlink" title="可见性裁剪culling"></a>可见性裁剪culling</h4><p>在游戏过程中，要使用事件锥来裁剪可见的对象</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528211949.png"></p><p>这里就要用包围盒来判断一个GO是否在事件锥的范围内</p><p>包围盒的种类：球，AABB，OBB，凸包等等</p><p>然后还要结合8叉树，BVH等空间划分算法来计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212124.png"></p><p>BVH的优点是对运动的物体culling很快</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212347.png"></p><p>PVS算法：主要思路就是根据所在位置看，能看到那些块就渲染哪些块</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212440.png"></p><p>利用光线追踪来判断哪些是可见的</p><p>PVS算法比Octree等算法快很多，并且一个更大的优点是<strong>可以判断哪些资源需要加载</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212632.png"></p><p>目前的算力已经很高了，显卡可以直接计算出哪些物体能看见，哪些被挡住了</p><p>Early Z：这个就是根据深度信息，可以提前判断好多物体不可见不用渲染，舍弃掉把它们光栅化的过程，节省性能</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528212916.png"></p><h4 id="纹理压缩"><a href="#纹理压缩" class="headerlink" title="纹理压缩"></a>纹理压缩</h4><p>图片的存储格式不能够随机访问，所以游戏引擎必须对都进来的图片进行转化，记得opengl里好像有一个函数叫gl_readpixel,这个就是用来读图的，而且有按照1字节读和4字节读的接口（RGBA通道）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528213249.png"></p><p>压缩纹理的方法</p><p>先找一个4*4块的最亮和最暗的值，其他值都可以插值出来</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528213624.png"></p><h4 id="建模工具"><a href="#建模工具" class="headerlink" title="建模工具"></a>建模工具</h4><p>blender，3dsMax，Houdini</p><p>一些建模方法：</p><ul><li>样条模型，贝塞尔曲线</li><li>点云扫描</li><li>雕刻建模</li><li>AI辅助建模</li></ul><h4 id="新的模型管线"><a href="#新的模型管线" class="headerlink" title="新的模型管线"></a>新的模型管线</h4><p>时代发展，算力膨胀，有了GPU驱动的渲染</p><p>因为有了几何着色器，细分着色器，可以凭空生成很多的三角形，可以根据相机的远近来生成不同分辨率的模型（类似QEM）</p><p>所以可以把gpu每个sm处理的粒度变得更小，像下图中的龙一样，一个patch只有32个小三角形这种</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220528214122.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li> 游戏引擎和硬件架构和算力息息相关</li><li>针对多材质的模型使用submesh分割</li><li>在绘制中尽可能的使要渲染的东西少，culling裁剪看不见的东西</li><li>Gpu越来越牛逼，未来可能直接靠算力就可以搞定很多东西</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四课-渲染数据组织&quot;&gt;&lt;a href=&quot;#第四课-渲染数据组织&quot; class=&quot;headerlink&quot; title=&quot;第四课 渲染数据组织&quot;&gt;&lt;/a&gt;第四课 渲染数据组织&lt;/h2&gt;&lt;h3 id=&quot;游戏中的渲染&quot;&gt;&lt;a href=&quot;#游戏中的渲染&quot; class=&quot;</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    
    <category term="Games-104" scheme="http://icecorn.github.io/tags/Games-104/"/>
    
    <category term="游戏引擎" scheme="http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
</feed>
