<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-06-29T11:30:31.307Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++ Primer笔记|第二章-变量和基本类型</title>
    <link href="http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/"/>
    <id>http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</id>
    <published>2022-02-20T12:25:30.000Z</published>
    <updated>2022-06-29T11:30:31.307Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二章-变量和基本类型"><a href="#第二章-变量和基本类型" class="headerlink" title="第二章 变量和基本类型"></a>第二章 变量和基本类型</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>如果定义变量时未指定初值，则变量被默认初始化（default initialized）。</p><p>对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。</p><p>所以类里边的成员变量一定要初始化，不然会有未定义的结果</p><hr><h3 id="变量声明和定义的关系"><a href="#变量声明和定义的关系" class="headerlink" title="变量声明和定义的关系"></a>变量声明和定义的关系</h3><p>声明（declaration）使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。(<strong>不分配内存</strong>)</p><p>定义（definition）负责创建与名字相关联的实体。（<strong>分配内存，不一定初始化</strong>）</p><p>如果想声明一个变量而不定义它，就在变量名前添加关键字<code>extern</code>，并且不要显式地初始化变量。</p><p><strong>总结：除了用extern修饰变量，其他的声明都是定义。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> i; <span class="comment">// declares but does not define i</span></span><br><span class="line"><span class="type">int</span> j;      <span class="comment">// declares and defines j</span></span><br></pre></td></tr></table></figure><p><code>extern</code>语句如果包含了初始值就不再是声明了，而变成了定义。</p><p>变量能且只能被定义一次，但是可以被声明多次。</p><p>如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。</p><h4 id="extern用法详解"><a href="#extern用法详解" class="headerlink" title="extern用法详解"></a>extern用法详解</h4><ol><li><p><strong>extern修饰变量的声明</strong>：</p><p>主要使用的情况是，不同的文件中都需要用到这个变量X（大多数情况是全局变量），而且，extern声明的变量可以在文件中的任何地方声明。</p><p><strong>总结：其实就是类似一个引用的手法，在一个项目中只在某一个地方<code>int x = 1;</code>声明加定义（开辟一块内存），这样在其他地方用到这个变量，只需要<code>extern int x；</code>就相当于获得了这个变量的引用，接下来的程序就可以用了。</strong></p></li><li><p><strong>extern修饰函数声明：</strong></p><p>本质的看，变量和函数没有区别，函数名是指向函数二进制块开头处的指针。也就是说extern在这里，也是一样的，如果A文件中有一个函数<code>int fun()</code>,那么想在B文件里用它，就可以<code>extern int fun()</code>就可以用了。</p><p><em>使用extern和包含头文件引用函数有什么区别呢？</em></p><p><strong>用extern更简洁，想用哪个函数就extern哪个，而不用整体include</strong>，另外的还可以<strong>加速程序的编译</strong>，因为不需要编译不要用到的函数了嘛！</p></li><li><p><strong>extern还可用于指示C或者C++的调用规范：</strong></p><p>比如在C++中调用C的函数，就需要在C++代码中用extern声明要引入的C库函数。这是给<strong>链接器</strong>看的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。</p></li></ol><blockquote><p>用C语言编写程序的时候，我们经常会遇到这样一种情况：<strong>希望在头文件中定义一个全局变量，然后包含到两个不同的c文件中，希望这个全局变量能在两个文件中共用。</strong></p></blockquote><blockquote><p>举例说明：项目文件夹project下有main.c、common.c和common.h三个文件，其中<br>common.h文件分别#include在main.c和common.c文件中。现在希望声明一个字符型变量key，在main.c和common.c中公用。如下图所示：<br>有人想，既然是想两个文件都用，那就在common.h中声明一个unsigned char key，然后由于包含关系，在main.c和common.c中都是可见的，所以就能共用了。<br>这种想法其实是很多初学者都会想到的，想起来确实有道理，但是实际写出来，我们发现编译的时候编译器提示出错，一般提示大概都类似于：Error: L6200E: Symbol key multiply defined (by common.o and main.o). 也就是说编译器认为我们重复定义了key这个变量。这是因为#include命令就是原封不同的把头文件中的内容搬到#include的位置，所以相当于main.c和common.c中都执行了一次unsigned char key，而C语言中全局变量是项目内（或者叫工程内）可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义。<br>正确的解决办法：使用extern关键字来声明变量为外部变量。具体说就是在其中一个c文件中定义一个全局变量key，然后在另一个要使用key这个变量的c文件中使用extern关键字声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：定义和声明。例如在main.c文件中定义变量key，在common.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了。</p></blockquote><hr><h3 id="标识符和名字的作用域"><a href="#标识符和名字的作用域" class="headerlink" title="标识符和名字的作用域"></a>标识符和名字的作用域</h3><p><strong>标识符：</strong></p><p>C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。</p><p><strong>名字的作用域</strong></p><p>定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。</p><p>最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。</p><p>作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。</p><p>可以用作用域操作符<code>::</code>来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// Program for illustration purposes only: It is bad style for a function</span></span><br><span class="line"><span class="comment">// to use a global variable and also define a local variable with the same name</span></span><br><span class="line"><span class="type">int</span> reused = <span class="number">42</span>;    <span class="comment">// reused has global scope</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> unique = <span class="number">0</span>; <span class="comment">// unique has block scope</span></span><br><span class="line">    <span class="comment">// output #1: uses global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span> reused = <span class="number">0</span>; <span class="comment">// new, local object named reused hides global reused</span></span><br><span class="line">    <span class="comment">// output #2: uses local reused; prints 0 0</span></span><br><span class="line">    std::cout &lt;&lt; reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// output #3: explicitly requests the global reused; prints 42 0</span></span><br><span class="line">    std::cout &lt;&lt; ::reused &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; unique &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。</strong></p><p><strong>总结：内部作用域可以用外部的变量，反之不行，内部作用域会覆盖同名外部作用域。可以用：：选择作用域中的变量。</strong></p><hr><h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><h4 id="引用（References）"><a href="#引用（References）" class="headerlink" title="引用（References）"></a>引用（References）</h4><p>引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成<code>&amp;d</code>的形式来定义引用类型，其中<em>d</em>是变量名称。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> &amp;refVal = ival; <span class="comment">// refVal refers to (is another name for) ival</span></span><br><span class="line"><span class="type">int</span> &amp;refVal2;       <span class="comment">// error: a reference must be initialized</span></span><br></pre></td></tr></table></figure><p>定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。</p><p>引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。</p><p>声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。</p><p>引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。</p><h4 id="指针（Pointer）"><a href="#指针（Pointer）" class="headerlink" title="指针（Pointer）"></a>指针（Pointer）</h4><p>与引用类似，指针也实现了对其他对象的间接访问。</p><ul><li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。</li><li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li></ul><p>通过将声明符写成<code>*d</code>的形式来定义指针类型，其中<em>d</em>是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号<code>*</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ip1, *ip2;     <span class="comment">// both ip1 and ip2 are pointers to int</span></span><br><span class="line"><span class="type">double</span> dp, *dp2;    <span class="comment">// dp2 is a pointer to double; dp is a double</span></span><br></pre></td></tr></table></figure><p>指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符<code>&amp;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br></pre></td></tr></table></figure><p>因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。</p><p>声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。</p><p>指针的值（即地址）应属于下列状态之一：</p><ul><li>指向一个对象。</li><li>指向紧邻对象所占空间的下一个位置。</li><li>空指针，即指针没有指向任何对象。</li><li>无效指针，即上述情况之外的其他值。</li></ul><p>试图拷贝或以其他方式访问无效指针的值都会引发错误。</p><p>如果指针指向一个对象，可以使用解引用（dereference）符<code>*</code>来访问该对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;ival; <span class="comment">// p holds the address of ival; p is a pointer to ival</span></span><br><span class="line">cout &lt;&lt; *p;     <span class="comment">// * yields the object to which p points; prints 42</span></span><br></pre></td></tr></table></figure><p>给解引用的结果赋值就是给指针所指向的对象赋值。</p><p>解引用操作仅适用于那些确实指向了某个对象的有效指针。</p><p><strong>空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值<code>nullptr</code>来初始化指针。</strong></p><p>旧版本程序通常使用<code>NULL</code>（预处理变量，定义于头文件<em>cstdlib</em>中，值为0）给指针赋值，但在C++11中，最好使用<code>nullptr</code>初始化空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="literal">nullptr</span>;  <span class="comment">// equivalent to int *p1 = 0;</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="number">0</span>;        <span class="comment">// directly initializes p2 from the literal constant 0</span></span><br><span class="line"><span class="comment">// must #include cstdlib</span></span><br><span class="line"><span class="type">int</span> *p3 = <span class="literal">NULL</span>;     <span class="comment">// equivalent to int *p3 = 0;</span></span><br></pre></td></tr></table></figure><p>建议初始化所有指针。</p><p><code>void*</code>是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作<code>void*</code>指针所指的对象。</p><h3 id="理解复合类型的声明"><a href="#理解复合类型的声明" class="headerlink" title="理解复合类型的声明"></a>理解复合类型的声明</h3><p>指向指针的指针（Pointers to Pointers）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="type">int</span> *pi = &amp;ival;    <span class="comment">// pi points to an int</span></span><br><span class="line"><span class="type">int</span> **ppi = &amp;pi;    <span class="comment">// ppi points to a pointer to an int</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211207145225233.png" alt="image-20211207145225233"></p><p>指向指针的引用（References to Pointers）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> *p;         <span class="comment">// p is a pointer to int</span></span><br><span class="line"><span class="type">int</span> *&amp;r = p;    <span class="comment">// r is a reference to the pointer p</span></span><br><span class="line">r = &amp;i;         <span class="comment">// r refers to a pointer; assigning &amp;i to r makes p point to i</span></span><br><span class="line">*r = <span class="number">0</span>;         <span class="comment">// dereferencing r yields i, the object to which p points; changes i to 0</span></span><br></pre></td></tr></table></figure><p><strong>面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。</strong></p><h3 id="const限定符"><a href="#const限定符" class="headerlink" title="const限定符"></a>const限定符</h3><p>在变量类型前添加关键字<code>const</code>可以创建值不能被改变的对象。**<code>const</code>变量必须被初始化。**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufSize = <span class="number">512</span>;    <span class="comment">// input buffer size</span></span><br><span class="line">bufSize = <span class="number">512</span>;      <span class="comment">// error: attempt to write to const object</span></span><br></pre></td></tr></table></figure><p><strong>默认情况下，<code>const</code>对象被设定成仅在文件内有效。当多个文件中出现了同名的<code>const</code>变量时，其实等同于在不同文件中分别定义了独立的变量。</strong></p><p>如果想在多个文件间共享<code>const</code>对象：</p><ul><li><p>若<code>const</code>对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。</p></li><li><p>若<code>const</code>对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时<code>const</code>变量的声明和定义前都应该添加<code>extern</code>关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file_1.cc defines and initializes a const that is accessible to other files</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize = <span class="built_in">fcn</span>();</span><br><span class="line"><span class="comment">// file_1.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> bufSize;   <span class="comment">// same bufSize as defined in file_1.cc</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="const的引用"><a href="#const的引用" class="headerlink" title="const的引用"></a>const的引用</h4><p>把引用绑定在<code>const</code>对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。<strong>这里其实就是因为不能用引用来修改原来是const的变量的值，所以不能有非const的引用，我一个本尊都不能修改，能让你一个假身（引用）修改嘛？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = ci;     <span class="comment">// ok: both reference and underlying object are const</span></span><br><span class="line">r1 = <span class="number">42</span>;        <span class="comment">// error: r1 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = ci;   <span class="comment">// error: non const reference to a const object</span></span><br></pre></td></tr></table></figure><p><strong>大部分情况下，引用的类型要和与之绑定的对象严格匹配。</strong>但是有两个例外：</p><ul><li><p>初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r1 = i;      <span class="comment">// we can bind a const int&amp; to a plain int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;     <span class="comment">// ok: r1 is a reference to const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = r1 * <span class="number">2</span>;     <span class="comment">// ok: r3 is a reference to const</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = r * <span class="number">2</span>;        <span class="comment">// error: r4 is a plain, non const reference</span></span><br></pre></td></tr></table></figure></li><li><p>允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure></li></ul><h4 id="指针和const（Pointers-and-const）"><a href="#指针和const（Pointers-and-const）" class="headerlink" title="指针和const（Pointers and const）"></a>指针和const（Pointers and const）</h4><p><strong>指向常量的指针（pointer to const）</strong>不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14</span>;     <span class="comment">// pi is const; its value may not be changed</span></span><br><span class="line"><span class="type">double</span> *ptr = &amp;pi;          <span class="comment">// error: ptr is a plain pointer</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *cptr = &amp;pi;   <span class="comment">// ok: cptr may point to a double that is const</span></span><br><span class="line">*cptr = <span class="number">42</span>;         <span class="comment">// error: cannot assign to *cptr</span></span><br><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>; <span class="comment">// dval is a double; its value can be changed</span></span><br><span class="line">cptr = &amp;dval;       <span class="comment">// ok: but can&#x27;t change dval through cptr</span></span><br></pre></td></tr></table></figure><p>定义语句中把<code>*</code>放在<code>const</code>之前用来说明指针本身是一个常量，<strong>常量指针（const pointer）</strong>必须初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr will always point to errNumb</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> *<span class="type">const</span> pip = &amp;pi;  <span class="comment">// pip is a const pointer to a const object</span></span><br></pre></td></tr></table></figure><p>指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。</p><h4 id="顶层const（Top-Level-const）"><a href="#顶层const（Top-Level-const）" class="headerlink" title="顶层const（Top-Level const）"></a>顶层const（Top-Level const）</h4><p>顶层<code>const</code>表示指针本身是个常量，底层<code>const</code>（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层<code>const</code>也可以是底层<code>const</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *<span class="type">const</span> p1 = &amp;i;     <span class="comment">// we can&#x27;t change the value of p1; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;      <span class="comment">// we cannot change ci; const is top-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p2 = &amp;ci;    <span class="comment">// we can change p2; const is low-level</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *<span class="type">const</span> p3 = p2; <span class="comment">// right-most const is top-level, left-most is not</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = ci;      <span class="comment">// const in reference types is always low-level</span></span><br></pre></td></tr></table></figure><p>当执行拷贝操作时，常量是顶层<code>const</code>还是底层<code>const</code>区别明显：</p><ul><li><p>顶层<code>const</code>没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = ci;     <span class="comment">// ok: copying the value of ci; top-level const in ci is ignored</span></span><br><span class="line">p2 = p3;    <span class="comment">// ok: pointed-to type matches; top-level const in p3 is ignored</span></span><br></pre></td></tr></table></figure></li><li><p>拷入和拷出的对象必须具有相同的底层<code>const</code>资格。或者两个对象的数据类型可以相互转换。一般来说，<strong>非常量可以转换成常量</strong>，反之则不行。</p><p><strong>这种就想，如果能把常量转换成非常量的话，这就代表你这个新的指针可以随便改这个值，那原来的变量又怎么能叫做常量呢？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = p3;    <span class="comment">// error: p3 has a low-level const but p doesn&#x27;t</span></span><br><span class="line">p2 = p3;        <span class="comment">// ok: p2 has the same low-level const qualification as p3</span></span><br><span class="line">p2 = &amp;i;        <span class="comment">// ok: we can convert int* to const int*</span></span><br><span class="line"><span class="type">int</span> &amp;r = ci;    <span class="comment">// error: can&#x27;t bind an ordinary int&amp; to a const int object</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = i;  <span class="comment">// ok: can bind const int&amp; to plain int</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="constexpr和常量表达式（constexpr-and-Constant-Expressions）"><a href="#constexpr和常量表达式（constexpr-and-Constant-Expressions）" class="headerlink" title="constexpr和常量表达式（constexpr and Constant Expressions）"></a>constexpr和常量表达式（constexpr and Constant Expressions）</h4><p>常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。</p><p>一个对象是否为常量表达式由它的数据类型和初始值共同决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_files = <span class="number">20</span>;           <span class="comment">// max_files is a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> limit = max_files + <span class="number">1</span>;    <span class="comment">// limit is a constant expression</span></span><br><span class="line"><span class="type">int</span> staff_size = <span class="number">27</span>;        <span class="comment">// staff_size is not a constant expression</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> sz = <span class="built_in">get_size</span>();  <span class="comment">// sz is not a constant expression</span></span><br></pre></td></tr></table></figure><p>C++11允许将变量声明为<code>constexpr</code>类型以便由编译器来验证变量的值是否是一个常量表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">constexpr int mf = 20;          // 20 is a constant expression</span><br><span class="line">constexpr int limit = mf + 1;   // mf + 1 is a constant expression</span><br><span class="line">constexpr int sz = size();      // ok only if size is a constexpr function</span><br></pre></td></tr></table></figure><p>指针和引用都能定义成<code>constexpr</code>，但是初始值受到严格限制。<code>constexpr</code>指针的初始值必须是0、<code>nullptr</code>或者是存储在某个固定地址中的对象。</p><p>函数体内定义的普通变量一般并非存放在固定地址中，因此<code>constexpr</code>指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化<code>constexpr</code>指针。</p><p>在<code>constexpr</code>声明中如果定义了一个指针，限定符<code>constexpr</code>仅对指针本身有效，与指针所指的对象无关。<code>constexpr</code>把它所定义的对象置为了顶层<code>const</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;     <span class="comment">// p是指向int的const指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">int</span> *cp = &amp;i;   <span class="comment">// cp是指向const int的const指针</span></span><br></pre></td></tr></table></figure><p><code>const</code>和<code>constexpr</code>限定的值都是常量。但<code>constexpr</code>对象的值必须在编译期间确定，而<code>const</code>对象的值可以延迟到运行期间确定。</p><p><strong>建议使用<code>constexpr</code>修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。</strong></p><hr><h3 id="处理类型（Dealing-with-Types）"><a href="#处理类型（Dealing-with-Types）" class="headerlink" title="处理类型（Dealing with Types）"></a>处理类型（Dealing with Types）</h3><h4 id="类型别名（Type-Aliases）"><a href="#类型别名（Type-Aliases）" class="headerlink" title="类型别名（Type Aliases）"></a>类型别名（Type Aliases）</h4><p>类型别名是某种类型的同义词，传统方法是使用关键字<code>typedef</code>定义类型别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">double</span> wages;   <span class="comment">// wages is a synonym for double</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p; <span class="comment">// base is a synonym for double, p for double*</span></span><br></pre></td></tr></table></figure><p>C++11使用关键字<code>using</code>进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales_item; <span class="comment">// SI is a synonym for Sales_item</span></span><br></pre></td></tr></table></figure><h4 id="auto类型说明符（The-auto-Type-Specifier）"><a href="#auto类型说明符（The-auto-Type-Specifier）" class="headerlink" title="auto类型说明符（The auto Type Specifier）"></a>auto类型说明符（The auto Type Specifier）</h4><p>C++11新增<code>auto</code>类型说明符，能让编译器自动分析表达式所属的类型。<code>auto</code>定义的变量必须有初始值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the type of item is deduced from the type of the result of adding val1 and val2</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;    <span class="comment">// item initialized to the result of val1 + val2</span></span><br></pre></td></tr></table></figure><p>编译器推断出来的<code>auto</code>类型有时和初始值的类型并不完全一样。</p><ul><li><p>当引用被用作初始值时，编译器以引用对象的类型作为<code>auto</code>的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;     <span class="comment">// a is an int (r is an alias for i, which has type int)</span></span><br></pre></td></tr></table></figure></li><li><p><code>auto</code>一般会忽略顶层<code>const</code>。<strong>因为是赋值出来的另一个变量，独立的内存</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">// b is an int (top-level const in ci is dropped)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">// c is an int (cr is an alias for ci whose const is top-level)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">// d is an int*(&amp; of an int object is int*)</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">// e is const int*(&amp; of a const object is low-level const)</span></span><br></pre></td></tr></table></figure><p>如果希望推断出的<code>auto</code>类型是一个顶层<code>const</code>，需要显式指定<code>const auto</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// deduced type of ci is int; f has type const int</span></span><br></pre></td></tr></table></figure></li></ul><p>设置类型为<code>auto</code>的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g is a const int&amp; that is bound to ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;   <span class="comment">// error: we can&#x27;t bind a plain reference to a literal</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;     <span class="comment">// ok: we can bind a const reference to a literal</span></span><br></pre></td></tr></table></figure><h4 id="decltype类型指示符（The-decltype-Type-Specifier）"><a href="#decltype类型指示符（The-decltype-Type-Specifier）" class="headerlink" title="decltype类型指示符（The decltype Type Specifier）"></a>decltype类型指示符（The decltype Type Specifier）</h4><p>C++11新增<code>decltype</code>类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) sum = x;  <span class="comment">// sum has whatever type f returns</span></span><br></pre></td></tr></table></figure><p><code>decltype</code>处理顶层<code>const</code>和引用的方式与<code>auto</code>有些不同，如果<code>decltype</code>使用的表达式是一个变量，则<code>decltype</code>返回该变量的类型（包括顶层<code>const</code>和引用）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;     <span class="comment">// x has type const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;     <span class="comment">// y has type const int&amp; and is bound to x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;     <span class="comment">// error: z is a reference and must be initialized</span></span><br></pre></td></tr></table></figure><p>如果<code>decltype</code>使用的表达式不是一个变量，则<code>decltype</code>返回表达式结果对应的类型。如果表达式的内容是解引用操作，则<code>decltype</code>将得到引用类型。如果<code>decltype</code>使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则<code>decltype</code>会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。</p><p><strong><code>decltype((var))</code>的结果永远是引用</strong>，而<code>decltype(var)</code>的结果只有当<em>var</em>本身是一个引用时才会是引用。</p><hr><h3 id="自定义数据结构（Defining-Our-Own-Data-Structures）"><a href="#自定义数据结构（Defining-Our-Own-Data-Structures）" class="headerlink" title="自定义数据结构（Defining Our Own Data Structures）"></a>自定义数据结构（Defining Our Own Data Structures）</h3><p>C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。</p><p><strong>类内初始值不能使用圆括号。</strong></p><p><strong>类定义的最后应该加上分号。</strong></p><p><strong>头文件（header file）通常包含那些只能被定义一次的实体，如类、<code>const</code>和<code>constexpr</code>变量。</strong></p><p><strong>头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。</strong></p><p>头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。<code>#define</code>指令把一个名字设定为预处理变量。<code>#ifdef</code>指令当且仅当变量已定义时为真，<code>#ifndef</code>指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到<code>#endif</code>指令为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sales_data</span></span><br><span class="line">&#123;</span><br><span class="line">    std::string bookNo;</span><br><span class="line">    <span class="type">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在高级版本的IDE环境中，可以直接使用<code>#pragma once</code>命令来防止头文件的重复包含。</p><p>预处理变量无视C++语言中关于作用域的规则。</p><p>整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。</p><p>头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二章-变量和基本类型&quot;&gt;&lt;a href=&quot;#第二章-变量和基本类型&quot; class=&quot;headerlink&quot; title=&quot;第二章 变量和基本类型&quot;&gt;&lt;/a&gt;第二章 变量和基本类型&lt;/h2&gt;&lt;h3 id=&quot;变量初始化&quot;&gt;&lt;a href=&quot;#变量初始化&quot; class</summary>
      
    
    
    
    <category term="ReadingNotes，C++" scheme="http://icecorn.github.io/categories/ReadingNotes%EF%BC%8CC/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--应用层</title>
    <link href="http://icecorn.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2022-02-16T11:25:30.000Z</published>
    <updated>2022-06-29T10:21:15.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–应用层"><a href="#计算机网络–应用层" class="headerlink" title="计算机网络–应用层"></a>计算机网络–应用层</h1><p>本章主要掌握各种应用层协议的使用方法和实现方法</p><p>常见的基于UDP和TCP的应用</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419210323.png"></p><h2 id="1-域名系统DNS"><a href="#1-域名系统DNS" class="headerlink" title="1 域名系统DNS"></a>1 域名系统DNS</h2><p>我们打开一个网页比如百度通常是使用<a href="http://www.baidu.com而不是它的ip地址加端口号,这就是靠域名服务器进行域名解析实现的.主机发送dns请求报文(使用udp)给**域名服务器**,收到响应中的ip地址后可与目的主机进行通信./">www.baidu.com而不是它的ip地址加端口号，这就是靠域名服务器进行域名解析实现的。主机发送DNS请求报文（使用UDP）给**域名服务器**，收到响应中的ip地址后可与目的主机进行通信。</a></p><hr><p>全球只用一个域名服务器显然是不现实的，所以域名服务器实际上是一个分布式系统，并且按如下划分了域名空间</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419170454.png"></p><p><strong>权限域名服务器</strong>：负责一个区的域名服务器，一般是一个公司内部的，比如可以划分abc.com和y.abc.com</p><p><strong>本地域名服务器</strong>：又叫做<strong>默认域名服务器</strong>，一般是离主机最近的服务器</p><hr><p>主机向本地域名服务器的查询一般采用<strong>递归查询</strong></p><p>本地服务器向根服务器的查询一般采用<strong>迭代查询</strong>，当然也可以用递归查询</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419174635.png"></p><p><strong>递归查询</strong>就是自己只发送一次查询报文然后剩下的一层层处理最后拿个结果就好了（小弟派小弟层层转包）</p><p><strong>迭代查询</strong>是自己发送查询接收响应反复操作最后得到结果（事必躬亲）</p><hr><h2 id="2-文件传送协议"><a href="#2-文件传送协议" class="headerlink" title="2 文件传送协议"></a>2 文件传送协议</h2><p>FTP基于TCP，TFTP基于UDP</p><h3 id="2-1-FTP协议"><a href="#2-1-FTP协议" class="headerlink" title="2.1 FTP协议"></a>2.1 FTP协议</h3><p>FTP使用客户服务器方式，FTP服务器由一个<strong>主进程</strong>和<strong>若干个从属进程</strong>组成，这是因为FTP服务器要接收好多个客户的请求，每次和一个客户连接后马上给这个客户分配几个从属进程，快点把主进程空出来给别的客户访问</p><p>对于一个主机来说，与服务器一般建立两个TCP连接，一个<strong>控制进程</strong>，一个<strong>数据传送进程</strong>，通信中控制进程一直连接着吗，因此FTP控制信息是<strong>带外</strong>的</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419180528.png" alt="一个主机与服务器的通信"></p><p>TCP只能整体传送文件，这就有了<strong>网络文件系统NFS</strong>，它可以允许应用程序只读取并修改指定位置的信息，减少了通信量</p><hr><h3 id="2-2-TFTP协议"><a href="#2-2-TFTP协议" class="headerlink" title="2.2 TFTP协议"></a>2.2 TFTP协议</h3><p>基于UDP的超级简单的协议，只支持传输不支持交互</p><p>优点：</p><ul><li>多个主机同时从服务器下载东西（因为UDP可以一对多嘛，可以理解类似于多播）</li><li>开销小，占内存小，这就适合很多不需要太多功能的开源硬件</li></ul><p>另外虽然UDP是不可靠传输，但TFTP类似与停止等待协议，这就是靠应用层实现传输控制来保证的</p><hr><h3 id="2-3-远程终端协议TELNET"><a href="#2-3-远程终端协议TELNET" class="headerlink" title="2.3 远程终端协议TELNET"></a>2.3 远程终端协议TELNET</h3><p>用来远程控制桌面的东东，只需要知道怎么用以及它是基于TCP的就ok</p><hr><h2 id="3-万维网协议"><a href="#3-万维网协议" class="headerlink" title="3 万维网协议"></a>3 万维网协议</h2><p>就是我们熟悉的www啦，了解万维网，主要了解一下几个问题：</p><ul><li>怎样标志分布在整个互联网上的各种万维网文档？ URL</li><li>用什么协议实现万维网的连接？  HTTP</li><li>不同风格的文档在不同主机怎么显示？  HTML</li><li>怎样查找需要的信息？  搜索引擎</li></ul><hr><h3 id="3-1-统一资源定位符URL"><a href="#3-1-统一资源定位符URL" class="headerlink" title="3.1 统一资源定位符URL"></a>3.1 统一资源定位符URL</h3><p>相当于互联网上任一文件的指针，一般形式为：</p><p>&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</p><p>协议常见的有http，ftp等，端口和路径可以省略</p><hr><h3 id="3-2-超文本传输协议HTTP"><a href="#3-2-超文本传输协议HTTP" class="headerlink" title="3.2 超文本传输协议HTTP"></a>3.2 超文本传输协议HTTP</h3><p>HTTP是<strong>面向事务</strong>的应用层协议，基于TCP</p><p>特点：</p><ul><li><strong>无连接的</strong>：意思就是http不用先建立连接再通信，因为是基于TCP的，由TCP来保证可靠传输</li><li><strong>无状态的</strong>： 意思是同一个客户再来访问结果还是一样，服务器不会记得</li><li><strong>面向文本</strong>： 意思是http报文中的每一个字段都是一些ASCII码，长度是由用户输入决定的</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419185159.png"></p><hr><p>http首先要与服务器建立TCP连接，这就需要3次握手，由传输层的知识我们知道这样就会导致客户实际收到消息时需要2RTT的时间间隔，而http1.0协议使用<strong>非持续传输</strong>，意思就是访问这个网页（服务器不同路径）上的任何一个元素都需要重新建立TCP连接，这就会浪费好多个2RTT时间</p><p>所以http1.1采用了<strong>持续连接</strong>，意思就是访问同一个服务器上东西的时候TCP连接不用断开，就用着一个就完事了，省下来很多<strong>握手时间</strong>，具体方式还分为<strong>流水线</strong>和<strong>非流水线</strong>方式，不赘述了</p><hr><p><strong>代理服务器</strong>，又叫做<strong>万维网高速缓存</strong></p><p>这玩意就是保存了一个局域网内最近主机的请求和响应信息，当又有主机访问相同的资源的时候就不用再去远端查找了。这就减少了链路的通信量。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419190059.png"></p><hr><p><strong>HTTP的报文结构</strong></p><p>主要就是<strong>请求报文</strong>和<strong>响应报文</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419190831.png"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419191111.png"></p><hr><h3 id="3-3-万维网文档"><a href="#3-3-万维网文档" class="headerlink" title="3.3 万维网文档"></a>3.3 万维网文档</h3><p><strong>超文本标记语言HTML</strong>：用于在浏览器上显示数据</p><p><strong>可扩展标记语言XML</strong>： 用于传输数据</p><p><strong>可扩展超文本标记语言XHTML</strong>： 更严格的html版本</p><p><strong>层叠样式表CSS</strong>： 用于定义html文档布局</p><hr><p><strong>动态文档</strong></p><p>上述都是<strong>静态文档</strong>，而<strong>动态文档</strong>只是文档的生成方法不同，静态文档只要放在服务器上就ok了，动态文档允许客户和服务器进行交互，也就是说服务器获取到客户的信息后进行一系列处理之后生成文档</p><p>这就需要在服务器中新增加一个应用程序叫做<strong>CGI程序</strong>，也叫作CGI脚本。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419192922.png"></p><hr><p><strong>活动文档</strong></p><p>它是用来满足更复杂的需求比如动画交互之类的，如果一直让服务器来传送的话太浪费资源，所以<strong>活动文档</strong>相当于是在服务器上的一个静态文档，类似一个浏览器可执行的小应用程序，现在常用的JS脚本</p><hr><h3 id="3-4-万维网的信息检索系统"><a href="#3-4-万维网的信息检索系统" class="headerlink" title="3.4 万维网的信息检索系统"></a>3.4 万维网的信息检索系统</h3><p>分为两种：</p><p><strong>全文检索搜索</strong>： 比如谷歌百度这种，本质是使用爬虫在数据库里搜索相关信息</p><p><strong>分类目录搜索</strong>： 比如门户网站这些，已经给你分配好了的专栏</p><hr><h2 id="4-电子邮件"><a href="#4-电子邮件" class="headerlink" title="4 电子邮件"></a>4 电子邮件</h2><p>主要涉及<strong>简单邮件传送协议SMTP</strong>，<strong>互联网邮件扩充MIME</strong>，<strong>邮局协议POP3</strong>，<strong>网际报文存取协议IMAP</strong></p><p><strong>要注意的是这些都是基于TCP的</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419195202.png"></p><p>上图基本给出了用户代理，发送方和接收方邮件服务器的作用</p><hr><p><strong>由于SMTP有以下缺点</strong>：</p><ul><li>不能传送可执行文件和其他的二进制对象</li><li>只能传送7位的ASCII码，导致其他国家文字不能传输</li><li>SMTP服务器会拒绝超出一定长度的邮件</li><li>将制表符tab转换为若干个空格</li></ul><p>由此提出了<strong>互联网扩充协议MIME</strong></p><p>具体看书吧，记住有了MIME实现了上述这些功能就行了</p><hr><p><strong>两种接收协议的特点</strong>：</p><p>POP3：</p><p>优点：简单</p><p>缺点：邮件读了后就自动删除了</p><p>IMAP：</p><p>优点：可以在不同主机上随时处理邮件服务器的邮件，支持阅读部分邮件</p><p>缺点：必须上网连接IMAP服务器才能阅读邮件</p><hr><p>互联网邮箱：</p><p>现在多数都是这些，记住<strong>浏览器和互联网上的邮件服务器通信使用的是HTTP协议，而邮件服务器之间通信使用SMTP即可</strong></p><hr><h2 id="5-动态主机配置协议DHCP"><a href="#5-动态主机配置协议DHCP" class="headerlink" title="5 动态主机配置协议DHCP"></a>5 动态主机配置协议DHCP</h2><p>DCHP使用UDP进行传输。就是动态的分配<strong>IP地址，子网掩码，默认路由地址，域名服务器地址</strong>（就是我们常用的自动配置IP）</p><p>一个新的主机第一次连接到一个网络，按照以下步骤：</p><ul><li>主机发送<strong>广播</strong>（目的地址全1）给网络中的<strong>DCHP中继代理</strong>（一般是一个路由器）</li><li>路由器发送<strong>单播</strong>告诉DCHP服务器</li><li>DCHP发送响应给主机A</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419201257.png"></p><p>注意两点：</p><ul><li>主机在一个网络中连了一次网，分配的IP就记录在DCHP服务器中了，下次联网还是这个IP地址</li><li>给了IP地址后，不是一直可以使用的，有一个<strong>租用期</strong>，长短有DCHP服务器控制，过半后主机发送续租报文，服务器同意就续上，不同意就不能用这个IP了</li></ul><h2 id="6-P2P应用"><a href="#6-P2P应用" class="headerlink" title="6 P2P应用"></a>6 P2P应用</h2><h3 id="6-1-集中服务器的P2P工作方式"><a href="#6-1-集中服务器的P2P工作方式" class="headerlink" title="6.1 集中服务器的P2P工作方式"></a>6.1 集中服务器的P2P工作方式</h3><p>在集中式目录服务器中建立一个数据库保存哪个资源都哪些主机有，这是要想下载一个东西就先去集中服务器查找，返回一串主机，在选一个主机进行下载</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419203549.png"></p><hr><h3 id="6-2-全分布式结构P2P共享程序"><a href="#6-2-全分布式结构P2P共享程序" class="headerlink" title="6.2 全分布式结构P2P共享程序"></a>6.2 全分布式结构P2P共享程序</h3><p>使用<strong>洪泛法</strong>，在网络内进行<strong>有限范围的洪泛查询</strong>，具有代表性的就是BT种子了（某播：技术是无罪的==）</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419203910.png"></p><p>P2P的本质就是惠人惠己，比如我们要下载一部小电影，实际上在p2p网络中这个小电影是由好多个<strong>文件块</strong>组成的，有好多主机上边都有这些文件块，可能这个给你一块那个给你一块那么我们就能很快把这个小电影下载完，当然之后我们电脑上有这个文件了（即使一些文件块）也要给别人下载，不能太自私啦。这些和我们互相交互下载文件块的主机叫做<strong>对等方</strong>。</p><p>同时在发送过程中有两个规则：</p><ul><li><strong>最稀有优先</strong>：意思就是小电影中哪个文件块在现在网上拥有的数目最少就要先下载哪个，不然那些主机都下线最后少了这个文件块导致看不了小电影就很难受QAQ</li><li><strong>优先发送对等方选择</strong>：前面说我们也要给别人下载，那么怎么确定优先给谁发呢？当然要优先发给给我们发送文件块的对等方了（按速率排序，互惠互利）。一般保持4个最高速的对等方，这些对等方叫<strong>已疏通的或无障碍的对等方</strong></li></ul><p>还有一个问题就是分布式结构到底怎么确定小电影在哪些主机上有呢？</p><p><strong>洪泛法的效率太低且浪费资源</strong>，所以最好还是建立一个<strong>分布式数据库</strong>，又不能像集中式服务器那样，所以现在有个算法是<strong>分布式散列表</strong>，具体内容再看吧QAQ</p><hr><h2 id="7-应用进程和系统调用"><a href="#7-应用进程和系统调用" class="headerlink" title="7 应用进程和系统调用"></a>7 应用进程和系统调用</h2><p>我们知道程序员的业务逻辑代码基本都是在应用层，对运输层的控制很少（只能设置最大数据长度MSS等），那么进行网络编程时实际上都是使用API（也可以说套接字）来对接操作系统从而实现网络通信</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419205843.png"></p><p>进行TCP的基本API调用流程如下，细节的话联系操作系统</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200419210211.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–应用层&quot;&gt;&lt;a href=&quot;#计算机网络–应用层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–应用层&quot;&gt;&lt;/a&gt;计算机网络–应用层&lt;/h1&gt;&lt;p&gt;本章主要掌握各种应用层协议的使用方法和实现方法&lt;/p&gt;
&lt;p&gt;常见的基于UDP和TC</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--运输层</title>
    <link href="http://icecorn.github.io/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2022-02-14T06:16:07.000Z</published>
    <updated>2022-06-29T10:20:45.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–运输层"><a href="#计算机网络–运输层" class="headerlink" title="计算机网络–运输层"></a>计算机网络–运输层</h1><h2 id="1-运输层基本概念"><a href="#1-运输层基本概念" class="headerlink" title="1. 运输层基本概念"></a>1. 运输层基本概念</h2><p>运输层向应用层提供通信服务，在运输层中，<strong>通信的真正端点不是主机而是主机中的进程</strong></p><p>网络层为主机之间提供逻辑通信，运输层为应用进程提供端到端的逻辑通信</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415155007.png"></p><hr><p>运输层连个主要协议：</p><ul><li>用户数据报协议UDP（不用连接）</li><li>传输控制协议TCP（面向连接）</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415155252.png" alt="使用这两种协议的应用及协议"></p><hr><p>运输层支持<strong>复用</strong>和<strong>分用</strong>，方法是使用<strong>协议端口号</strong>（端口）</p><p>这里的端口号是指软件端口，分为两大类：</p><ul><li><p>服务器端使用的端口号</p><p>1.熟知端口号（系统端口号）：  0~1023 比如FTP是21</p><p>2.登记算口号：  1024~49151  其他应用使用的</p></li><li><p>客户端使用的端口号</p><p>数值49152~65535  在客户进程运行时才动态选择，又叫<strong>短暂端口号</strong>  ，在不同主机可以随意分配</p></li></ul><hr><h2 id="2-用户数据报协议UDP"><a href="#2-用户数据报协议UDP" class="headerlink" title="2 用户数据报协议UDP"></a>2 用户数据报协议UDP</h2><p>UDP在IP数据报服务上增加了复用分用功能和差错检测功能</p><p>主要特点：</p><ul><li><strong>是无连接的</strong></li><li><strong>尽最大努力交付：</strong>  即不保证可靠交付</li><li><strong>是面向报文的：</strong>  意思是UDP接收到应用层报文不做任何操作仅仅加上UDP首部就构成了UDP报文，这就要求应用层控制报文大小（太大会导致IP报文需要分片，太小导致传输效率太低）</li><li><strong>没有拥塞控制</strong></li><li><strong>支持1对1,1对多，多对1，多对多的交互通信</strong></li><li><strong>首部开销小</strong>：  只有8字节</li></ul><hr><p>UDP 首部格式</p><p>首部共8字节，四个字段，分别是<strong>源端口</strong>  <strong>目的端口</strong>  <strong>长度</strong>（UDP报文总长度，最小为8只有首部）  <strong>检验和</strong>  每个字段2字节</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415161027.png"></p><p>伪首部只在计算检验和时被用于计算，检验方法类似IP数据报首部校验方法，<strong>区别是UDP的校验是把首部和数据部分一起都检验</strong></p><hr><h2 id="3-传输控制协议TCP"><a href="#3-传输控制协议TCP" class="headerlink" title="3 传输控制协议TCP"></a>3 传输控制协议TCP</h2><p>TCP具有可靠传输，流量控制，拥塞控制等等功能</p><p>主要特点：</p><ul><li><strong>面向连接</strong>：通信前必须建立TCP连接</li><li><strong>点对点</strong>：每一条TCP连接只能有两个端点，即只能1对1传输</li><li><strong>提供可靠交付</strong>： 无差错，不丢失，不重复，按序到达</li><li><strong>全双工通信</strong>：TCP连接两端设有<strong>发送缓存</strong>和<strong>接收缓存</strong></li><li><strong>面向字节流</strong>：对TCP来说应用程序发送的数据仅仅看成一连串<strong>无结构的字节流</strong>，TCP不理解这些玩意代表啥意思，只是必须把这些字节流按照顺序完整的传达到终点，它的任务就完成了。解析的活就交给终端处理就好</li></ul><p><strong>这里有一个UDP与TCP的差别就是，UDP发送的报文长度是应用进程给出的，而TCP是根据对方的窗口值和网络拥塞之类的自己判断（如果应用数据太长就分几段，太短就攒几个一起发）</strong></p><hr><p>TCP连接的端点叫<strong>套接字socket</strong>，将端口号拼接到IP地址就是套接字</p><p>比如 192.3.4.5:80</p><p>TCP把连接作为最基本的抽象，每条TCP连接唯一的被通信两端的套接字确定</p><p>TCP连接::={socket1,socket2}={(IP1:port1),(IP2,port2)}</p><hr><h2 id="4-TCP报文段首部格式"><a href="#4-TCP报文段首部格式" class="headerlink" title="4 TCP报文段首部格式"></a>4 TCP报文段首部格式</h2><p>TCP首部前20字节是固定的，后边可根据需要增加4n字节</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415164539.png" alt="TCP报文段首部格式"></p><ul><li><strong>源端口和目的端口</strong>：各占2字节，目的是实现分用</li><li><strong>序号</strong>：4字节，TCP是面向字节流的，所以该字段是指<strong>本报文段所发送的第一个字节的序号</strong></li><li><strong>确认号</strong>：4字节，是<strong>期望收到对方下一个报文段的第一个数据字节序号</strong></li><li><strong>数据偏移</strong>：4位，和IP数据报中的首部长度类似，表示的是TCP首部的实际长度（最大二进制15,4字节为单位，所以TCP首部最大也是60字节）</li><li><strong>保留</strong>：目前没用，置0</li><li><strong>紧急URG</strong>：1位，置1时代表高优先级优先发送</li><li><strong>确认ACK</strong>：1位，置1时才有效，TCP连接建立后所有报文ACK都为1</li><li><strong>推送PSH</strong>：1位，表示接收端收到就上交给应用层（不用少量信息攒一波），很少用</li><li><strong>复位RST</strong>：1位，TCP连接出现严重差错，该字段置1重建连接</li><li><strong>同步SYN</strong>：1位，建立连接时用来同步序号，置1表示这是一个连接请求或连接接受报文</li><li><strong>终止FIN</strong>：1位，用来释放一个连接，置1表示发送方数据发送完毕，请求释放运输连接</li><li><strong>窗口</strong>：2字节，是指发送本报文段的一方的<strong>接收窗口</strong></li><li><strong>检验和</strong>：2字节，检验首部和数据两部分，和UDP一样计算时也加伪首部</li><li><strong>紧急指针</strong>：2字节，仅在URG置1时有意义，指出<strong>紧急数据在的末尾在此报文段中的位置</strong></li><li><strong>选项</strong>：长度可变，最多40字节</li></ul><hr><h2 id="5-可靠传输的原理和实现"><a href="#5-可靠传输的原理和实现" class="headerlink" title="5 可靠传输的原理和实现"></a>5 可靠传输的原理和实现</h2><p>TCP是面向连接且可靠的传输协议，理想的传输协议需要具备以下两点：</p><ul><li>传输信道不产生差错</li><li> 不管发送方以多快的速度发送分组，接收端总能正确接收并处理</li></ul><hr><h3 id="5-1-停止等待协议"><a href="#5-1-停止等待协议" class="headerlink" title="5.1 停止等待协议"></a>5.1 停止等待协议</h3><p>停止等待是最简单的可靠传输，<strong>A发生完一个分组就停止发送等待对方的确认</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415181928.png" alt="停止等待协议"></p><p><strong>超时重传</strong>：当发送方发送的分组出现差错没有送达接收方，就会启动<strong>超时重传机制</strong>，A每发送一个分组立刻设置一个<strong>超时计时器</strong>。这里有三点需要注意：</p><ul><li>A发送一个分组后，必须暂时保留该<strong>分组副本</strong>，收到确认后才删除</li><li>分组和确认分组都要进行<strong>编号</strong>，对于停止等待来说 0和1两个编号循环使用就行</li><li>超时重传时间应该设置的比<strong>数据传输的平均往返时间</strong>长一些</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415182617.png" alt="确认丢失额确认迟到"></p><p>确认丢失时B忽略第二次收到的重复分组并发送确认给A</p><p>确认迟到B同样忽略第二次收到的重复分组，A忽略重复确认</p><p>这样我们就在不可靠的传输网络上实现了可靠通信，这种可靠传输协议叫做<strong>自动重传请求ARQ</strong></p><hr><h3 id="5-2-流水线传输"><a href="#5-2-流水线传输" class="headerlink" title="5.2 流水线传输"></a>5.2 流水线传输</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低，所以出现了流水线传输。流水线传输需要用到<strong>连续ARQ协议，回退N帧（gobackN）协议，滑动窗口协议等等</strong></p><hr><p>连续ARQ协议：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415183407.png" alt="连续ARQ协议工作原理"></p><p>发送方根据接收方的<strong>窗口</strong>参数和<strong>自身的发送缓存</strong>决定窗口大小，窗口内的分组都是可以发送的，每收到一个确认窗口就向前移动一个分组</p><p><strong>累计确认</strong>：接收方不用每收到一个分组就发送一条确认，而是攒几个发送一个确认（<strong>按序到达的最后一个分组编号</strong>）即可。</p><p>累计确认的优点是<strong>容易实现</strong>，<strong>减少了通信量</strong>，<strong>即使确认丢失也不用重传</strong>。</p><p>累计确认的缺点是<strong>不能向发送方反应已经正确收到的所有分组信息</strong></p><p><strong>比如发送了前5个分组，接收方收到了1 2 4 5，那么接收方直接发送收到了2，这样发送方就必须重新发送3 4 5，哪怕4 5 已经收到了，这就叫做回退N帧协议（Go-back-N）</strong></p><hr><h3 id="5-3-滑动窗口协议"><a href="#5-3-滑动窗口协议" class="headerlink" title="5.3 滑动窗口协议"></a>5.3 滑动窗口协议</h3><p>滑动窗口协议其实就是<strong>以字节为单位</strong>的连续ARQ协议，但是研究的时候通常也可以以分组为单位研究</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415184550.png"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415185230.png" alt="缓存与窗口的关系"></p><p>这里要注意以下几点：</p><ul><li>A<strong>根据B可接收的窗口大小</strong>和<strong>A的发送缓存大小</strong>（取较小值）来确定A的发送窗口，当然有时还可以根据<strong>拥塞状况</strong>适当减小。</li><li>发送窗口中已发送数据在<strong>没收到确认之前</strong>不能删除</li><li>接收方一定要支持<strong>累计确认</strong>功能，减小传输开销</li><li>TCP是全双工通信，通信双方都有发送窗口和接收窗口</li></ul><hr><h3 id="5-4-超时重传时间的选择"><a href="#5-4-超时重传时间的选择" class="headerlink" title="5.4 超时重传时间的选择"></a>5.4 超时重传时间的选择</h3><p>重传时间的选择是TCP中最复杂的问题，TCP采用一种自适应的算法线算出报文段的往返时间RTT，再计算一个加权平均往返时间RTTS。</p><p>不想写了，用到的话看书吧QAQ</p><hr><h3 id="5-5-选择确认SACK"><a href="#5-5-选择确认SACK" class="headerlink" title="5.5 选择确认SACK"></a>5.5 选择确认SACK</h3><p>若接收方收到的分组无差错，只是没按序号，或者只有中间的几个分组丢失了，能不能告诉发送方只发送这几个分组？</p><p>没错，这玩意就是解决这个问题的，要在TCP建立连接时在扩展首部里加上“允许SACK”选项</p><p>具体内容不写了，QAQ</p><hr><h2 id="6-TCP流量控制"><a href="#6-TCP流量控制" class="headerlink" title="6 TCP流量控制"></a>6 TCP流量控制</h2><h3 id="6-1-利用滑动窗口实现流量控制"><a href="#6-1-利用滑动窗口实现流量控制" class="headerlink" title="6.1 利用滑动窗口实现流量控制"></a>6.1 利用滑动窗口实现流量控制</h3><p>流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417165127.png"></p><p>TCP是面向字节流的，seq代表发送字节的序号，ACK是确认位，ack是确认编号，rwnd是<strong>接收端允许发送端发送的数据窗口大小</strong></p><p>图中最后rwnd置0，说明此时A不能再发送字节了，要是之后B发送重置rwnd时确认丢失，就会产生死锁，解决方案就是TCP的每条连接都有一个<strong>持续计时器</strong>，在发送端收到rwnd置0消息时开启，超时后发送端发送一个<strong>1字节的零窗口探测报文段</strong>，这样接收端就知道响应报文丢失了。</p><hr><h3 id="6-2-TCP的传输效率"><a href="#6-2-TCP的传输效率" class="headerlink" title="6.2 TCP的传输效率"></a>6.2 TCP的传输效率</h3><p>对于UDP来说，什么时候发送报文是应用程序决定的，UDP只需要原封不动的转发就行。但是对于TCP，应用进程把数据传送到TCP的发送缓存后就不管了，所以TCP是什么时候发送报文就是一个很重要的问题，有下面几种机制来发送：</p><ul><li>TCP维持一个<strong>最大报文段长度MSS</strong>变量，只要缓存中数据达到MSS字节就发送</li><li>发送方的应用进程指明要求发送报文段，即TCP支持<strong>推送</strong>操作</li><li>用一个计时器规定时间，到点发送</li></ul><p><strong>Nagle算法</strong>：发送方先发送<strong>第一个数据字节</strong>，将后续应用程序输入的字节保存在<strong>发送缓存</strong>，收到接收方的<strong>确认</strong>后，将攒了一波的数据发送出去（当然不能超过MSS），同时继续保存发送缓存。在收到接收方确认，再发送数据报。<strong>另外，当发送缓存中数据已经到达窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。</strong></p><p><strong>糊涂窗口综合症</strong>：  这个玩意是指TCP<strong>接收方的缓存</strong>已经满了，并且接受方的<strong>应用程序</strong>比较懒，一次处理一个字节，那么接收缓存每次仅仅空出一个字节还每次都发送确认（并把rwnd设置为1，导致发送方每次有效传输只有1字节），发送1字节还要加上TCP首部20字节，IP首部20字节，这样效率实在太低</p><p>解决方案可以<strong>让接收方等一会，等接收缓存空出来一个最大报文段或者等到接收缓存有一半以上空地方</strong></p><p>总结： 发送效率主要就是要减少40字节的首部的占比，所以记住发送方别发送太短的报文，接收方也别没事就发信号让发送方发报文就完事了。</p><hr><h3 id="6-3-吞吐量"><a href="#6-3-吞吐量" class="headerlink" title="6.3 吞吐量"></a>6.3 吞吐量</h3><p>吞吐量是指一个传输周期内传输的字节速率，注意单位是<strong>bit/s</strong>，经常会有和<strong>发送窗口</strong>相关的计算题</p><p>一个TCP连接下面使用256Kb/s的链路，其端到端时延为128ms。经测试，发现吞吐量只有120kb/s，则发送窗口大约是</p><p>A．3614字节<br>B．7228字节<br>C．57826字节<br>D．120k比特</p><p>本题目主要考查的是“TCP流量控制”。<br>为了提高报文段的传输效率，TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位为字节。发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。发送端利用发送窗口调节向网络注入分组的速率不仅是为了使接收端来得及接收，而且还是为了对网络进行拥塞控制。在每一个运输连接上报文段是断续发送的，这样就有了两种速率。一种是链路层的数据率，另一种是从运输层看到的数据注入速率。<br>题目中给出端到端时延为128ms，则在一个传输周期里，从发送第一个报文段到收到所有确认时间为：W/R+2<em>T，其中w为发送窗口的大小，R为链路速率，T为端到端时延。因此吞吐量TP=W/(W/R+2</em>T)，将题目中的具体数据代入，即可求得W=7228字节。</p><hr><h2 id="7-TCP的拥塞控制"><a href="#7-TCP的拥塞控制" class="headerlink" title="7 TCP的拥塞控制"></a>7 TCP的拥塞控制</h2><h3 id="7-1-拥塞控制概念"><a href="#7-1-拥塞控制概念" class="headerlink" title="7.1 拥塞控制概念"></a>7.1 拥塞控制概念</h3><p><strong>拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不会过载</strong></p><p>拥塞控制和流量控制的区别是：拥塞控制涉及到是整条通信线路上所有的资源（主机，路由器，链路等等），所以需要控制调整的措施也比较复杂。而<strong>流量控制是端到端的交流</strong>，就是接收端告诉发送端你慢点，我吃不消了QAQ</p><p>拥塞控制主要分为两种方法：</p><ul><li><strong>开环控制</strong>：在设计网络时将会导致拥塞的因素都考虑到，运行时就基本不能改了</li><li><strong>闭环控制</strong>：基于反馈环路，几种措施 </li></ul><p>​             1.监测网络拥塞发生在何处</p><p>​             2.把拥塞信息传达到可以采取行动的地方</p><p>​             3.调整网络系统的运行解决问题</p><hr><h3 id="7-2-TCP的拥塞控制方法"><a href="#7-2-TCP的拥塞控制方法" class="headerlink" title="7.2 TCP的拥塞控制方法"></a>7.2 TCP的拥塞控制方法</h3><p>TCP进行拥塞控制的算法有四种：<strong>慢开始</strong>  <strong>拥塞避免</strong>  <strong>快重传</strong>  <strong>快恢复</strong></p><p>首先，发送当要维持一个<strong>拥塞窗口cnwd变量</strong>，<strong>发送方让自己的发送窗口等于拥塞窗口</strong>，cnwd的单位是<strong>发送方的最大报文段SMSS</strong>，一般初始设置为1。</p><p><strong>慢开始</strong>：意思就是初始cnwd设置为1，然后以指数方式增长</p><p><strong>拥塞避免</strong>：当cnwd超过预设门限值ssthresh时，改为线性增大，尽量避免拥塞发生</p><p><strong>快重传</strong>：  为了避免发送方一检测到<strong>超时</strong>就进行慢开始（有时候超时不意味着拥塞），快重传就是说发送方收到连续3次确认（因为中间一个数据报丢了，后边的收到了累计确认），这时发送方直接重传丢失数据报</p><p><strong>快恢复</strong>：  3ACK后不进行慢开始，而是直接把cnwd置为一半</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417184443.png" alt="TCP拥塞控制流程"></p><p>这就是所谓的<strong>加法增大，乘法减小</strong></p><p>另外<strong>发送窗口</strong>大小还取决于接收方的<strong>通知窗口</strong>，所以<strong>发送窗口</strong>取值=MIN[rnwd,cnwd]</p><hr><p><strong>主动队列管理AQM</strong></p><p>在通信链路中的路由器中，路由器缓存队列一般都是<strong>先进先出</strong>，而一旦发生拥塞后来的分组就会被路由器丢弃，那么发送方就会进行<strong>慢开始</strong>，而由于TCP的<strong>复用</strong>特性（路由器接到的都是IP数据报，同一个IP地址可能包装了不同的端口号），这就会导致一时间整个网络很多的TCP连接都<strong>慢开始</strong>了，这种现象叫<strong>全局同步</strong>，严重影响了传送效率</p><p>而AQM就是解决这个问题的，AQM其中一种方法叫<strong>随机早期检测RED</strong>，其实就是给路由器的缓存设置一个门限值，不让它到满了的时候再丢弃，用一个随机算法在它超过门限时就随机丢弃，这就保证了不是所有TCP都会同时慢开始了。</p><hr><h2 id="8-TCP的运输连接管理"><a href="#8-TCP的运输连接管理" class="headerlink" title="8.TCP的运输连接管理"></a>8.TCP的运输连接管理</h2><p>TCP连接三个阶段：连接建立，数据传送，连接释放</p><p>TCP连接建立采用<strong>客户服务器</strong>方式</p><h3 id="8-1-连接建立"><a href="#8-1-连接建立" class="headerlink" title="8.1 连接建立"></a>8.1 连接建立</h3><p>就是著名的<strong>三次握手</strong>啦</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417190511.png"></p><ul><li>SYN报文不允许携带数据，但是<strong>消耗一个序号</strong></li><li>ACK报文<strong>携带数据的话消耗序号，不携带的话不消耗序号</strong></li></ul><p>为什么最后A一定要在发送一次确认给B呢？</p><p>这是因为假设A发送请求滞留在路由器里导致超时了，这是A以为报文丢了就重发了一个请求与B建立了连接通信后又断开连接。然后这是A的第一个请求报文到达了B，B就会发送确认给A，此时A知道已经连接完了不搭理B，但B还会傻傻的等着A给他发消息，这就浪费了很多资源。</p><hr><h3 id="8-2-连接释放"><a href="#8-2-连接释放" class="headerlink" title="8.2 连接释放"></a>8.2 连接释放</h3><p>四次挥手</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417200113.png"></p><ul><li>FIN不携带数据，但是消耗序号</li><li>ACK不携带数据不消耗序号，携带消耗</li></ul><p>MSL叫做<strong>最长报文段寿命</strong>，为什么time-wait状态后要有2MSL等待时间呢？</p><p>1.因为B再发送完FIN-ACK确认报文后还在等着A发送确认，而A的最后一个确认报文可能会丢失，丢失了B收不到确认就会发送重传，此时如果没有2MSL时间A直接结束了连接，B就会一直发确认，资源浪费</p><p>2.就是上边提到的A重复发送连接请求，第一个请求延迟到达了的情况，有了2MSL就能使本连接持续时间内产生的所有报文段都从网络中消失</p><p><strong>保活计时器</strong>：有时候建立连接后客户端突然挂掉，这是服务器就会一直等着，所以要有这个保活计时器，服务器没收到一次数据就重置保活计时器，时间大约2小时，2小时没有新的数据，服务器就发送一个探测报文段，每75s发送一次，连续10次无反应服务器就关闭连接</p><hr><h3 id="8-3-TCP状态机"><a href="#8-3-TCP状态机" class="headerlink" title="8.3 TCP状态机"></a>8.3 TCP状态机</h3><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200417201411.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–运输层&quot;&gt;&lt;a href=&quot;#计算机网络–运输层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–运输层&quot;&gt;&lt;/a&gt;计算机网络–运输层&lt;/h1&gt;&lt;h2 id=&quot;1-运输层基本概念&quot;&gt;&lt;a href=&quot;#1-运输层基本概念&quot; class</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--网络层</title>
    <link href="http://icecorn.github.io/2022/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2022-02-13T08:53:09.000Z</published>
    <updated>2022-06-29T10:20:16.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–网络层"><a href="#计算机网络–网络层" class="headerlink" title="计算机网络–网络层"></a>计算机网络–网络层</h1><h2 id="1-网络层的两种服务形式"><a href="#1-网络层的两种服务形式" class="headerlink" title="1 网络层的两种服务形式"></a>1 网络层的两种服务形式</h2><p>一种是虚电路服务，另一种是数据报服务，虚电路面向连接的通信方式，在分组交换中建立一条虚电路来预留通信双方所需的一切网络资源，这样在网络层实现可靠传输。数据报服务是采用分组传输方式，网络层向上只提供简单的，无连接的，尽最大努力的不可靠传输。</p><p>本质是是否要在网络层实现可靠传输的问题，由于现在的终端相比于过去的电话设备具有更强的处理能力，所以现在数据报服务成为主流，将可靠传输的实现上移到传输层和用户主机由TCP处理。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414104232.png" alt="两种服务"></p><table><thead><tr><th>对比</th><th>虚电路</th><th>数据报</th></tr></thead><tbody><tr><td>思路</td><td>可靠通信由网络层保证</td><td>可靠通信由用户主机保证</td></tr><tr><td>连接建立</td><td>必须有</td><td>不需要</td></tr><tr><td>终点地址</td><td>仅在建立连接时使用，每个分组使用短的虚电路号</td><td>每个分组都有终点的完整地址</td></tr><tr><td>分组转发</td><td>同一条虚电路分组由同一路由器转发</td><td>每个分组独立选择路由器转发</td></tr><tr><td>结点故障</td><td>所有通过故障结点的虚电路均不能工作</td><td>出故障结点可能会丢失分组，但可以选择其他路由器发送分组</td></tr><tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点不一定按先后顺序</td></tr><tr><td>端到端差错处理及流量控制</td><td>可以由网络负责也可以由用户主机负责</td><td>由用户主机负责</td></tr></tbody></table><hr><h2 id="2-网际协议IP"><a href="#2-网际协议IP" class="headerlink" title="2 网际协议IP"></a>2 网际协议IP</h2><p>IP协议是很重要的协议，它也是一族协议</p><p>除了IP协议外还有与之配套的</p><ul><li>地址解析协议 ARP</li><li>网际控制报文协议 ICMP</li><li>网际组管理协议 IGMP</li></ul><p>要把世界上数以万计的网络连接起来是非常复杂的，并且没有一种网络能够满足所有用户的需求。所以，在网络层使用IP协议构成一个虚拟互连网络，也就是说对于ip协议的网络层，下边的数据链路层和物理层是透明的。</p><hr><h3 id="2-1-分类的IP地址"><a href="#2-1-分类的IP地址" class="headerlink" title="2.1 分类的IP地址"></a>2.1 分类的IP地址</h3><p>IP地址就是给互联网上每一台主机或路由器分配一个全世界范围内唯一的32位的标识符，这里只研究IPv4。</p><p>IP地址的编码方式经历了三个阶段：</p><ul><li>分类的IP地址</li><li>划分子网</li><li>构成超网</li></ul><p>本节研究分类的IP地址，就是将IP地址划分为若干个固定类，每一类地址由两个固定长度字段组成，第一个字段是<strong>网络号</strong>，第二个阻断是<strong>主机号</strong>，全网唯一</p><p>分为以下几类：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414152321.png" alt="IP地址分类"></p><ul><li>其中A B C类都是单播地址（1对1）</li><li>A B C类地址网络号分别为1,2,3字节，且网络号前边类别位分别为0,10,110</li><li>D类地址是多播地址，类别位1110</li><li>E类地址目前不使用</li></ul><p>采用点分十进制来记录IP，如128.0.0.1</p><hr><p>常见的三类IP地址</p><p>对于A B C类IP地址来说，都有几个不能指派的网络号和主机号</p><p>对A类地址，网络号全0不能指派，用来表示“此网络”，全1也不能指派，用来表示“环回测试”；主机号全0表示“本主机”，全1表示“所有主机”</p><p>对B类和C类地址，因为网络号有类别码10和110故不存在全0全1，但去除掉类别码后的网络号也不能设置为全0，表示的意义和A类一样；主机号也不能全0全1</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414160355.png" alt="一般不使用的特殊IP地址"></p><hr><p>IP地址特点：</p><ul><li>由网络号+主机号组成，分配时只分配网络号，主机号由单位自行分配。另一个好处是路由器转发时可以根据网络号转发分组，减少路由表存储空间</li><li>实际上IP地址标志一台主机和一条链路的接口，这意味着路由器两端连接两个网络就必然拥有两个IP地址，而连接两个网络的主机叫做多归属主机</li><li>一个网络通常是指网络号相同的网络，所以用转发器和网桥连接起来的局域网通常认为是一个网络</li><li>IP地址中，所有分配到网络号的网络都是平等的</li></ul><hr><h3 id="2-2-IP地址和硬件地址"><a href="#2-2-IP地址和硬件地址" class="headerlink" title="2.2 IP地址和硬件地址"></a>2.2 IP地址和硬件地址</h3><p>IP地址是逻辑地址，封装在IP数据报首部</p><p>硬件地址是物理地址，存放在适配器ROM中，封装在MAC帧首部</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414162049.png" alt="IP地址和硬件地址"></p><p>这里只要记住通信时网络层，数据链路层同一层级的传输都是透明的，即不需要考虑封装帧，解析帧之类的。可以理解为网络层直接传送IP数据报，数据链路层只传送MAC帧。</p><p>那么有一个问题是路由器转发IP数据报需要包装成MAC帧格式在数据链路层传输，怎么才能知道要添加的MAC地址是多少呢？换句话说怎样通过目的IP得到目的MAC地址？这就需要使用ARP地址解析协议了。</p><hr><h3 id="2-3-地址解析协议ARP"><a href="#2-3-地址解析协议ARP" class="headerlink" title="2.3 地址解析协议ARP"></a>2.3 地址解析协议ARP</h3><p>主要作用就是根据目的IP地址找出目的MAC地址，实现方法是在每一个主机都设有一个ARP高速缓存，里边保存<strong>本局域网</strong>上各主机和路由器的IP地址到MAC地址映射表。主机A要向B发送IP数据报时，先去高速缓存查找B的映射，如果有直接就找到了，没有的话就要运行ARP根据以下步骤找到B的MAC地址。</p><ol><li>ARP进程在本局域网上广播一个ARP请求分组，主要内容是“我的IP地址是xxx。MAC地址是xxx，我想知道IP地址是XXX的主机的硬件地址”</li><li>本局域网上所有主机的ARP进程都收到消息</li><li>主机B发现A要找的人是自己，，向A发送一个响应分组（注意这里是单播） 内容是“我的IP地址是XXX，我的MAC地址是XXX”，同时把A的映射记录在自己的高速缓存中（这一步是为了以后B向A发消息方便），非B的其他主机当然对A发送的请求分组不理睬</li><li>A收到B的响应，将B的映射记录在高速缓存中</li></ol><p>总结就是一个喊话（广播）找人的过程，且找人必须要先自报家门让别人可以响应，喊道谁的名字谁就答应（单播），并且互相都把对方的映射记录了下来，<strong>这就方便了之后再进行通信，否则每次都要广播喊话再响应浪费资源</strong>。</p><p>另外，ARP高速缓存每一份映射都要设置生存时间（如10~20分钟），这是因为适配器可能会故障，比如B的适配器坏了，MAC地址失效了，A用失效的MAC地址也找不到B，留着没用还浪费资源，所以定期删除重新广播建立联系，确保不会有“死掉”的映射浪费资源</p><p>这里有一个最重要的点就是<strong>ARP协议是运行在同一个局域网上</strong>的，如果如下图H1要向不在同一个局域网的H4发送消息，那么首先ARP协议会找到路由器R1的MAC地址，A将MAC帧封装的IP数据报发给R1，接下来交给R1来找下一跳的路由器R2，再次运次ARP协议找到和R1同属一个网络的路由器R2的MAC地址，如此反复进行ARP解析。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414165140.png" alt="ARP解析"></p><p>那么有一个问题是既然最后在链路上传送的帧最终都是要用MAC地址送出，为什么还要用抽象的IP地址而不直接用MAC地址呢？</p><p>这是因为全世界有各种不同的网络和设备，就有不同的硬件地址，要使这些异构网络通信就必须进行复杂的硬件地址转接工作，而使用IP地址将这些差异屏蔽掉，给用户就带来了极大的方便，对于用户来说只要关注IP地址就好了，反正ARP是自动运行的，对于用户是透明的。</p><hr><h3 id="2-4-IP数据报格式"><a href="#2-4-IP数据报格式" class="headerlink" title="2.4 IP数据报格式"></a>2.4 IP数据报格式</h3><p>这里介绍IPv4，在TCP/IP中，各种数据报格式常常以32位（4字节）为单位来描述。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414165738.png" alt="IP数据报格式"></p><p>IP数据报由首部+数据部分组成，首部前一部分固定长度20字节，后边还有一些可选字段（一般不用，用了必须是4字节的倍数）</p><ul><li>版本 占4位，是指IPv4或IPv6</li><li>首部长度  4位，这里必须要注意的是首部长度表示数的单位是32位（4字节，意思是首部长度是数字1实际上代表4字节），最小必须要20字节（也就是十进制5，二进制0101），最大为60字节（因为只占4位，二进制最大1111，相当于十进制15）</li><li>区分服务  8位，一般不用这个字段</li><li>总长度  16位，单位为字节。最大长度是2的16次幂-1 = 65535字节，实际一般不会这么长。这个总长度指的是<strong>首部+数据部分</strong>。这是因为总程度不能大于数据链路层的最大传送单元MTU，一般MTU = 1500，超过就要进行分片处理。<strong>分片后总长度指的是每一片的首部+数据部分</strong>     另外，大部分路由器必须能够接受长度不超过576的IP数据报，至于支不支持1500的根据路由器而定</li><li>标识  16位，这个字段是每产生一个数据报，计数器+1，将这个数写入标识符。<strong>主要作用是分片后的每一片都是这个标识，接受端根据这个标识把每一片拼在一起</strong></li><li>标志  3位  只有前两位有意义，最低位MF（1代表后边还有分片，0标识没了）；中间位DF（1代表不允许分片，0才允许分片）</li><li>片偏移  13位  分片后每一片在原数据中的位置，意思是代表这片是从原数据何处开始的。片偏移以8个字节为偏移单位，每个分片长度一定是8的整数倍，具体结合问题去看</li><li>生存时间  8位  TTL  现在一般代表跳数，最大值为255，意味着跳了255次路由器就会把它扔掉</li><li>协议  8位  指出数据报携带的数据使用哪种协议，上交给谁。常见的有TCP  UDP  ICMP  IGMP  IP等等</li><li>首部校验和  16位  <strong>只检验首部，不包括数据部分</strong> 。这是因为每经过一个路由器可能分片信息之类的会发生变化，需要校验。不用复杂的CRC算法，使用16位反码相加的方法，具体参考书本</li><li>源地址 32位</li><li>目的地址  32位</li></ul><p>首部可变部分：这里可以添加很多字段支持排错，安全等但是一般不用，<strong>只要记住如果使用必须要填充字节变成4的倍数</strong></p><hr><h3 id="2-5-IP层分组转发流程"><a href="#2-5-IP层分组转发流程" class="headerlink" title="2.5 IP层分组转发流程"></a>2.5 IP层分组转发流程</h3><p>在IP层进行分组转发，主要是根据路由器中的转发表来进行转发，本节不介绍路由器中的转发表是怎么生成和更新的，放在后边处理。</p><p>这里要注意的是每个路由器连接几个子网，并且每个子网都有若干台主机，都记录路由转发表的话数据量过多，所以路由器转发是根据网段（网络号）来转发的，并且从源地址到目的地址不是一蹴而就的（不能从开始就知道整条路径），而是进行若干个下一跳达到终点。</p><p>每条路由最主要的两个信息（目的网络地址，下一跳地址）</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414180341.png" alt="路由转发"></p><p>特定路由： 目的网络地址可以设置一个特定的路由器，直接转发到该路由器即可</p><p>默认路由：  是指路由表中没有指定跳到哪个路由器时直接转发给默认路由器进行处理（路由表中记为0.0.0.0）</p><p><strong>分组转发算法：</strong></p><ol><li>从数据报首部提取目的主机的IP地址D，得出网络地址N</li><li>若N是与此路由器直连的某个地址，则<strong>直接交付</strong> ，不需要经过别的路由器（当然这里必须使用ARP协议解析出目的主机MAC地址，封装后传输，但是研究网络层时看成透明的即可）；否则进行<strong>间接交付</strong> ，执行3</li><li>若路由表中有目的地址为D的<strong>特定路由</strong>，则跳到特定路由</li><li>若路由表中有到网络N的路由，进行下一跳即可</li><li>若都没有，而路由表中有一个<strong>默认路由</strong>，则跳到默认路由，都没有执行6</li><li>报告分组转发出错</li></ol><hr><h2 id="3-划分子网和构成超网"><a href="#3-划分子网和构成超网" class="headerlink" title="3 划分子网和构成超网"></a>3 划分子网和构成超网</h2><h3 id="3-1-划分子网"><a href="#3-1-划分子网" class="headerlink" title="3.1 划分子网"></a>3.1 划分子网</h3><p>本质是拥有许多物理网络的单位，将所属的物理网络划分为若干个<strong>子网</strong>，但是对外表现仍然是一个网络。</p><p>IP地址 = 网络号 + 子网号 + 主机号</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414182543.png" alt="划分子网"></p><p>外部路由器还是按网络号145.13.0.0找到R1，R1对内分为145.13.3.0,145.13.7.-，145.13.21.0三个子网进行转发</p><p>划分子网知识把IP地址主机号这部分再划分一下</p><hr><p>子网掩码：由连续的1和连续的0构成的32位数据</p><p>因为IP首部没有标识子网信息的位置，所以使用子网掩码来解决，每一个路由器的路由表中都要配置一项子网掩码。使用时将目的IP地址和子网掩码<strong>按位与</strong>运算得到子网的网络号，再进行传输。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414183430.png" alt="子网掩码运算"></p><p>要注意的是即使没有划分子网，单使用A B C类划分地址也要有默认的子网掩码</p><p><strong>路由器在交换路由表时，要把自己所连接的子网和对应的子网掩码同时发送交换</strong></p><p>划分子网的目的是增加灵活性，看需求分配主机数不同的子网掩码</p><hr><p>划分子网后路由表必须有三项内容： 目的网络地址，子网掩码，下一跳地址</p><p>分组转发比不划分子网的情况多了用子网掩码按位与操作</p><hr><h3 id="3-2-构成超网（无分类编址CIDR）"><a href="#3-2-构成超网（无分类编址CIDR）" class="headerlink" title="3.2 构成超网（无分类编址CIDR）"></a>3.2 构成超网（无分类编址CIDR）</h3><p>为了应对B类地址即将用完，互联网路由表项目急速增长，IPv4地址空间将要耗尽等问题，提出了无分类域间路由选择CIDR</p><p>取消了分类地址和划分子网，采用网络前缀和主机号两级编址方式</p><p>IP地址 = 网络前缀+主机号</p><p>记为形如10.0.0.0/10  或者 00001010 00*（ *后边是主机号）</p><p>代表前10位是网络前缀，后22位是主机号</p><p>CIDR的好处主要有两个：</p><ul><li>增加了IP地址的数量</li><li>形成地址聚合，从而减少路由表中的条目</li></ul><hr><p>最长前缀匹配：</p><p>使用CIDR，路由表的每个项目由<strong>网络前缀</strong>和<strong>下一跳地址</strong>来组成，而由于地址聚合的性质，同一个目的IP地址在路由表中匹配不同的CIDR可能都符合，这时就要选择匹配成功中的最长前缀的下一跳地址来转发（因为短的包含长的，换句换说长的CIDR是短的精细再分配后的）</p><hr><p>二叉线索查找：</p><p>由于采用最长前缀匹配，那么最长采用的方法就是遍历路由表来找到最长前缀匹配，但过于浪费时间和资源，所以诞生了二叉线索查找的方法更快的找出目的前缀，具体算法参考教材</p><hr><h2 id="4-网际控制报文协议ICMP"><a href="#4-网际控制报文协议ICMP" class="headerlink" title="4 网际控制报文协议ICMP"></a>4 网际控制报文协议ICMP</h2><p>ICMP协议是IP协议族中的，不是高层协议，因为ICMP的报文是装在IP数据报中的，作为数据部分。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414212811.png" alt="ICMP报文格式"></p><p>类型字段代表协议类型，代码字段细分类型中的具体情况，<strong>校验和保证ICMP报文（即IP数据报数据部分）正确，还记得IP报文首部校验和只计算IP首部不计算IP数据部分吧</strong></p><hr><h3 id="4-1-ICMP报文种类"><a href="#4-1-ICMP报文种类" class="headerlink" title="4.1 ICMP报文种类"></a>4.1 ICMP报文种类</h3><p>种类有两种： <strong>ICMP差错报告报文</strong>    <strong>ICMP询问报文</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414213302.png" alt="常见ICMP报文类型"></p><p><strong>ICMP差错报告报文</strong>主要有四种：</p><ul><li>终点不可达</li><li>时间超过：还记得IP首部生存时间字段吧，TTL为0时丢弃该IP数据报并向源点发送此条ICMP报文</li><li>参数问题：收到的数据报首部有字段值不正确发送</li><li>改变路由（重定向）：主要是默认路由器找到更优秀的线路时发送</li></ul><p>ICMP差错报文格式如下，将要发送差错的IP数据报的首部和紧跟着的8字节（这里是端口号，为上层TCP UDP服务的）拼上ICMP前8字节（差错类型）组成ICMP差错报文发送</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414214603.png" alt="ICMP差错报文格式"></p><p>不该发送ICMP差错报文情况：</p><ul><li>对ICMP差错报文，不再发送ICMP差错报文</li><li>对第一个分片数据报的后续分片不发送</li><li>对多播的数据报不发送</li><li>对特殊地址127.0.0.0/0.0.0.0（环回测试）不发送</li></ul><hr><p><strong>ICMP询问报文</strong>：</p><ul><li>回送请求和回答：测试目的站状态</li><li>时间戳请求和回答：用于时钟同步和时间测量</li></ul><hr><h3 id="4-2-ICMP应用举例"><a href="#4-2-ICMP应用举例" class="headerlink" title="4.2 ICMP应用举例"></a>4.2 ICMP应用举例</h3><p><strong>分组网间探测PING</strong>，测试主机间连通性，PING使用了ICMP询问报文中的回送请求和回答。<strong>注意PING应用是应用层直接使用网络层ICMP协议的一个典型例子，没有通过运输层的TCP或UDP</strong></p><hr><p>traceroute应用，用来跟踪一个分组从源点到终点的路径</p><p>原理是源主机向终点发送一串<strong>IP数据报</strong>，数据报中封装的是无法交付的<strong>UDP用户数据报</strong>。第一个数据报的<strong>TTL</strong>设为1，第二个设为2等等。这样第一个数据报到达路径上第一个路由器R1，TTL变成0，于是R1将第一个数据报丢弃同时向源站发送<strong>ICMP时间超过报文</strong>。同理我们得到第二个路由器R2发回来的<strong>ICMP时间超时报文</strong>等等。当有一个数据报成功到达终点时，又因为UDP用户数据报无法被接受，于是终点会向源点发送<strong>ICMP终点不可达报文</strong>，这样就得到了源点到终点的整条路径。</p><hr><h2 id="5-互联网路由选择协议"><a href="#5-互联网路由选择协议" class="headerlink" title="5 互联网路由选择协议"></a>5 互联网路由选择协议</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>路由选择协议就是讨论路由表中的路由是怎样得出的</p><p>理想的路由算法：</p><ul><li>算法必须是正确的和完整的</li><li>算法在计算上应简单</li><li>算法应能适应通信量和网络拓扑变化（自适应性，更新路由表）</li><li>稳定性（一段时间内端到端基本保持一条路径）</li><li>公平性（照顾到所有用户）</li><li>能够找出最佳的路径</li></ul><p>从能否适应通信量和网络拓扑变化来划分为两大类：</p><ul><li>静态路由选择策略（非自适应）</li><li>动态路由选择策略</li></ul><hr><p>互联网采用的都是动态的，分布式的路由选择协议</p><p>可以将整个互联网划分成若干个自治系统AS，比如一个大ISP，在这个基础上分为两大类：</p><ul><li>内部网关协议IGP：  研究的是在一个AS中用的什么路由选择协议，主要有RIP和OSPF协议。这种路由选择也叫域内路由选择</li><li>外部网关协议EPG：  研究的是不同AS间主机通信的路由选择，主要用BGP-4协议。这种路由选择也叫域间路由选择</li></ul><p>每个AS内自主决定用什么IGP，而在每个AS的边界都要有一个或者几个路由器不仅运行IGP还要运行EPG实现系统外通信</p><hr><h3 id="5-2-内部网关协议RIP"><a href="#5-2-内部网关协议RIP" class="headerlink" title="5.2 内部网关协议RIP"></a>5.2 内部网关协议RIP</h3><p>RIP是一种<strong>基于距离向量</strong>的路由选择协议，优点是简单</p><p><strong>可以把使用RIP协议的所有路由器想象成一张图，那么距离就是图中顶点到顶点的距离，并且RIP实际上最求的就是最短距离参考，实际上路由表中维护的就是图中每个顶点到其他顶点的最短路径</strong></p><p>RIP将直连的两个路由器距离向量记为1（当然也可以记作0），同时RIP允许一条路径上最多包含15个路由器，因此距离16相当于不可达，这代表<strong>RIP只适用于小型互联网</strong></p><p>不管是RIP还是OSPF都是动态分布式协议，我们要注意三个问题，<strong>和那些路由器交换信息？</strong>  <strong>交换什么信息？</strong>  <strong>什么时候交换信息？</strong></p><p>RIP协议特点：</p><ul><li>只和相邻路由器交换信息</li><li>交换全部的信息，即整个路由表</li><li>按固定时间间隔交换（30s）或者网络拓扑发生变化</li></ul><hr><p>距离向量算法：用相邻路由发来的信息更新自己的路由表，做个例题很容易理解</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414223831.png" alt="R6更新R4发来的信息"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414223952.png" alt="解答"></p><hr><p>RIP报文格式：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414224635.png" alt="RIP报文格式"></p><p>主要掌握RIP协议使用<strong>UDP用户数据报</strong>进行传送</p><p>RIP有一个特点是<strong>好消息传播的快，坏消息传播的慢</strong></p><p>这个主要是指R1连接的网1故障了，却收到R2之前记录的信息，从而在R1R2之间反复横跳，直到都变成16不可达，具体查看教材</p><h3 id="5-3-内部网关协议OSPF"><a href="#5-3-内部网关协议OSPF" class="headerlink" title="5.3 内部网关协议OSPF"></a>5.3 内部网关协议OSPF</h3><p>OSPF（开放最短路径优先，因为使用了dijkstra算法）是使用分布式的<strong>链路状态协议</strong></p><p>特点：</p><ul><li>向AS中<strong>所有路由器</strong>发送信息，采用<strong>洪泛法</strong></li><li>发送的信息是与本路由器<strong>相邻的所有路由器的链路状态</strong>以及<strong>代价</strong>（带宽，时延之类的）</li><li>只有<strong>链路状态发生变化</strong>时，才发送信息</li></ul><p>通过这种方式最终所有路由器都能建立一个<strong>链路状态数据库</strong>，实际上就是<strong>全网的拓扑结构图</strong>，在全网是<strong>一致的</strong>。这样每个路由器根据这个数据库生成自己的路由表</p><p>OSPF可以支持很多的路由器接入，为了方便管理将AS划分成一些小的区域，每个区域内路由器数目最好小于200个</p><hr><p>OSPF<strong>直接用IP数据报传送</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414232323.png" alt="OSPF报文格式"></p><p>其他优点：</p><ul><li>建立路径时允许计算代价而不是单单看最短路径</li><li>负载平衡（几条相同代价的线路平均分配通信量）</li></ul><hr><p>OSPF有五种分组类型：</p><p>问候分组，数据库描述分组，链路请求分组，链路状态更新，链路状态确认</p><p>OSPF规定每隔10s相邻站点发送问候分组确定有没有站点挂掉，超过40s没有回应，则用剩下4种分组进行更新操作，更新时采用<strong>可靠的洪泛法</strong></p><hr><h3 id="5-4-外部网关协议BGP"><a href="#5-4-外部网关协议BGP" class="headerlink" title="5.4 外部网关协议BGP"></a>5.4 外部网关协议BGP</h3><p>解决不同AS之间的路由选择问题</p><p>BGP采用<strong>路径向量</strong>路由选择协议，每个AS至少选择一个<strong>BGP发言人</strong>，一般是边界路由器，但也可以不是</p><p>需要知道的是BGP发言人之间<strong>通过建立TCP连接</strong>来交换信息，在主干网上发出生命，例如BGP1：“到达N1可以经过AS1”</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414234412.png" alt="BGP报文格式"></p><hr><h2 id="6-IPv6"><a href="#6-IPv6" class="headerlink" title="6 IPv6"></a>6 IPv6</h2><p>相比IPv4主要变化：</p><ul><li>更大的地址空间：128位</li><li>首部固定为40字节</li><li>扩展的地址层次结构：空间大，可划分层次多</li><li>灵活的首部格式：IPv6精简了首部字段，并且在数据部分支持各种扩展首部</li><li>改进的选项：允许在数据部分增加控制信息</li><li>允许协议继续扩充</li><li>支持即插即用（自动配置）：IPv6不需要DHCP</li><li>支持资源预分配</li><li>首部改为8字节对齐，IPv4是4字节对齐</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414235650.png" alt="IPv6数据报一般形式"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200414235738.png" alt="IPv6首部字段"></p><ul><li>版本： 4位，指明IPv6</li><li>通信量类：  8位，为了区分不同的IPv6数据报的类别或优先级</li><li>流标号：  20位，主要视为流媒体进行资源预分配</li><li>有效载荷长度：  16位，指明数据报除了基本首部的字节数，最大值65535字节</li><li>下一个首部：  8位，可选字段，标识下一个扩展首部的类型</li><li>跳数限制：  8位，就是TTL改个名</li><li>源地址：  128位</li><li>目的地址：  128位</li></ul><p><strong>数据报途中经过的路由器都不处理扩展首部，大大提高了路由器处理效率</strong></p><hr><p>IPv6数据报的目的地址可以是三种类型：</p><ul><li>单播  同ipv4</li><li>多播  同ipv4，ipv6认为广播时特殊的多播</li><li>任播  终点是一组计算机，但只交付其中的一个，通常是最近的</li></ul><hr><p>IPv6使用<strong>冒号十六进制记法</strong></p><p>68E6:8C33:FFFF:FFFF:0:DF34:2376:FFFF</p><p>中间的0可以压缩： </p><p>FF05::B3</p><p>还可以结合点分十进制法表示之前的ipv4地址：</p><p>::128.0.0.1</p><p>CIDR也可以使用：</p><p>12AB:0:0:CD30::/60</p><hr><p>IPv4向IPv6过渡</p><p>两种方法，<strong>双协议栈</strong>    <strong>隧道技术</strong></p><ul><li>双协议栈：将一部分的主机/路由器同时支持两种协议，不支持的网络通过<strong>转换首部</strong>来实现通信，当然不可避免会丢失一些字段</li><li>隧道技术：原理是在经过ipv4网络时，将ipv6数据报文整个封装进ipv4数据报里，出了ipv4网络再去掉。</li></ul><hr><p>ICMPv6是IPv6支持的控制协议，比ipv4的ICMP更加复杂，并且ICMPv6将ARP和IGMP等协议都合并到一起了</p><hr><h2 id="7-IP多播"><a href="#7-IP多播" class="headerlink" title="7 IP多播"></a>7 IP多播</h2><p>多播就是一对多进行传播，需要支持多播的路由器实现。多播的标识符就是IP地址中的D类地址，用一个D类地址标识一个多播组，是<strong>尽最大努力交付的（即不保证多播组中每个主机都收到消息）</strong>，使用的是IGMP协议，故不产生ICMP差错报文</p><p>分为<strong>硬件多播</strong>和<strong>互联网多播</strong></p><p>需要使用<strong>IGMP协议</strong>（使用IP数据报传送报文，即IGMP报文构成IP数据报的数据部分）和<strong>多播路由选择协议</strong>，具体查看教材</p><hr><h2 id="8-虚拟专用网VPN"><a href="#8-虚拟专用网VPN" class="headerlink" title="8 虚拟专用网VPN"></a>8 虚拟专用网VPN</h2><p>实际上一个部门内不是所有的主机都要接入互联网，给这些主机分配全球唯一IP是一种浪费，这时只给这些主机分配本地地址就可以</p><p>所以规定了一些<strong>专用地址</strong>（可重用地址），这些地址只能作为<strong>本地地址</strong>不能作为<strong>全球地址</strong></p><p>由这些专用地址组成的网络叫做<strong>专用网</strong>，假定一个部门在两地拥有两个专用A和B，AB通信的话就要使用公用的互联网作为专用网间的通信载体，这种专用网叫做<strong>虚拟专用网VPN</strong></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415004337.png" alt="隧道技术实现虚拟专用网"></p><hr><h2 id="9-网络地址转换NAT"><a href="#9-网络地址转换NAT" class="headerlink" title="9 网络地址转换NAT"></a>9 网络地址转换NAT</h2><p>如果专用网内的主机已经分配了本地IP地址，但是又想和互联网连接，这时就要用到网络地址转换NAT了</p><p>方法是将专用网连接到互联网的路由器装上NAT插件，这样的路由器叫<strong>NAT路由器</strong>，它必须有至少一个全球IP地址</p><p>主机A发送数据报时，NAT路由器将数据报中的本地IP地址转换成全球IP地址用于通信，接收到目的服务器响应后将收到数据报中的全球IP地址转换成主机A的本地IP地址</p><p>同一时刻有几个全球IP地址就可以有几个专用网主机与外界通信</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415005114.png" alt="NAT路由器工作原理"></p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200415005331.png" alt="NAT地址转换表"></p><p>也可以加上端口号，这样就可以实现不同端口访问不同的外界服务器。这时一个全球IP地址就可以分配不同的端口给不同专用网内主机使用了。这样的NAT较做<strong>网络地址与端口号转换NAPT</strong></p><hr><h2 id="10-多协议标记交换MPLS"><a href="#10-多协议标记交换MPLS" class="headerlink" title="10 多协议标记交换MPLS"></a>10 多协议标记交换MPLS</h2><p>一种新的面向连接的协议，看书吧QAQ</p><p>特点：</p><ul><li>支持面向连接的服务质量</li><li>支持流量工程，平衡网络负载</li><li>有效地支持虚拟专用网VPN</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–网络层&quot;&gt;&lt;a href=&quot;#计算机网络–网络层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–网络层&quot;&gt;&lt;/a&gt;计算机网络–网络层&lt;/h1&gt;&lt;h2 id=&quot;1-网络层的两种服务形式&quot;&gt;&lt;a href=&quot;#1-网络层的两种服务形式&quot;</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--数据链路层</title>
    <link href="http://icecorn.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2022-02-11T09:25:10.000Z</published>
    <updated>2022-06-29T10:19:25.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–数据链路层"><a href="#计算机网络–数据链路层" class="headerlink" title="计算机网络–数据链路层"></a>计算机网络–数据链路层</h1><p>数据链路层主要研究的是同一个局域网中，数据分组怎样从一台主机传送到另一台主机，不经过路由器的转发。局域网虽然是网络但不放在网络层来研究，因为网络层主要是研究多个网络之间的互连。</p><p>数据链路层使用的信道有两种类型： 点对点信道      广播信道</p><hr><h2 id="1-点对点信道的数据链路层"><a href="#1-点对点信道的数据链路层" class="headerlink" title="1 点对点信道的数据链路层"></a>1 点对点信道的数据链路层</h2><h3 id="1-1-数据链路和帧"><a href="#1-1-数据链路和帧" class="headerlink" title="1.1 数据链路和帧"></a>1.1 数据链路和帧</h3><p><strong>链路</strong>：  链路是从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有其他的交换节点。（物理链路）</p><p><strong>数据链路</strong>：  传送数据时，还需要必要的通信协议来控制数据的传输，吧实现这些协议的硬件和软件加到链路上就构成了数据链路。（逻辑链路）</p><p><strong>帧</strong>：  数据链路层的协议数据单元  PDU</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413164754.png" alt="点对点信道传输模型"></p><p>主机A将IP数据报封装成帧→A发送帧给B→B去掉帧头帧尾取出IP数据报</p><p>另外，对于数据链路层，不需要考虑物理层，即物理层是透明的。</p><hr><h3 id="1-2-三个基本问题"><a href="#1-2-三个基本问题" class="headerlink" title="1.2 三个基本问题"></a>1.2 三个基本问题</h3><p>对于数据链路层有不同种协议，但都要实现三个基本的问题。分别是封装成帧，透明传输，差错检测。</p><ul><li>封装成帧</li></ul><p>将IP数据报加上帧头和帧尾构成帧，首部和尾部的重要作用是<strong>帧定界</strong>。</p><p>为了提高传输效率，帧的数据部分应尽可能大于首部和尾部。</p><p>帧的<strong>数据部分长度上限</strong>——<strong>最大传送单元MTU</strong></p><p>帧定界使用特殊的帧定符：</p><p>帧开始符SOH（start of head） 十六进制编码01（二进制00000001）</p><p>帧结束符EOT（end of transmission） 十六进制编码04（二进制00000100）</p><ul><li>透明传输</li></ul><p>主要目的是防止传输的文件中含有和控制字符SOH或EOT相同的二进制bit导致接收方解析帧错误。</p><p>解决方案是在传输数据中出现的SOH或EOT前面加上一个转义字符ESC（十六进制编码1B，二进制00011011）。如果转义字符也出现在数据当中，那么就在ESC前再加一个ESC，接收端解析时会自动去掉前边一个，这种方法叫做字节填充或字符填充。</p><ul><li>差错检验</li></ul><p>通信链路会因干扰导致比特差错，即0变成1之类。为了保证传输可靠性，我们使用循环冗余检验CRC。</p><p>具体的CRC方法参考课本例题，需要知道的是CRC差错检验仅仅保证无比特差错，但这并不代表实现了可靠传输。因为还有另一类传输差错比如帧丢失，帧重复和帧失序等，由于成本原因这类问题不放在数据链路层解决，而由传输层的TCP协议来解决。<strong>即不要求数据链路层向上提供可靠的传输服务。</strong>这样可以提高通信效率。</p><h2 id="2-点对点ppp协议"><a href="#2-点对点ppp协议" class="headerlink" title="2 点对点ppp协议"></a>2 点对点ppp协议</h2><p>ppp协议用于用户和ISP进行通信时使用的数据链路协议</p><h3 id="2-1-ppp协议要求"><a href="#2-1-ppp协议要求" class="headerlink" title="2.1 ppp协议要求"></a>2.1 ppp协议要求</h3><ol><li>简单：  意味着不可靠，只需要进行CRC校验</li><li>封装成帧：  使用帧定界符</li><li>透明性：  字节填充ESC</li><li>多种网络层协议：  要在同一条物理链路上支持多种网络层协议（如IP和IPX），连接的局域网或路由器同理</li><li>多种类型链路：  电的，光的，交换的或非交换的链路。以太网PPPOE</li><li>差错检测：  CRC</li><li>检测连接状态：  及时检测链路故障的功能</li><li>最大传送单元：  MTU，如果超过最大长度，ppp就将帧丢弃</li><li>网络层地址协商：  提供一种机制使通信的两个网络层实体能够知道彼此的网络层地址，IP地址</li><li>数据压缩协商：  提供一种方法来协商使用数据压缩算法</li><li>PPP协议只支持全双工链路</li></ol><hr><h3 id="2-2-ppp帧格式"><a href="#2-2-ppp帧格式" class="headerlink" title="2.2 ppp帧格式"></a>2.2 ppp帧格式</h3><ul><li>字段意义</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413173932.png" alt="ppp帧格式"></p><p>首尾各一个字节标志字段F（flag，0x7E，01111110），表示帧开始和结束，连续两帧间只需要一个。连续两个标志字段代表空帧，丢弃。</p><p>首部地址字段A规定为FF，控制字段C规定为03，不能改。</p><p>首部协议字段2字节，为0x0021时表示IP数据报，0xC021表示ppp链路控制协议LCP数据，0x8021表示网络层的控制数据。</p><p>尾部FCS是CRC的帧检验序列、</p><p>信息部分最大1500字节</p><hr><ul><li>字节填充</li></ul><p>和上文中字节填充一样，ppp选用转义字符为0x7D(01111101)</p><p>信息字段出现 0x7E 变成 0x7D 0x5E</p><p>信息字段出现 0x7D变成 0x7D 0x5D</p><p>信息字段出现ASCII码的控制字符（即数值小于0x20的字符）如0x23变成 0x7D 0x23</p><hr><ul><li>零比特填充</li></ul><p>另一种实现透明传输的方法，适用于同步传输（一连串的比特连续发送）</p><p>具体方法是发现有5个连续的1，立刻填入一个0，因此可以保证信息字段不会出现连续的6个1（因为7E的二进制01111110），接收端发现连续的5个1时把后边的0去掉即可实现透明传输</p><hr><h3 id="2-3-ppp协议的工作状态"><a href="#2-3-ppp协议的工作状态" class="headerlink" title="2.3 ppp协议的工作状态"></a>2.3 ppp协议的工作状态</h3><p>简单的说就是用户点击拨号上网，此时调制解调器发出载波信号被路由器监听到，建立了一条物理连接。然后用户电脑向ISP发送链路控制协议LCP分组（封装成多个ppp帧），配置了一些参数建立LCP连接。之后进行网络层配置，网络控制协议给用户电脑分配一个临时的IP地址，实现通信。通信结束后，NCP释放网络层连接，收回IP地址，LCP释放数据链路层连接，最后释放物理层连接。</p><p>几个状态：</p><ul><li>链路静止：  这是用户电脑和ISP路由器间无物理连接</li><li>链路建立：  拨号后，建立物理连接后进入该状态，目的建立LCP连接</li><li>鉴别：  建立LCP连接后进入该状态，发送鉴别协议分组等待鉴别</li><li>网络层协议：  ppp协议两端的网络层协商所使用的网络层配置</li><li>链路打开：  此时可以正常通信</li><li>链路终止：出现故障或鉴定错误等问题时跳变的状态</li></ul><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413181656.png" alt="ppp协议状态图"></p><hr><h2 id="3-广播信道的数据链路层"><a href="#3-广播信道的数据链路层" class="headerlink" title="3 广播信道的数据链路层"></a>3 广播信道的数据链路层</h2><h3 id="3-1-局域网的数据链路层"><a href="#3-1-局域网的数据链路层" class="headerlink" title="3.1 局域网的数据链路层"></a>3.1 局域网的数据链路层</h3><p>局域网优点：</p><ul><li>具有广播功能，局域网内主机共享各种硬件软件资源</li><li>便于系统的扩展和逐渐演变，设备位置灵活调整改变</li><li>提高系统的可靠性，可用性，生存性</li></ul><hr><p>按网络拓扑分类：</p><p>星型网，环型网，总线网</p><hr><p>为保证众多用户共享媒体资源，采用两种技术方法</p><ul><li>静态划分信道： 频分，时分，波分，码分复用等等，代价高，不适合局域网使用</li><li>动态媒体接入控制：随机接入（重点），受控接入</li></ul><hr><p>两种以太网标准：</p><p>DIX Ethernet V2标准和IEEE 802.3标准，802.3比较繁琐，所以目前主要使用的还是V2版本</p><hr><p>适配器的作用：</p><p>适配器，即是网络接口卡（NIC   网卡），其与局域网通信是通过双绞线或无线连接等传输媒体（串行传输），与计算机通信则是通过主板上的I/O总线（并行传输）。</p><p>所以网卡中须有缓存的存储芯片来协调接受或发送网络通信内容传达给CPU进行处理。且我们说的MAC地址就在适配器的ROM之中。</p><hr><h3 id="3-2-CSMA-CD协议"><a href="#3-2-CSMA-CD协议" class="headerlink" title="3.2 CSMA/CD协议"></a>3.2 CSMA/CD协议</h3><p>以太网采用随机接入，而一条总线网络同一时间只能传送一条信息，这就会导致会有信息的碰撞，CSMA/CD协议就是为了解决这个问题诞生的。</p><p>协议要点：</p><ul><li>多点接入：  说明是总线型网络，多台主机接入</li><li>载波监听：  检测信道，总线上每个站时刻不停的检测信道</li><li>碰撞检测：  边发送边监听，发送时判断有没有其他站也在发送信息，发生碰撞立刻停止发送</li></ul><p>CSMA/CD协议中的每个站不可能同时发送和接收，故只能半双工通信</p><p>把总线上单程端到端的传播时延记为T，每个站发出一个帧后最长需要经过2T时间可以知道是否发生了碰撞，故2T叫做<strong>争用期</strong>（碰撞窗口）。对于10Mbit/s的以太网，争用期时间为51.2微秒，征用期内可发送512bit，即64字节。也可以说争用期是512bit时间，用bit作为争用期的单位。</p><p>发生碰撞后以太网使用<strong>截断二进制指数退避</strong>选择重传的时机，从离散集合【0,1，…,2的k次幂-1】随机取出一个数r，等待r倍的争用期再进行重传。重传16次仍不成功，丢弃该帧，向上级反映。</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413192126.png" alt="碰撞检测"></p><p><strong>重点：</strong>一种特殊情况是某个站发出了一个很短的帧，在发送完毕前没有检测到碰撞，而实际上该帧发生了碰撞并被丢弃，但发送站不知道碰撞从而不会进行重发。</p><p>为了避免这种状况，以太网规定一个最短帧长64字节，即512bit（争用期时间），不满64字节的帧要补充到64字节，所以如果收到小于64字节的帧即为错误帧，舍弃。</p><p><strong>强化碰撞：</strong>发送站发现碰撞，立刻停止发送，并且发送32bit或48bit的<strong>人为干扰信号</strong>，此举是为了让所有的站都知道现在发生了碰撞。</p><p><strong>帧间最小间隔</strong>：  以太网规定最小间隔为96bit时间。</p><hr><h3 id="3-3-以太网信道利用率"><a href="#3-3-以太网信道利用率" class="headerlink" title="3.3 以太网信道利用率"></a>3.3 以太网信道利用率</h3><p>因为会发生碰撞，所以以太网信道利用率不会是100%，T是bit端到端单程的时间，T1是帧的发送时间</p><p>a = T/T1</p><p>a越小信道利用率越高，故可采用的办法有两个，限制以太网连线的长度，适当增大以太网帧的长度</p><p>信道的利用率S = T/T+T1 = 1/1+a  </p><hr><h3 id="3-4-以太网MAC层"><a href="#3-4-以太网MAC层" class="headerlink" title="3.4 以太网MAC层"></a>3.4 以太网MAC层</h3><p>MAC地址又叫硬件地址或物理地址，是在适配器ROM中存在的具有唯一性的标识。MAC地址格式为6字节（48bit）由IEEE分配的全球唯一标识。</p><p>主机通信时，适配器使用过滤功能，主要有三种情况</p><ul><li>单播帧（一对一）：  收到帧的MAC地址与自己的相同</li><li>广播帧（一对全体）：  发送给本局域网多有站点的帧（全1地址）</li><li>多播帧（一对多）：  发送给局域网上一部分站点，需要多播协议设置，有的适配器不支持</li></ul><p><strong>MAC帧的格式：</strong></p><p>只介绍V2的帧格式：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413194806.png" alt="以太网V2MAC帧格式"></p><p>很简单前边两个字段是目的地址和源地址，类型字段用来标志数据使用的是什么协议，0x0800代表IP数据报。数据是46~1500，46是因为最小长度64-首尾18=46。尾部FCS用于CRC校验。</p><p>另外，帧的前边有8字节的前同步码，是因为MAC帧是异步传输，需要与适配器进行时钟同步，最后一个字节是帧定界符，最后的11告诉适配器接下来的就是有用的MAC帧消息了。还有个问题是，MAC帧没有长度字段怎么确定数据部分是从哪到哪呢？</p><p>这是因为以太网采用了曼彻斯特编码，具有自同步功能，当接受完全部的帧信息后，从后往前数4个字节就可以得到IP数据报的结束位置了，这也是MAC帧不需要结尾帧定界的原因。</p><hr><h3 id="3-5-以太网的扩展"><a href="#3-5-以太网的扩展" class="headerlink" title="3.5 以太网的扩展"></a>3.5 以太网的扩展</h3><ul><li>物理层</li></ul><p>物理层的以太网使用多个集线器，连接成很大范围内的以太网</p><p>好处：</p><ol><li>可以使远端计算机互相连接</li><li>扩大了以太网范围，因为集线器最大距离只有100m</li></ol><p>坏处：</p><p>   1.碰撞域也增大了，大的以太网上同一时间也只能传送一个帧</p><ol start="2"><li>不同速率的适配器不能连接在一起</li></ol><ul><li>数据链路层</li></ul><p>网桥：可以对收到的MAC帧进行转发和过滤，根据网桥中的地址表选择转发和丢弃</p><p>交换机：实质上是一个多接口的网桥，可以使多对主机同时通信，其内部的地址表不用像网桥一样配置而是通过自学习算法自主建立的。最大的优点是每个用户可以使用独自的带宽</p><p>交换机的自学习功能：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413201405.png" alt="以太网交换机"></p><p>A向B发送帧，把自己的MAC地址和接口1写入地址表，然后去地址表查有没有B的地址，有就转发，没有就向除了自己的接口1之外的其他接口<strong>广播</strong>这个帧，这是B发现和自己的MAC地址一样就接受了，C D扔掉。</p><p><strong>中心思想就是谁发帧谁登记，这样慢慢的所有主机都记录在地址表上了</strong></p><p>另外两个交互接空闲接口多的时候广播时容易发生兜圈子现象，这是就要使用生成树协议STP从逻辑上切断某些链路</p><p>总结： 集线器工作在物理层，用它连接后的网络依然还是一个网，需要使用CSMA/CD协议，且集线器只是转发电信号而已。网桥有一定的转发过滤功能，只有两个接口，网桥两边的网络可以理解为分开的网络，是全双工的不会发生碰撞。交换机是加强版的网桥，有很多接口，全双工不会发生碰撞，并且有强大的自学习算法不需要人工配置地址表。换句话说集线器连接的网络整个都是冲突域，网桥是端口两端分别为冲突域，而交换机每个端口是一个冲突域。</p><hr><h3 id="3-6-虚拟局域网"><a href="#3-6-虚拟局域网" class="headerlink" title="3.6 虚拟局域网"></a>3.6 虚拟局域网</h3><p>利用交换机实现的一种逻辑上的局域网</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413202553.png" alt="虚拟局域网"></p><p>支持虚拟局域网的以太网帧扩展：最大长度从1518字节增加到1522字节</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413202656.png" alt="802.1Q帧"></p><hr><h3 id="3-7-使用以太网进行宽带接入"><a href="#3-7-使用以太网进行宽带接入" class="headerlink" title="3.7 使用以太网进行宽带接入"></a>3.7 使用以太网进行宽带接入</h3><p>因为以太网帧格式中没有标识用户名字段的位置，所以采用pppoe（ppp over ethernet）的方法连接互联网。现在的光纤入户宽带接入都是采用这种方式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–数据链路层&quot;&gt;&lt;a href=&quot;#计算机网络–数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–数据链路层&quot;&gt;&lt;/a&gt;计算机网络–数据链路层&lt;/h1&gt;&lt;p&gt;数据链路层主要研究的是同一个局域网中，数据分组怎样从一台主机传送到另</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络--物理层</title>
    <link href="http://icecorn.github.io/2022/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>http://icecorn.github.io/2022/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2022-02-10T06:35:54.000Z</published>
    <updated>2022-06-29T09:48:26.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络–物理层"><a href="#计算机网络–物理层" class="headerlink" title="计算机网络–物理层"></a>计算机网络–物理层</h1><h2 id="1-物理层的基本概念"><a href="#1-物理层的基本概念" class="headerlink" title="1. 物理层的基本概念"></a>1. 物理层的基本概念</h2><p>物理层的主要任务是尽可能的屏蔽掉不同传输媒体和通信手段的差异，使物理层之上的数据链路层使用起来是透明的。物理层的协议又叫做规程。</p><p>物理层的主要任务描述为确定与传输媒体的接口有关的一些特性：</p><ul><li>机械特性：  指明接口所用的接线器的形状，尺寸，引脚数目和排列，固定等。平时常见的各种规格的接插件都有严格的标准化规定。</li><li>电气特性：  指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：  指明某条线上出现的某一电平的电压的意义。</li><li>过程特性：  指明对于不同功能的各种可能事件的的出现顺序。</li></ul><hr><p>物理层协议：点对点，多点连接，广播连接</p><p>传输媒体：  </p><ul><li>导引型传输媒体：架空明线，双绞线，同轴电缆，光缆</li><li>非导引型传输媒体：  各种波段的无线信道，微波，卫星通信</li></ul><h2 id="2-数据通信的基础知识"><a href="#2-数据通信的基础知识" class="headerlink" title="2. 数据通信的基础知识"></a>2. 数据通信的基础知识</h2><h3 id="2-1-通信系统三部分："><a href="#2-1-通信系统三部分：" class="headerlink" title="2.1 通信系统三部分："></a>2.1 通信系统三部分：</h3><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413114817.png" alt="数据通信系统模型"></p><p>源系统： </p><ul><li>源点： 产生要传输数据的设备   如计算机产生数字比特流，又叫源站，信源</li><li>发送器：  比特流要经过发送器编码才能传输，典型发送器就是调制器，计算机使用内置的调制解调器</li></ul><p>目的系统：</p><ul><li>接收器：接受传输系统发出的信号，并转换为终端设备可处理的信号，典型接收器就是解调器，将模拟信号解调还原发送端产生的数字比特流。</li><li>终点：  从接收器获取数字比特流，显示在输出设备上，如屏幕</li></ul><p>传输系统：  可以使简单的传输线，也可以是复杂的网络系统</p><hr><p>消息：  话音，文字，图像，视频</p><p>数据：  运送消息的实体</p><p>信号：  是数据的电气或者电磁表现  分为模拟信号（连续信号）和数字信号（离散信号）两种</p><h3 id="2-2-信道的概念及极限容量"><a href="#2-2-信道的概念及极限容量" class="headerlink" title="2.2 信道的概念及极限容量"></a>2.2 信道的概念及极限容量</h3><p>信道一般表示向某一个方向传送信息的媒体，一条通信电路包括一条发送信道和一条接收信道。</p><table><thead><tr><th>通信方式</th><th>信道</th><th>举例</th></tr></thead><tbody><tr><td>单工通信</td><td>一条</td><td>无线广播</td></tr><tr><td>半双工通信</td><td>一条（正向或反向）</td><td>对讲机</td></tr><tr><td>全双工通信</td><td>两条（正反各一条）</td><td>手机</td></tr></tbody></table><p>文字图像等信源输出的信号属于基带信号，传输不便，故需要进行调制。</p><p>调制方法：</p><ul><li>基带调制：  将数字信号转换为另一种数字信号，变换后仍为基带信号，故称编码。</li><li>载波调制：  将基带信号频率调到较高的频段，转换为模拟信号，能更好的在模拟信道中传输，调制后的信号成为带通信号（仅在一段频率范围内能够通过信道），故也称为带通调制。</li></ul><hr><p>常见编码方式：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413121418.png" alt="编码方式"></p><p>曼彻斯特编码是看周期中心的跳变是正还是负（上下），差分曼彻斯特编码是看位开始边界是否有跳变。曼彻斯特编码有自同步能力，不归零则没有。</p><p>要注意的是以上每种编码的0/1都是人为规定的，所以是可以互换的。</p><hr><p>基本带通调制：</p><p><img src="https://gitee.com/Icecorn/blogimages/raw/master/img/20200413122157.png" alt="带通调制"></p><p>另外还有QAM16为代表的正交振幅调制，利用编码让每一个码元携带更多比特的信息量。</p><hr><p><strong>奈氏准则</strong>：  在任何信道中，码元传输的速率是有上限的，传输速率超过上限，就会出现码间串扰，影响接收端的识别。</p><p><strong>信噪比</strong>：  信号的平均功率和噪声的平均功率之比。记作S/N，度量单位为分贝db</p><p>信噪比（db） = 10 log10（S/N）（db）</p><p><strong>香农公式</strong>： 信道的极限信息传输速率C</p><p>C = W * log2（1+S/N）(bit/s)   </p><p>其中W为信道带宽（单位HZ），S为信道内信号的平均功率，N为信道内高斯噪声功率。</p><p>香农公式表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。</p><hr><h3 id="2-3-信道复用技术"><a href="#2-3-信道复用技术" class="headerlink" title="2.3 信道复用技术"></a>2.3 信道复用技术</h3><ul><li>频分复用 FDM：  所有用户在同一时间内占用不同的带宽资源（频带宽度HZ）。即频带分片</li><li>时分复用 TDM：  所有用户在不同时间占用同样的频带宽度。即时间分片</li><li>统计时分复用 STDM：  一种改进的时分复用，明显提高信道的利用率，又叫异步时分复用。</li><li>波分复用 WDM： 光的频分复用。分光器</li><li>码分复用 CDM：  码分多址CDMA，抗干扰能力强，广泛应用与民用的移动通信中，特别是无线局域网。</li></ul><p>在CDMA中，每一个比特时间再划分为m个短的时间间隔，称为码片，m通常为64或128，实际就是发送64个比特来表示一个逻辑比特0或1，虽然降低了发送效率，但是完成了加密更安全。</p><p>一个站要发送比特1，则发送自己的m bit码片序列，发送0则发送码片序列的二进制补码。CDMA系统给每一个站分配的码片序列不仅必须各不相同而且必须互相正交。这样可以保证每一个码片都与其他站的码片的內积为0。另外码片自身的內积为1，自身与自身补码的內积为-1（-1代表二进制0）。</p><p>现假定一个站X要接受站S发送的数据，则X需要知道S的码片序列，在同一时刻会有很多不同的站发来数据，而此时X使用S的码片序列与接收到的比特流进行內积操作，这样X收到其他非S站的数据內积均是0，只有收到S的比特流內积可以得出1或者-1，即可获得S站发出的逻辑比特流。</p><hr><h3 id="2-4-宽带接入技术"><a href="#2-4-宽带接入技术" class="headerlink" title="2.4 宽带接入技术"></a>2.4 宽带接入技术</h3><ul><li><strong>ADSL 技术</strong>：  非对称数字用户线ADSL技术是用数字技术对现有的模拟电话用户线进行改造。ADSL将0~4khz的低端频谱保留给传统电话使用，4khz以上的高频谱分为上行带宽和下行带宽。</li><li><strong>光纤同轴混合网</strong>：  即HFC网，是一种基于有线电视网的居民宽带。</li><li><strong>FTTx技术</strong>：及光纤入户，光纤入楼。使用分光器使几十户人家共用一根光纤干线。  使用光线路终端OLT把收到的下行数据发往无源的1：N光分路器，然后用广播方式向所有用户端的光网络单元ONU发送。ONU在用户家中即是光纤入户，从ONU到个人电脑一般用以太网连接，使用5类线作为传输媒体。</li></ul><hr><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="3-1-传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？"><a href="#3-1-传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？" class="headerlink" title="3.1 传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？"></a>3.1 传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？</h3><p>不是，传输媒体在物理层下面。由于物理层是体系结构第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号是什么意思，即不知道传输的信号什么时候代表1，什么时候代表0。但物理层由于规定了电气特性，所以能够识别比特流。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络–物理层&quot;&gt;&lt;a href=&quot;#计算机网络–物理层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络–物理层&quot;&gt;&lt;/a&gt;计算机网络–物理层&lt;/h1&gt;&lt;h2 id=&quot;1-物理层的基本概念&quot;&gt;&lt;a href=&quot;#1-物理层的基本概念&quot; cla</summary>
      
    
    
    
    <category term="计算机基础" scheme="http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Markdown常用语法</title>
    <link href="http://icecorn.github.io/2022/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://icecorn.github.io/2022/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</id>
    <published>2022-02-09T11:37:26.000Z</published>
    <updated>2022-06-29T11:19:33.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h1><h2 id="1-Markdown-的基础语法"><a href="#1-Markdown-的基础语法" class="headerlink" title="1.Markdown 的基础语法"></a>1.Markdown 的基础语法</h2><p>本文介绍markdown的基本语法，很容易掌握，一看就会。</p><h3 id="1-1标题"><a href="#1-1标题" class="headerlink" title="1.1标题"></a>1.1标题</h3><p>  这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。Markdown 支持 6 种级别的标题，对应 HTML 标签 h1 ~ h6。l例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># h1</span></span><br><span class="line"><span class="comment">## h2</span></span><br><span class="line"><span class="comment">### h3</span></span><br><span class="line"><span class="comment">#### h4</span></span><br><span class="line"><span class="comment">##### h5</span></span><br><span class="line"><span class="comment">###### h6</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>```<h1 id=""><a href="#" class="headerlink" title=""></a></h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">  和标题之间建议保留一个字符的空格，这是最标准的 Markdown 写法。以上标记效果如下：</span><br><span class="line"></span><br><span class="line">  ![ ](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/h1.png)</span><br><span class="line"></span><br><span class="line">- 除此之外，Markdown 还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">这是一级标题</span><br><span class="line">===</span><br><span class="line">这是二级标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></li></ul><p>以上标记效果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/h2.png" alt=" "></p><p>  这种处理方式在 Github 的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。</p><h3 id="1-2段落及区块引用"><a href="#1-2段落及区块引用" class="headerlink" title="1.2段落及区块引用"></a>1.2段落及区块引用</h3><p>  <strong>需要记住的是，Markdown 其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。</strong>其最终依然会转换为 HTML 标签，因此使用 Markdown 分段非常简单，将你要分段的部分前后至少保留一个空行即可。<br>  而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown 提供了一个特殊符号 &gt; 用于段首进行强调，被强调的文字部分将会高亮显示。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">|&gt; 如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><blockquote><p>如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。</p></blockquote><p>注意：</p><ul><li>聪明的你可能已经发现了，上面显示的引用效果和文章开头引用百度百科的效果是一样的。没错，本站所有文章均采用 Markdown 语法写作，而且大家在评论时也可以采用 Markdown 语法进行评论。这也是为什么第二篇文章写 Markdown 的原因之一了。至于我渲染出来的结果为什么跟你不一样，这是因为我们采用了不同的 CSS 进行调节，这一内容会在后面的教程进行讲解。</li><li>引用完后，一定记得空出一行再写其他东西，不然，你接下来写作的内容也都在引用内容里。</li><li><code>&gt;</code>与你要引用的文字之间一定有<code>一个空格</code>，不然会被认为是普通的文本。<code>&gt;</code>前面不能有文字，必须单独一行才能引用。</li></ul><h3 id="1-3目录"><a href="#1-3目录" class="headerlink" title="1.3目录"></a>1.3目录</h3><p>  Markdown引入目录非常简单，只需要在你想加入目录的地方输入<code>[TOC]</code>就可以了。</p><h3 id="1-4首行缩进方法"><a href="#1-4首行缩进方法" class="headerlink" title="1.4首行缩进方法"></a>1.4首行缩进方法</h3><p>  在用中文写文章时，我们通常习惯段首缩进两个字，但是使用 Markdown 编辑时我们手打空格缩进是不起作用的，因此我们需要通过使用 HTML 中的空格实体来帮助我们实现缩进效果。<br>  为了让本文不那么难以理解，这一部分我只打算讲一个，也是我比较推荐的一个，<code>&amp;emsp</code>;。一个汉字占两个空格大小，所以使用四个空格就可以达到首行缩进两个汉字的效果。而一个 <code>&amp;emsp</code>; 代表两个空格，所以用两个 <code>&amp;emsp</code>; 就代表两个汉字、四个空格了。</p><h3 id="1-5分割线"><a href="#1-5分割线" class="headerlink" title="1.5分割线"></a>1.5分割线</h3><p>  分割线可以由 <code>*</code> 、 <code>-</code> 、 _（星号，减号，底线）这 3 个符号的至少 3 个符号表示，注意至少要 3 个，且不需要连续，有空格也可以。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br><span class="line">* * *</span><br><span class="line">****</span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><hr><hr><hr><hr><hr><h3 id="1-6粗体和斜体"><a href="#1-6粗体和斜体" class="headerlink" title="1.6粗体和斜体"></a>1.6粗体和斜体</h3><p>  Markdown 的粗体和斜体也非常简单，用<code>**</code>或者<code>__</code>包含一段文本就是粗体的语法，用<code>*</code>或者<code>_</code>包含一段文本就是斜体的语法。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*始于颜值、陷于才华、忠于人品*</span><br><span class="line">_始于颜值、陷于才华、忠于人品_</span><br><span class="line">**始于颜值、陷于才华、忠于人品**</span><br><span class="line">__始于颜值、陷于才华、忠于人品__</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><p><em>始于颜值、陷于才华、忠于人品</em><br><em>始于颜值、陷于才华、忠于人品</em><br><strong>始于颜值、陷于才华、忠于人品</strong><br><strong>始于颜值、陷于才华、忠于人品</strong></p><h3 id="1-7删除线"><a href="#1-7删除线" class="headerlink" title="1.7删除线"></a>1.7删除线</h3><p>  用 ~~ 包含一段文本就是删除线了。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~请删除我~~</span><br></pre></td></tr></table></figure><p>其显示结果如下：<del>请删除我</del></p><h3 id="1-8列表"><a href="#1-8列表" class="headerlink" title="1.8列表"></a>1.8列表</h3><p>  Markdown 支持有序列表和无序列表两种形式：无序列表使用<code>*</code>或<code>+</code>或<code>-</code> 标识；有序列表使用数字加 . 标识。例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* 黄瓜</span><br><span class="line">* 玉米</span><br><span class="line">* 茄子</span><br><span class="line"></span><br><span class="line">+ 黄瓜</span><br><span class="line">+ 玉米</span><br><span class="line">+ 茄子</span><br><span class="line"></span><br><span class="line">- 黄瓜</span><br><span class="line">- 玉米</span><br><span class="line">- 茄子</span><br><span class="line"></span><br><span class="line">1. 黄瓜</span><br><span class="line">2. 玉米</span><br><span class="line">3. 茄子</span><br><span class="line"></span><br><span class="line">4. 黄瓜</span><br><span class="line">5. 玉米</span><br><span class="line">6. 茄子</span><br><span class="line"></span><br><span class="line">7. 黄瓜</span><br><span class="line">8. 玉米</span><br><span class="line">9. 茄子</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><ul><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li><li><p>黄瓜</p></li><li><p>玉米</p></li><li><p>茄子</p></li></ul><ol><li>黄瓜</li><li>玉米</li><li>茄子</li><li>黄瓜</li><li>玉米</li><li>茄子</li><li>黄瓜</li><li>玉米</li><li>茄子</li></ol><p>注意：</p><ul><li>有序表不用 1. 2. 3. 这样排下去，可以直接 1. 1. 1. 这样，如果以 3. 开头，如 3. 2. 1. 这样，那么结果是 3. 4. 5.。即以什么数字开头，结果就以什么数字开头，后面的数字可以随便写。如果中间要再插入一项，就不用修改整个列表的序号了。</li><li>如果需要写多级列表，这可以用缩进的办法实现，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 动物</span><br><span class="line">  1. 哺乳动物</span><br><span class="line">  2. 爬行动物</span><br><span class="line">  3. 鸟类</span><br><span class="line">  4. 其他</span><br><span class="line">2. 植物</span><br><span class="line">  5. 被子植物</span><br><span class="line">  6. 裸子植物</span><br><span class="line">  7. 其他</span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><ol><li>动物</li><li>哺乳动物</li><li>爬行动物</li><li>鸟类</li><li>其他</li><li>植物</li><li>被子植物</li><li>裸子植物</li><li>其他</li></ol><h3 id="1-9代办清单-To-do-List"><a href="#1-9代办清单-To-do-List" class="headerlink" title="1.9代办清单 To-do List"></a>1.9代办清单 To-do List</h3><p>  你可以在 Markdown 中编写代办清单，相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- [x] 已完成项目<span class="number">1</span></span><br><span class="line">  - [x] 已完成事项</span><br><span class="line">  - [ ] 代办事项</span><br><span class="line">- [ ] 代办项目<span class="number">2</span></span><br><span class="line">- [ ] 代办项目<span class="number">3</span></span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><ul><li>已完成项目1</li><li>已完成事项</li><li>代办事项</li><li>代办项目2</li><li>代办项目3</li></ul><h3 id="1-10插入链接"><a href="#1-10插入链接" class="headerlink" title="1.10插入链接"></a>1.10插入链接</h3><p>  Markdown 针对链接的处理比较简单，可以使用下面的语法进行标记：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[点击跳转至百度](http://www.baidu.com)</span><br></pre></td></tr></table></figure><p>其显示结果如下：<a href="http://www.baidu.com/">点击跳转至百度</a></p><h2 id="2-Markdown-的高级语法"><a href="#2-Markdown-的高级语法" class="headerlink" title="2.Markdown 的高级语法"></a>2.Markdown 的高级语法</h2><p>  通过上一节的讲解，我们现在已经可以进行简单的纯文字写作了。你可能想问，Markdown 只能处理纯文本吗，那如果我想插入表格，图片，公式等等该怎么办。不要急，Markdown 虽然语法简单，但是功能很强大的，上面的这些需求完全可以满足。</p><h3 id="2-1插入图片"><a href="#2-1插入图片" class="headerlink" title="2.1插入图片"></a>2.1插入图片</h3><h4 id="2-1-1基本用法"><a href="#2-1-1基本用法" class="headerlink" title="2.1.1基本用法"></a>2.1.1基本用法</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![当链接内容不存在时显示的内容](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya2.jpg)</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya2.jpg" alt="当链接内容不存在时显示的内容"></p><p><strong>当链接内容不存在时显示的内容</strong></p><h4 id="2-1-2加入图名和居中对齐"><a href="#2-1-2加入图名和居中对齐" class="headerlink" title="2.1.2加入图名和居中对齐"></a>2.1.2加入图名和居中对齐</h4><p>  Markdown 图片默认左对齐，如果需要居中对齐，就需要采用 HTML 的语法了（注：博主采用了样式表，使图片默认居中，显示图名）。语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align=<span class="string">&quot;center&quot;</span>&gt;&lt;img src=<span class="string">&quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot;</span>&gt;&lt;/br&gt;小雅&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/cdn@1.2/cover/loading3.gif" alt="img"></p><p>小雅</p><h4 id="2-1-3控制图片大小"><a href="#2-1-3控制图片大小" class="headerlink" title="2.1.3控制图片大小"></a>2.1.3控制图片大小</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src = <span class="string">&quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot;</span> width = 50%/&gt;</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg" alt="img"></p><h4 id="2-1-4其他"><a href="#2-1-4其他" class="headerlink" title="2.1.4其他"></a>2.1.4其他</h4><p>  主要采用的是HTML标记语言和CSS样式表来控制图片格式的。本系列教程不涉及这些，如果你有需要，可以点击<a href="https://www.runoob.com/html/html-images.html">HTML图片|菜鸟教程</a>和<a href="https://www.runoob.com/css3/css3-images.html">CSS图片|菜鸟教程</a> 进行学习。</p><h4 id="2-1-5图床"><a href="#2-1-5图床" class="headerlink" title="2.1.5图床"></a>2.1.5图床</h4><p>图床请参考我的<a href="https://www.liuyao-blog.cn/posts/7410.html">Github+Hexo博客搭建小白教程</a> 里面详细的介绍了七牛云图床的使用方法</p><h3 id="2-2表格"><a href="#2-2表格" class="headerlink" title="2.2表格"></a>2.2表格</h3><p>  表格是 Markdown 语法中比较复杂的一个，也是我们平常常用的样式之一，但也不是无迹可寻。</p><h4 id="2-2-1基本用法"><a href="#2-2-1基本用法" class="headerlink" title="2.2.1基本用法"></a>2.2.1基本用法</h4><ul><li>使用 <code>|</code> 来分隔不同的单元格，使用 <code>-</code> 来分隔表头和其他行。</li><li>为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 <code>|</code> 来标记单元格边界。</li><li>在表头下方的分隔线标记中加入<code>:</code>，即可标记下方单元格内容的对齐方式。</li></ul><blockquote><p>:— 代表左对齐<br>:–: 代表居中对齐<br>—: 代表右对齐<br>  例如：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | <span class="variable">$1600</span> |</span><br><span class="line">| col 2 is      | centered      |   <span class="variable">$12</span> |</span><br><span class="line">| zebra stripes | are neat      |    <span class="variable">$1</span> |</span><br></pre></td></tr></table></figure><p>  其显示结果如下：</p><table><thead><tr><th align="left">Tables</th><th align="left">Are</th><th align="left">Cool</th></tr></thead><tbody><tr><td align="left">col 3 is</td><td align="left">right-aligned</td><td align="left">$1600</td></tr><tr><td align="left">col 2 is</td><td align="left">centered</td><td align="left">$12</td></tr><tr><td align="left">zebra stripes</td><td align="left">are neat</td><td align="left">$1</td></tr></tbody></table><p> 例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog | bird | <span class="built_in">cat</span></span><br><span class="line">----|------|----</span><br><span class="line">foo | foo  | foo</span><br><span class="line">bar | bar  | bar</span><br><span class="line">baz | baz  | baz</span><br></pre></td></tr></table></figure><p>其显示结果如下：</p><table><thead><tr><th align="left">dog</th><th align="left">bird</th><th align="left">cat</th></tr></thead><tbody><tr><td align="left">foo</td><td align="left">foo</td><td align="left">foo</td></tr><tr><td align="left">bar</td><td align="left">bar</td><td align="left">bar</td></tr><tr><td align="left">baz</td><td align="left">baz</td><td align="left">baz</td></tr></tbody></table><p>注意：</p><ul><li><code>| 、 - 、:</code> 之间的多余空格会被忽略，不影响布局。</li><li>默认标题栏居中对齐，内容居左对齐。</li><li>-: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。</li><li>内容和 | 之间的多余空格会被忽略，每行第一个<code>|</code>和最后一个<code>|</code>可以省略，<code>-</code>的数量至少有一个。</li></ul><h4 id="2-2-2加入表头"><a href="#2-2-2加入表头" class="headerlink" title="2.2.2加入表头"></a>2.2.2加入表头</h4><p>  Markdown 默认语法里面没有关于表头的，但如果我们需要有表头，那该怎么办呢。通过图片章节的学习，我想你应该知道解决办法了。对，没错，就是 HTML + CSS。点击 HTML 表格 | 菜鸟教程 进行学习。</p><h3 id="2-3插入代码块"><a href="#2-3插入代码块" class="headerlink" title="2.3插入代码块"></a>2.3插入代码块</h3><p>  Markdown 在 IT 圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码，其实我在前面已经多次向大家展示了代码块的最终效果。代码块的语法特别简单，只要把你想要展示的代码片段用 <code>包裹就可以了。行内代码用一个</code> 包裹，如 <code>var y=x^3+2</code><br>  如果要插入一整段代码，就需要至少三个` 进行包裹，如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line">num=[];</span><br><span class="line">i=2</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(2,100):</span><br><span class="line">  j=2</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(2,i):</span><br><span class="line">      <span class="keyword">if</span>(i%j==0):</span><br><span class="line">        <span class="built_in">break</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        num.append(i)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p>  上面的例子就是输出100以内的素数的Python代码。</p><p>注意：</p><ul><li>在代码前面，三个反引号后面填写你插入代码的类型，如 Markdown、Python，这样就可以高亮你的代码块了。</li><li>很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧 esc 键下面的第一个键点击即可。</li></ul><h3 id="2-4数学公式"><a href="#2-4数学公式" class="headerlink" title="2.4数学公式"></a>2.4数学公式</h3><p>  Markdown 可以插入 LaTex 数学公式，这一点我非常的喜欢，因为我是先学习了 LaTex，然后再接触到 Markdown 的，Markdown 几乎支持 LaTex 的所有数学公式语法。至于 LaTex 是什么，我会在后面的文章进行介绍，现在你只要知道 Markdown 适合记一些笔记，写一些文字，但它并不适合写论文，而 LaTex 就是为排版而生的。<br>  下面引用百度百科的介绍：</p><blockquote><p>LaTeX（LATEX，音译 “拉泰赫”）是一种基于 ΤΕΧ 的排版系统，由美国计算机学家莱斯利・兰伯特（Leslie Lamport）在 20 世纪 80 年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由 TeX 所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。</p></blockquote><p>  从百度百科的介绍中我们可以知道，LaTex 非常适合生成复杂的数学公式，理工科的同学看到这点是不是很激动啊。在 Word 里面输入公式，我们一般会用到 Mathtype 这个插件，但每次都需要点很多次才能输入我们想要的公式，这严重影响到了我们的思绪。而 LaTex 只需要记住少量的代码，就可以非常流畅且快速的书写数学公式了。我曾在知乎上面看到过这样的介绍，「1700 页数学笔记火了！全程敲代码，速度飞快易搜索，硬核小哥教你上手 LaTeX+Vim」，虽然有 Vim 这样的编辑器之神（此处多说几句，自从用上Vim后，对其他编辑器的操作方式再也没正眼瞧过，看我文章的应该没有Emacs党吧）加持，但依然从侧面说明了 LaTex 在书写数学公式方面的强大和易用。<br>  由于数学公式语法较多，后面我会在 LaTex 系列专门写一篇文章进行介绍，这里就展示几个例子。</p><ul><li>行内公式：将公式插入到本行内，用一个美元符号包裹公式。</li><li>独行公式：将公式插入到新的一行内，并且居中，用两个美元符号包裹公式。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%欧拉公式</span><br><span class="line">$<span class="variable">$e</span>^&#123;i\pi&#125;+1=0$$</span><br><span class="line">%薛定谔方程</span><br><span class="line">$$</span><br><span class="line">i \hbar \frac&#123;\partial&#125;&#123;\partial t&#125; \Psi(\boldsymbol&#123;r&#125;, t)=-\frac&#123;\hbar^&#123;2&#125;&#125;&#123;2 m&#125; \nabla^&#123;2&#125; \Psi(\boldsymbol&#123;r&#125;, t)+V(\boldsymbol&#123;r&#125;, t) \Psi(\boldsymbol&#123;r&#125;, t)</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h3 id="2-5特殊符号处理"><a href="#2-5特殊符号处理" class="headerlink" title="2.5特殊符号处理"></a>2.5特殊符号处理</h3><p>  Markdown 使用反斜杠 \ 插入语法中用到的特殊符号。在 Markdown 中，主要有以下几种特殊符号需要处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.\ 反斜线</span><br><span class="line">2.` 反引号</span><br><span class="line">3.* 星号</span><br><span class="line">4._ 底线</span><br><span class="line">5.&#123;&#125; 花括号</span><br><span class="line">6.[] 方括号</span><br><span class="line">7.括弧</span><br><span class="line">8.<span class="comment"># 井字号</span></span><br><span class="line">9.+ 加号</span><br><span class="line">10.- 减号</span><br><span class="line">11.. 英文句点</span><br><span class="line">12.! 惊叹号</span><br></pre></td></tr></table></figure><p>1.\ 反斜线<br>2.` 反引号<br>3.* 星号<br>4._ 底线<br>5.{} 花括号<br>6.[] 方括号<br>7.括弧<br>8.# 井字号<br>9.+ 加号<br>10.- 减号<br>11.. 英文句点<br>12.! 惊叹号</p><h2 id="3-Markdown-软件推荐"><a href="#3-Markdown-软件推荐" class="headerlink" title="3.Markdown 软件推荐"></a>3.Markdown 软件推荐</h2><p>  对于初学者，我推荐你使用Typora，Typora 的优点太多了：简洁美观、实时预览、扩展语法、跨平台、免费。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h1&gt;&lt;h2 id=&quot;1-Markdown-的基础语法&quot;&gt;&lt;a href=&quot;#1-Mar</summary>
      
    
    
    
    <category term="工具" scheme="http://icecorn.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="Markdown" scheme="http://icecorn.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
