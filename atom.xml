<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Icecorn</title>
  
  
  <link href="http://icecorn.github.io/atom.xml" rel="self"/>
  
  <link href="http://icecorn.github.io/"/>
  <updated>2022-06-29T15:43:07.948Z</updated>
  <id>http://icecorn.github.io/</id>
  
  <author>
    <name>Icecorn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux高性能服务器|第十四章-多线程编程</title>
    <link href="http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-15T09:25:10.000Z</published>
    <updated>2022-06-29T15:43:07.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-多线程编程"><a href="#第十四章-多线程编程" class="headerlink" title="第十四章 多线程编程"></a>第十四章 多线程编程</h1><p>根据运行环境和调度者身份, 线程可以分为两种<br>内核线程<br>运行在内核空间, 由内核来调度.<br>用户线程<br>运行在用空间, 由线程库来调用</p><p>当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器.</p><p>线程有三种实现方式</p><ul><li>完全在用户空间实现-无需内核支持<br>创建和调度线程无需内核干预, 速度很快.<br>不占用额外的内核资源, 对系统影响较小<br>但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的</li><li>完全由内核调度<br>创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理<br>优缺点正好与上一个相反</li><li>双层调度<br>结合了前两个的优点<br>不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势</li></ul><h2 id="线程的创建和终止"><a href="#线程的创建和终止" class="headerlink" title="线程的创建和终止"></a>线程的创建和终止</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_create</span><span class="params">(<span class="type">pthread_t</span>* thread, <span class="type">const</span> <span class="type">pthread_attr_t</span>* attr, <span class="type">void</span>* (*start_routine)(<span class="type">void</span>*), <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回错误码</span></span><br><span class="line"><span class="comment">// thread 用来唯一的标识一个新线程</span></span><br><span class="line"><span class="comment">// attr用来设置新县城的属性 传递NULL表示默认线程属性</span></span><br><span class="line"><span class="comment">// start_routine 指定新线程运行的函数</span></span><br><span class="line"><span class="comment">// arg指定函数的参数</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="type">void</span>* retval)</span></span>;</span><br><span class="line">用来保证线程安全干净的退出, 线程函数最好结束时调用.</span><br><span class="line">通过`retval`参数向线程的回收者传递其退出信息</span><br><span class="line">执行后不会返回到调用者, 而且永远不会失败</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span>** retval)</span></span></span><br><span class="line"><span class="function">可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.</span></span><br><span class="line"><span class="function">成功时返回0, 失败返回错误码</span></span><br><span class="line"><span class="function">等待其他线程结束</span></span><br><span class="line"><span class="function">thread 线程标识符</span></span><br><span class="line"><span class="function">retval 目标线程的退出返回信息</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">错误码如下</span></span><br><span class="line"><span class="function">`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用</span></span><br><span class="line"><span class="function">`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程</span></span><br><span class="line"><span class="function">`ESRCH`目标线程不存在</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br><span class="line"><span class="function">异常终止一个线程, 即为取消线程</span></span><br><span class="line"><span class="function">成功返回0, 失败返回错误码</span></span><br></pre></td></tr></table></figure><p><strong>线程属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.</span><br><span class="line"><span class="comment">// 启动线程取消</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcancelstart</span><span class="params">(<span class="type">int</span> state, <span class="type">int</span>* oldstate)</span></span></span><br><span class="line"><span class="function">第一个参数</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到</span></span><br><span class="line"><span class="function">这个线程允许被取消</span></span><br><span class="line"><span class="function">第二个参数 返回之前设定的状态</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 设置线程取消类型</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_setcanceltype</span><span class="params">(<span class="type">int</span> type, <span class="type">int</span>* oldtype)</span></span></span><br><span class="line"><span class="function">第一个参数</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消</span></span><br><span class="line"><span class="function">PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数</span></span><br><span class="line"><span class="function">最好使用pthread_testcancel函数设置取消点</span></span><br><span class="line"><span class="function">设置取消类型<span class="params">(如何取消)</span></span></span><br><span class="line"><span class="function">第二个参数</span></span><br><span class="line"><span class="function">原来的取消类型</span></span><br></pre></td></tr></table></figure><p><strong>设置脱离线程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化线程属性对象</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span>;</span><br><span class="line"><span class="comment">// 销毁线程属性对象, 直到再次初始化前都不能用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_destory</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 参数取值</span></span></span><br><span class="line"><span class="function"><span class="comment">// -PTHREAD_CREATE_JOINABLE 线程可回收</span></span></span><br><span class="line"><span class="function"><span class="comment">// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span></span>;</span><br><span class="line"><span class="comment">// 可以直接设置为脱离线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span></span></span><br></pre></td></tr></table></figure><h2 id="线程同步机制的使用场景"><a href="#线程同步机制的使用场景" class="headerlink" title="线程同步机制的使用场景"></a>线程同步机制的使用场景</h2><p>POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值<br>两份计数值容易出错</p><p>互斥锁-对临界资源的独占式访问</p><p>条件变量-等待某个条件满足<br>当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程</p><p>读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写</p><p>自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景</p><h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>多线程也必须考虑线程同步的问题.<br>虽然<code>pthread_join()</code>可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求<br>比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;semaphore&gt;</span></span></span><br><span class="line"><span class="comment">// 用于初始化一个未命名的信号量.</span></span><br><span class="line"><span class="comment">// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享</span></span><br><span class="line"><span class="comment">// value指定参数的初始值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_init</span><span class="params">(<span class="type">sem_t</span>* sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁信号量, 释放其占用的系统资源</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_destory</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_wait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errno</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 原子操作将信号量的值 +1</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sem_post</span><span class="params">(<span class="type">sem_t</span>* sem)</span></span></span><br></pre></td></tr></table></figure><p>初始化已经存在的信号量会导致无法预期的结果</p><p>销毁正被其他线程等待的信号量, 将会导致无法预期的结果</p><p>例子如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kNumberMax = <span class="number">10</span>;</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">number</span><span class="params">(kNumberMax)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kThreadNum = <span class="number">10</span>;</span><br><span class="line"><span class="type">sem_t</span> sems[kThreadNum];</span><br><span class="line"><span class="type">pthread_t</span> threads[kThreadNum];</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> kPrintTime = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">t</span><span class="params">(<span class="type">void</span> *no)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> start_sub = *<span class="built_in">static_cast</span>&lt;<span class="type">int</span>*&gt;(no);</span><br><span class="line">    <span class="type">int</span> sub =start_sub;</span><br><span class="line">    <span class="type">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(++time &lt;= kPrintTime)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 锁住本线程 释放下一个线程</span></span><br><span class="line">        <span class="built_in">sem_wait</span>(&amp;sems[start_sub]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, number[sub]);</span><br><span class="line">        <span class="built_in">sem_post</span>(&amp;sems[(start_sub + <span class="number">1</span>) % kThreadNum]);</span><br><span class="line"><span class="comment">// 计算下一次要打印的下标</span></span><br><span class="line">        sub = (sub + kThreadNum) % kNumberMax;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::<span class="built_in">iota</span>(number.<span class="built_in">begin</span>(), number.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">sem_init</span>(&amp;sems[<span class="number">0</span>], <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; kThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_init</span>(&amp;sems[i], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; kThreadNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;threads[i], <span class="literal">nullptr</span>, t, &amp;number[i]);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 等待最后一个线程结束</span></span><br><span class="line">    <span class="built_in">pthread_join</span>(threads[kThreadNum - <span class="number">1</span>], <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kThreadNum个进程依次打印<code>[0, kNumberMax)</code><br>每个进程打印kPrintTime次<br>最后一个进程打印完后主线程才能结束</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化互斥锁</span></span><br><span class="line"><span class="comment">// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex, <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *mutexattr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁目标互斥锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_destory</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对普通锁加锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>销毁一个已经加锁的互斥锁 会发生不可预期的后果<br>也可使使用宏<code>PTHREAD_MUTEX_INITIALIZER</code>来初始化一个互斥锁<br>pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;</p><p><strong>互斥锁属性设置</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_init</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_destory</span><span class="params">(<span class="type">pthread_mutexattr_t</span> *attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTHREAD_PROCESS_SHARED 跨进程共享</span></span><br><span class="line"><span class="comment">// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_getpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_setpshared</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> pshared)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_NORMAL 普通锁 默认类型</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_ERRORCHECK 检错锁</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_RECURSVE 嵌套锁</span></span><br><span class="line"><span class="comment">// PTHREAD_MUTEX_DEFAULT 默认锁</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_gettype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_mutexattr_settype</span><span class="params">(<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *attr, <span class="type">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>PTHREAD_MUTEX_NORMAL<br>一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平<br>A线程对一个<code>已经加锁</code>的普通锁<code>再次加锁(也是A线程)</code>-同一线程在解锁前再次加锁引发死锁<br>对一个已经<code>被其他线程加锁</code>的普通锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的普通锁–解锁-不可预期后果</p><p>PTHREAD_MUTEX_ERRORCHECK<br>线程对<code>已经加锁</code>的检错锁<code>再次加锁</code>–加锁-加锁操作返回EDEADLK<br>对一个已经<code>被其他线程加锁</code>的检错锁<code>解锁</code>, 或者<code>再次解锁已经解锁</code>的检错锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_RECURSVE<br>允许一个线程在释放锁前多次加锁 而不发生死锁.<br>如果<code>其他线程</code>要获得这个锁, 则<code>当前锁拥有者</code>必须执行相应次数的解锁操作–加锁<br>对于<code>已经被其他进程</code>加锁的嵌套锁解锁, 或者对<code>已经解锁</code>的再次解锁–解锁-返回EPERM</p><p>PTHREAD_MUTEX_DEFAULT<br>这种锁的实现可能为上面三种之一<br>对已经加锁的默认锁再次加锁<br>对被其他线程加锁的默认锁解锁<br>再次解锁已经解锁的默认锁<br>都将会发生不可预料后果</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">t</span><span class="params">(<span class="type">void</span> *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count);</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> thread[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;thread[i], <span class="literal">nullptr</span>, t, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">const</span> pthread_condattr *cond_attr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个正在被等待的条件变量 将会失败并返回EBUSY</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cont_destory</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播式的唤醒所有等待目标条件变量的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cont_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒一个等待目标条件变量的线程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待目标条件变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond, <span class="type">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_cond_t cond = PTHREAD_COND_INITIALIZER;<br>将各个字段初始化为0</p><p>pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁<br>掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.<br>函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁</p><p>从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值<br>也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,<br>将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上</p><p>例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="type">pthread_cond_t</span> cond;</span><br><span class="line"><span class="type">int</span> good = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> produce_count = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> consume_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Producer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(produce_count &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        good++;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        produce_count++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;produce a good\n&quot;</span>);</span><br><span class="line"><span class="comment">// 通知一个线程</span></span><br><span class="line">        <span class="built_in">pthread_cond_signal</span>(&amp;cond);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">Consumer</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (consume_count &lt; <span class="number">13</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">// 传入前需要加锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span> (good &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            good--;</span><br><span class="line">            consume_count++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;consume a good, reset %d\n&quot;</span>, good);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;good is 0\n&quot;</span>);</span><br><span class="line">            <span class="comment">// wait pthread_cond_signal</span></span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">usleep</span>(<span class="number">500</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line">    cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line">    <span class="type">pthread_t</span> producer, consumer;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;consumer, <span class="literal">nullptr</span>, Consumer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;producer, <span class="literal">nullptr</span>, Producer, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_join</span>(consumer, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_cond_destroy</span>(&amp;cond);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><h2 id="线程同步包装类-多线程环境"><a href="#线程同步包装类-多线程环境" class="headerlink" title="线程同步包装类-多线程环境"></a>线程同步包装类-多线程环境</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sem</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sem_init</span>(&amp;sem_, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Sem</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sem_destroy</span>(&amp;sem_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_wait</span>(&amp;sem_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Post</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sem_post</span>(&amp;sem_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">sem_t</span> sem_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Mutex</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cond</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_mutex_init</span>(&amp;mutex_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">pthread_cond_init</span>(&amp;cond_, <span class="literal">nullptr</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里我一开始没有想到..</span></span><br><span class="line">            <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">exception</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cond</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_cond_destroy</span>(&amp;cond_);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Wait</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex_);</span><br><span class="line">        ret = <span class="built_in">pthread_cond_wait</span>(&amp;cond_, &amp;mutex_);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex_);</span><br><span class="line">        <span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pthread_cond_signal</span>(&amp;cond_) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_cond_t</span> cond_;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> mutex_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件</p><p>多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程<br>子进程只有一个线程-调用fork线程的完美复制</p><p>但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但<code>不是由</code>调用fork线程<br>锁住的, 此时<code>子进程</code>再次对这个互斥锁<code>执行加锁</code>操作将会<code>死锁</code>.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> mutex;</span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">another</span><span class="params">(<span class="type">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;in child thread, lock the mutex\n&quot;</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 解锁后 Prepare才能加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">pthread_exit</span>(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个函数在fork创建子进程前被调用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行</span></span><br><span class="line">    <span class="comment">// 这个函数执行完毕前fork不会创建子进程</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fork创建线程后 返回前 会在子进程和父进程中执行这个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Infork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="type">pthread_t</span> id;</span><br><span class="line">    <span class="built_in">pthread_create</span>(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// pthread_atfork(Prepare, Infork, Infork);</span></span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;emmm????\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_join</span>(id, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process, want to get the lock\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i cann&#x27;t run to here, opps....\n&quot;</span>);</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;mutex);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait start\n&quot;</span>);</span><br><span class="line">        <span class="built_in">wait</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;wait over\n&quot;</span>); <span class="comment">// 没有打印 因为子进程不会终止</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pthread_join</span>(id, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">pthread_mutex_destroy</span>(&amp;mutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// $ in child thread, lock the mutex</span></span><br><span class="line"><span class="comment">// $ wait start</span></span><br><span class="line"><span class="comment">// $ child process, want to get the lock</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $ in child thread, lock the mutex</span></span><br><span class="line"><span class="comment">// $ wait start</span></span><br><span class="line"><span class="comment">// $ child process, want to get the lock</span></span><br><span class="line"><span class="comment">// $ i cann&#x27;t run to here, opps....</span></span><br><span class="line"><span class="comment">// $ wait over</span></span><br></pre></td></tr></table></figure><p>原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pthread_atfork</span> <span class="params">(<span class="type">void</span> (*__prepare) (<span class="type">void</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> (*__parent) (<span class="type">void</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">void</span> (*__child) (<span class="type">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>第一个句柄 在fork创建子进程前执行<br>第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行<br>第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十四章-多线程编程&quot;&gt;&lt;a href=&quot;#第十四章-多线程编程&quot; class=&quot;headerlink&quot; title=&quot;第十四章 多线程编程&quot;&gt;&lt;/a&gt;第十四章 多线程编程&lt;/h1&gt;&lt;p&gt;根据运行环境和调度者身份, 线程可以分为两种&lt;br&gt;内核线程&lt;br&gt;运行在内</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    <category term="系统编程" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="多线程" scheme="http://icecorn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第十三章-多进程编程</title>
    <link href="http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-15T09:25:10.000Z</published>
    <updated>2022-06-29T15:41:00.095Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章多进程编程"><a href="#第十三章多进程编程" class="headerlink" title="第十三章多进程编程"></a>第十三章多进程编程</h1><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 声明这个是外部函数或外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>** environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻</span></span><br><span class="line"><span class="comment">// arg-接受可变参数 和 argv用于向新的程序传递参数数组</span></span><br><span class="line"><span class="comment">// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量</span></span><br><span class="line"><span class="comment">// exec函数是不返回的, 除非出错</span></span><br><span class="line"><span class="comment">// 如果未报错则源程序被新的程序完全替换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">const</span> <span class="type">char</span>* arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">const</span> <span class="type">char</span>* arg, ..., <span class="type">char</span>* <span class="type">const</span> envp[])</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* file, <span class="type">char</span>* <span class="type">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* path, <span class="type">char</span>* <span class="type">const</span> argv[], <span class="type">char</span>* <span class="type">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><h2 id="fork系统调用-进程的创建"><a href="#fork系统调用-进程的创建" class="headerlink" title="fork系统调用-进程的创建"></a>fork系统调用-进程的创建</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0</span></span><br><span class="line"><span class="comment">// 次返回值用于区分是父进程还是子进程</span></span><br><span class="line"><span class="comment">// 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(viod)</span></span>;</span><br></pre></td></tr></table></figure><p>fork系统调用<br>fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项<br>新的进程表项有很多的属性和原进程相同</p><ul><li>堆指针</li><li>栈指针</li><li>标志寄存器的值</li><li>子进程代码与父进程完全相同</li><li>同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据)</li><li>创建子进程后, <em>父进程打开的文件描述符默认在子进程中也是打开的</em> <code>文件描述符的引用计数</code>, <code>父进程的用户根目录, 当前工作目录等变量的引用计数</code> 均加1</li></ul><p>也存在不同的项目</p><ul><li>该进程的PPID(标识父进程)被设置成原进程的PID,  </li><li><code>信号位图被清除</code>(原进程设置的信号处理函数对新进程无效)</li></ul><p>(引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。)</p><p>The child process is an exact duplicate of the parent process except<br>for the following points:</p><ul><li><p>The child has its own unique process ID, and this PID does not<br> match the ID of any existing process group (setpgid(2)) or<br> session. 子进程拥有自己唯一的进程ID, 不与其他相同</p></li><li><p>The child’s parent process ID is the same as the parent’s process<br> ID. 子进程的父进程ID PPID 与父进程ID PID相同</p></li><li><p>The child does not inherit its parent’s memory locks (mlock(2),<br> mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区)</p></li><li><p>Process resource utilizations (getrusage(2)) and CPU time counters<br> (times(2)) are reset to zero in the child.<br> 进程资源使用和CPU时间计数器在子进程中重置为0</p></li><li><p>The child’s set of pending signals is initially empty<br> (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置</p></li><li><p>The child does not inherit semaphore adjustments from its parent<br> (semop(2)). 不会继承semadj</p></li><li><p>The child does not inherit process-associated record locks from<br> its parent (fcntl(2)).  (On the other hand, it does inherit<br> fcntl(2) open file description locks and flock(2) locks from its<br> parent.)</p></li><li><p>The child does not inherit timers from its parent (setitimer(2),<br> alarm(2), timer_create(2)). 不会继承定时器</p></li><li><p>The child does not inherit outstanding asynchronous I/O operations<br> from its parent (aio_read(3), aio_write(3)), nor does it inherit<br> any asynchronous I/O contexts from its parent (see io_setup(2)).</p></li></ul><h2 id="处理僵尸进程-进程的管理"><a href="#处理僵尸进程-进程的管理" class="headerlink" title="处理僵尸进程-进程的管理"></a>处理僵尸进程-进程的管理</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">wait</span><span class="params">(<span class="type">int</span>* stat_loc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)</span></span><br><span class="line"><span class="comment">// options函数取值WNOHANG-waitpid立即返回</span></span><br><span class="line"><span class="comment">// 如果目标子进程正常退出, 则返回子进程的pid</span></span><br><span class="line"><span class="comment">// 如果还没有结束或意外终止, 则立即返回0</span></span><br><span class="line"><span class="comment">// 调用失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span>* stat_loc, <span class="type">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">WIFEXITED</span>(stat_val); <span class="comment">// 子进程正常结束, 返回一个非0</span></span><br><span class="line"><span class="built_in">WEXITSTATUS</span>(stat_val); <span class="comment">// 如果WIFEXITED 非0, 它返回子进程的退出码</span></span><br><span class="line"><span class="built_in">WIFSIGNALED</span>(stat_val);<span class="comment">// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值</span></span><br><span class="line"><span class="built_in">WTERMSIG</span>(stat_val);<span class="comment">// 如果WIFSIGNALED非0 返回一个信号值</span></span><br><span class="line"><span class="built_in">WIFSTOPPED</span>(stat_val);<span class="comment">// 如果子进程意外终止, 它返回一个非0值</span></span><br><span class="line"><span class="built_in">WSTOPSIG</span>(stat_val);<span class="comment">// 如果WIFSTOPED非0, 它返回一个信号值</span></span><br></pre></td></tr></table></figure><p>对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询</p><ul><li>在<code>子进程结束运行之后, 父进程读取其退出状态前</code>, 我们称该子进程处于<code>僵尸态</code></li><li>另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) <code>父进程结束运行之后, 子进程退出之前</code>, 处于<code>僵尸态</code></li></ul><p>以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源.</p><p>waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.<br>SIGCHLD信号- 子进程结束后将会给父进程发送此信号</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">handle_child</span><span class="params">(<span class="type">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">pid_t</span> pid;</span><br><span class="line"><span class="type">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 善后处理emmmm</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量-进程的锁"><a href="#信号量-进程的锁" class="headerlink" title="信号量-进程的锁"></a>信号量-进程的锁</h2><p><em>信号量原语</em><br>只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.<br>假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为</p><ul><li>P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行</li><li>V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BF%9D%E6%8A%A4%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E6%AE%B5.png"></li></ul><p><strong>总结PV使用方法</strong></p><p>使用<code>semget</code>获取到唯一的标识.<br>使用<code>semctl</code>的<code>SETVAL</code>传入初始化val的<code>sem_un</code>联合体.来初始化val<br>调用<code>semop</code> 传入唯一标识, <code>sem_op=-1</code>执行P(锁)操作<code>sem_op=1</code>执行V(开锁)操作<br>开关锁通过当<code>sem_op=-1,semval=0 </code><br>且未指定<code>IPC_NOWAIT</code><br>等待<code>semval</code>被<code>sem_op=1</code>改为<code>semval=1</code></p><p><strong>创建信号量</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semeget 系统调用</span></span><br><span class="line"><span class="comment">// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集</span></span><br><span class="line"><span class="comment">// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取</span></span><br><span class="line"><span class="comment">// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1</span></span><br><span class="line"><span class="comment">// sem_flags指定一组标志, 来控制权限</span></span><br><span class="line"><span class="comment">// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错</span></span><br><span class="line"><span class="comment">// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST</span></span><br><span class="line"><span class="comment">// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> num_sems, <span class="type">int</span> sem_flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sem_id = <span class="built_in">semget</span>((<span class="type">key_t</span>)<span class="number">1234</span>, <span class="number">1</span>, <span class="number">0666</span> | IPC_CREAT);</span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// semctl 系统调用</span></span><br><span class="line"><span class="comment">// sem_id 参数是由semget返回的信号量集标识符</span></span><br><span class="line"><span class="comment">// sen_num指定被操作的信号量在信号集中的编号</span></span><br><span class="line"><span class="comment">// command指定命令, 可以追加命令所需的参数, 不过有推荐格式</span></span><br><span class="line"><span class="comment">// 成功返回对应command的参数, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semctl</span><span class="params">(<span class="type">int</span> sem_id, <span class="type">int</span> sem_num, <span class="type">int</span> command, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个参数 竟然需要手动声明...</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span> *buf;    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span>  *array;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">seminfo</span>  *__buf;  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">(Linux-specific) */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 初始化信号量</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> sem_union;</span><br><span class="line">sem_union.val = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这里可以直接第三个参数传入1(val)</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, SETVAL, sem_union) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除信号量</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">semun</span> sem_union&#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">semctl</span>(sem_id, <span class="number">0</span>, IPC_RMID, sem_union) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>与semop信号量关联的一些重要的内核变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semval; <span class="comment">// 信号量的值</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semzcnt; <span class="comment">// 等待信号量值变为0的进程数量</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> semncnt<span class="comment">// 等待信号量值增加的进程数量</span></span><br><span class="line"><span class="type">pid_t</span> sempid; <span class="comment">// 最后一次执行semop操作的进程ID</span></span><br></pre></td></tr></table></figure><p>操作信号量, 实际上就是对上面的内核变量操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.</span></span><br><span class="line"><span class="comment">// sem_ops 参数指向一个sembuf结构体类型的数组</span></span><br><span class="line"><span class="comment">// num_sem_ops 说明操作数组中哪个信号量</span></span><br><span class="line"><span class="comment">// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">semop</span><span class="params">(<span class="type">int</span> sem_id, <span class="keyword">struct</span> sembuf* sem_ops, <span class="type">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op &lt; 0 期望获得信号量</span></span><br><span class="line"><span class="comment">// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限</span></span><br><span class="line"><span class="comment">// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN</span></span><br><span class="line"><span class="comment">// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒</span></span><br><span class="line"><span class="comment">// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj</span></span><br><span class="line"><span class="comment">// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)</span></span><br><span class="line"><span class="comment">// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">P</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>; <span class="comment">// 信号量编号 第几个信号量 一般都是第0个</span></span><br><span class="line">    sem_b.sem_op = <span class="number">-1</span>; <span class="comment">// P</span></span><br><span class="line"><span class="comment">// IPC_NOWAIT 无论信号量操作是否成功, 都立即返回</span></span><br><span class="line"><span class="comment">// SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// sem_op &gt; 0 </span></span><br><span class="line"><span class="comment">// semval+=sem_op , 要求调用进程对被操作的信号量集有写权限</span></span><br><span class="line"><span class="comment">// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">V</span><span class="params">(<span class="type">int</span> sem_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sembuf</span> sem_b;</span><br><span class="line">    sem_b.sem_num = <span class="number">0</span>;</span><br><span class="line">    sem_b.sem_op = <span class="number">1</span>; <span class="comment">// V</span></span><br><span class="line">    sem_b.sem_flg = SEM_UNDO;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">semop</span>(sem_id, &amp;sem_b, <span class="number">1</span>) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -- sem_op = 0</span></span><br><span class="line"><span class="comment">// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限</span></span><br><span class="line"><span class="comment">// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0</span></span><br><span class="line"><span class="comment">// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN</span></span><br><span class="line"><span class="comment">// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生</span></span><br><span class="line"><span class="comment">// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1</span></span><br><span class="line"><span class="comment">// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM</span></span><br><span class="line"><span class="comment">// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>semget成功时返回一个与之关联的内核结构体semid_ds</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">semid_ds</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span> sem_perm;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> sem_nsems; <span class="comment">// 被设置为num_sems</span></span><br><span class="line"><span class="type">time_t</span> sem_otime; <span class="comment">// 被设置为0</span></span><br><span class="line"><span class="type">time_t</span> sem_ctime; <span class="comment">// 被设置为当前的系统时间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用来描述权限</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uid_t</span> uid; <span class="comment">// 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">gid_t</span> gid; <span class="comment">// 所有者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">uid_t</span> cuid; <span class="comment">// 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">gid_t</span> cgid; <span class="comment">// 创建者的有效组ID, 被semget设置为调用进程的有效用户ID</span></span><br><span class="line"><span class="type">mode_t</span> mode;<span class="comment">// 访问权限, 背着只为sem_flags参数的最低9位.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存-进程间通信"><a href="#共享内存-进程间通信" class="headerlink" title="共享内存-进程间通信"></a>共享内存-进程间通信</h2><p><strong>最高效的IPC(进程间通信)机制</strong><br>需要自己同步进程对其的访问, 否则会产生竞态条件</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// key</span></span><br><span class="line"><span class="comment">// 与semget相同 标识一段全局唯一的共享内存</span></span><br><span class="line"><span class="comment">// size 内存区域大小 单位字节</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// IPC_CREAT 存不存在都创建新的共享内存</span></span><br><span class="line"><span class="comment">// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错</span></span><br><span class="line"><span class="comment">// SHM_HUGETLB 系统将使用&quot;大页面&quot;来为共享内存分配空间</span></span><br><span class="line"><span class="comment">// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足</span></span><br><span class="line"><span class="comment">// -在执行写操作的时候将会触发`SIGSEGV`信号</span></span><br><span class="line"><span class="comment">// -成功返回唯一标识, 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shm_id </span></span><br><span class="line"><span class="comment">// shmget返回的唯一标识</span></span><br><span class="line"><span class="comment">// shm_addr </span></span><br><span class="line"><span class="comment">// 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响</span></span><br><span class="line"><span class="comment">// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处</span></span><br><span class="line"><span class="comment">// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*</span></span><br><span class="line"><span class="comment">// shmflg</span></span><br><span class="line"><span class="comment">// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式</span></span><br><span class="line"><span class="comment">// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联</span></span><br><span class="line"><span class="comment">// SHM_EXEC 有执行权限</span></span><br><span class="line"><span class="comment">// 成功返回关联到的地址, 失败返回 (void*)-1 errno</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">shmat</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">const</span> <span class="type">void</span>* shm_addr, <span class="type">int</span> shmflg)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容</span></span></span><br><span class="line"><span class="function"><span class="comment">// -shm_nattach +1</span></span></span><br><span class="line"><span class="function"><span class="comment">// -更新 shm_lpid</span></span></span><br><span class="line"><span class="function"><span class="comment">// -shm_atime设置为当前时间</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将共享内存从进程地址空间中分离</span></span><br><span class="line"><span class="comment">// 成功后</span></span><br><span class="line"><span class="comment">// -shm_nattach -1</span></span><br><span class="line"><span class="comment">// -更新 shm_lpid和shm_dtime设置为当前时间</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1 errno</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* shm_addr)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">shm_ctl</span><span class="params">(<span class="type">int</span> shm_id, <span class="type">int</span> command, <span class="keyword">struct</span> shmid_ds* buf)</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/shmctl.png"></p><hr><p>shmget 同时会创建对应的<code>shmid_ds</code>结构体</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">shmid_ds</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ipc_perm</span> shm_per; <span class="comment">// 权限相关</span></span><br><span class="line"><span class="type">size_t</span> shm_segsz; <span class="comment">// 共享内存大小 单位字节size</span></span><br><span class="line"><span class="type">__time_t</span> shm_atime; <span class="comment">// 对这段内存最后一次调用semat的时间 0</span></span><br><span class="line"><span class="type">__time_t</span> shm_dtime; <span class="comment">// 对这段内存最后一次调用semdt的时间 0</span></span><br><span class="line"><span class="type">__time_t</span> shm_ctime; <span class="comment">// 对这段内存最后一次调用semctl的时间 当前时间</span></span><br><span class="line"><span class="type">__pid_t</span> shm_cpid; <span class="comment">// 创建者PID</span></span><br><span class="line"><span class="type">__pid_t</span> lpid; <span class="comment">// 最后一次执行shmat或shmdt的进程PID</span></span><br><span class="line"><span class="type">shmatt_t</span> shm_nattach <span class="comment">// 关联到此共享内存空间的进程数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>共享内存的POSIX方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> shmfd = <span class="built_in">shm_open</span>(<span class="string">&quot;/shm_name&quot;</span>, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line"><span class="built_in">ERROR_IF</span>(shmfd == <span class="number">-1</span>, <span class="string">&quot;shm open&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">ftruncate</span>(shmfd, BUFFER_SIZE);</span><br><span class="line"><span class="built_in">ERROR_IF</span>(ret == <span class="number">-1</span>, <span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line"></span><br><span class="line">share_mem = (<span class="type">char</span>*)<span class="built_in">mmap</span>(<span class="literal">nullptr</span>, BUFFER_SIZE,</span><br><span class="line">PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">ERROR_IF</span>(share_mem == MAP_FAILED, <span class="string">&quot;share_mem&quot;</span>);</span><br><span class="line"><span class="built_in">close</span>(shmfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消关联</span></span><br><span class="line"><span class="built_in">munmap</span>((<span class="type">void</span>*)share_mem, BUFFER_SIZE);</span><br></pre></td></tr></table></figure><h2 id="进程通信-管道"><a href="#进程通信-管道" class="headerlink" title="进程通信-管道"></a>进程通信-管道</h2><p>管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证<br>父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1].</p><p>可以用两个管道来实现双向传输数据, 也可以用<code>socketpair</code>来创建管道</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.<br>每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="comment">// 与semget 相同, 成功返回标识符</span></span><br><span class="line"><span class="comment">// msgflg的设置和作用域setget相同</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义</span></span><br><span class="line"><span class="comment">// msg_sz 指的是mtext的长度!!!</span></span><br><span class="line"><span class="comment">// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line">默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT</span><br><span class="line">就立即返回 设置errno=EAGIN</span><br><span class="line"></span><br><span class="line">系统自带这个结构体 不过mtext长度是<span class="number">1.</span>..</span><br><span class="line"><span class="keyword">struct</span> msgbuf</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> mtype; <span class="comment">/* 消息类型 正整数*/</span></span><br><span class="line"><span class="type">char</span> mtext[<span class="number">512</span>]; <span class="comment">/* 消息数据*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// msgtype = 0 读取消息队列第一个消息</span></span><br><span class="line"><span class="comment">// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT</span></span><br><span class="line"><span class="comment">// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG</span></span><br><span class="line"><span class="comment">// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据</span></span><br><span class="line"><span class="comment">// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msg_ptr, <span class="type">size_t</span> msg_sz, <span class="type">long</span> <span class="type">int</span> msgtype, <span class="type">int</span> msgflg)</span></span>;</span><br><span class="line">处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> command, <span class="keyword">struct</span> msqid_ds *buf)</span></span>;</span><br><span class="line"></span><br><span class="line">IPC_STAT 复制消息队列关联的数据结构</span><br><span class="line">IPC_SET 将buf中的部分成员更新到目标的内核数据</span><br><span class="line">IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程</span><br><span class="line">IPC_INFO 获取系统消息队列资源配置信息</span><br><span class="line"></span><br><span class="line">MSG_INFO 返回已经分配的消息队列所占用资源信息</span><br><span class="line">MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引</span><br></pre></td></tr></table></figure><h2 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h2><h2 id="IPC命令-查看进程间通信的全局唯一key"><a href="#IPC命令-查看进程间通信的全局唯一key" class="headerlink" title="IPC命令-查看进程间通信的全局唯一key"></a>IPC命令-查看进程间通信的全局唯一key</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十三章多进程编程&quot;&gt;&lt;a href=&quot;#第十三章多进程编程&quot; class=&quot;headerlink&quot; title=&quot;第十三章多进程编程&quot;&gt;&lt;/a&gt;第十三章多进程编程&lt;/h1&gt;&lt;h2 id=&quot;exec系列系统调用&quot;&gt;&lt;a href=&quot;#exec系列系统调用&quot; cla</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="多进程" scheme="http://icecorn.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第九章-IO复用</title>
    <link href="http://icecorn.github.io/2022/05/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%B9%9D%E7%AB%A0-IO%E5%A4%8D%E7%94%A8/"/>
    <id>http://icecorn.github.io/2022/05/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%B9%9D%E7%AB%A0-IO%E5%A4%8D%E7%94%A8/</id>
    <published>2022-05-09T09:25:10.000Z</published>
    <updated>2022-06-29T15:36:48.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-I-O复用"><a href="#第九章-I-O复用" class="headerlink" title="第九章 I/O复用"></a>第九章 I/O复用</h1><p>I/O复用使得程序能同时监听多个文件描述符.</p><ul><li>客户端程序需要同时处理多个socket 非阻塞connect技术</li><li>客户端程序同时处理用户输入和网络连接 聊天室程序</li><li>TCP服务器要同时处理监听socket和连接socket</li><li>同时处理TCP和UDP请求 - 回射服务器</li><li>同时监听多个端口, 或者处理多种服务 - xinetd服务器</li></ul><p>常用手段<code>select</code>, <code>poll</code>, <code>epoll</code></p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="comment">// nfds - 被监听的文件描述符总数</span></span><br><span class="line"><span class="comment">// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">select</span> <span class="params">(<span class="type">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, <span class="keyword">struct</span> timeval* timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作fd_set的宏</span></span><br><span class="line"><span class="built_in">FD_ZERO</span>(fd_set* fdset);</span><br><span class="line"><span class="built_in">FD_SET</span>(<span class="type">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="built_in">FD_CLR</span>(<span class="type">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="built_in">FD_ISSET</span>(<span class="type">int</span> fd, fd_set* fdset);</span><br><span class="line"><span class="comment">// 设置 timeval 超时时间</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">timeval</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> tv_sec; <span class="comment">// 秒</span></span><br><span class="line"><span class="type">long</span> tv_usec; <span class="comment">// 微秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select</strong></p><p>文件描述符就绪条件</p><ul><li>socket内核接收缓存区中的字节数大于或等于 其低水位标记</li><li>socket通信的对方关闭连接, 对socket的读操作返回0</li><li>监听socket上有新的连接请求</li><li>socket上有未处理的错误, 可以使用getsockopt来读取和清除错误</li><li>socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记</li><li>socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号</li><li>socket使用非阻塞connect 连接成功或失败后</li></ul><h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p><strong>poll</strong><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B1.png"><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/poll%E6%97%B6%E9%97%B4%E7%B1%BB%E5%9E%8B2.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="comment">// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\</span></span><br><span class="line"><span class="comment">// nfds 遍历结合大小 左闭右开</span></span><br><span class="line"><span class="comment">// timeout 单位为毫秒 -1 为阻塞 0 为立即返回</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">poll</span><span class="params">(<span class="keyword">struct</span> pollfd* fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">pollfd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">short</span> events;  <span class="comment">//注册的事件, 告知poll监听fd上的哪些事件</span></span><br><span class="line"><span class="type">short</span> revents; <span class="comment">// 实际发生的事件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> exit_if(r, ...) \</span></span><br><span class="line"><span class="meta">&#123;   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (r)  \</span></span><br><span class="line"><span class="meta">    &#123;   \</span></span><br><span class="line"><span class="meta">        printf(__VA_ARGS__);    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;errno no: %d, error msg is %s&quot;</span>, errno, strerror(errno));    \</span></span><br><span class="line"><span class="meta">        exit(1);    \</span></span><br><span class="line"><span class="meta">    &#125;   \</span></span><br><span class="line"><span class="meta">&#125;   \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">client_info</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ip_;</span><br><span class="line">    <span class="type">int</span> port_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> port = <span class="number">8001</span>;</span><br><span class="line">    <span class="type">char</span> ip[] = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> address;</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>(port);</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_addr.s_addr = <span class="built_in">htons</span>(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit_if</span>(listenfd &lt; <span class="number">0</span>, <span class="string">&quot;socket error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;address, <span class="built_in">sizeof</span>(address));</span><br><span class="line">    <span class="built_in">exit_if</span>(ret == <span class="number">-1</span>, <span class="string">&quot;bind error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>(listenfd, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">exit_if</span>(ret == <span class="number">-1</span>, <span class="string">&quot;listen error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> MAX_CLIENTS = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">pollfd</span> polls[MAX_CLIENTS] = &#123;&#125;;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">client_info</span> clientsinfo[MAX_CLIENTS] = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    polls[<span class="number">3</span>].fd = listenfd;</span><br><span class="line">    polls[<span class="number">3</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = <span class="built_in">poll</span>(polls, MAX_CLIENTS + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">exit_if</span>(ret == <span class="number">-1</span>, <span class="string">&quot;poll error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= MAX_CLIENTS; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> fd = polls[i].fd;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (polls[i].revents &amp; POLLRDHUP)</span><br><span class="line">            &#123;</span><br><span class="line">                polls[i].events = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;close fd-%d from %s:%d\n&quot;</span>, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (polls[i].revents &amp; POLLIN)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (fd == listenfd)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_address;</span><br><span class="line">                    <span class="type">socklen_t</span> client_addresslen = <span class="built_in">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> clientfd = <span class="built_in">accept</span>(listenfd, (<span class="keyword">struct</span> sockaddr*)&amp;client_address,</span><br><span class="line">                            &amp;client_addresslen);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">struct</span> <span class="title class_">client_info</span> *clientinfo = &amp;clientsinfo[clientfd];</span><br><span class="line"></span><br><span class="line">                    clientinfo-&gt;ip_ = <span class="built_in">inet_ntoa</span>(client_address.sin_addr);</span><br><span class="line">                    clientinfo-&gt;port_ = <span class="built_in">ntohs</span>(client_address.sin_port);</span><br><span class="line"></span><br><span class="line">                    <span class="built_in">exit_if</span>(clientfd &lt; <span class="number">0</span>, <span class="string">&quot;accpet error, from %s:%d\n&quot;</span>, clientinfo-&gt;ip_,</span><br><span class="line">                            clientinfo-&gt;port_);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;accept from %s:%d\n&quot;</span>, clientinfo-&gt;ip_, clientinfo-&gt;port_);</span><br><span class="line"></span><br><span class="line">                    polls[clientfd].fd = clientfd;</span><br><span class="line">                    polls[clientfd].events = POLLIN | POLLRDHUP;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">                    <span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line"></span><br><span class="line">                    ret = <span class="built_in">read</span>(fd, buffer, <span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">if</span>(ret == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">close</span>(fd);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;recv from %s:%d:\n%s\n&quot;</span>, clientsinfo[fd].ip_,</span><br><span class="line">                               clientsinfo[fd].port_, buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h2><p><strong>epoll</strong></p><p>epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异</p><ul><li>epoll使用一组函数完成任务</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中</li><li>epoll无需每次调用都传入文件描述符集或事件集.</li></ul><p>有特定的文件描述符创建函数, 来标识这个事件表<code>epoll_create()</code><br><code>epoll_ctl()</code> 用来操作这个内核事件表<br><code>epoll_wait()</code> 为主要函数 成功返回就绪的文件描述符个数 失败返回-1<br>如果<code>epoll_wait()</code>函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出<code>epoll_wait</code>检测到的就绪事件.</p><p><em>event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">poll</span>(fds, MAX_EVENT_NUMBER - <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="type">int</span> sockfd = fds[i].fd;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENT_NUMBER,  <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="type">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">// sockfd 一定就绪 ?????</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LT和ET模式</strong><br>LT(电平触发, 默认的工作模式)<br>LT模式下的epoll相当于一个效率较高的poll<br>epoll_wait将会一只通知一个事件知道这个事件被处理</p><p>ET(边沿触发, epoll的高效工作模式)模式<br>当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个<br>文件描述符<br>epoll_wait只会通知一次, 不论这个事件有没有完成</p><p>ET模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of content: 123456789</span><br><span class="line">get 9bytes of content: -12345678</span><br><span class="line">get 9bytes of content: 9-1234567</span><br><span class="line">get 4bytes of content: 89</span><br><span class="line">read later</span><br></pre></td></tr></table></figure><p>LT模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-&gt; 123456789-123456789-123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 123456789</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: -12345678</span><br><span class="line">event trigger once</span><br><span class="line">get 9bytes of contents: 9-1234567</span><br><span class="line">event trigger once</span><br><span class="line">get 4bytes of contents: 89</span><br></pre></td></tr></table></figure><p>ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式<br>LT模式只要事件没被处理就会一直通知</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;epoll.h&gt;</span></span></span><br><span class="line"><span class="comment">// size 参数只是给内核一个提示, 事件表需要多大</span></span><br><span class="line"><span class="comment">// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_create</span><span class="params">(<span class="type">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epfd 为 epoll_create的返回值</span></span><br><span class="line"><span class="comment">// op为操作类型</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_ADD 向事件表中注册fd上的事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_MOD 修改fd上的注册事件</span></span><br><span class="line"><span class="comment">// - EPOLL_CTL_DEL 删除fd上的注册事件</span></span><br><span class="line"><span class="comment">// fd 为要操作的文件描述符</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event* event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">_uint32_t</span> events; <span class="comment">// epoll事件</span></span><br><span class="line"><span class="type">epoll_data_t</span> data; <span class="comment">// 用户数据 是一个联合体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="title class_">epoll_data</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* ptr; <span class="comment">// ptr fd 不能同时使用</span></span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="type">uint32_t</span> u32;</span><br><span class="line"><span class="type">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="type">epoll_data_t</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// maxevents监听事件数 必须大于0</span></span><br><span class="line"><span class="comment">// timeout 为-1 表示阻塞</span></span><br><span class="line"><span class="comment">// 成功返回就绪的文件描述符个数 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event* events, <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="三种IO复用的比较"><a href="#三种IO复用的比较" class="headerlink" title="三种IO复用的比较"></a>三种IO复用的比较</h2><p><code>select</code>以及<code>poll</code>和<code>epoll</code><br>相同</p><ul><li>都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生.</li><li>返回值为就绪的文件描述符数量, 返回0则表示没有事件发生</li><li><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E4%B8%89%E7%A7%8DIO%E5%A4%8D%E7%94%A8%E6%AF%94%E8%BE%83.png"></li></ul><h2 id="I-O-复用的高级应用-非阻塞connect"><a href="#I-O-复用的高级应用-非阻塞connect" class="headerlink" title="I/O 复用的高级应用, 非阻塞connect"></a>I/O 复用的高级应用, 非阻塞connect</h2><p>connect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件.</p><p>当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第九章-I-O复用&quot;&gt;&lt;a href=&quot;#第九章-I-O复用&quot; class=&quot;headerlink&quot; title=&quot;第九章 I/O复用&quot;&gt;&lt;/a&gt;第九章 I/O复用&lt;/h1&gt;&lt;p&gt;I/O复用使得程序能同时监听多个文件描述符.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端程序需</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第八章-Linux高性能服务器框架</title>
    <link href="http://icecorn.github.io/2022/05/05/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%85%AB%E7%AB%A0-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://icecorn.github.io/2022/05/05/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%85%AB%E7%AB%A0-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</id>
    <published>2022-05-05T09:25:10.000Z</published>
    <updated>2022-06-29T15:34:50.041Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第八章高性能服务器程序框架"><a href="#第八章高性能服务器程序框架" class="headerlink" title="第八章高性能服务器程序框架"></a>第八章高性能服务器程序框架</h2><p><strong>服务器模型-CS模型</strong></p><p><strong>优点</strong></p><ul><li>实现起来简单<br><strong>缺点</strong></li><li>服务器是通信的中心, 访问过大的时候会导致响应过慢</li></ul><p>模式图<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233248719.png" alt="image-20220629233248719"></p><p>编写的demo 没有用到fork函数. 后续待完善</p><p><strong>服务器框架 IO模型</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%9E%B6.png"></p><p>这个模型大概能够理解, 自己也算是学了半年的Javaweb.</p><p>socket在创建的时候默认是阻塞的, 不过可以通过传<code>SOCK_NONBLOCK</code>参解决<br>非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会<code>返回-1</code> 所以需要通过<code>errno</code>来区分这些错误.<br><strong>事件未发生</strong><br>accept, send,recv errno被设置为 <code>EAGAIN(再来一次)</code>或<code>EWOULDBLOCK(期望阻塞)</code><br>connect 被设置为 <code>EINPROGRESS(正在处理中)</code></p><p>需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能</p><p>常用IO复用函数 <code>select</code> <code>poll</code> <code>epoll_wait</code> 将在第九章后面说明<br>信号将在第十章说明</p><p><strong>两种高效的事件处理模式和并发模式</strong><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/Reactor%E6%A8%A1%E5%BC%8F.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233354924.png" alt="image-20220629233354924"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233409090.png" alt="image-20220629233409090"></p><p>程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).<br>前者使用并发编程反而会降低效率, 后者则会提升效率<br>并发编程有多进程和多线程两种方式</p><p>并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.<br>服务器主要有两种并发模式</p><ul><li>半同步/半异步模式</li><li>领导者/追随者模式</li></ul><p><strong>半同步/半异步模式</strong><br>在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核)</p><p>而在这里(并发模式)<br>同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程<br>异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程<br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629233423078.png" alt="image-20220629233423078"></p><p>服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式<br>同步线程 - 处理客户逻辑, 处理请求队列中的对象<br>异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列</p><p>半同步/半异步模式 存在变体 <code>半同步/半反应堆模式</code><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E6%A8%A1%E5%BC%8F.png"></p><p>异步线程 - 主线程 - 负责监听所有socket上的事件</p><p><strong>领导者/追随者模式</strong><br>略</p><p><strong>高效编程方法 - 有限状态机</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 状态独立的有限状态机</span></span><br><span class="line">STATE_MACHINE(Package _pack) &#123;</span><br><span class="line"></span><br><span class="line">PackageType _type = _pack.GetType();</span><br><span class="line"><span class="keyword">switch</span>(_type) &#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">xxxx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">xxxx;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带状态转移的有限状态机</span></span><br><span class="line">STATE_MACHINE() &#123;</span><br><span class="line">State cur_State = type_A;</span><br><span class="line"><span class="keyword">while</span>(cur_State != type_C) &#123;</span><br><span class="line"></span><br><span class="line">Package _pack = getNewPackage();</span><br><span class="line"><span class="keyword">switch</span>(cur_State) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_state_A(_pack);</span><br><span class="line">cur_State = type_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">xxxx;</span><br><span class="line">cur_State = type_C;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提高服务器性能的其他建议-池-数据复制-上下文切换和锁"><a href="#提高服务器性能的其他建议-池-数据复制-上下文切换和锁" class="headerlink" title="提高服务器性能的其他建议 池 数据复制 上下文切换和锁"></a>提高服务器性能的其他建议 池 数据复制 上下文切换和锁</h3><p><strong>池</strong> - 用空间换取时间<br>进程池和线程池</p><p><strong>数据复制</strong> - 高性能的服务器应该尽量避免不必要的复制</p><p><strong>上下文切换和锁</strong><br>减少<code>锁</code>的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第八章高性能服务器程序框架&quot;&gt;&lt;a href=&quot;#第八章高性能服务器程序框架&quot; class=&quot;headerlink&quot; title=&quot;第八章高性能服务器程序框架&quot;&gt;&lt;/a&gt;第八章高性能服务器程序框架&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;服务器模型-CS模型&lt;/strong</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第6-7章-Linux高级IO函数&amp;Linux服务器程序规范</title>
    <link href="http://icecorn.github.io/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC6-7%E7%AB%A0-Linux%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0&amp;Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/"/>
    <id>http://icecorn.github.io/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC6-7%E7%AB%A0-Linux%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0&amp;Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/</id>
    <published>2022-05-03T09:25:10.000Z</published>
    <updated>2022-06-29T15:30:17.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第六章高级IO函数"><a href="#第六章高级IO函数" class="headerlink" title="第六章高级IO函数"></a>第六章高级IO函数</h2><p>Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率<br><em>文件描述符</em><br>文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。<br>STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件</p><h3 id="创建文件描述符-pipe-dup-dup2-splice-select"><a href="#创建文件描述符-pipe-dup-dup2-splice-select" class="headerlink" title="创建文件描述符 - pipe dup dup2 splice select"></a>创建文件描述符 - pipe dup dup2 splice select</h3><p><strong>pipe函数</strong><br>这个函数可用于创建一个管道, 实现进程间的通信. </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="comment">// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道</span></span><br><span class="line"><span class="comment">// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组</span></span><br><span class="line"><span class="comment">// 失败返回-1 errno</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向管道</span></span><br><span class="line"><span class="comment">// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">socketpair</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol, <span class="type">int</span> fd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><p>学习了后面的内容了解到了进程间通信, 回来补上一个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">    socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, fds);</span><br><span class="line">    <span class="type">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">char</span> a[] = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        send(fds[<span class="number">1</span>], a, <span class="built_in">strlen</span>(a), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">char</span> b[<span class="number">20</span>] &#123;&#125;;</span><br><span class="line">        recv(fds[<span class="number">0</span>], b, <span class="number">20</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>dup和dup2函数</strong><br>复制一个现有的文件描述符</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回的文件描述符总是取系统当前可用的最小整数值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"><span class="comment">// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭</span></span><br><span class="line"><span class="comment">// 如果newfd==oldfd 则不关闭newfd直接返回</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br></pre></td></tr></table></figure><p>dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.<br>回来补上例子, 这个例子由于关掉了<code>STDOUT_FILENO</code>dup最小的即为<code>STDOUT_FILENO</code>所以<br>标准输出都到了这个文件之中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> filefd = open(<span class="string">&quot;/home/lsmg/1.txt&quot;</span>, O_WRONLY);</span><br><span class="line">    close(STDOUT_FILENO);</span><br><span class="line">    dup(filefd);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;123\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读写数据-readv-writev-mmap-munmap"><a href="#读写数据-readv-writev-mmap-munmap" class="headerlink" title="读写数据 - readv writev mmap munmap"></a>读写数据 - readv writev mmap munmap</h3><p><strong>readv/writev</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="comment">// count 为 vector的长度, 即为有多少块内存</span></span><br><span class="line"><span class="comment">// 成功时返回写入\读取的长度 失败返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* <span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec* <span class="built_in">vector</span>, <span class="type">int</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line"><span class="type">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line"><span class="type">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中<br>使用hexdump查看这个文件<code>0000000 86a0 0001</code>可以看到<code>186a0</code>即为100000</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2020年1月7日16:52:11</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> file = open(<span class="string">&quot;/home/lsmg/1.txt&quot;</span>, O_WRONLY);</span><br><span class="line">    <span class="type">int</span> temp = <span class="number">100000</span>;</span><br><span class="line">    iovec temp_iovec&#123;&#125;;</span><br><span class="line">    temp_iovec.iov_base = &amp;temp;</span><br><span class="line">    temp_iovec.iov_len = <span class="keyword">sizeof</span>(temp);</span><br><span class="line">    writev(file, &amp;temp_iovec, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendfile函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"><span class="comment">// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendfile</span><span class="params">(<span class="type">int</span> out_fd, <span class="type">int</span> in_fd, <span class="type">off_t</span>* offset, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line">O_RDONLY只读模式</span><br><span class="line">O_WRONLY只写模式</span><br><span class="line">O_RDWR读写模式</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(file_name, flag)</span>;</span><br></pre></td></tr></table></figure><p>stat结构体, 可用fstat生成, <strong>简直就是文件的身份证</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">dev_t</span>       st_dev;     <span class="comment">/* ID of device containing file -文件所在设备的ID*/</span></span><br><span class="line">    <span class="type">ino_t</span>       st_ino;     <span class="comment">/* inode number -inode节点号*/</span></span><br><span class="line">    <span class="type">mode_t</span>      st_mode;    <span class="comment">/* protection -保护模式?*/</span></span><br><span class="line">    <span class="type">nlink_t</span>     st_nlink;   <span class="comment">/* number of hard links -链向此文件的连接数(硬连接)*/</span></span><br><span class="line">    <span class="type">uid_t</span>       st_uid;     <span class="comment">/* user ID of owner -user id*/</span></span><br><span class="line">    <span class="type">gid_t</span>       st_gid;     <span class="comment">/* group ID of owner - group id*/</span></span><br><span class="line">    <span class="type">dev_t</span>       st_rdev;    <span class="comment">/* device ID (if special file) -设备号，针对设备文件*/</span></span><br><span class="line">    <span class="type">off_t</span>       st_size;    <span class="comment">/* total size, in bytes -文件大小，字节为单位*/</span></span><br><span class="line">    <span class="type">blksize_t</span>   st_blksize; <span class="comment">/* blocksize for filesystem I/O -系统块的大小*/</span></span><br><span class="line">    <span class="type">blkcnt_t</span>    st_blocks;  <span class="comment">/* number of blocks allocated -文件所占块数*/</span></span><br><span class="line">    <span class="type">time_t</span>      st_atime;   <span class="comment">/* time of last access -最近存取时间*/</span></span><br><span class="line">    <span class="type">time_t</span>      st_mtime;   <span class="comment">/* time of last modification -最近修改时间*/</span></span><br><span class="line">    <span class="type">time_t</span>      st_ctime;   <span class="comment">/* time of last status change - */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>身份证</strong>生成函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个参数需要调用open生成文件描述符</span></span><br><span class="line"><span class="comment">// 下面其他两个为文件全路径</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> filedes, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="keyword">struct</span> stat *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* ln -s source dist  建立软连接, 类似快捷方式, 也叫符号链接</span></span><br><span class="line"><span class="comment">* ln source dist  建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全</span></span><br><span class="line"><span class="comment">* 删除就可以正常访问</span></span><br><span class="line"><span class="comment">* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说</span></span><br><span class="line"><span class="comment">* `文件`本身就类似快捷方式, 指向文件存在的区域.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> <strong>mmap和munmap函数</strong></p><p><code>mmap</code>创建一块进程通讯共享的内存(可以将文件映射入其中), <code>munmap</code>释放这块内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度</span></span><br><span class="line"><span class="comment">// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)</span></span><br><span class="line"><span class="comment">// flag参数 内存被修改后的行为</span></span><br><span class="line"><span class="comment">// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中</span></span><br><span class="line"><span class="comment">// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中</span></span><br><span class="line"><span class="comment">// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略</span></span><br><span class="line"><span class="comment">// 成功返回区域指针, 失败返回 -1</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length, <span class="type">int</span> port, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span>* start, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p><strong>splice函数</strong><br>用于在两个文件名描述符之间移动数据, 0拷贝操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置</span></span><br><span class="line"><span class="comment">// len为指定移动的数据长度, flags参数控制数据如何移动.</span></span><br><span class="line"><span class="comment">// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞</span></span><br><span class="line"><span class="comment">// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">splice</span><span class="params">(<span class="type">int</span> fd_in, <span class="type">loff_t</span>* off_in, <span class="type">int</span> fd_out, <span class="type">loff_t</span>* off_out, <span class="type">size_t</span> len, <span class="type">unsigned</span> <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用splice函数  实现echo服务器</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;the parmerters is wrong\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(errno);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;the port is %d the ip is %s\n&quot;</span>, port, ip);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    address.sin_port = htons(port);</span><br><span class="line">    inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = bind(sockfd, (sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">    assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    ret = listen(sockfd, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> clientfd&#123;&#125;;</span><br><span class="line">    sockaddr_in client_address&#123;&#125;;</span><br><span class="line">    <span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"></span><br><span class="line">    clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span> (clientfd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;accept error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a new connection from %s:%d success\n&quot;</span>, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port));</span><br><span class="line">        <span class="type">int</span> fds[<span class="number">2</span>];</span><br><span class="line">        pipe(fds);</span><br><span class="line">        ret = splice(clientfd, nullptr, fds[<span class="number">1</span>], nullptr, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        ret = splice(fds[<span class="number">0</span>], nullptr, clientfd, nullptr, <span class="number">32768</span>, SPLICE_F_MORE);</span><br><span class="line">        assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">        close(clientfd);</span><br><span class="line">    &#125;</span><br><span class="line">    close(sockfd);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>select 函数</strong><br>select函数在第二个参数列表 可读的时候返回<br>或者是等到了规定的时间返回</p><p>返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表<br>这就需要每次返回后都更新 fdset集合</p><p>返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中<br>然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读<br>还是此连接断开</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="comment">// maxfdp 最大数 FD_SETSIZE</span></span><br><span class="line"><span class="comment">// struct fd_set 一个集合,可以存储多个文件描述符</span></span><br><span class="line"><span class="comment">// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd</span></span><br><span class="line"><span class="comment">// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中</span></span><br><span class="line"><span class="comment">// readfds  需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回</span></span><br><span class="line"><span class="comment">// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回</span></span><br><span class="line"><span class="comment">// errorfds 错误</span></span><br><span class="line"><span class="comment">// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数</span></span><br><span class="line"><span class="comment">// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,<span class="keyword">struct</span> timeval*timeout)</span>; </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> exit_if(r, ...) \</span></span><br><span class="line"><span class="meta">&#123;   \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (r)  \</span></span><br><span class="line"><span class="meta">    &#123;   \</span></span><br><span class="line"><span class="meta">        printf(__VA_ARGS__);    \</span></span><br><span class="line"><span class="meta">        printf(<span class="string">&quot;errno no: %d, error msg is %s&quot;</span>, errno, strerror(errno));    \</span></span><br><span class="line"><span class="meta">        exit(1);    \</span></span><br><span class="line"><span class="meta">    &#125;   \</span></span><br><span class="line"><span class="meta">&#125;   \</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> keyboard_fd = open(<span class="string">&quot;/dev/tty&quot;</span>, O_RDONLY | O_NONBLOCK);</span><br><span class="line">    exit_if(keyboard_fd &lt; <span class="number">0</span>, <span class="string">&quot;open keyboard fd error\n&quot;</span>);</span><br><span class="line">    fd_set readfd;</span><br><span class="line">    <span class="type">char</span> recv_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FD_ZERO(&amp;readfd);</span><br><span class="line">        FD_SET(<span class="number">0</span>, &amp;readfd);</span><br><span class="line"></span><br><span class="line">        timeval timeout &#123;<span class="number">5</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ret = select(keyboard_fd + <span class="number">1</span>, &amp;readfd, nullptr, nullptr, &amp;timeout);</span><br><span class="line">        exit_if(ret == <span class="number">-1</span>, <span class="string">&quot;select error\n&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(keyboard_fd, &amp;readfd))</span><br><span class="line">            &#123;</span><br><span class="line">                recv_buffer = <span class="number">0</span>;</span><br><span class="line">                read(keyboard_fd, &amp;recv_buffer, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;\n&#x27;</span> == recv_buffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&#x27;q&#x27;</span> == recv_buffer)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;the input is %c\n&quot;</span>, recv_buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第七章Linux服务器程序规范"><a href="#第七章Linux服务器程序规范" class="headerlink" title="第七章Linux服务器程序规范"></a>第七章Linux服务器程序规范</h2><ul><li>Linux程序服务器 一般以后台进程形式运行.  后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程)</li><li>Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它.</li><li>Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql.</li><li>Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改.</li><li>Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID.</li><li>Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力</li></ul><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service rsyslog restart // 启动守护进程</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"><span class="comment">// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或</span></span><br><span class="line"><span class="comment">// - 0 LOG_EMERG  /* 系统不可用*/</span></span><br><span class="line"><span class="comment">// - 1 LOG_ALERT   /* 报警需要立即采取行动*/</span></span><br><span class="line"><span class="comment">// - 2 LOG_CRIT /* 非常严重的情况*/</span></span><br><span class="line"><span class="comment">// - 3 LOG_ERR  /* 错误*/</span></span><br><span class="line"><span class="comment">// - 4 LOG_WARNING /* 警告*/</span></span><br><span class="line"><span class="comment">// - 5 LOG_NOTICE /* 通知*/</span></span><br><span class="line"><span class="comment">// - 6 LOG_INFO /* 信息*/</span></span><br><span class="line"><span class="comment">//  -7 LOG_DEBUG /* 调试*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span>* message, .....)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ident 位于日志的时间后 通常为名字</span></span><br><span class="line"><span class="comment">// logopt 对后续 syslog调用的行为进行配置</span></span><br><span class="line"><span class="comment">// -  0x01 LOG_PID  /* 在日志信息中包含程序PID*/</span></span><br><span class="line"><span class="comment">// -  0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/</span></span><br><span class="line"><span class="comment">// -  0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/</span></span><br><span class="line"><span class="comment">// -  0x08 LOG_NDELAY /* 不延迟打开日志功能*/</span></span><br><span class="line"><span class="comment">// facility参数可以修改syslog函数中的默认设施值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* ident, <span class="type">int</span> logopt, <span class="type">int</span> facility)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// maskpri 一共八位 0000-0000</span></span><br><span class="line"><span class="comment">// 如果将最后一个0置为1 表示 记录0级别的日志</span></span><br><span class="line"><span class="comment">// 如果将最后两个0都置为1 表示记录0和1级别的日志</span></span><br><span class="line"><span class="comment">// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT</span></span><br><span class="line"><span class="comment">// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setlogmask</span><span class="params">(<span class="type">int</span> maskpri)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭日志功能</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="用户信息-切换用户"><a href="#用户信息-切换用户" class="headerlink" title="用户信息, 切换用户"></a>用户信息, 切换用户</h3><p>UID - 真实用户ID<br>EUID - 有效用户ID - 方便资源访问<br>GID - 真实组ID<br>EGID - 有效组ID</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">getuid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">uid_t</span> <span class="title function_">geteuid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getgid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">gid_t</span> <span class="title function_">getegid</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setuid</span><span class="params">(<span class="type">uid_t</span> uid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">seteuid</span><span class="params">(<span class="type">uid_t</span> euid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setgid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setegid</span><span class="params">(<span class="type">gid_t</span> gid)</span>;</span><br></pre></td></tr></table></figure><p>可以通过 <code>setuid</code>和<code>setgid</code>切换用户 <strong>root用户uid和gid均为0</strong></p><h3 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h3><p>PGID - 进程组ID(Linux下每个进程隶属于一个进程组)</p><p>#include &lt;unistd.h&gt;<br>pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1<br>int setpgid(pid_t pid, pid_t pgid);</p><p><strong>会话</strong><br>一些有关联的进程组将形成一个会话</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第六章高级IO函数&quot;&gt;&lt;a href=&quot;#第六章高级IO函数&quot; class=&quot;headerlink&quot; title=&quot;第六章高级IO函数&quot;&gt;&lt;/a&gt;第六章高级IO函数&lt;/h2&gt;&lt;p&gt;Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第五章-Linux网络编程基础API</title>
    <link href="http://icecorn.github.io/2022/04/30/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%94%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/"/>
    <id>http://icecorn.github.io/2022/04/30/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%94%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/</id>
    <published>2022-04-30T09:25:10.000Z</published>
    <updated>2022-06-29T15:27:08.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第五章Linux网络编程基础API"><a href="#第五章Linux网络编程基础API" class="headerlink" title="第五章Linux网络编程基础API"></a>第五章Linux网络编程基础API</h2><p>socket基础api位于 <code>sys/socket.h</code> 头文件中<br>socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段<br>网络信息api <code>netdb.h</code>头文件中</p><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><p>字节序分为 <code>大端字节序</code>和<code>小端字节序</code><br>由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序</p><p>为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).<br>这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><strong>基础连接</strong><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%BD%93.jpg"><br><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%8D%8F%E8%AE%AE%E7%BB%84%E5%90%88%E5%9C%B0%E5%9D%80%E6%97%8F.jpg"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机序和网络字节序转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">htonl</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> hostlong)</span></span>; <span class="comment">// host to network long</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> hostlong)</span></span>; <span class="comment">// host to network short</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> <span class="title">htonl</span> <span class="params">(<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="title">htons</span> <span class="params">(<span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> netlong)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IP地址转换函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONE</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span>  <span class="title">inet_addr</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* strptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">( <span class="type">const</span> <span class="type">char</span>* cp, <span class="keyword">struct</span> in_addr* inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族</span></span><br><span class="line"><span class="comment">// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> * src, <span class="type">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span>*  src, <span class="type">char</span>* dst, <span class="type">socklen_t</span> cnt)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 命名 监听 socket</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// domain指定使用那个协议族 PF_INET PF_INET6</span></span><br><span class="line"><span class="comment">// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)</span></span><br><span class="line"><span class="comment">// protocol设置为默认的0</span></span><br><span class="line"><span class="comment">// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// socket为socket文件描述符</span></span><br><span class="line"><span class="comment">// my_addr 为地址信息</span></span><br><span class="line"><span class="comment">// addrlen为socket地址长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回 -1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bind</span><span class="params">(<span class="type">int</span> socket, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* my_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backlog表示队列最大的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> socket, <span class="type">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">// 接受连接 失败返回-1 成功时返回socket</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* addr, <span class="type">socklen_t</span>* addrlen)</span></span></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发起连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第三个参数为 地址指定的长度</span></span><br><span class="line"><span class="comment">// 成功返回0 失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr * serv_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭连接</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数为保存的socket</span></span><br><span class="line"><span class="comment">// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 立即关闭</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 第二个参数为可选值 </span></span><br><span class="line"><span class="comment">//SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃</span></span><br><span class="line"><span class="comment">//SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去</span></span><br><span class="line"><span class="comment">//SHUT_RDWR 同时关闭读和写</span></span><br><span class="line"><span class="comment">// 成功返回0 失败为-1 设置errno</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shutdown</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> howto)</span></span><br></pre></td></tr></table></figure><p><strong>基础TCP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取sockfd的数据</span></span><br><span class="line"><span class="comment">// buf 指定读缓冲区的位置</span></span><br><span class="line"><span class="comment">// len 指定读缓冲区的大小</span></span><br><span class="line"><span class="comment">// flags 参数较多</span></span><br><span class="line"><span class="comment">// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取.   读取到0 通信对方已经关闭连接, 错误返回-1</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项名</th><th>含义</th><th>可用于发送</th><th>可用于接收</th></tr></thead><tbody><tr><td>MSG_CONFIRM</td><td>指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTROUTE</td><td>不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中)</td><td>Y</td><td>N</td></tr><tr><td>MSG_DONTWAIT</td><td>非阻塞</td><td>Y</td><td>Y</td></tr><tr><td>MSG_MORE</td><td>告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率</td><td>Y</td><td>N</td></tr><tr><td>MSG_WAITALL</td><td>读操作一直等待到读取到指定字节后才会返回</td><td>N</td><td>Y</td></tr><tr><td>MSG_PEEK</td><td>看一下内缓存数据, 并不会影响数据</td><td>N</td><td>Y</td></tr><tr><td>MSG_OOB</td><td>发送或接收紧急数据</td><td>Y</td><td>Y</td></tr><tr><td>MSG_NOSIGNAL</td><td>向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号</td><td>Y</td><td>N</td></tr></tbody></table><p><strong>基础UDP</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.</span></span><br><span class="line"><span class="comment">// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址</span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags, <span class="keyword">struct</span> sockaddr* src_addr, <span class="type">socklen_t</span>* addrlen)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span>* buf, <span class="type">size_t</span> len, ing flags, <span class="type">const</span> <span class="keyword">struct</span> sockaddr* dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>通用读写函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inclued <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr* msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/</span></span><br><span class="line"><span class="type">void</span>* msg_name; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">socklen_t</span> msg_namelen;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由</span></span><br><span class="line"><span class="comment">     * msg_iov指向的数组指定, 称为分散读(scatter read)  ---对于sendmsg而言, msg_iovlen块的分散内存中</span></span><br><span class="line"><span class="comment">     * 的数据将一并发送称为集中写(gather write);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span></span><br><span class="line"><span class="type">int</span> msg_iovlen; <span class="comment">/* 分散内存块的数量*/</span></span><br><span class="line"><span class="type">void</span>* msg_control; <span class="comment">/* 指向辅助数据的起始位置*/</span></span><br><span class="line"><span class="type">socklen_t</span> msg_controllen; <span class="comment">/* 辅助数据的大小*/</span></span><br><span class="line"><span class="type">int</span> msg_flags; <span class="comment">/* 复制函数的flags参数, 并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">void</span>* iov_base <span class="comment">/* 内存起始地址*/</span></span><br><span class="line"><span class="type">size_t</span> iov_len <span class="comment">/* 这块内存长度*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其他Api</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, </span></span><br><span class="line"><span class="comment">// 是的话返回1, 不是返回0</span></span><br><span class="line"><span class="comment">// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sockatmark</span><span class="params">(<span class="type">int</span> sockfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1</span></span><br><span class="line"><span class="comment">// getpeername 获取远端的信息, 同上</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockname</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpeername</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr* address, <span class="type">socklen_t</span>* address_len)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以下函数头文件均相同*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度</span></span><br><span class="line"><span class="comment">// 成功时返回0 失败返回-1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> <span class="keyword">restrict</span> option_len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> option_name, <span class="type">void</span>* option_value, </span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> <span class="keyword">restrict</span> option_len)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>SO_REUSEADDR</th><th>重用本地地址</th><th>sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock</th></tr></thead><tbody><tr><td>SO_RCVBUF</td><td>TCP接收缓冲区大小</td><td>最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞</td></tr><tr><td>SO_SNDBUF</td><td>TCP发送缓冲区大小</td><td>最小值为2048字节</td></tr><tr><td>SO_RCVLOWAT</td><td>接收的低水位标记</td><td>默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据</td></tr><tr><td>SO_SNDLOWAT</td><td>发送的高水位标记</td><td>默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据</td></tr><tr><td>SO_LINGER</td><td></td><td></td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> l_onoff <span class="comment">/* 开启非0, 关闭为0*/</span></span><br><span class="line"><span class="type">int</span> l_linger; <span class="comment">/* 滞留时间*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 当onoff为0的时候此项不起作用, close调用默认行为关闭socket</span></span><br><span class="line"><span class="comment">* 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段</span></span><br><span class="line"><span class="comment">* 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 </span></span><br><span class="line"><span class="comment">* 闭, 如果是处于非阻塞则立即关闭</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/socket%E9%80%89%E9%A1%B9.jpg"></p><p><strong>网络信息API</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 通过主机名查找ip</span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过ip获取主机完整信息 </span></span><br><span class="line"><span class="comment">// type为IP地址类型 AF_INET和AF_INET6</span></span><br><span class="line"><span class="keyword">struct</span> hostent* <span class="title function_">gethostbyaddr</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> type)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *h_name;<span class="comment">/* Official name of host.  */</span></span><br><span class="line">  <span class="type">char</span> **h_aliases;<span class="comment">/* Alias list.  */</span></span><br><span class="line">  <span class="type">int</span> h_addrtype;<span class="comment">/* Host address type.  */</span></span><br><span class="line">  <span class="type">int</span> h_length;<span class="comment">/* Length of address.  */</span></span><br><span class="line">  <span class="type">char</span> **h_addr_list;<span class="comment">/* List of addresses from name server.  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;非法输入\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span>* name = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> *<span class="title">hostptr</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    hostptr = gethostbyname(name);</span><br><span class="line">    <span class="keyword">if</span> (hostptr == nullptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入存在错误 或无法获取\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Official name of hostptr: %s\n&quot;</span>, hostptr-&gt;h_name);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> **pptr;</span><br><span class="line">    <span class="type">char</span> inet_addr[INET_ADDRSTRLEN];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Alias list:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (pptr = hostptr-&gt;h_aliases; *pptr != nullptr; ++pptr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\t%s\n&quot;</span>, *pptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (hostptr-&gt;h_addrtype)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> AF_INET:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;List of addresses from name server:\n&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (pptr = hostptr-&gt;h_addr_list; *pptr != nullptr; ++pptr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;\t%s\n&quot;</span>,</span><br><span class="line">                        inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, <span class="keyword">sizeof</span>(inet_addr)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;unknow address type\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">./run baidu.com</span></span><br><span class="line"><span class="comment">Official name of hostptr: baidu.com</span></span><br><span class="line"><span class="comment">Alias list:</span></span><br><span class="line"><span class="comment">List of addresses from name server:</span></span><br><span class="line"><span class="comment">39.156.69.79</span></span><br><span class="line"><span class="comment">220.181.38.148</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科</p><p>Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下</p><ul><li>通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名</li><li>如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 根据名称获取某个服务的完整信息</span></span><br><span class="line"><span class="keyword">struct</span> servent <span class="title function_">getservbyname</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name, <span class="type">const</span> <span class="type">char</span>* proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据端口号获取服务信息</span></span><br><span class="line"><span class="keyword">struct</span> servent <span class="title function_">getservbyport</span><span class="params">(<span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* proto)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span>* s_name; <span class="comment">/* 服务名称*/</span></span><br><span class="line"><span class="type">char</span> ** s_aliases; <span class="comment">/* 服务的别名列表*/</span></span><br><span class="line"><span class="type">int</span> s_port; <span class="comment">/* 端口号*/</span></span><br><span class="line"><span class="type">char</span>* s_proto; <span class="comment">/* 服务类型, 通常为TCP或UDP*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// 内部使用的gethostbyname 和 getserverbyname</span></span><br><span class="line"><span class="comment">// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)</span></span><br><span class="line"><span class="comment">// service 用于接收服务名, 字符串表示的十进制端口号</span></span><br><span class="line"><span class="comment">// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果</span></span><br><span class="line"><span class="comment">// result 指向一个链表, 用于存储getaddrinfo的反馈结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getaddrinfo</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* hostname, <span class="type">const</span> <span class="type">char</span>* service, <span class="type">const</span> <span class="keyword">struct</span> addrinfo* hints, <span class="keyword">struct</span> addrinfo** result)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> addrinfo</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ai_flags;</span><br><span class="line"><span class="type">int</span> ai_family;</span><br><span class="line"><span class="type">int</span> ai_socktype; <span class="comment">/* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/</span></span><br><span class="line"><span class="type">int</span> ai_protocol;</span><br><span class="line"><span class="type">socklen_t</span> ai_addrlen;</span><br><span class="line"><span class="type">char</span>* ai_canonname; <span class="comment">/* 主机的别名*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/* 指向socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/* 指向下一个结构体*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要手动的释放堆内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeaddrinfo</span><span class="params">(<span class="keyword">struct</span> addrinfo* res)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/7ebedb14d8eedeac.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="comment">// host 存储返回的主机名</span></span><br><span class="line"><span class="comment">// serv存储返回的服务名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnameinfo</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> sockaddr* sockaddr, <span class="type">socklen_t</span> addrlen, <span class="type">char</span>* host, <span class="type">socklen_t</span> hostlen, <span class="type">char</span>* serv</span></span><br><span class="line"><span class="params"><span class="type">socklen_t</span> servlen, <span class="type">int</span> flags)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/bc7196e9a30d5152.png"></p><p>测试使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet ip port #来连接服务器的此端口</span><br><span class="line">netstat -nt | grep port #来查看此端口的监听</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第五章Linux网络编程基础API&quot;&gt;&lt;a href=&quot;#第五章Linux网络编程基础API&quot; class=&quot;headerlink&quot; title=&quot;第五章Linux网络编程基础API&quot;&gt;&lt;/a&gt;第五章Linux网络编程基础API&lt;/h2&gt;&lt;p&gt;socket基础ap</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    <category term="socket编程" scheme="http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux高性能服务器|第1-3章-计算机网络部分</title>
    <link href="http://icecorn.github.io/2022/04/27/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%AE%A1%E7%BD%91%E9%83%A8%E5%88%86-1-3%E7%AB%A0/"/>
    <id>http://icecorn.github.io/2022/04/27/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%AE%A1%E7%BD%91%E9%83%A8%E5%88%86-1-3%E7%AB%A0/</id>
    <published>2022-04-27T09:25:10.000Z</published>
    <updated>2022-06-29T15:22:52.187Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-TCP-IP协议族"><a href="#第一章-TCP-IP协议族" class="headerlink" title="第一章 TCP/IP协议族"></a>第一章 TCP/IP协议族</h2><h3 id="TCP-IP协议族体系结构和主要协议"><a href="#TCP-IP协议族体系结构和主要协议" class="headerlink" title="TCP/IP协议族体系结构和主要协议"></a>TCP/IP协议族体系结构和主要协议</h3><p>协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.jpg"></p><p>同样七层是osi参考模型, 简化后得到四层<br>不同层次之间, 通过接口互相交流, 这样方便了各层次的修改</p><p><strong>应用层</strong><br>负责处理应用程序的逻辑</p><p><strong>表示层</strong><br>定义了数据的格式及加密</p><p><strong>会话层</strong><br>它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的</p><p><strong>传输层</strong><br>为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.<br>此层存在两大协议TCP协议和UDP协议<br>TCP协议(Transmission Control Protocol 传输控制协议)</p><ul><li>为应用层提供<code>可靠的, 面向连接, 基于流的服务</code></li><li>通过<code>超时重传</code>和<code>数据确认</code>等确保数据正常送达.</li><li>TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器<br>UPD协议(User Datagram Protocol 用户数据报协议)</li><li>为应用层提供<code>不可靠的, 无连接的, 基于数据报的服务</code></li><li>一般需要自己处理<code>数据确认</code>和<code>超时重传</code>的问题</li><li>通信两者不存储状态, 每次发送都需要指定地址信息. <code>有自己的长度</code></li></ul><p><strong>网络层</strong><br>实现了数据包的选路和转发.  只有数据包到不了目标地址, 就<code>下一跳</code>(hop by hop), 选择最近的.<br><em>IP协议(Internet Protocol)</em> 以及 <em>ICMP协议(Internet Control Message Protocol)</em><br>后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达)</p><p><strong>数据链路层</strong><br>实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.<br>存在两个协议 <em>ARP协议(Address Resolve Protocol, 地址解析协议)</em>. 还有<em>RARP(Reverse ~, 逆地址解析协议)</em>.  由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议<em>ARP欺骗, 可能与这个有关, 目前不去学习</em></p><p><strong>封装</strong><br>上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.<br>被TCP封装的数据成为 <code>TCP报文段</code></p><ul><li>内核部分发送成功后删除数据</li></ul><p>被UDP封装的数据成为 <code>UDP数据报</code></p><ul><li>发送后即删除</li></ul><p>再经IP封装后成为<code>IP数据报</code><br>最后经过数据链路层封装后为 <code>帧</code></p><p>以太网最大数据帧1518字节 抛去14头部 帧尾4校验<br>MTU: 帧的最大传输单元 一般为1500字节<br>MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分</p><p><strong>ARP</strong><br>ARP协议能实现任意网络层地址到任意物理地址的转换</p><h2 id="第二章-IP协议详解"><a href="#第二章-IP协议详解" class="headerlink" title="第二章 IP协议详解"></a>第二章 IP协议详解</h2><p>IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一<br>IP协议为上层协议提供无状态, 无连接, 不可靠的服务</p><p>IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制</p><p>当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E6%90%BA%E5%B8%A6ICMP%E6%8A%A5%E6%96%87%E7%9A%84IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E8%A2%AB%E5%88%86%E7%89%87.png"></p><p>路由机制</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/%E8%B7%AF%E7%94%B1%E6%9C%BA%E5%88%B6.png"></p><p>给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤</p><ul><li>查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步</li><li>查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步</li><li>选择默认路由项, 通常意味着下一跳路由是网关</li></ul><h2 id="第三章-TCP协议详解"><a href="#第三章-TCP协议详解" class="headerlink" title="第三章 TCP协议详解"></a>第三章 TCP协议详解</h2><p>Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系.</p><p>UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断</p><p>ISN-初始序号值<br>32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移<br>32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答</p><p>ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为<code>确认报文段</code><br>PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间<br>RST标志: 要求对方重新建立连接 携带……<code>复位报文段</code><br>SYN标志: 标志请求建立一个连接 携带……<code>同步报文段</code><br>FIN标志: 通知对方本端连接要关闭了, 携带..<code>结束报文段</code></p><p>16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据<br>16位校验和: <code>可靠传输的重要保障</code>发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验<code>TCP头部</code>和<code>数据部分</code></p><p><strong>TCP连接的建立和关闭</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 三次握手</span><br><span class="line"># 客户端发送请求连接 ISN=seq + 0 = 3683340920</span><br><span class="line"># mss 最大数据载量1460</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [S], seq 3683340920, win 64240, </span><br><span class="line">options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0</span><br><span class="line"></span><br><span class="line"># 同意客户端连接</span><br><span class="line"># ack = 客户端发送 seq + 1</span><br><span class="line"># 同时发送服务端的seq</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [S.], seq 938535101, ack 3683340921, win 64240, </span><br><span class="line">options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0</span><br><span class="line"></span><br><span class="line"># 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值</span><br><span class="line"># 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 = 1</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 938535102, win 4106, length 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 包含FIN标志 说明要求结束连接 也需要占用一个序号值</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [F.], seq 1, ack 1, win 4106, length 0</span><br><span class="line"></span><br><span class="line"># 服务端确认关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [.], ack 2, win 502, length 0</span><br><span class="line"></span><br><span class="line"># 服务端发送关闭连接</span><br><span class="line">IP ubuntu.8000 &gt; 192.168.80.1.7467: </span><br><span class="line">Flags [F.], seq 1, ack 2, win 4105, length 0</span><br><span class="line"></span><br><span class="line"># 客户端确认</span><br><span class="line">IP 192.168.80.1.7467 &gt; ubuntu.8000: </span><br><span class="line">Flags [.], ack 2, win 503, length 0</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-TCP-IP协议族&quot;&gt;&lt;a href=&quot;#第一章-TCP-IP协议族&quot; class=&quot;headerlink&quot; title=&quot;第一章 TCP/IP协议族&quot;&gt;&lt;/a&gt;第一章 TCP/IP协议族&lt;/h2&gt;&lt;h3 id=&quot;TCP-IP协议族体系结构和主要协议&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="Linux" scheme="http://icecorn.github.io/categories/ReadingNotes/Linux/"/>
    
    
    <category term="计算机网络" scheme="http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Linux高性能服务器" scheme="http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第四讲-分配器/new&amp;delete</title>
    <link href="http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    <id>http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/</id>
    <published>2022-04-16T09:25:10.000Z</published>
    <updated>2022-06-29T15:09:23.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h3 id="七种分配器"><a href="#七种分配器" class="headerlink" title="七种分配器"></a>七种分配器</h3><ul><li><p><strong>new_allocator</strong></p><p>没做什么事，直接调用malloc/free，包装了一层而已</p></li><li><p><strong>malloc_allocator</strong></p><p>和new_allocator一样</p></li><li><p><strong>array_allocator</strong></p><p>分配一个静态的内存空间，不需要考虑归还的事情，其实就是c++的array</p></li><li><p><strong>debug_allocator</strong></p><p>其实就是每分配一块内存都多加一个M_extra的内存来占一个元素的大小用于debug</p></li><li><p><strong>pool_allocator</strong></p><p>就是第二讲讲的内存池的实现，16个自由链表挂载不同粒度的内存块，缺点是没有动态free,但不能算作内存泄漏，因为那些内存还在分配器的掌控之下</p></li><li><p>bitmap_allocator</p><p>用一个索引以 2 的指数倍数成长的桶子(exponentially increasing power-of-two-sized buckets)的思路。先捋一捋bitmap_allocator实现当中的相关数据结构的概念：</p><p><strong>blocks：</strong>即是进行分配的内存区块，每个block size一般取8bytes，是super-block的一部分；<br><strong>super-blocks：</strong>表示一个__mini_vector所管理的整个内存空间，bitmap_allocator进行管理内存空间扩容/缩减的操作就是通过增加或减少super-blocks的数目来实现的，是 bitmap_allocator 进行内存管理的基本单位；<br>bitmap：记录一个__mini_vector所管理的内存空间所属的64个 blocks 的分配情况(依据增长情况，不一定是64个，也可能是128/256，block数目是2的幂次增长的)，所以为64bit，8bytes(0表示分配出去了，1表示未分配出去；若是全未分配出去则为0x FFFF FFFF FFFF FFFF，若是第一个分配出去则为 0x FFFF FFFF FFFF FFFE(1110)，即bitmap字节序从低位到高位表示的是block序号从63到0)，是super-block的一部分；<br><strong>mini-vector：</strong>该数据结构的实现是为了避免作为容器的分配其还嵌套容器所造成的先有鸡还是先有蛋的困扰，实现过程也即和vector的实现思路相似，见 vector 容器。含有三个成员变量_M_start；(表示所管理的block的起始位置，即block0的内存地址)，_M_finish；(表示第一个可分配的block的内存位置)，_M_end_of_storage;(类似于vector当中的capacity概念)。其作用是对 super-block 进行存储、访问和管理。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514202055.png"></p></li><li><p><strong>mt_allocator</strong></p><p>针对多线程的分配器</p></li></ul><hr><h3 id="关于Const"><a href="#关于Const" class="headerlink" title="关于Const"></a>关于Const</h3><p>const放在<strong>成员函数</strong>后，是告诉编译器这个成员函数不改变这个类的data</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514210303.png"></p><p>记住non_const obj可以调用const函数，反过来则不行，如果const和non_const函数都有的话，就各调用各的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514211437.png"></p><p>上图右边两个函数名称一样，只是一个多了const，所以const是算在函数签名里边的。</p><p>举例 string s1 = “abc”; s1[0] = ‘d’;这样就发生了写操作，这里s1实际调用的就是重载[]的非const版本，<strong>同时这里要考虑COW，就是有多个线程同时共有s1的话，要加锁，不要发生重写，脏数据等情况</strong></p><p>const string s2 = “abc”; s2是常量，所以s2[0]访问的就是const版本的重载[]函数，且无需考虑COW</p><hr><h3 id="关于new，delete"><a href="#关于new，delete" class="headerlink" title="关于new，delete"></a>关于new，delete</h3><p><strong>new：</strong></p><p>1.调用operator new(),这个函数是可以重载的，可以实现内存池，这个函数默认就是调用malloc（）分配一块内存</p><p>2.static_cast&lt;T*&gt; 将1中分配的内存强制转型成想new的数据类型</p><p>3.调用new的类的构造函数</p><p><strong>delete：</strong></p><p>1.调用该对象的析构函数，这里要注意的是，如果这个对象没有指针类型的data，那么其实不析构也没啥事，有的话就一定要析构</p><p>2.调用delete释放这块内存，这里实际就是调用free（）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514212527.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h3 id=&quot;七种分配器&quot;&gt;&lt;a href=&quot;#七种分配器&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第三讲-malloc/free</title>
    <link href="http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/"/>
    <id>http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/</id>
    <published>2022-04-11T09:25:10.000Z</published>
    <updated>2022-06-29T15:08:22.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h2 id="malloc-free"><a href="#malloc-free" class="headerlink" title="malloc/free"></a>malloc/free</h2><h3 id="一、VC6内存分配"><a href="#一、VC6内存分配" class="headerlink" title="一、VC6内存分配"></a>一、VC6内存分配</h3><p>下图左边是函数调用栈，最下方是操作系统</p><p><img src="https://i.imgur.com/GSff1Jp.png"></p><p>SBH：VC6 malloc对小区块（1016）的分配有特殊处理。在后续的版本VC10 取消了SBH的实现，全部交给操作系统来做（HeapAlloc()函数，OS对小区快内存的分配也和VC6类似）</p><p>下图是VC10的call stack，红×是相对VC6去掉的，最大区别就是取消了SBH，全部移交OS分配</p><p><img src="https://i.imgur.com/EZG35WQ.png"></p><h4 id="SBH之始"><a href="#SBH之始" class="headerlink" title="SBH之始"></a>SBH之始</h4><p><strong>以下内容核心的目的，就是通过组织一些数据结构和算法来管理1MB的内存的灵活分配和释放（因为超过1MB就不用SBH，直接交给OS管理）</strong></p><p>首先call OS的系统函数HeapCreate（），申请一块4096bits的内存(_crtheap)供后续使用，</p><p>即__cdecl_heap_init()，创建了16个Header</p><p><img src="https://s2.loli.net/2022/05/13/4kxruOeRVKcI3GM.png"></p><p>CRT：C Run Time</p><p>Header里边包括下边这些东西，具体干什么用的下文再说</p><p><img src="https://s2.loli.net/2022/05/13/Cu87lfJpyGnMLFz.png"></p><p>debug模式会多增加一些内存用于跟踪我们使用的内存，这就是VS debug模式能显示堆栈中变量及地址的原因</p><p><strong>ioinit（）</strong>函数是首次分配内存的函数，而且必定是256个字节（16进制为100）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513215753.png"></p><p>接着往下调用到**_heap_alloc_dbg()<strong>,这个函数的参数是下图中的blocksize= debug模式需要的内存（下图上方灰色部分）+ 上下两个“无人区”（下图深绿部分，一个4字节）+ 实际内存大小（下图浅绿部分，256字节）</strong>补充一点：上下无人区实际也属于debug模式的信息，release模式就没有了**</p><p><strong>无人区</strong>起到一个栏杆的作用，从而调试器可以检测出内存越界行为</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513223103.png"></p><p>pBlockHeaderNext;pBlockHeaderPrev这两个指针的作用就是将SBH分配的所有的内存区块全部串联起来，从而来管理</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513230245.png"></p><p>接下来调用**_heap_alloc_base()**这个函数就是在加完debug这些内存之后，判断有没有超过1016个字节，没超过就SBH，超过了就OS分配</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513230944.png"></p><p>接下来调用**__sbh_alloc_block()**,这个函数作用：</p><p>下图add 8 bytes就是加入了上下cookies，然后进行对齐操作，将这个带着上下cookies的内存块上调为16 bytes对齐</p><p>这些整个的大小是0X130，但是cookies里却存的是00000131，这里是用了个trick，因为内存块是16位对齐的，那么最后一位必然是0，所以这里cookies那里就用结尾存0或1来表示这个内存块的状态（使用，释放）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220513231905.png"></p><p><strong>以上这些内容都是在计算所需内存大小，还没有实际分配内存，自然更谈不上初始化内容</strong></p><p>下面将进入实际分配内存的环节：</p><p>之前讲过有16个Header，它们每个控制1MB的内存（通过win API申请的Virtual melloc（））</p><p>下图就是将它们控制的region是怎么玩的，细节是一个header的一个group维护了64个指针（双向链表）来控制这1MB，这些指针消耗大概16K</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220513233203018.png" alt="image-20220513233203018"></p><p>32个group分1MB，一个32K，再分成8分，一份4K称为一个page，看到这里恍然大悟，和OS连上了，这个就是OS里的分页，目的就是最大程度的里用零散的小内存</p><p>所以这里实际上就看出来SBH就是类似上一讲的内存池那样挖出一块大内存1MB然后手动画好格子32group * 8page，并且搞一堆指针形成链表让他们能找到，然后就可以分配管理了</p><p><strong>另外，这个header控制的1MB实际上只是逻辑上的地址空间，因为win系统的虚拟内存机制，前边也说了它是用Virtual malloc申请的，这里联想以下OS里的虚内存机制就可以了。所以这里不是直接再物理空间上挖1MB，而是最小只用分配1page 4k就可以了，为什么呢？这里联想下虚内存和硬盘的交互，恰恰就是按page的粒度来进行换入换出的！</strong></p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220513234229182.png" alt="image-20220513234229182"></p><p>上图中一个group的64根指针实际上就像第二讲的allocator内存池一样，第一个用来挂在8字节，第二个16字节，这样一直到最后一个指针是挂载1KB及1KB以上的</p><p> 下面是实际切的情况：</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514002537699.png" alt="image-20220514002537699"></p><p>VC6的内存管理分配情况：</p><p>其实就和内存池的分配差不多，把一个group用64个指针管理，按照所需分配的内存大小选择挂载在哪个指针下边，每一次分配从下往上长</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514102213.png"></p><p>收回内存，就是把这块内存挂载到对应的链表上（例下图是35号链表），然后把group的标志数组对应的35号位子置为1，表示这个底下有闲置的内存可以分配</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514103905946.png" alt="image-20220514103905946"></p><p>下一次再分配内存，算出要挂载在25号指针，但是它的group标志位是0，那么就往后找比它大的最近的指针标志位为1的，这里是35号链表，所以这次分配的内存实际上就是在上一次回收的35号内存上切一刀再分配给当前申请内存的程序。这里相比第二讲allocate简陋的内存池，就有了一个很大的好处，可以将这一个group32K的内存的压榨的很满。</p><p><strong>区块合并</strong></p><p>一个区块要被free的情况，在直接挂载到group对应的指针下之前，可以先看这个区块的上下区块是不是也是free的状态，如果是，那么可以将它们合并成一个大区块（上下cookies的最后一位是0表示是free状态的区块，可以合并，<strong>这也是上下cookies的作用之一</strong>）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514155941.png"></p><p><strong>Free（p）挂载内存到指针上</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514160556.png"></p><p>确定哪一个Header-&gt;确定哪一个group-&gt;最后确定是64个指针中的哪一个</p><p>至于怎么找，就用指针的地址减去头的地址就行</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>SBH实际上就是将内存分成不同的粒度大小，16个Header每个管理1MB，1MB又分成了32个group每个32K，32K用分成8个page每个4K，<strong>这实际上就是OS内存的段页式管理，目的就是为了最大化合理利用内存碎片，从最大的内存一层一层找到最后内存所在的page就是句柄？</strong></p><p><strong>全回收判断</strong></p><p>因为是链表的结构，所以不容易判断内存是否全部回收完毕，所以设置了一个cntEntires参数每次melloc就+1，free就-1，如果为0就表示全回收啦（就是最后8个page全部挂在最后一个链表上，因为最后一个链表指针控制1KB以上的字节）</p><p>另外这里有个buffer机制，就是有个defer指针，当有第一个全回收的group时先不回收（还给OS），出现第二个全回收的group再把第一个回收掉，这样就减少了像OS申请虚拟内存的次数（当没有第二个group时，又有进程申请内存，这时直接分配defer指针下全回收的group就行）</p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220514162140680.png" alt="image-20220514162140680"></p><p>allocator内存池的设计其实只是为了减少cookies内存的占用，而不是减少malloc的调用次数，因为malloc其实很快</p><p>在下图中各层级的调用栈中，确实存在一些冗余，但因为过于庞大且不是一拨开发人员所以没办法，但VC因为是微软自家的，所以在VC10就取消了SBH的设计，将小区块内存也一并交给下层OS来管理了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220514163554.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h2 id=&quot;malloc-free&quot;&gt;&lt;a href=&quot;#malloc-free&quot; class=&quot;head</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第二讲-std_allocator-内存池</title>
    <link href="http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/"/>
    <id>http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/</id>
    <published>2022-04-08T09:25:10.000Z</published>
    <updated>2022-06-29T15:07:32.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h2 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h2><h3 id="一、malloc-内部原理"><a href="#一、malloc-内部原理" class="headerlink" title="一、malloc()内部原理"></a>一、malloc()内部原理</h3><h4 id="1、VC6-0-malloc"><a href="#1、VC6-0-malloc" class="headerlink" title="1、VC6.0 malloc"></a>1、VC6.0 malloc</h4><p><img src="https://i.imgur.com/gQUae6j.png"></p><p>从上图可见，VC6中的malloc()函数分配的内存里面除了我们需要申请的内存空间外还有cookie，debug信息和pad，其中cookie是我们不需要的，如果大量调用malloc的话cookie总和会增多，这回造成较大的浪费。</p><p><img src="https://i.imgur.com/cmEOkpQ.png"></p><p>从上面可以看出，VC6.0的allocate()函数只是对malloc的二次封装，并没有做什么很特殊的操作，它是以类型字节长度为单位分配内存的，上图就分配了512个int类型空间。</p><h4 id="2、BC5-malloc"><a href="#2、BC5-malloc" class="headerlink" title="2、BC5 malloc"></a>2、BC5 malloc</h4><p><img src="https://i.imgur.com/ob9hMFD.png"></p><p>BC5的allocate()函数和VC6.0本质一样。</p><h4 id="3、G2-9-malloc"><a href="#3、G2-9-malloc" class="headerlink" title="3、G2.9 malloc"></a>3、G2.9 malloc</h4><p><img src="https://i.imgur.com/e2MZ9ZG.png"></p><p>GCC 2.9版本的allocator如上图所示，但是在实际中该部分却没有被包含使用，从下图容器使用的Alloc可以看到，实际的分配器是使用了一个叫alloc的类，该类分配内存是以字节为单位的，而不是以对象为单位。下图右边灰色部分分配的是512字节，而不是512个对象。</p><p><img src="https://i.imgur.com/FVlBA20.png"></p><h4 id="4、-pool-alloc"><a href="#4、-pool-alloc" class="headerlink" title="4、__pool_alloc"></a>4、__pool_alloc</h4><p>在GCC 4.9版本，2.9版本的allocate不属于正式使用的那个版本，而是变成了__pool_alloc：</p><p><img src="https://i.imgur.com/K7XxqvN.png"></p><p><img src="https://i.imgur.com/6MTLUB7.png"></p><p>从上面两张图可以对比看出，2.9版本的allocate和4.9版本的__pool_alloc做的事是一样的，只是修改了变量名和一些细小操作而已。</p><p><img src="https://i.imgur.com/AHgQElz.png"></p><p><img src="https://i.imgur.com/BVIH5XG.png"></p><p>测试的代码如所示：</p><pre><code>#include &lt;iostream&gt;#include &lt;vector&gt; #include &lt;ext\pool_allocator.h&gt;using namespace std;template&lt;typename Alloc&gt; void cookie_test(Alloc alloc, size_t n)                                                                                &#123;    typename Alloc::value_type *p1, *p2, *p3;        //需有 typename       p1 = alloc.allocate(n);         //allocate() and deallocate() 是 non-static, 需以 object 呼叫之.       p2 = alloc.allocate(n);             p3 = alloc.allocate(n);        cout &lt;&lt; &quot;p1= &quot; &lt;&lt; p1 &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;p2= &quot; &lt;&lt; p2 &lt;&lt; &#39;\t&#39; &lt;&lt; &quot;p3= &quot; &lt;&lt; p3 &lt;&lt; &#39;\n&#39;;                alloc.deallocate(p1,sizeof(typename Alloc::value_type));     //需有 typename       alloc.deallocate(p2,sizeof(typename Alloc::value_type));      //有些 allocator 對於 2nd argument 的值無所謂            alloc.deallocate(p3,sizeof(typename Alloc::value_type));     &#125;int main(void)&#123;    cout &lt;&lt; sizeof(__gnu_cxx::__pool_alloc&lt;double&gt;) &lt;&lt; endl;    vector&lt;int, __gnu_cxx::__pool_alloc&lt;double&gt; &gt; vecPool;    cookie_test(__gnu_cxx::__pool_alloc&lt;double&gt;(), 1);        cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl;        cout &lt;&lt; sizeof(std::allocator&lt;double&gt;) &lt;&lt; endl;    vector&lt;int, std::allocator&lt;double&gt; &gt; vecPool2;    cookie_test(std::allocator&lt;double&gt;(), 1);        return 0;&#125;</code></pre><p>测试环境是Dev C++5.1.1版本，GCC 4.9，测试结果如下：</p><p><img src="https://i.imgur.com/n7pUFXm.png"></p><p>从上面的测试结果可以看出，如果使用了__pool_alloc的话，连续两块内存之间的距离是8，而一个double类型变量的大小也是8个字节，说明这连续几块内存之间是不带cookie的（即使这几块内存在物理上也是不连续的）。如果使用std的allocator，那么相邻两块内存之间距离为18个字节，每块内存带有一个4字节的头和4字节的尾。</p><h3 id="二、std-alloc"><a href="#二、std-alloc" class="headerlink" title="二、std::alloc"></a>二、std::alloc</h3><h4 id="1、std-alloc运作模式"><a href="#1、std-alloc运作模式" class="headerlink" title="1、std:alloc运作模式"></a>1、std:alloc运作模式</h4><p><img src="https://i.imgur.com/lzcpFvY.png"></p><p>std::alloc使用一个16个元素的数组来管理内存链表，而我们上一章只是用了一条链表。数组不同的元素管理不同的区块管理，例如#3号元素负责管理32bytes为一小块的链表。</p><p>假设现在用户需要32字节的内存，std::allloc先申请一块区间，为32<em>20</em>2大小，用一条链表管理，然后让数组的#3元素管理这条链表。接着讲该以32为一个单元的链表的一个单元（32字节）分给用户。为什么是32<em>20</em>2？<br>前面32<em>20空间是分配给用户的，但是后面的32</em>20空间是预留的，如果这时用户需要一个64字节的空间，那么剩下的32<em>20空间将变成64</em>10，然后将其中64字节分配给用户，而不用再一次地构建链表和申请空间。</p><p>但是也有上限。如果该链表组维护的链表最大的一个小块为128byte，但是用户申请内存块超过了128byte，那么std::alloc将调用malloc给用户分配空间，然后该块将带上cookie头和尾。</p><p><img src="https://i.imgur.com/8MNTpki.png"></p><p>在真正的商业级的内存分配器中，一般都会使用嵌入式指针，将每一个小块的前四个字节用作指针连接下一块可用的内存块。</p><h4 id="2、std-alloc运行一瞥"><a href="#2、std-alloc运行一瞥" class="headerlink" title="2、std::alloc运行一瞥"></a>2、std::alloc运行一瞥</h4><p><img src="https://i.imgur.com/lGNyqvP.png"></p><p><img src="https://i.imgur.com/G4h5VE1.png"></p><p><img src="https://i.imgur.com/oEh5eUL.png"></p><p><img src="https://i.imgur.com/gjy2DCM.png"></p><p><img src="https://i.imgur.com/Ik5j4AB.png"></p><p><img src="https://i.imgur.com/0EbenSF.png"></p><p><img src="https://i.imgur.com/KiVVXm0.png"></p><p><img src="https://i.imgur.com/KzfwDdr.png"></p><p><img src="https://i.imgur.com/Vb9WrUI.png"></p><p><img src="https://i.imgur.com/iYdhtkB.png"></p><p><img src="https://i.imgur.com/NTqyfwF.png"></p><p><img src="https://i.imgur.com/kGj86gM.png"></p><p><img src="https://i.imgur.com/2udQslV.png"></p><p><img src="https://i.imgur.com/jfBEG5f.png"></p><h4 id="3、std-alloc源码剖析"><a href="#3、std-alloc源码剖析" class="headerlink" title="3、std::alloc源码剖析"></a>3、std::alloc源码剖析</h4><p>侯杰老师的ppt上总结的很好，在看这部分内容时需要结合老师的ppt，为了方便分析，这里结合老师的课程，使用“倒叙”的方式，先介绍中间的几张ppt，然后跳回前面，顺序和原版ppt不一样。</p><p>原版ppt的1-3张介绍的是GCC 2.9的std::alloc的第一级分配器，这里先从第二级开始分析，然后再到第一级。</p><p><img src="https://i.imgur.com/SCvJ2A6.png"></p><p>该分配器为__default_alloc_template，一开始默认使用的分配器，在该类中定义了ROUND_UP函数，用来将申请内存数量做16字节对齐。定义了union free_list_link，在后面会介绍它的作用，在上一章中我们构建的一个小的分配器中也定义了该联合体，作用类似，该联合体可以使用struct代替。free_list是一个有16个obj*元素的数组，在前面讲过，GCC 2.9的分配器用一个16字节数组管理16条链表，free_list便是该管理数组。refill和chunk_alloc在后面再介绍。start_free和end_free分别指向该内存池的头和尾。</p><p><img src="https://i.imgur.com/ofe7YUv.png"></p><p>首先看allocate函数，在函数的一开始便定义了:</p><pre><code>obj* volatile *my_free_list;</code></pre><p>结合上图右侧的链表图和上上一张图片内容，my_free_list指向的是free_list中16个元素中的任何一个，*my_free_list则取出free_list某元素中的值，该值指向一条分配内存的链表。所以my_free_list要定义为二级指针。</p><p>result则保存分配给用户的一块内存的地址。</p><p>首先：</p><pre><code>if (n &gt; (size_t)__MAX_BYTES) &#123;    return(malloc_alloc::allocate(n));&#125;</code></pre><p>检查用户申请内存块大小，如果大于__MAX_BYTES（128）那么将调用malloc_alloc::allocate()，这便是第一级分配器，这在后面分析。现在假设用户申请内存小于128字节，那么将根据用户申请内存大小分配对应的内存，由于内存池使用free_list链表管理的，每个free_list链表元素管理不同的内存块大小，这在前面介绍过了。于是有：</p><pre><code>my_free_list = free_list + FREELIST_INDEX(n);</code></pre><p>定位到该内存块的位置，这时my_free_list指向的是管理该内存块的空间的地址，使用*my_free_list便可以取到该内存块的地址：</p><pre><code>result = *my_free_list;</code></pre><p>然后判断result是否为空：</p><pre><code>if (result == 0) &#123;    void* r = refill(ROUND_UP(n));    return r;&#125;</code></pre><p>如果为空，说明系统内存不够用了，将使用refill()函数分配内存，这部分在后面会介绍。</p><p>如果情况正常，那么将该链表中下一个可以使用的空间设置为当前分配给用户空间指向的下一个、在逻辑上连续的空间，最后将result返回给用户：</p><pre><code>*my_free_list = result-&gt;free_list_link;return (result);</code></pre><p>下面的这张图很形象地演示了内存分配的过程：</p><p><img src="https://i.imgur.com/zXMf35J.png"></p><p>接下来分析释放内存。</p><pre><code>  static void deallocate(void *p, size_t n)  //p may not be 0  &#123;    obj* q = (obj*)p;    obj* volatile *my_free_list;   //obj** my_free_list;    if (n &gt; (size_t) __MAX_BYTES) &#123;        malloc_alloc::deallocate(p, n);        return;    &#125;    my_free_list = free_list + FREELIST_INDEX(n);    q-&gt;free_list_link = *my_free_list;    *my_free_list = q;  &#125;</code></pre><p>释放内存的代码也不难理解，找到需要释放内存的那块空间的地址，然后将当前可分配给用户的空间地址设置为需要释放的该内存空间，一开始指向的可分配的内存空间地址赋值给需要释放空间地址的逻辑连续的下一个内存地址。感觉十分拗口，图和代码更能体现这一过程：</p><p><img src="https://i.imgur.com/ubYKWxM.png"></p><p>上面说到，不论是分配内存还是释放内存，则有：</p><pre><code>if (n &gt; (size_t)__MAX_BYTES) &#123;    return(malloc_alloc::allocate(n));&#125;</code></pre><p>和：</p><pre><code>if (n &gt; (size_t) __MAX_BYTES) &#123;    malloc_alloc::deallocate(p, n);    return;&#125;</code></pre><p>也就是将内存分配与释放操作放到第一级allocator中：</p><p><img src="https://i.imgur.com/Mf5qVqE.png"></p><p>从上图中可以看到，第一级分配器叫做：</p><pre><code>class __malloc_alloc_template</code></pre><p>其实有：</p><pre><code>typedef __malloc_alloc_template&lt;0&gt;  malloc_alloc;</code></pre><p>这在后面会介绍。</p><p>分配器的allocate函数如下：</p><pre><code>  static void* allocate(size_t n)  &#123;    void *result = malloc(n);   //直接使用 malloc()    if (0 == result) result = oom_malloc(n);    return result;  &#125;</code></pre><p>直接调用malloc函数分配内存，如果分配失败则调用oom_malloc函数。</p><p>同样地，reallocate也是如此：</p><pre><code>  static void* reallocate(void *p, size_t /* old_sz */, size_t new_sz)  &#123;    void * result = realloc(p, new_sz); //直接使用 realloc()    if (0 == result) result = oom_realloc(p, new_sz);    return result;  &#125;</code></pre><p>如果重新要求内存失败，则调用oom_realloc函数，这两个函数在后续会介绍。</p><p>deallocate操作则直接释放内存：</p><pre><code>static void deallocate(void *p, size_t /* n */)&#123;    free(p);                    //直接使用 free()&#125;</code></pre><p>set_malloc_handler是个函数指针，里面传入一个void (*f)()类型函数：</p><pre><code>  static void (*set_malloc_handler(void (*f)()))()  &#123; //類似 C++ 的 set_new_handler().    void (*old)() = __malloc_alloc_oom_handler;    __malloc_alloc_oom_handler = f;    return(old);  &#125;</code></pre><p>该函数设置的是内存分配不够情况下的错误处理函数，这个需要交给用户来管理，首先保存先前的处理函数，然后再将新的处理函数f赋值给__malloc_alloc_oom_handler，然后返回旧的错误处理函数，这也在下一张图片中会介绍：</p><p><img src="https://i.imgur.com/tWjkErU.png"></p><p>可以看到oom_malloc函数内部做的事：</p><pre><code>template &lt;int inst&gt;void* __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n)&#123;  void (*my_malloc_handler)();  void* result;  for (;;) &#123;    //不斷嘗試釋放、配置、再釋放、再配置…    my_malloc_handler = __malloc_alloc_oom_handler;    if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;    (*my_malloc_handler)();    //呼叫處理常式，企圖釋放記憶體    result = malloc(n);        //再次嘗試配置記憶體    if (result) return(result);  &#125;&#125;</code></pre><p>该函数不断调用__malloc_alloc_oom_handler和malloc函数，直到内存分配成功才返回。oom_realloc也是如此：</p><pre><code>template &lt;int inst&gt;void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n)&#123;  void (*my_malloc_handler)();  void* result;  for (;;) &#123;    //不斷嘗試釋放、配置、再釋放、再配置…    my_malloc_handler = __malloc_alloc_oom_handler;    if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125;    (*my_malloc_handler)();    //呼叫處理常式，企圖釋放記憶體。    result = realloc(p, n);    //再次嘗試配置記憶體。    if (result) return(result);  &#125;&#125;</code></pre><p><img src="https://i.imgur.com/hK3r07F.png"></p><p>到这里，分配器只剩下refill函数没有分析了，下面将重点讨论该函数。不过在讨论refill函数之前有必要分析chunk_alloc函数：</p><p><img src="https://i.imgur.com/ICXnj4c.png"></p><p><img src="https://i.imgur.com/p9EfgAj.png"></p><p>该函数声明如下：</p><pre><code>template &lt;bool threads, int inst&gt;char*__default_alloc_template&lt;threads, inst&gt;::chunk_alloc(size_t size, int&amp; nobjs)</code></pre><p>函数一开始计算了一些需要的值：</p><pre><code>char* result;size_t total_bytes = size * nobjs;size_t bytes_left = end_free - start_free;</code></pre><p>result指向分配给用户的内存，total_bytes为需要分配的内存块的大小，bytes_left则是当前内存池中剩余的空间大小。</p><p>然后：</p><pre><code>if (bytes_left &gt;= total_bytes) &#123;  result = start_free;  start_free += total_bytes;  return(result);&#125;</code></pre><p>判断如果内存池剩余的内存大小多余需要分配的内存块大小，那么将内存池的首地址start_free直接赋值给result，然后将start_free指针下移total_bytes距离，将当下的result~start_free之间的空间返回给用户。</p><p>当然，如果bytes_left比total_bytes小，但是却比size大：</p><pre><code>else if (bytes_left &gt;= size) &#123;      nobjs = bytes_left / size;      total_bytes = size * nobjs;      result = start_free;      start_free += total_bytes;      return(result);  &#125;</code></pre><p>这意味着不能直接分配size * nobjs大小内存给用户，那么可以先看看内存池当下的空间能分配多少个size大小的块给用户，然后将该块分配给用户，start_free指针移动total_bytes长度。</p><pre><code>  size_t bytes_to_get =             2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4);  // Try to make use of the left-over piece.  if (bytes_left &gt; 0) &#123;      obj* volatile *my_free_list =             free_list + FREELIST_INDEX(bytes_left);      ((obj*)start_free)-&gt;free_list_link = *my_free_list;      *my_free_list = (obj*)start_free;  &#125;</code></pre><p>这部分查看内存池里面还有没有多余的内存，如果有，就充分利用。然后就是不断地获取内存块，将这些内存块不断切割用链表连接起来，递归这些过程：</p><pre><code>  start_free = (char*)malloc(bytes_to_get);  if (0 == start_free) &#123;      int i;      obj* volatile *my_free_list, *p;      //Try to make do with what we have. That can&#39;t      //hurt. We do not try smaller requests, since that tends      //to result in disaster on multi-process machines.      for (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;          my_free_list = free_list + FREELIST_INDEX(i);          p = *my_free_list;          if (0 != p) &#123;              *my_free_list = p -&gt; free_list_link;              start_free = (char*)p;              end_free = start_free + i;              return(chunk_alloc(size, nobjs));              //Any leftover piece will eventually make it to the              //right free list.          &#125;      &#125;      end_free = 0;       //In case of exception.      start_free = (char*)malloc_alloc::allocate(bytes_to_get);      //This should either throw an exception or      //remedy the situation. Thus we assume it      //succeeded.  &#125;  heap_size += bytes_to_get;  end_free = start_free + bytes_to_get;  return(chunk_alloc(size, nobjs));</code></pre><p><img src="https://i.imgur.com/j26x3xi.png"></p><p><img src="https://i.imgur.com/t4Gz1D7.png"></p><p><img src="https://i.imgur.com/QhuRqGz.png"></p><p><img src="https://i.imgur.com/eL1hcds.png"></p><p><img src="https://i.imgur.com/cUVMnHp.png"></p><p><img src="https://i.imgur.com/VcXK94y.png"></p><p><img src="https://i.imgur.com/zvx7Zmx.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h2 id=&quot;std-allocator&quot;&gt;&lt;a href=&quot;#std-allocator&quot; class=&quot;</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
    <category term="内存池" scheme="http://icecorn.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>C++内存管理机制|第一讲-primitives</title>
    <link href="http://icecorn.github.io/2022/04/05/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%AE%B2primitives/"/>
    <id>http://icecorn.github.io/2022/04/05/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%AE%B2primitives/</id>
    <published>2022-04-05T09:25:10.000Z</published>
    <updated>2022-06-29T15:06:13.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-内存管理"><a href="#C-内存管理" class="headerlink" title="C++内存管理"></a>C++内存管理</h2><h3 id="一、四种内存分配和释放方法"><a href="#一、四种内存分配和释放方法" class="headerlink" title="一、四种内存分配和释放方法"></a>一、四种内存分配和释放方法</h3><p><img src="https://i.imgur.com/AREog97.png"></p><p>在编程时可以通过上图的几种方法直接或间接地操作内存。下面将介绍四种C++内存操作方法：</p><p><img src="https://i.imgur.com/8F62Mf8.png"></p><p>通常可以使用malloc和new来分配内存，当然也可以使用::operator new()和分配器allocator来操作内存，下面将具体介绍这些函数的使用方法。对于不同的编译器，其allocate函数的接口也有所不同：</p><p><img src="https://i.imgur.com/lljUGp1.png"></p><p>对于GNU C，不同版本又有所不同：</p><p><img src="https://i.imgur.com/xkUvBlJ.png"></p><p>这张图中的__gnu_cxx::__pool_alloc<T>().allocate()对应于上张图中的allocator<T>().allocate()。</p><p>通过malloc和new分配内存、通过free和delete释放内存是十分常用的，通过::operator new操作内存比较少见，allocator分配器操作内存在STL源码中使用较多，对于不同的编译环境使用也有所不同。下面这个例子是基与VS2013环境做测试的:</p><pre><code>#include &lt;iostream&gt;#include &lt;complex&gt;#include &lt;memory&gt;                 //std::allocator  //#include &lt;ext\pool_allocator.h&gt;     //GCC使用，欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; using namespace std;namespace jj01&#123;    void test_primitives()    &#123;        cout &lt;&lt; &quot;\ntest_primitives().......... \n&quot;;        void* p1 = malloc(512);    //512 bytes        free(p1);        complex&lt;int&gt;* p2 = new complex&lt;int&gt;; //one object        delete p2;        void* p3 = ::operator new(512); //512 bytes        ::operator delete(p3);        //以下使用 C++ 標準庫提供的 allocators。        //其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。#ifdef _MSC_VER        //以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.        int* p4 = allocator&lt;int&gt;().allocate(3, (int*)0);        p4[0] = 666;        p4[1] = 999;        p4[2] = 888;        cout &lt;&lt; &quot;p4[0] = &quot; &lt;&lt; p4[0] &lt;&lt; endl;        cout &lt;&lt; &quot;p4[1] = &quot; &lt;&lt; p4[1] &lt;&lt; endl;        cout &lt;&lt; &quot;p4[2] = &quot; &lt;&lt; p4[2] &lt;&lt; endl;        allocator&lt;int&gt;().deallocate(p4, 3);#endif#ifdef __BORLANDC__        //以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.        int* p4 = allocator&lt;int&gt;().allocate(5);        allocator&lt;int&gt;().deallocate(p4, 5);#endif#ifdef __GNUC__        //以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.        //void* p4 = alloc::allocate(512);         //alloc::deallocate(p4,512);           //以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.            void* p4 = allocator&lt;int&gt;().allocate(7);        allocator&lt;int&gt;().deallocate((int*)p4, 7);        //以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.            void* p5 = __gnu_cxx::__pool_alloc&lt;int&gt;().allocate(9);        __gnu_cxx::__pool_alloc&lt;int&gt;().deallocate((int*)p5, 9);#endif    &#125;&#125; //namespaceint main(void)&#123;    jj01::test_primitives();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/wFWZoad.png"></p><p>可见 int* p4 = allocator<int>().allocate(3, (int*)0) 操作成功申请了三个int的空间。</p><h3 id="二、基本构件之-new-delete-expression"><a href="#二、基本构件之-new-delete-expression" class="headerlink" title="二、基本构件之 new/delete expression"></a>二、基本构件之 new/delete expression</h3><h4 id="1、内存申请"><a href="#1、内存申请" class="headerlink" title="1、内存申请"></a>1、内存申请</h4><p><img src="https://i.imgur.com/SU7545t.png"></p><p>上面这张图揭示了new操作背后编译器做的事：</p><ul><li>1、第一步通过operator new()操作分配一个目标类型的内存大小，这里是Complex的大小；</li><li>2、第二步通过static_cast将得到的内存块强制转换为目标类型指针，这里是Complex*</li><li>3、第三版调用目标类型的构造方法，但是需要注意的是，直接通过pc-&gt;Complex::Complex(1, 2)这样的方法调用构造函数只有编译器可以做，用户这样做将产生错误。</li></ul><p>值得注意的是，operator new()操作的内部是调用了malloc()函数。</p><h4 id="2、内存释放"><a href="#2、内存释放" class="headerlink" title="2、内存释放"></a>2、内存释放</h4><p><img src="https://i.imgur.com/FS9k7Lw.png"></p><p>同样地，delete操作第一步也是调用了对象的析构函数，然后再通过operator delete()函数释放内存，本质上也是调用了free函数。</p><h4 id="3、模拟编译器直接调用构造和析构函数"><a href="#3、模拟编译器直接调用构造和析构函数" class="headerlink" title="3、模拟编译器直接调用构造和析构函数"></a>3、模拟编译器直接调用构造和析构函数</h4><p>下面的代码测试环节为VS2013：</p><pre><code>#include &lt;iostream&gt;#include &lt;string&gt;//#include &lt;memory&gt;                 //std::allocator  using namespace std;namespace jj02&#123;    class A    &#123;    public:        int id;        A() : id(0)      &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        A(int i) : id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        ~A()             &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;    &#125;;    void test_call_ctor_directly()    &#123;        cout &lt;&lt; &quot;\ntest_call_ctor_directly().......... \n&quot;;        string* pstr = new string;        cout &lt;&lt; &quot;str= &quot; &lt;&lt; *pstr &lt;&lt; endl;        //! pstr-&gt;string::string(&quot;jjhou&quot;);          //[Error] &#39;class std::basic_string&lt;char&gt;&#39; has no member named &#39;string&#39;        //! pstr-&gt;~string();    //crash -- 其語法語意都是正確的, crash 只因為上一行被 remark 起來嘛.          cout &lt;&lt; &quot;str= &quot; &lt;&lt; *pstr &lt;&lt; endl;</code></pre><p>​<br>​            //————<br>​<br>            A* pA = new A(1);             //ctor. this=000307A8 id=1<br>            cout &lt;&lt; pA-&gt;id &lt;&lt; endl;       //1<br>            pA-&gt;A::A(3);<br>            cout &lt;&lt; pA-&gt;id &lt;&lt; endl;<br>            //!    pA-&gt;A::A(3);                //in VC6 : ctor. this=000307A8 id=3<br>            //in GCC : [Error] cannot call constructor ‘jj02::A::A’ directly</p><pre><code>        A::A(5);        //!    A::A(5);                      //in VC6 : ctor. this=0013FF60 id=5        //         dtor. this=0013FF60              //in GCC : [Error] cannot call constructor &#39;jj02::A::A&#39; directly        //         [Note] for a function-style cast, remove the redundant &#39;::A&#39;        cout &lt;&lt; pA-&gt;id &lt;&lt; endl;       //in VC6 : 3        //in GCC : 1              delete pA;                    //dtor. this=000307A8         //simulate new        void* p = ::operator new(sizeof(A));        cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; endl;     //p=000307A8        pA = static_cast&lt;A*&gt;(p);        pA-&gt;A::A(2);        //!    pA-&gt;A::A(2);                //in VC6 : ctor. this=000307A8 id=2        //in GCC : [Error] cannot call constructor &#39;jj02::A::A&#39; directly              cout &lt;&lt; pA-&gt;id &lt;&lt; endl;     //in VC6 : 2        //in GCC : 0              //simulate delete        pA-&gt;~A();                    //dtor. this=000307A8         ::operator delete(pA);        //free()    &#125;&#125; //namespaceint main(void)&#123;    jj02::test_call_ctor_directly();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/pFUmLy0.png"></p><p>VS下可以直接通过内存空间调用构造函数，但侯杰测试在GNU C下无法通过，具体的内容可见代码注解和打印效果。</p><h3 id="三、Array-new"><a href="#三、Array-new" class="headerlink" title="三、Array new"></a>三、Array new</h3><p><img src="https://i.imgur.com/aWEq4Ve.png"></p><p><strong>上图主要展示的是关于new array内存分配的大致情况。当new一个数组对象时（例如 new Complex[3]），编译器将分配一块内存，这块内存首部是关于对象内存分配的一些标记，然后下面会分配三个连续的对象内存，在使用delete释放内存时需要使用delete[]。如果不使用delete[]，只是使用delete只会将分配的三块内存空间释放，但不会调用对象的析构函数，如果对象内部还使用了new指向其他空间，如果指向的该空间里的对象的析构函数没有意义，那么不会造成问题，如果有意义，那么由于该部分对象析构函数不会调用，那么将会导致内存泄漏。图中new string[3]便是一个例子，虽然str[0]、str[1]、str[2]被析构了，但只是调用了str[0]的析构函数，其他对象的析构函数不被调用，这里就会出问题。</strong></p><p>下面将演示数组对象创建与析构过程：</p><p><img src="https://i.imgur.com/7FwNSzm.png"></p><pre><code>#include &lt;iostream&gt;#include &lt;new&gt;        //placement newusing namespace std;namespace jj03&#123;    class A    &#123;    public:        int id;        A() : id(0)      &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        A(int i) : id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;        ~A()             &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125;    &#125;;    void test_array_new_and_placement_new()    &#123;        cout &lt;&lt; &quot;\ntest_placement_new().......... \n&quot;;        size_t size = 3;        &#123;            //case 1            //模擬 memory pool 的作法, array new + placement new. 崩潰             A* buf = (A*)(new char[sizeof(A)*size]);            A* tmp = buf;            cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            for (int i = 0; i &lt; size; ++i)                new (tmp++) A(i);              //3次 调用ctor             cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            //!    delete [] buf;        //crash. why?            //因為這其實是個 char array，看到 delete [] buf; 編譯器會企圖喚起多次 A::~A.             // 但 array memory layout 中找不到與 array 元素個數 (本例 3) 相關的信息,             // -- 整個格局都錯亂 (從我對 VC 的認識而言)，於是崩潰。             delete buf;         //dtor just one time, ~[0]                cout &lt;&lt; &quot;\n\n&quot;;        &#125;        &#123;            //case 2            //回頭測試單純的 array new            A* buf = new A[size];  //default ctor 3 次. [0]先於[1]先於[2])            //A必須有 default ctor, 否則 [Error] no matching function for call to &#39;jj02::A::A()&#39;            A* tmp = buf;            cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            for (int i = 0; i &lt; size; ++i)                new (tmp++) A(i);          //3次 ctor             cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot;  tmp=&quot; &lt;&lt; tmp &lt;&lt; endl;            delete[] buf;    //dtor three times (次序逆反, [2]先於[1]先於[0])            &#125;        &#123;            //case 3                //掌握崩潰原因, 再次模擬 memory pool作法, array new + placement new.                 //不, 不做了, 因為 memory pool 只是供應 memory, 它並不管 construction,             //也不管 destruction. 它只負責回收 memory.             //所以它是以 void* 或 char* 取得 memory, 釋放 (刪除)的也是 void* or char*.              //不像本例 case 1 釋放 (刪除) 的是 A*.             //            //事實上 memory pool 形式如 jj04::test         &#125;    &#125;&#125; //namespaceint main(void)&#123;    jj03::test_array_new_and_placement_new();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/kcoXFR6.png"></p><p>构造函数调用顺序是按照构建对象顺序来执行的，但是析构函数执行却相反。值得注意的是，在调用了delete的大括号代码段中，数组有三个元素，但最后只调用了第一个对象的析构函数。</p><p>接下来将更具体地展示new array对象的内存分配情况：</p><p><img src="https://i.imgur.com/mQAjijM.png"></p><p>如果使用new分配十个内存的int，内存空间如上图所示，首先内存块会有一个头和尾，黄色部分为debug信息，灰色部分才是真正使用到的内存，蓝色部分的12bytes是为了让该内存块以16字节对齐。在这个例子中delete pi和delete[] pi效果是一样的，因为int没有析构函数。但是下面的例子就不一样了：</p><p><img src="https://i.imgur.com/RCX6Hfm.png"></p><p>上图通过new申请三个Demo空间大小，内存块使用了96byte，这里是这样计算得到的:黄色部分调试信息32 + 4 = 36byte；黄色部分下面的“3”用于标记实际分配给对象内存个数，这里是三个所以里面内容为3，消耗4byte；Demo内有三个int类型成员变量，一个Demo消耗内存3 * 4 = 12byte，由于有三个Demo，所以消耗了12 * 3 = 36byte空间；到目前为止消耗36 + 4 + 36 = 76byte，加上头尾cookie一共8byte一共消耗84byte，由于需要16位对齐，所以填充蓝色部分为12byte，一共消耗了84 + 12 = 96byte。这里释放内存时需要加上delete[]，上面分配内存中有个标记“3”，所以编译器将释放三个Demo对象空间，如果不加就会报错。</p><h3 id="四、placement-new"><a href="#四、placement-new" class="headerlink" title="四、placement new"></a>四、placement new</h3><p><img src="https://i.imgur.com/aWyButl.png"></p><h3 id="五、重载"><a href="#五、重载" class="headerlink" title="五、重载"></a>五、重载</h3><h4 id="1、C-内存分配的途径"><a href="#1、C-内存分配的途径" class="headerlink" title="1、C++内存分配的途径"></a>1、C++内存分配的途径</h4><p><img src="https://i.imgur.com/xAguah0.png"></p><p>如果是正常情况下，调用new之后走的是第二条路线，如果在类中重载了operator new()，那么走的是第一条路线，但最后还是要调用到系统的::operator new()函数，这在后续的例子中会体现。</p><p><img src="https://i.imgur.com/XkgjnI1.png"></p><p>对于GNU C，背后使用的allocate()函数最后也是调用了系统的::operator new()函数。</p><h4 id="2、重载new-和-delete"><a href="#2、重载new-和-delete" class="headerlink" title="2、重载new 和 delete"></a>2、重载new 和 delete</h4><p><img src="https://i.imgur.com/2o83TNy.png"></p><p>上面这张图演示了如何重载系统的::operator new()函数，该方法最后也是模拟了系统的做法，效果和系统的方法一样，但一般不推荐重载::operator new()函数，因为它对全局有影响，如果使用不当将造成很大的问题。</p><p><img src="https://i.imgur.com/KMrjz7s.png"></p><p>如果是在类中重载operator new()方法，那么该方法有N多种形式，但必须保证函数参数列表第一个参数是size_t类型变量；对于operator delete()，第一个参数必须是void* 类型，第二个size_t是可选项，可以去掉。</p><p><img src="https://i.imgur.com/sZrLSr8.png"></p><p>对于operator new[]和operator delete[]函数的重载，和前面类似。</p><p><img src="https://i.imgur.com/S2yG6Um.png"></p><p><img src="https://i.imgur.com/6D7odtt.png"></p><p><img src="https://i.imgur.com/KjGXpFs.png"></p><p><img src="https://i.imgur.com/GPW5wRa.png"></p><p><img src="https://i.imgur.com/0ZoNJdM.png"></p><p><img src="https://i.imgur.com/VgcPaVf.png"></p><p><img src="https://i.imgur.com/PcPsPWd.png"></p><h4 id="3、测试案例"><a href="#3、测试案例" class="headerlink" title="3、测试案例"></a>3、测试案例</h4><p>测试一：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;namespace jj06&#123;    class Foo    &#123;    public:        int _id;        long _data;        string _str;    public:        static void* operator new(size_t size);        static void  operator delete(void* deadObject, size_t size);        static void* operator new[](size_t size);        static void  operator delete[](void* deadObject, size_t size);        Foo() : _id(0)      &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125;        Foo(int i) : _id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125;        //virtual         ~Foo()              &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125;        //不加 virtual dtor, sizeof = 12, new Foo[5] =&gt; operator new[]() 的 size 參數是 64,         //加了 virtual dtor, sizeof = 16, new Foo[5] =&gt; operator new[]() 的 size 參數是 84,         //上述二例，多出來的 4 可能就是個 size_t 欄位用來放置 array size.     &#125;;    void* Foo::operator new(size_t size)    &#123;        Foo* p = (Foo*)malloc(size);        cout &lt;&lt; &quot;Foo::operator new(), size=&quot; &lt;&lt; size &lt;&lt; &quot;\t  return: &quot; &lt;&lt; p &lt;&lt; endl;        return p;    &#125;    void Foo::operator delete(void* pdead, size_t size)    &#123;        cout &lt;&lt; &quot;Foo::operator delete(), pdead= &quot; &lt;&lt; pdead &lt;&lt; &quot;  size= &quot; &lt;&lt; size &lt;&lt; endl;        free(pdead);    &#125;    void* Foo::operator new[](size_t size)    &#123;        Foo* p = (Foo*)malloc(size);  //crash, 問題可能出在這兒         cout &lt;&lt; &quot;Foo::operator new[](), size=&quot; &lt;&lt; size &lt;&lt; &quot;\t  return: &quot; &lt;&lt; p &lt;&lt; endl;        return p;    &#125;    void Foo::operator delete[](void* pdead, size_t size)    &#123;        cout &lt;&lt; &quot;Foo::operator delete[](), pdead= &quot; &lt;&lt; pdead &lt;&lt; &quot;  size= &quot; &lt;&lt; size &lt;&lt; endl;        free(pdead);    &#125;    //-------------        void test_overload_operator_new_and_array_new()    &#123;        cout &lt;&lt; &quot;\ntest_overload_operator_new_and_array_new().......... \n&quot;;        cout &lt;&lt; &quot;sizeof(Foo)= &quot; &lt;&lt; sizeof(Foo) &lt;&lt; endl;        &#123;            Foo* p = new Foo(7);            delete p;            Foo* pArray = new Foo[5];    //無法給 array elements 以 initializer             delete[] pArray;        &#125;        &#123;            cout &lt;&lt; &quot;testing global expression ::new and ::new[] \n&quot;;            // 這會繞過 overloaded new(), delete(), new[](), delete[]()             // 但當然 ctor, dtor 都會被正常呼叫.              Foo* p = ::new Foo(7);            ::delete p;            Foo* pArray = ::new Foo[5];            ::delete[] pArray;        &#125;    &#125;&#125; //namespaceint main(void)&#123;    jj06::test_overload_operator_new_and_array_new();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/c6l7tRe.png"></p><p>测试二：</p><pre><code>#include &lt;vector&gt;  //for test#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;namespace jj07&#123;    class Bad &#123; &#125;;    class Foo    &#123;    public:        Foo() &#123; cout &lt;&lt; &quot;Foo::Foo()&quot; &lt;&lt; endl; &#125;        Foo(int) &#123;            cout &lt;&lt; &quot;Foo::Foo(int)&quot; &lt;&lt; endl;            // throw Bad();          &#125;        //(1) 這個就是一般的 operator new() 的重載         void* operator new(size_t size)&#123;            cout &lt;&lt; &quot;operator new(size_t size), size= &quot; &lt;&lt; size &lt;&lt; endl;            return malloc(size);        &#125;        //(2) 這個就是標準庫已經提供的 placement new() 的重載 (形式)        //    (所以我也模擬 standard placement new 的動作, just return ptr)         void* operator new(size_t size, void* start)&#123;            cout &lt;&lt; &quot;operator new(size_t size, void* start), size= &quot; &lt;&lt; size &lt;&lt; &quot;  start= &quot; &lt;&lt; start &lt;&lt; endl;            return start;        &#125;        //(3) 這個才是嶄新的 placement new         void* operator new(size_t size, long extra)&#123;            cout &lt;&lt; &quot;operator new(size_t size, long extra)  &quot; &lt;&lt; size &lt;&lt; &#39; &#39; &lt;&lt; extra &lt;&lt; endl;            return malloc(size + extra);        &#125;        //(4) 這又是一個 placement new         void* operator new(size_t size, long extra, char init)&#123;            cout &lt;&lt; &quot;operator new(size_t size, long extra, char init)  &quot; &lt;&lt; size &lt;&lt; &#39; &#39; &lt;&lt; extra &lt;&lt; &#39; &#39; &lt;&lt; init &lt;&lt; endl;            return malloc(size + extra);        &#125;        //(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new)         //!      void* operator new(long extra, char init) &#123; //[Error] &#39;operator new&#39; takes type &#39;size_t&#39; (&#39;unsigned int&#39;) as first parameter [-fpermissive]        //!          cout &lt;&lt; &quot;op-new(long,char)&quot; &lt;&lt; endl;        //!        return malloc(extra);        //!      &#125;             //以下是搭配上述 placement new 的各個 called placement delete.         //當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起.         //應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory.          //(1) 這個就是一般的 operator delete() 的重載         void operator delete(void*, size_t)        &#123;            cout &lt;&lt; &quot;operator delete(void*,size_t)  &quot; &lt;&lt; endl;        &#125;        //(2) 這是對應上述的 (2)          void operator delete(void*, void*)        &#123;            cout &lt;&lt; &quot;operator delete(void*,void*)  &quot; &lt;&lt; endl;        &#125;        //(3) 這是對應上述的 (3)          void operator delete(void*, long)        &#123;            cout &lt;&lt; &quot;operator delete(void*,long)  &quot; &lt;&lt; endl;        &#125;        //(4) 這是對應上述的 (4)          //如果沒有一一對應, 也不會有任何編譯報錯         void operator delete(void*, long, char)        &#123;            cout &lt;&lt; &quot;operator delete(void*,long,char)  &quot; &lt;&lt; endl;        &#125;    private:        int m_i;    &#125;;</code></pre><p>​<br>​        //————-<br>​        void test_overload_placement_new()<br>​        {<br>​            cout &lt;&lt; “\n\n\ntest_overload_placement_new()………. \n”;<br>​<br>            Foo start;  //Foo::Foo</p><pre><code>        Foo* p1 = new Foo;           //op-new(size_t)        Foo* p2 = new (&amp;start) Foo;  //op-new(size_t,void*)        Foo* p3 = new (100) Foo;     //op-new(size_t,long)        Foo* p4 = new (100, &#39;a&#39;) Foo; //op-new(size_t,long,char)        Foo* p5 = new (100) Foo(1);     //op-new(size_t,long)  op-del(void*,long)        Foo* p6 = new (100, &#39;a&#39;) Foo(1); //        Foo* p7 = new (&amp;start) Foo(1);  //        Foo* p8 = new Foo(1);           //        //VC6 warning C4291: &#39;void *__cdecl Foo::operator new(unsigned int)&#39;        //no matching operator delete found; memory will not be freed if        //initialization throws an exception    &#125;&#125; //namespace    int main(void)&#123;    jj07::test_overload_placement_new();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/J7nEVmm.png"></p><h3 id="五、pre-class-allocator"><a href="#五、pre-class-allocator" class="headerlink" title="五、pre-class allocator"></a>五、pre-class allocator</h3><p><img src="https://i.imgur.com/o1landO.png"></p><p><img src="https://i.imgur.com/XeVjepx.png"></p><p>案例如下：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;using namespace std;namespace jj04&#123;    //ref. C++Primer 3/e, p.765    //per-class allocator     class Screen &#123;    public:        Screen(int x) : i(x) &#123; &#125;;        int get() &#123; return i; &#125;        void* operator new(size_t);        void  operator delete(void*, size_t);    //(2)        //! void  operator delete(void*);            //(1) 二擇一. 若(1)(2)並存,會有很奇怪的報錯 (摸不著頭緒)     private:        Screen* next;        static Screen* freeStore;        static const int screenChunk;    private:        int i;    &#125;;    Screen* Screen::freeStore = 0;    const int Screen::screenChunk = 24;    void* Screen::operator new(size_t size)    &#123;        Screen *p;        if (!freeStore) &#123;            //linked list 是空的，所以攫取一大塊 memory            //以下呼叫的是 global operator new            size_t chunk = screenChunk * size;            freeStore = p =                reinterpret_cast&lt;Screen*&gt;(new char[chunk]);            //將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來            for (; p != &amp;freeStore[screenChunk - 1]; ++p)                p-&gt;next = p + 1;            p-&gt;next = 0;        &#125;        p = freeStore;        freeStore = freeStore-&gt;next;        return p;    &#125;</code></pre><p>​<br>​        //! void Screen::operator delete(void *p)        //(1)<br>​        void Screen::operator delete(void *p, size_t)    //(2)二擇一<br>​        {<br>​            //將 deleted object 收回插入 free list 前端<br>​            (static_cast&lt;Screen*&gt;(p))-&gt;next = freeStore;<br>​            freeStore = static_cast&lt;Screen*&gt;(p);<br>​        }<br>​<br>        //————-<br>        void test_per_class_allocator_1()<br>        {<br>            cout &lt;&lt; “\ntest_per_class_allocator_1()………. \n”;</p><pre><code>        cout &lt;&lt; sizeof(Screen) &lt;&lt; endl;        //8            size_t const N = 100;        Screen* p[N];        for (int i = 0; i&lt; N; ++i)            p[i] = new Screen(i);        //輸出前 10 個 pointers, 用以比較其間隔         for (int i = 0; i&lt; 10; ++i)            cout &lt;&lt; p[i] &lt;&lt; endl;        for (int i = 0; i&lt; N; ++i)            delete p[i];    &#125;&#125; //namespaceint main(void)&#123;    jj04::test_per_class_allocator_1();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/AAD8dur.png"></p><p>每个对象以8byte对齐。内存池本质上是分配了一大块内存，然后将该内存分割为多个小块通过链表拼接起来，所以物理上不一定连续但是逻辑上是连续的。</p><p><img src="https://i.imgur.com/Va92P0d.png"></p><p><img src="https://i.imgur.com/DEjg6FL.png"></p><p>案例如下：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;using namespace std;namespace jj05&#123;    //ref. Effective C++ 2e, item10    //per-class allocator     class Airplane &#123;   //支援 customized memory management    private:        struct AirplaneRep &#123;            unsigned long miles;            char type;        &#125;;    private:        union &#123;            AirplaneRep rep;  //此針對 used object            Airplane* next;   //此針對 free list        &#125;;    public:        unsigned long getMiles() &#123; return rep.miles; &#125;        char getType() &#123; return rep.type; &#125;        void set(unsigned long m, char t)        &#123;            rep.miles = m;            rep.type = t;        &#125;    public:        static void* operator new(size_t size);        static void  operator delete(void* deadObject, size_t size);    private:        static const int BLOCK_SIZE;        static Airplane* headOfFreeList;    &#125;;    Airplane* Airplane::headOfFreeList;    const int Airplane::BLOCK_SIZE = 512;    void* Airplane::operator new(size_t size)    &#123;        //如果大小錯誤，轉交給 ::operator new()        if (size != sizeof(Airplane))        return ::operator new(size);        Airplane* p = headOfFreeList;        //如果 p 有效，就把list頭部移往下一個元素        if (p)            headOfFreeList = p-&gt;next;        else &#123;            //free list 已空。配置一塊夠大記憶體，            //令足夠容納 BLOCK_SIZE 個 Airplanes            Airplane* newBlock = static_cast&lt;Airplane*&gt;                (::operator new(BLOCK_SIZE * sizeof(Airplane)));            //組成一個新的 free list：將小區塊串在一起，但跳過             //#0 元素，因為要將它傳回給呼叫者。            for (int i = 1; i &lt; BLOCK_SIZE - 1; ++i)                newBlock[i].next = &amp;newBlock[i + 1];            newBlock[BLOCK_SIZE - 1].next = 0; //以null結束            // 將 p 設至頭部，將 headOfFreeList 設至            // 下一個可被運用的小區塊。            p = newBlock;            headOfFreeList = &amp;newBlock[1];        &#125;        return p;    &#125;    // operator delete 接獲一塊記憶體。    // 如果它的大小正確，就把它加到 free list 的前端    void Airplane::operator delete(void* deadObject,        size_t size)    &#123;        if (deadObject == 0) return;        if (size != sizeof(Airplane)) &#123;            ::operator delete(deadObject);            return;        &#125;        Airplane *carcass =            static_cast&lt;Airplane*&gt;(deadObject);        carcass-&gt;next = headOfFreeList;        headOfFreeList = carcass;    &#125;    //-------------    void test_per_class_allocator_2()    &#123;        cout &lt;&lt; &quot;\ntest_per_class_allocator_2().......... \n&quot;;        cout &lt;&lt; sizeof(Airplane) &lt;&lt; endl;    //8        size_t const N = 100;        Airplane* p[N];        for (int i = 0; i&lt; N; ++i)            p[i] = new Airplane;</code></pre><p>​<br>​            //隨機測試 object 正常否<br>​            p[1]-&gt;set(1000, ‘A’);<br>​            p[5]-&gt;set(2000, ‘B’);<br>​            p[9]-&gt;set(500000, ‘C’);<br>​            cout &lt;&lt; p[1] &lt;&lt; ‘ ‘ &lt;&lt; p[1]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[1]-&gt;getMiles() &lt;&lt; endl;<br>​            cout &lt;&lt; p[5] &lt;&lt; ‘ ‘ &lt;&lt; p[5]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[5]-&gt;getMiles() &lt;&lt; endl;<br>​            cout &lt;&lt; p[9] &lt;&lt; ‘ ‘ &lt;&lt; p[9]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[9]-&gt;getMiles() &lt;&lt; endl;<br>​<br>            //輸出前 10 個 pointers, 用以比較其間隔<br>            for (int i = 0; i&lt; 10; ++i)<br>                cout &lt;&lt; p[i] &lt;&lt; endl;</p><pre><code>        for (int i = 0; i&lt; N; ++i)            delete p[i];    &#125;&#125; //namespaceint main(void)&#123;    jj05::test_per_class_allocator_2();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/fM1lMiv.png"></p><p>这种做法有几点比较有意思，首先是使用了union保存链表元素的next指针，这样整体上可以节省空间；其次是delete函数，它并没有直接将目标元素删除，而是将它当作下一个可分配的内存空间，也就是说如果delete某元素，那么该元素占有的内存空间不会被free掉，而是在下一次调用new时分配给新的对象。</p><h3 id="六、static-allocator"><a href="#六、static-allocator" class="headerlink" title="六、static allocator"></a>六、static allocator</h3><p><img src="https://i.imgur.com/9dojXlJ.png"></p><p><img src="https://i.imgur.com/OrZw2Ik.png"></p><p><img src="https://i.imgur.com/akWdqgr.png"></p><p>代码如下：</p><pre><code>#include &lt;cstddef&gt;#include &lt;iostream&gt;#include &lt;complex&gt;using namespace std;namespace jj09&#123;    class allocator    &#123;    private:        struct obj &#123;            struct obj* next;  //embedded pointer        &#125;;    public:        void* allocate(size_t);        void  deallocate(void*, size_t);        void  check();    private:        obj* freeStore = nullptr;        const int CHUNK = 5; //小一點方便觀察     &#125;;    void* allocator::allocate(size_t size)    &#123;        obj* p;        if (!freeStore) &#123;            //linked list 是空的，所以攫取一大塊 memory            size_t chunk = CHUNK * size;            freeStore = p = (obj*)malloc(chunk);            //cout &lt;&lt; &quot;empty. malloc: &quot; &lt;&lt; chunk &lt;&lt; &quot;  &quot; &lt;&lt; p &lt;&lt; endl;            //將分配得來的一大塊當做 linked list 般小塊小塊串接起來            for (int i = 0; i &lt; (CHUNK - 1); ++i)    &#123;  //沒寫很漂亮, 不是重點無所謂.                  p-&gt;next = (obj*)((char*)p + size);                p = p-&gt;next;            &#125;            p-&gt;next = nullptr;  //last               &#125;        p = freeStore;        freeStore = freeStore-&gt;next;        //cout &lt;&lt; &quot;p= &quot; &lt;&lt; p &lt;&lt; &quot;  freeStore= &quot; &lt;&lt; freeStore &lt;&lt; endl;        return p;    &#125;    void allocator::deallocate(void* p, size_t)    &#123;        //將 deleted object 收回插入 free list 前端        ((obj*)p)-&gt;next = freeStore;        freeStore = (obj*)p;    &#125;    void allocator::check()    &#123;        obj* p = freeStore;        int count = 0;        while (p) &#123;            cout &lt;&lt; p &lt;&lt; endl;            p = p-&gt;next;            count++;        &#125;        cout &lt;&lt; count &lt;&lt; endl;    &#125;    //--------------    class Foo &#123;    public:        long L;        string str;        static allocator myAlloc;    public:        Foo(long l) : L(l) &#123;  &#125;        static void* operator new(size_t size)        &#123; return myAlloc.allocate(size); &#125;        static void  operator delete(void* pdead, size_t size)        &#123;            return myAlloc.deallocate(pdead, size);        &#125;    &#125;;    allocator Foo::myAlloc;</code></pre><p>​<br>​        class Goo {<br>​        public:<br>​            complex<double> c;<br>​            string str;<br>​            static allocator myAlloc;<br>​        public:<br>​            Goo(const complex<double>&amp; x) : c(x) {  }<br>​            static void* operator new(size_t size)<br>​            { return myAlloc.allocate(size); }<br>​            static void  operator delete(void* pdead, size_t size)<br>​            {<br>​                return myAlloc.deallocate(pdead, size);<br>​            }<br>​        };<br>​        allocator Goo::myAlloc;<br>​<br>        //————-<br>        void test_static_allocator_3()<br>        {<br>            cout &lt;&lt; “\n\n\ntest_static_allocator()………. \n”;</p><pre><code>        &#123;            Foo* p[100];            cout &lt;&lt; &quot;sizeof(Foo)= &quot; &lt;&lt; sizeof(Foo) &lt;&lt; endl;            for (int i = 0; i&lt;23; ++i) &#123;    //23,任意數, 隨意看看結果                 p[i] = new Foo(i);                cout &lt;&lt; p[i] &lt;&lt; &#39; &#39; &lt;&lt; p[i]-&gt;L &lt;&lt; endl;            &#125;            //Foo::myAlloc.check();            for (int i = 0; i&lt;23; ++i) &#123;                delete p[i];            &#125;            //Foo::myAlloc.check();        &#125;        &#123;            Goo* p[100];            cout &lt;&lt; &quot;sizeof(Goo)= &quot; &lt;&lt; sizeof(Goo) &lt;&lt; endl;            for (int i = 0; i&lt;17; ++i) &#123;    //17,任意數, 隨意看看結果                 p[i] = new Goo(complex&lt;double&gt;(i, i));                cout &lt;&lt; p[i] &lt;&lt; &#39; &#39; &lt;&lt; p[i]-&gt;c &lt;&lt; endl;            &#125;            //Goo::myAlloc.check();            for (int i = 0; i&lt;17; ++i) &#123;                delete p[i];            &#125;            //Goo::myAlloc.check();            &#125;    &#125;&#125; //namespace    int main(void)&#123;    jj09::test_static_allocator_3();    return 0;&#125;</code></pre><p>编译运行结果如下：</p><p><img src="https://i.imgur.com/czxP8JH.png"></p><p>之前的几个版本都是在类的内部重载了operator new()和operator delete()函数，这些版本都将分配内存的工作放在这些函数中，但现在的这个版本将这些分配内存的操作放在了allocator类中，这就渐渐接近了标准库的方法。从上面的代码中可以看到，两个类Foo和Goo中operator new()和operator delete()函数等很多部分代码类似，于是可以使用宏来将这些高度相似的代码提取出来，简化类的内部结构，但最后达到的结果是一样的：</p><p><img src="https://i.imgur.com/baXE2RO.png"></p><p><img src="https://i.imgur.com/nog6qAD.png"></p><h3 id="七、global-allocator"><a href="#七、global-allocator" class="headerlink" title="七、global allocator"></a>七、global allocator</h3><p>上面我们自己定义的分配器使用了一条链表来管理内存的，但标准库却用了多条链表来管理，这在后续会详细介绍：</p><p><img src="https://i.imgur.com/0M5X6lY.png"></p><h3 id="八、new-handler"><a href="#八、new-handler" class="headerlink" title="八、new handler"></a>八、new handler</h3><p><img src="https://i.imgur.com/TJ9GqFz.png"></p><p>如果用户调用new申请一块内存，如果由于系统原因或者申请内存过大导致申请失败，这时将抛出异常，在一些老的编译器中可能会直接返回0，可以参考上图右边代码，当无法分配内存时，operator new()函数内部将调用_calnewh()函数，这个函数通过左边的typedef传入，看程序员是否能自己写一个handler处理函数来处理该问题。一般有两个选择，让更多的Memory可用或者直接abort()或exit()。下面是测试的一个结果：</p><p><img src="https://i.imgur.com/JfazkE0.png"></p><p>该部分中自定义了处理函数noMoreMemory()并通过set_new_handler来注册该处理函数，在BCB4编译器中会调用到自定义的noMoreMemory()函数，但在右边的dev c++中却没有调用，这个还要看平台。</p><h3 id="九、-default和-delete"><a href="#九、-default和-delete" class="headerlink" title="九、=default和=delete"></a>九、=default和=delete</h3><p><img src="https://i.imgur.com/WUtaH2m.png"></p><p><img src="https://i.imgur.com/2lxEgBI.png"></p><p>更加详细的内容可以参考下面这篇文章:</p><blockquote><p><a href="https://blog.csdn.net/u012333003/article/details/25299939">https://blog.csdn.net/u012333003/article/details/25299939</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-内存管理&quot;&gt;&lt;a href=&quot;#C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;C++内存管理&quot;&gt;&lt;/a&gt;C++内存管理&lt;/h2&gt;&lt;h3 id=&quot;一、四种内存分配和释放方法&quot;&gt;&lt;a href=&quot;#一、四种内存分配和释放方法&quot; class=&quot;</summary>
      
    
    
    
    <category term="c++" scheme="http://icecorn.github.io/categories/c/"/>
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/c/ReadingNotes/"/>
    
    
    <category term="C++内存管理机制" scheme="http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Games-101|光线追踪部分</title>
    <link href="http://icecorn.github.io/2022/03/25/Games-101/Games101-%E5%85%89%E8%BF%BD%E9%83%A8%E5%88%86/"/>
    <id>http://icecorn.github.io/2022/03/25/Games-101/Games101-%E5%85%89%E8%BF%BD%E9%83%A8%E5%88%86/</id>
    <published>2022-03-25T09:25:10.000Z</published>
    <updated>2022-06-29T14:59:01.221Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Games101-光追部分"><a href="#Games101-光追部分" class="headerlink" title="Games101 光追部分"></a>Games101 光追部分</h1><h2 id="Ray-Tracing"><a href="#Ray-Tracing" class="headerlink" title="Ray Tracing"></a>Ray Tracing</h2><p>光栅化是局部光照模型，无法体现出全局光照的效果（比如软阴影，全局光照，glossy reflection)</p><p>所以出现了光线追踪技术，但是光追相比光栅化很慢</p><p>从每个像素射出一根光线，打到好多物体，这里可以很方便的得到深度信息</p><p> <img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618131619.png"></p><p>有了焦点，将焦点和光源连接，如果没有遮挡就着色，如果有遮挡说明这个位置在这个光源形成的阴影里</p><h2 id="Whitted-Style-Ray-Tracing"><a href="#Whitted-Style-Ray-Tracing" class="headerlink" title="Whitted-Style Ray Tracing"></a>Whitted-Style Ray Tracing</h2><p>递归处理的光追</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618132157.png"></p><p>模拟光的折射和反射，然后将下图中的红色框住的点分别进行着色，然后在进行加权最后作为该像素的颜色，当然还要考虑阴影信息，判断某一个点是否要进入加权。这里我们可以控制反射/折射的次数</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618132444.png"></p><h3 id="光线和物体求交点"><a href="#光线和物体求交点" class="headerlink" title="光线和物体求交点"></a>光线和物体求交点</h3><p>Ray-Surface Intersection</p><p>定义射线，有点O和方向d来表示</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133112.png"></p><h4 id="隐式表面"><a href="#隐式表面" class="headerlink" title="隐式表面"></a>隐式表面</h4><p>求光线和球的交点</p><p>交点P既在射线上又在球上，只有t未知，联立求解</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133254.png"></p><p>t必须是正的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133453.png"></p><p>针对复杂的隐式表达的曲面，都可以用这种方法求解，数值计算</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618133837.png"></p><h4 id="显示表面"><a href="#显示表面" class="headerlink" title="显示表面"></a>显示表面</h4><p>光线和三角网格求交点，遍历每个三角面片求角点（必然为0或1个交点）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618134027.png"></p><p>先求光线和三角面片所在平面的角点，在判断交点是否在三角形内</p><p><strong>平面可以用一个点+平面法向来定义</strong></p><p><img src="C:\Users\Jun\AppData\Roaming\Typora\typora-user-images\image-20220618134411190.png" alt="image-20220618134411190"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618134447.png"></p><p>另一种直接算交点的方法</p><p>直接用重心坐标进行联立等式求解</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618134757.png"></p><h4 id="加速求交点"><a href="#加速求交点" class="headerlink" title="加速求交点"></a>加速求交点</h4><p>光线和每个面片都算一遍求交太慢了，需要进行加速</p><h2 id="利用包围盒和空间、物体划分方法加速光追"><a href="#利用包围盒和空间、物体划分方法加速光追" class="headerlink" title="利用包围盒和空间、物体划分方法加速光追"></a>利用包围盒和空间、物体划分方法加速光追</h2><h3 id="轴对齐包围盒"><a href="#轴对齐包围盒" class="headerlink" title="轴对齐包围盒"></a>轴对齐包围盒</h3><p>Axis-Aligned Bounding Box</p><p>思想就是将模型包围起来，如果一个光线和包围盒都没有交点，那么它一定和模型没有交点，这样只用考虑6个面就好了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618135528.png"></p><p>判断光线和盒子是否相交</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618140144.png"></p><p>求三组tmin和tmax的交集得出tenter和texit</p><p>当且仅当下方红框，光线和包围盒有交点</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618142323.png"></p><p>另外要说的一点是这个盒子其实都是和着色空间轴平行的盒子，这样方便计算</p><hr><h3 id="空间划分算法"><a href="#空间划分算法" class="headerlink" title="空间划分算法"></a>空间划分算法</h3><p>利用AABB包围盒的空间划分加速算法</p><h4 id="均匀空间划分"><a href="#均匀空间划分" class="headerlink" title="均匀空间划分"></a>均匀空间划分</h4><p>Uniform Spatial Partitions(Grids)</p><p>对每个物体求一个包围盒，在与三角形面求交之前先对包围盒求交，这样不是已经可以达到不错加速效果了吗？作者认为可以考虑这样两个极端情况：</p><p><strong>1 整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升</strong></p><p><strong>2 整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限</strong></p><p>基于以上两点考虑，AABB并不应只局限于以<strong>物体模型</strong>为单位，可以更加精细的考虑到以<strong>三角面</strong>为单位。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。 <strong>因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！</strong> (以下的划分形成的AABB更是一种general的概念，可能不会严格包围物体，读者不必纠结)</p><p>那么接下来就从最简单的划分方法，均匀空间划分开始介绍。 第一步对所要考虑的场景找一个包围盒：</p><ul><li>找包围盒</li><li>画网格</li><li>在每个格子上存储物体模型</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618144723.png"></p><p>紧接着，根据光线的方向与判断出所有相交的方格(这一步可以利用bresenham算法，就是如何光栅化一条线)，倘若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交。</p><p>光线和格子求交点是非常快的</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618144949.png"></p><p>以上就是均匀空间划分的全部过程了，简单来说就是将空间划分为多个均匀的小的AABB，再根据光线方向找出相交grid(这一步并不需要判断所有方格，正如上文提示，可以用brenham类似的方法来做)，再判断grid中是否存储了模型信息，若有则进一步求交。（这种划分方法假设了找出相交方格要比直接判断与物体求交相对容易，因此划分方格数的多少也是性能的关键，方格太少，没有加速效果，方格太多，判断与方格的求交可能会拖累效率）</p><p>因此这种方法最适合的场景就是空间中均匀布满了三角形面，如果说场景较为空旷，物体较小且分离得比较开，那么均匀分割的效果就会很差了，因为会有很多无效的方格与光线的求交过程。</p><h4 id="KD-Tree空间划分"><a href="#KD-Tree空间划分" class="headerlink" title="KD-Tree空间划分"></a>KD-Tree空间划分</h4><p>几种空间划分算法：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618153918.png"></p><p>第一种Oct-Tree，也就是八叉树，每次将空间分为8个相等的部分，再递归的对子空间进行划分，因为图中是2维例子，所以只划分了4部分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。</p><p>第二种KD-Tree，也是本小节将要主要介绍的方法，其每次将空间划分为两部分，且划分依次沿着x-axis，y-axis，z-axis，即如图中所示，第一次横着将2维空间分为上下，第二次再竖着将上下两个子空间分别划分为左右部分，依次递归划分，终止条件与八叉树类似，细节问题之后按具体例子详解。</p><p>第三种BSP-Tree，其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。</p><p>接下来从一个例子具体介绍KD-Tree 第一步将空间分为两部分</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618192037.png"></p><p>第二步对左右两个子空间换个方向再分为两部分(这里只画出了有半部分，其实左边也是一样)</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618192135.png"></p><p>如此递归的划分下去，且在划分过程当中遵循这样几点：</p><p><strong>1 依次沿着x-axis,y-axis,z-axis划分，使得空间被划分的更加平衡</strong></p><p><strong>2 划分的位置由空间中三角面的分布决定，具体细节不展开</strong></p><p><strong>3 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间</strong></p><p><strong>4 当划分空间太小或是子空间内只有少量三角形则停止划分</strong></p><p>当KD-Tree建立完成之后，如何进行光线与物体求交判断呢？过程如下： 第一步判断光线是否与最外层的包围盒相交</p><p><img src="https://pic2.zhimg.com/80/v2-e5a612ef01ef5fd4b0f4e7b45f721009_720w.jpg" alt="img"></p><p>如果相交进一步判断是否与对应的两个子空间相交</p><p><img src="https://pic4.zhimg.com/80/v2-2f840d662f0d7b5dd95aadab4c4d08fb_720w.jpg" alt="img"></p><p>注意！因图中做了简化，最大包围盒的左半边并没继续进行划分(实际上应该要划分的)，所以左半部分对应的1号空间是叶子节点，如果光线与之相交，进一步判断与存储与叶子节点的物体信息求交。左半边判断完之后，接着判断右半部分</p><p><img src="https://pic4.zhimg.com/80/v2-0ccfa5171938411f65203465d41ea353_720w.jpg" alt="img"></p><p>同样如果对于有半部分存在相交情况，则对于右半部分的所有子空间，递归的执行这个步骤即可</p><p><img src="https://pic3.zhimg.com/80/v2-63048362e98117dfa53ace2a6810cffe_720w.jpg" alt="img"></p><p>更加具体的过程不再展开。</p><p><strong>优点：</strong> 利用KD-Tree的结构来构建AABB的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，在原始的纯粹的AABB之上更进一步提升了加速效率。</p><p><strong>缺点：</strong> </p><ul><li>缺点是判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单</li><li>其次同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面</li></ul><p>综上所述，我们详细介绍了利用AABB的均匀划分方法，KD-Tree划分方法，也简略提及了Oct-Tree以及BSP-Tree。但其实这些技术在业界之中以及逐渐不再被多使用，但依然有很多借鉴参考价值，在下面一节会介绍一种现在被广泛使用的加速光线追踪的方法，即Bounding Volume Hierarchy。</p><h4 id="BVH划分-对物体的划分"><a href="#BVH划分-对物体的划分" class="headerlink" title="BVH划分(对物体的划分)"></a>BVH划分(对物体的划分)</h4><p>Bounding Volume Hierarchy</p><p>BVH与前几种方法最显著的区别  就是，<strong>不再以空间作为划分依据，而是从对象的角度考虑，即三角形面</strong>，过程如下： 第一步同样找出场景的整体包围盒作为根节点</p><p><img src="https://pic2.zhimg.com/80/v2-70193926724bf8bc2a5bae00bbd7ddb1_720w.jpg" alt="img"></p><p>第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒</p><p><img src="https://pic1.zhimg.com/80/v2-bca572b39a57a86697aa9f35c35c6240_720w.jpg" alt="img"></p><p>注意到这里，<strong>包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内，而这也就解决了KD-Tree的缺点！</strong> 接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤</p><p><img src="https://pic4.zhimg.com/80/v2-ab08eb6c85843a732f78828644f02117_720w.jpg" alt="img"></p><p>最终可以建立出如上图的所示的树形结构，同样为了画图方便，只进行了左半部分的划分，右半部分其实同理。</p><p>tips：</p><ol><li>每次划分一般选择最长的那一轴划分，假设是x轴，那么划分点选择所有三角面的重心坐标在x坐标上的中位数进行划分（快排思想二分，O(n）)，如此便能保证划分的三角形左右两边三角形数量尽可能差不多，<strong>当然也就使得树形结构建立的更加平衡，深度更小，平均搜索次数更少，提高了效率</strong>，这些都是数据结构的知识，相信大家掌握的都不错，就不多赘述了。</li><li>与KD-Tree一样，中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少 （e.g. 5个）</li></ol><p>最后给出这样一个BVH加速结构遍历节点的伪代码参考：</p><p><img src="https://pic4.zhimg.com/80/v2-d626a6bf35f46e6372c8bb3cb246d84b_720w.jpg" alt="img"></p><hr><h2 id="基于物理渲染的基础知识"><a href="#基于物理渲染的基础知识" class="headerlink" title="基于物理渲染的基础知识"></a>基于物理渲染的基础知识</h2><p>首先要说明的是通过上文的处理我们获得了交点，并且简单的使用blinn-Phong模型加权平均来着色，这显然是不准确的，而PBR就是在如何正确处理着色的方法。</p><h3 id="为什么需要辐射度量学？"><a href="#为什么需要辐射度量学？" class="headerlink" title="为什么需要辐射度量学？"></a>为什么需要辐射度量学？</h3><p>首先，想一想到目前为止我们对光线亮度的定义是什么？只是简单的用3维(R,G,B)向量来描述，但却没有任何的单位，如果想要一个完全正确的模型，这显然是不应该的，必须用合适的物理量来描述光线！</p><p>其次，考虑在前两篇文章中提到的whited-style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下：</p><p><strong>1 whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色</strong></p><p><strong>2 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的</strong></p><p>而就以上的各种缺点而言，所有的问题都能在辐射度量学之中得到完美解决！</p><h3 id="辐射度量学"><a href="#辐射度量学" class="headerlink" title="辐射度量学"></a>辐射度量学</h3><p>辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。</p><p>几个基本概念：</p><ul><li> <strong>辐射能量(Radiant energy)</strong></li><li> <strong>辐射通量(Radiant flux)</strong></li><li><strong>辐射强度(Radiant intensity)</strong></li><li><strong>irradiance</strong></li><li><strong>radiance</strong></li></ul><h4 id="辐射能量和辐射通量"><a href="#辐射能量和辐射通量" class="headerlink" title="辐射能量和辐射通量"></a>辐射能量和辐射通量</h4><p>Radiant energy定义： </p><p><img src="https://pic1.zhimg.com/v2-af57b246bdaf1e68e219ad003ededa68_b.jpg" alt="img"></p><p> 所谓辐射能量其实非常直观，就是辐射出来的电磁能量，单位为焦耳。可以用物理当中的做功的大小来进行类比。</p><p>接下来是Radiant flux(power)： </p><p><img src="https://pic2.zhimg.com/v2-e66e744741aacbb2f311c3b8cfa5284d_b.png" alt="img"></p><p> 所谓辐射通量或者说辐射功率，其实就是在辐射能量的基础之上除以时间，也就是单位时间的能量。同样也可以用物理当中的功率来进行类比。<strong>在光学中能量的单位通常用lumen流明</strong></p><p>(tips: 具体来说一般偏向用radiant flux来衡量光线的亮度，因为我们更关心的是单位时间的效果，事实上也是这么做的，想想在说白炽灯泡的时候也是说60W亮度，80W亮度)</p><h4 id="辐射强度"><a href="#辐射强度" class="headerlink" title="辐射强度"></a>辐射强度</h4><p>在进行具体的数学定义之前，先借助如下一张图建立对剩下3个概念的一些直观的理解： </p><p><img src="https://pic1.zhimg.com/v2-039fbcb784ca5531560b50b69a9cca68_b.jpg" alt="img"></p><ul><li><p><strong>Radiant itensity其实就是指从一个光源出发某一方向上的亮度</strong></p></li><li><p><strong>Irradiance指某一微小平面所接受到的光线亮度</strong></p></li><li><p><strong>radiance衡量的是一条传播光线所具有的亮度(不受传播方向影响而改变)</strong></p></li></ul><p>（这里的亮度也可以理解为radiant flux(power)。）</p><p>好了，接下来首先看Radiant intensity的数学定义： </p><p><img src="https://pic1.zhimg.com/v2-ff2e020aa81d545c785a4dc0d558bca8_b.jpg" alt="img"></p><p> Radiant intensity一句话来说就是从光源发出的<strong>每单位立体角上的功率</strong>，关于辐射功率的定义在上文已经解释，这里唯一还不知道的就是立体角(solid angle)了。</p><p>solid angle其实就是对应二维空间中圆的弧度在三维空间中球上的拓展。 首先看在二维计算弧度公式如下： </p><p><img src="https://pic1.zhimg.com/v2-cfbc6ba4ed667f7586b946364f73b27c_b.jpg" alt="img"></p><p> 即 <img src="https://www.zhihu.com/equation?tex=%5Ctheta+=+%5Cfrac%7Bl%7D%7Br%7D" alt="[公式]">(至于为什么这么算，中学知识这里就不展开了。)</p><p>那么对应在三维上的球的弧度(立体角)，只需进行一个简单的扩展如下： </p><p><img src="https://pic2.zhimg.com/v2-c181f1010783556ce6fb8d1755ba8185_b.jpg" alt="img"></p><p> 即立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为<img src="https://www.zhihu.com/equation?tex=4%5Cpi" alt="[公式]">。</p><p>那么对于Radiant intensity的定义当中，微分立体角<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">计算如下： </p><p><img src="https://pic2.zhimg.com/v2-08bd4e7fe0adbef6e11f8dc77f344001_b.jpg" alt="img"></p><p> 首先确定空间中一个方向(通过<img src="https://www.zhihu.com/equation?tex=%5Ctheta,%5Cphi" alt="[公式]">)，在这两个角度上分别增加一个微分值，则可以计算出如图中所示的对应到球上的投影面积。其中<img src="https://www.zhihu.com/equation?tex=rd%5Ctheta" alt="[公式]">就是微分面积元的高，<img src="https://www.zhihu.com/equation?tex=rsin%5Ctheta+d%5Cphi" alt="[公式]">是微分面积元的宽，二者相乘，自然就是面积了，再根据立体角的定义除以 <img src="https://www.zhihu.com/equation?tex=r%5E2" alt="[公式]"> 即可得到微分立体角了。</p><p>在此还可以验证下，对<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">在整个球上积分：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5COmega+&=%5Cint_%7BS%5E%7B2%7D%7D+%5Cmathrm%7Bd%7D+%5Comega+%5C%5C+&=%5Cint_%7B0%7D%5E%7B2+%5Cpi%7D+%5Cint_%7B0%7D%5E%7B%5Cpi%7D+%5Csin+%5Ctheta+%5Cmathrm%7Bd%7D+%5Ctheta+%5Cmathrm%7Bd%7D+%5Cphi+%5C%5C+&=4+%5Cpi+%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>与之前所讲的球的立体角为<img src="https://www.zhihu.com/equation?tex=4%5Cpi" alt="[公式]">一致。</p><p><strong>tips：</strong></p><p>注意在计算微分立体角之前，我们其实选定了空间当中的一个方向（由<img src="https://www.zhihu.com/equation?tex=%5Ctheta,%5Cphi" alt="[公式]">所确定），称这个方向为<img src="https://www.zhihu.com/equation?tex=%5Comega" alt="[公式]">，然后才在此基础之上分别对<img src="https://www.zhihu.com/equation?tex=%5Ctheta,%5Cphi" alt="[公式]">增加<img src="https://www.zhihu.com/equation?tex=d%5Ctheta,d%5Cphi" alt="[公式]">经计算得到最终的<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">，因此Radiant intensity的物理含义此时就很清楚了，为光源向某一方向所发射出的单位立体角的功率，简而言之就是光源在某个方向上的亮度如何！</p><p>最后举一个对各向同性点光源计算Radiant intensity的例子： </p><p><img src="https://pic3.zhimg.com/v2-ee0c1e7d905b47a0de73f60238b29f2e_b.jpg" alt="img"></p><p> 因为各项同性点光源所有方向上的亮度都与方向无关，因此立体角可以直接积分出来为<img src="https://www.zhihu.com/equation?tex=4%5Cpi" alt="[公式]">，最终计算得<img src="https://www.zhihu.com/equation?tex=I+=+%5Cfrac%7B%5CPhi%7D%7B4%5Cpi%7D" alt="[公式]">。 (如果不是各项同性的话这里的<img src="https://www.zhihu.com/equation?tex=I(%5Comega)" alt="[公式]">应该为一个关于<img src="https://www.zhihu.com/equation?tex=%5Comega" alt="[公式]">方向的的函数)</p><p><strong>以上就已经详细介绍完了关于Radiant intensity的定义，接下来给出irradiance的相关定义</strong></p><h4 id="irradiance"><a href="#irradiance" class="headerlink" title="irradiance"></a>irradiance</h4><p><img src="https://pic3.zhimg.com/v2-594c083ca0df39a60bd1021a0449d93a_b.jpg" alt="img"></p><p> 同样用一句话来说，irradiance是指每单位<strong>照射</strong>面积所接收到的power，单位如图中所示。 借助于irradiance，可以很轻松的解释在Blinn-Phong所提到的Lambert’s Law,即光线亮度在计算时需要乘上一个<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">，如下图所示： </p><p><img src="https://pic1.zhimg.com/v2-783a8236548da199f5f463bec1067314_b.jpg" alt="img"></p><p> 当光线垂直照射平面时，如上图左边所示，<strong>照射</strong>到平面上的面积与光线本身的“宽度一致”。但当光线斜着照射到平面时，此时的<strong>照射</strong>面积就不再是光线本身的“宽度”了，具体来说此时的照射面积<img src="https://www.zhihu.com/equation?tex=A_2+=+A/cos%5Ctheta" alt="[公式]">。</p><p>那么针对右边情况的irradiance的计算就应该为：</p><p><img src="https://www.zhihu.com/equation?tex=E2+=+%5CPhi/A_2=%5CPhi+cos%5Ctheta/A" alt="[公式]">，相对于<img src="https://www.zhihu.com/equation?tex=E1=%5CPhi/A" alt="[公式]">多了一个<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">。</p><p>而这其实也就解释了Lambert’s Law要乘以一个<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">的原因了。</p><p>此外，回想一下也是在Blinn-Phong模型所提到的光线越远会越加衰减： </p><p><img src="https://pic3.zhimg.com/v2-1b60efad48a95bee425e70b4ee638fa6_b.jpg" alt="img"></p><p> 该现象也完全可以用irradiance解释，因为光的功率始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的面积值也就越大，irradiance也就越小。</p><h4 id="radiance"><a href="#radiance" class="headerlink" title="radiance"></a>radiance</h4><p>最后，我们终于来到了最后一条概念了，这条概念也是所有辐射度量学的概念当中最为重要的一个，那么首先直接就来看他的数学定义是怎么样的： </p><p><img src="https://pic2.zhimg.com/v2-2abc66f02abec7c085ed78e41033015d_b.jpg" alt="img"></p><p> 用一句话概述的话，所谓radiance就是指<strong>每单位立体角，每单位垂直面积的功率</strong>，直观来看的话，很像是Intensity和irradiance的结合。<strong>它同时指定了光的方向与照射到的表面所接受到的亮度</strong>。</p><p>但这里有一个细微的区别，在irradiance中定义的<strong>每单位照射面积</strong>，而在radiance当中，为了更好的使其成为描述一条光线传播中的亮度，且在传播过程当中大小不随方向改变，所以在定义中关于接收面积的部分是<strong>每单位垂直面积</strong>，而这一点的不同也正解释了图中式子分母上的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">，具体可以观察如下图： </p><p><img src="https://pic4.zhimg.com/v2-f4069d6992189e1bd74eb8d4af371dbb_b.jpg" alt="img"></p><p> 即图中的<img src="https://www.zhihu.com/equation?tex=dA" alt="[公式]">是irradiance中定义所对应的，而<img src="https://www.zhihu.com/equation?tex=%7Bd%7D+A%5E%7B%5Cperp%7D" alt="[公式]">才是radiance中所定义的面积。二者之间的关系为<img src="https://www.zhihu.com/equation?tex=%7Bd%7D+A%5E%7B%5Cperp%7D+=+dAcos%5Ctheta" alt="[公式]">。</p><p>(以上各项定义确实比较绕，我在闫老师的讲解上又去借鉴了PBR书中的定义，对这些概念加以了自己的解释，希望能对大家有帮助！)</p><p>好了，在理解了radiance和irradiance的定义之后，再讨论讨论它们之间的关系，通过二者的定义式子，不难得出如下结果：</p><p><img src="https://www.zhihu.com/equation?tex=L(%5Cmathrm%7Bp%7D,+%5Comega)=%5Cfrac%7B%5Cmathrm%7Bd%7D+E(%5Cmathrm%7Bp%7D)%7D%7B%5Cmathrm%7Bd%7D+%5Comega+%5Ccos+%5Ctheta%7D+%5C%5C" alt="[公式]"></p><p>进一步推导得到： </p><p><img src="https://pic4.zhimg.com/v2-91a45fb046a362b5c6c4b767b231354b_b.jpg" alt="img"></p><p> 观察一下积分后的式子，<img src="https://www.zhihu.com/equation?tex=E(p)" alt="[公式]">就是点p的irradiance，其物理含义是上文所提到过的点p上<strong>每单位照射面积的功率</strong>，而<img src="https://www.zhihu.com/equation?tex=L_i(p,%5Comega)" alt="[公式]">指入射光<strong>每立体角，每垂直面积的功率</strong>，因此积分式子右边的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">解释了面积上定义的差异，而对<img src="https://www.zhihu.com/equation?tex=d%5Comega" alt="[公式]">积分，则是相当于对所有不同角度的入射光线做一个求和，那么该积分式子的物理含义便是，一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到。</p><h3 id="双向反射分布函数-BRDF"><a href="#双向反射分布函数-BRDF" class="headerlink" title="双向反射分布函数(BRDF)"></a>双向反射分布函数(BRDF)</h3><p>Bidirectional Scattering Distribution Function</p><p>通过上述所有辐射度量学各种概念的定义之后，我们可以从这样一个角度理解光线的反射，如下图所示： </p><p><img src="https://pic2.zhimg.com/v2-4b994e259e57655f1145a51b3832ac75_b.jpg" alt="img"></p><p><strong>一个点(微分面积元)在接受到一定方向上的亮度(</strong><img src="https://www.zhihu.com/equation?tex=dE(%5Comega_i)" alt="[公式]"><strong>)之后，再向不同方向把能量辐射出去(</strong><img src="https://www.zhihu.com/equation?tex=dL_r(%5Comega_r)" alt="[公式]"><strong>)</strong></p><p>从直观的理解来说，不同物体表面材质自然会把一定方向上的入射亮度(<img src="https://www.zhihu.com/equation?tex=dE(%5Comega_i))" alt="[公式]">反射到不同的方向的光线上(<img src="https://www.zhihu.com/equation?tex=dL_r(%5Comega_r)" alt="[公式]">)， <strong>如理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有。如理想粗糙表面会把入射光线均匀的反射到所有方向。因此所谓BRDF就是描述这样一个从不同方向入射之后，反射光线分布情况的函数</strong>，定义如下： </p><p><img src="https://pic4.zhimg.com/v2-690f3e96bd2730eeda4255a21c9e330f_b.jpg" alt="img"></p><p> 上图中下方的式子即为BRDF，它接收两个参数，入射光方向<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">,反射光方向<img src="https://www.zhihu.com/equation?tex=%5Comega_r" alt="[公式]">，函数值为反射光的radiance与入射光的iiradiance的比值。(从某个方向接受到的光能有多少反射到另外一个方向)</p><p>借助BRDF，可以定义出<strong>反射方程</strong>如下： </p><p><img src="https://pic2.zhimg.com/v2-ac12ff2871a3666a07b1d91b8820d4d9_b.jpg" alt="img"></p><p> 即摄像机所接受到的<img src="https://www.zhihu.com/equation?tex=%5Comega_r" alt="[公式]">方向上的反射光，是由所有不同方向上入射光线的irradiance贡献得到的(即图中式子的<img src="https://www.zhihu.com/equation?tex=L_%7Bi%7D%5Cleft(%5Cmathrm%7Bp%7D,+%5Comega_%7Bi%7D%5Cright)+%5Ccos+%5Ctheta_%7Bi%7D+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D" alt="[公式]">)，而不同方向入射光线的irradiance对反射方向<img src="https://www.zhihu.com/equation?tex=%5Comega_r" alt="[公式]">的贡献程度则由物体表面材质决定，所以乘上了一个BRDF函数。</p><p>到这里，通过辐射度量学，以及BRDF最终得到的反射方程正是一个<strong>完全正确的光线传播模型了</strong>，解决了在第一章提到的现有模型的所有缺点！（渲染方程只是在反射方程的基础之上加了一个自发光项，关于渲染方程会在下一章仔细去了解)。</p><p>在进入到渲染方程之前，再仔细观察一下反射方程： </p><p><img src="https://pic3.zhimg.com/v2-713d854abe8bcc32710b7292563326a6_b.jpg" alt="img"></p><p> 不难发现正如上图中所说的，入射光线的radiance不仅仅是光源所引起的，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p(即间接光照)，同时其他物体上的反射光线的radiance依然也是由直接光照和间接光照构成，因此这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程。所以说想要解这样一个方程还是比较难的。</p><p>接下来，在最后一章我们会引入渲染方程，并对渲染方程做一些直观上的物理解释，对于反射方程或者说是渲染方程的具体求解，留在下一篇文章里面去说。</p><h3 id="渲染方程及其物理含义解释"><a href="#渲染方程及其物理含义解释" class="headerlink" title="渲染方程及其物理含义解释"></a>渲染方程及其物理含义解释</h3><p>正如在上一节中提到的，渲染方程知识在反射方程的基础之上添加了一个自发光项(Emission term)，从而使得反射方程更加的general：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=L_%7Be%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)+%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>其中<img src="https://www.zhihu.com/equation?tex=L_e(p,%5Comega_o)" alt="[公式]">为自发光项，反射方程中的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta" alt="[公式]">用，<img src="https://www.zhihu.com/equation?tex=n%5Ccdot%5Comega_i" alt="[公式]">代替。 (tips：所有光线方向均指向外)</p><p>接下来从一个点光源和单个物体的场景开始理解渲染方程： </p><p><img src="https://pic2.zhimg.com/v2-80d5e7a9cb7533eaa48ea76f658a56c1_b.jpg" alt="img"></p><p> (点光源对一个点来说自然只有一个方向有入射光，所以这里没有了积分)</p><p>多个点光源一个物体的情况： </p><p><img src="https://pic1.zhimg.com/v2-6bf8c6b5bee54674648d8805a34c133c_b.jpg" alt="img"></p><p> 将这些所有的点光源的贡献全部求和即可，那么如果点光源变成了面光源呢？如下图所示： </p><p><img src="https://pic2.zhimg.com/v2-20ef57e7db1040edd7de6797b0df91bd_b.jpg" alt="img"></p><p> 其实面光源就相当于无穷多个点光源的集合，只需要对 面光源所在的立体角范围进行积分，并且能够确定不同立体角方向的面光源的入射光radiance即可。</p><p>那么更进一步的，再在场景当中加入其它物体，使得物体之间发生光线交互之后是什么情况呢： </p><p><img src="https://pic1.zhimg.com/v2-aa6ee1c6af3ac2c8f7dadfdf4920d9c4_b.jpg" alt="img"></p><p> 如上图所示，可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。</p><p>观察一下图中的渲染方程可以发现除了两个radiance，其它所有项都是知道的，可以将上式进一步写成如下图下方所示的式子： </p><p><img src="https://pic4.zhimg.com/v2-995a0c3a7f373a80ceaa9c9fff9de5f7_b.jpg" alt="img"></p><p> 其中各项与原渲染方程中一一对应，(这里其实是有数学严格推导的，不过我们只是为了接下来构建直观的物理解释，对于这些推导不必在意，默认成立即可)，再接着，可以把该式子离散化写为线性代数的形式： </p><p><img src="https://pic4.zhimg.com/v2-cf43f163f31001283275a91ecb22f493_b.jpg" alt="img"></p><p> 呼，经过两步我们不是很清楚但其实是正确的数学推导之后，得到了这样一个式子：</p><p><img src="https://www.zhihu.com/equation?tex=L=E+KL+%5C%5C" alt="[公式]"></p><p>其中L其实就是想要求得的反射光，E是自发光其实就是光源的发光项，K可以理解为对光线进行反射的一种算子操作(因为它由BRDF化来的)。那么利用线性代数的知识很容易就可以推导出L的结果如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+L+&=E+K+L+%5C%5C+IL-K+L+&=E+%5C%5C+(I-K)+L+&=E+%5C%5C+L+&=(I-K)%5E%7B-1%7D+E+%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>其中<img src="https://www.zhihu.com/equation?tex=I" alt="[公式]">为单位矩阵，再接着对<img src="https://www.zhihu.com/equation?tex=(I-K)%5E%7B-1%7D" alt="[公式]">使用广义二项式定理得到：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Bl%7D+L=%5Cleft(I+K+K%5E%7B2%7D+K%5E%7B3%7D+%5Cldots%5Cright)+E+%5C%5C+L=E+K+E+K%5E%7B2%7D+E+K%5E%7B3%7D+E+%5Cldots+.+%5Cend%7Barray%7D%5C%5C" alt="[公式]"></p><p>仔细观察这个式子，注意E是光源所发出的光，K为反射算子，这样一个式子的物理含义如下图所示： </p><p><img src="https://pic2.zhimg.com/v2-91eedfd2bb5d78841807410df577d921_b.jpg" alt="img"></p><p> E为光源发出的光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果，对于全局光照来说，还考虑了<img src="https://www.zhihu.com/equation?tex=K%5E2E" alt="[公式]">，即一次弹射的间接照明，<img src="https://www.zhihu.com/equation?tex=K%5E3E" alt="[公式]">就是两次弹射的间接照明，依次类推。</p><p>这样来看整个结果是不是就很清晰了，就是光源发光加上直接光照与多次间接光照的结果！而这一切都是从渲染方程推导而来的，因此这也正是渲染方程的物理意义！</p><p>最后以几张基于物理渲染的图片作为本篇文章的结束 一次反射直接光照： </p><p><img src="https://pic2.zhimg.com/v2-e089c847c76885d7fd2d16dacd6926dd_b.jpg" alt="img"></p><p> 两次反射，考虑到一次弹射的间接光照： </p><p><img src="https://pic3.zhimg.com/v2-8d29adb7ef636cee958d858dd4f19dae_b.jpg" alt="img"></p><p> 3次反射，考虑到两次弹射的间接光照： </p><p><img src="https://pic3.zhimg.com/v2-63e675a1a7ea4bc637c4412393008b96_b.jpg" alt="img"></p><p> (考虑次数越多越接近真实图片效果,趋近收敛)</p><p>以上就是所有的关于PBR的一些相关基础知识了，我们从辐射度量学入手，掌握了正确衡量光线属性的方法，由此定义出了BRDF，来表示物体的材质，即它对于光线的反射能量分布，最后结合辐射度量学与BRDF得到渲染方程，一个个真正完全正确的光线传播模型！</p><hr><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><p>概率密度函数值为1</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220618222319.png"></p><hr><h3 id="全局光照"><a href="#全局光照" class="headerlink" title="全局光照"></a>全局光照</h3><p>蒙特卡洛积分求解渲染方程</p><p>我们通过对辐射度量学当中一系列概念的定义，引入了渲染方程，一个正确的光线传播模型，但并没有去涉及如何解出该渲染方程，或者说如何通过该渲染方程计算出屏幕上每一个坐标的像素值。</p><h4 id="蒙特卡洛积分"><a href="#蒙特卡洛积分" class="headerlink" title="蒙特卡洛积分"></a>蒙特卡洛积分</h4><p>Monte Carlo Integration</p><p>首先让我们先搞懂蒙特卡洛路径追踪的这个“蒙特卡洛”的前缀到底指什么。</p><p><strong>蒙特卡洛积分的目的：</strong> <strong>其实就是用一种数值方法求解定积分</strong>，当一个积分很难通过解析的方式得到答案的时候可以通过蒙特卡洛的方式近似得到积分结果，如下图所示： </p><p><img src="https://pic4.zhimg.com/v2-49dba6285defd950f23247805bdc46ab_b.jpg" alt="img"></p><p> 显然对于这样一个函数，很难去用一个数学式子去表示，因此无法用一般解析的方法直接求得积分值，而这时候就可以采用蒙特卡洛的思想了。</p><p><strong>蒙特卡洛积分的原理及做法：</strong> 对函数值进行多次采样求均值作为积分值的近似</p><p>该做法十分容易理解，想象一下如果对上图这个函数值进行<strong>均匀采样</strong>的话，其实就相当于将整个积分面积切成了许许多多个长方形，然后将这些小长方形的面积全部加起来。没错，该做法其实就与黎曼积分的想法几乎一致。但蒙特卡洛积分更加的general，因为它可以指定一个分布来对被积分的值进行采样，定义如下： </p><p><img src="https://pic4.zhimg.com/v2-89678cd612b45b024bed2789acf275f3_b.jpg" alt="img"></p><p> 如图所示，我们希望求出一个函数<img src="https://www.zhihu.com/equation?tex=f(x)" alt="[公式]">在积分域<img src="https://www.zhihu.com/equation?tex=%5Ba,b%5D" alt="[公式]">上的积分值，选定一个采样的分布<img src="https://www.zhihu.com/equation?tex=p(x)" alt="[公式]">，通过对该分布来进行多次的函数值采样，最后估计的值如图中最下方式子所示。</p><p>这里对该式子进行一个简单的推导。相信大家都知道，求均值的做法其实也是对期望的逼近，因此：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7BN%7D+%5Csum_%7Bi=1%7D%5E%7BN%7D+%5Cfrac%7Bf%5Cleft(X_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(X_%7Bi%7D%5Cright)%7D+%5Capprox+%5Cmathbb%7BE%7D_%7Bx%5Csim+p(x)%7D(%5Cfrac%7Bf%5Cleft(x%5Cright)%7D%7Bp%5Cleft(x%5Cright)%7D)+%5C%5C" alt="[公式]"></p><p>那么对于这样一个服从某一分布的期望的计算套公式直接计算得：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+%5Cmathbb%7BE%7D_%7BX_i%5Csim+p(x)%7D(%5Cfrac%7Bf%5Cleft(X_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(X_%7Bi%7D%5Cright)%7D)+&=%5Cint_%7Ba%7D%5E%7Bb%7D+%5Cfrac%7Bf(x)%7D%7Bp(x)%7Dp(x)d+x%5C%5C+&=%5Cint_%7Ba%7D%5E%7Bb%7D+f(x)d+x%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>通过以上推导即可明白蒙特卡洛的近似正是对积分值的一个无偏估计。</p><p>但在本文中为了方便，所有的采样都使用均匀采样，因此很容易推出： </p><p><img src="https://pic4.zhimg.com/v2-cdfc9bd57ff05fe32ad48e29fe507c97_b.jpg" alt="img"></p><p> 因此，<strong>蒙特卡洛在此来说就是一个帮助求得困难积分值的方法</strong>。</p><h4 id="蒙特卡洛路径追踪"><a href="#蒙特卡洛路径追踪" class="headerlink" title="蒙特卡洛路径追踪"></a>蒙特卡洛路径追踪</h4><p>Monte Carlo Path Tracing</p><p>回顾一下上篇文章中所得到的渲染方程：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=L_%7Be%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)+%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>要想解出以上方程的解主要有两个难点：</p><ol><li>积分的计算</li><li>递归形式</li></ol><p>而解决这些难点自然就要利用上节中所提到的蒙特卡洛积分方法了。</p><p>在进入具体计算之前，对渲染方程做出一点小修改，即舍弃一下自发光项(因为除了光源其他物体不会发光), 以方便进行计算推导：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>从具体例子出发，首先仅仅考虑直接光照： </p><p><img src="https://pic2.zhimg.com/v2-26f8046689feafff2d84e8422e4575a1_b.jpg" alt="img"></p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>再次观察该修改过之后的方程其实就只是一个单纯的积分计算了，其物理含义为着色点p到摄像机或人眼的Radiance值。</p><p>回想第一章所提的，对于一个困难积分只要选定一个被积分变量的采样分布即可通过蒙特卡洛的方法得到积分结果的近似值，而此时的被积分值为<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">，选定<img src="https://www.zhihu.com/equation?tex=%5Comega_i+%5Csim+p(%5Comega_i)" alt="[公式]">，不难得出积分近似结果如下：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)+%5Capprox+%5Cfrac%7B1%7D%7BN%7D+%5Csum_%7Bi=1%7D%5E%7BN%7D+%5Cfrac%7BL_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)%7D%7Bp%5Cleft(%5Comega_%7Bi%7D%5Cright)%7D+%5C%5C" alt="[公式]"></p><p>正如一开始所说，先单独考虑直接光照，因此只有当采样的方向<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">击中光源的时候，光源才会对该着色点有贡献，计算伪代码如下： </p><p><img src="https://pic2.zhimg.com/v2-b47375a846c2c970fe94fa8407d64eed_b.jpg" alt="img"></p><p> 显而易见的，单独仅仅考虑直接光照自然是不够的，还需要间接光照，即当采样的<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">方向碰撞到了别的物体，如下图所示： </p><p><img src="https://pic3.zhimg.com/v2-2bf4ed87211fa8756bd2982e7f7b51e6_b.jpg" alt="img"></p><p> 此时采样的光线碰撞到了另一个物体的Q点，那么该条路径对着色点P的贡献是多少呢？自然是在点Q的直接光照再乘上反射到该方向上的百分比了！显然这是一个类似光线追踪的递归过程，不同在于该方法通过对光线方向的采样从而找出一条条可行的路径，这也正是为什么叫路径追踪的原因，伪代码如下： </p><p><img src="https://pic2.zhimg.com/v2-cfa9e75a770b298b95eaa592b4726611_b.jpg" alt="img"></p><p>至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但该方法至此有一个非常致命的缺陷： </p><p><img src="https://pic1.zhimg.com/v2-3ac15235ec0e981aaae4e632005644d4_b.jpg" alt="img"></p><p> 我们通过每次对光线方向的采样从而解出方程，假设每次采样100条，那么从人眼出发的第一次采样就是100条，在进行第二次反射之后就是10000条，依次类推，反射越多次光线数量便会爆炸增长，计算量会无法负担，那么如何才能使得光线数量不爆炸增长呢？<strong>唯有每次只采样一个方向！N=1</strong> </p><p><img src="https://pic2.zhimg.com/v2-4166c72edb9154d759c4f02340c2cf15_b.jpg" alt="img"></p><p> 每次如果只采样一个方向那么所带来的问题也是显而易见的，积分计算的结果会非常的noisy，虽然蒙特卡洛积分是无偏估计，但样本越少显然偏差越大。但该问题很好解决，如果每次只去寻找一条路径结果不好，那么重复多次寻找到多条路径，将多条路径的结果求得平均即可！如下图所示： </p><p><img src="https://pic1.zhimg.com/v2-271216ad202de93f81a88736feca7920_b.jpg" alt="img"></p><p> 改良之后的Path Tracing伪代码如下： </p><p><img src="https://pic2.zhimg.com/v2-0b1bd71c9b0646340f63a1380903f371_b.jpg" alt="img"></p><p> 通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。</p><p>那么现在所有的问题都解决了吗？还没有！因为shade函数的递归没有出口，永远不会停下。 但这里并不没有采用类似光线追踪当中设定反射深度显示的给出递归出口的方法，而是非常精妙的采用了**俄罗斯轮盘赌(Russian Roulette)**。 </p><p><img src="https://pic3.zhimg.com/v2-0a56506e94dd87a4261c4db18c4df26e_b.jpg" alt="img"></p><p> 给你一把左轮，两发子弹，你不知道哪一发会真正的射出子弹，因此拿这把左轮射自己，你有4/6的概率活下来，这就是俄罗斯轮盘赌的概念。</p><p>将其应用在路径追踪当中，首先设定一个概率<img src="https://www.zhihu.com/equation?tex=P" alt="[公式]">, 有P的概率光线会继续递归并设置返回值为<img src="https://www.zhihu.com/equation?tex=L_o+/P" alt="[公式]">，有<img src="https://www.zhihu.com/equation?tex=1-P" alt="[公式]">的概率光线停止递归，并返回0。这样巧妙的设定之下光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为Radiance的期望不变，证明如下：</p><p><img src="https://www.zhihu.com/equation?tex=E=P%5E%7B%5Cstar%7D(L+o+/+P)+(1-P)%5E%7B%5Cstar%7D+0=L_%7B0%7D+%5C%5C" alt="[公式]"></p><p>shade函数的伪代码变更如下，使得可以停止递归了： </p><p><img src="https://pic3.zhimg.com/v2-b89455bc8933ef9eed64d92f0690a4e6_b.jpg" alt="img"></p><p> 至此，我们的路径追踪算法已经完成大半，只差最后一个小问题！现在的路径追踪效率非常的低下，如图所示： </p><p><img src="https://pic3.zhimg.com/v2-00d6036dae14d6bdc5cf819f8149cee6_b.jpg" alt="img"></p><p> 在每次计算直接光照的时候，通过均匀采样任选一个方向，但很少会的光线可以hit光源，尤其当光源较小的时候，这种现象越明显，大量采样的光线都被浪费了。</p><p>因此在计算直接光照的时候改进为<strong>直接对光源进行采样！</strong>这样所有采样的光线都一定会击中光源(如果中间没有别的物体)，没有光线再会被浪费了。假设光源的面积为A，那么对光源进行采样的 <img src="https://www.zhihu.com/equation?tex=pdf+=+1/A" alt="[公式]"> (因为<img src="https://www.zhihu.com/equation?tex=%5Cint+%5Coperatorname%7Bpdf%7D+d+A=1" alt="[公式]">)，但原始的渲染方程：</p><p><img src="https://www.zhihu.com/equation?tex=L_%7Bo%7D%5Cleft(p,+%5Comega_%7Bo%7D%5Cright)=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(p,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(p,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)%5Cleft(n+%5Ccdot+%5Comega_%7Bi%7D%5Cright)+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C" alt="[公式]"></p><p>很明显是对光线方向<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">进行积分的，如果想要对光源进行采样的并依然使用蒙题卡洛的方法，那么一定要将其修改为对光源面积 dA的积分，换言之就是需要找到dA与d<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">的关系即可。如下图所示： </p><p><img src="https://pic4.zhimg.com/v2-e2c132bd2bbd66f2781c26ce5990d94b_b.jpg" alt="img"></p><p> 关系式中的<img src="https://www.zhihu.com/equation?tex=cos%5Ctheta%5E%7B%5Cprime%7D" alt="[公式]">是为了计算出光源上微分面积元正对半球的面积，之后再按照立体角的定义<img src="https://www.zhihu.com/equation?tex=%5Cmathrm%7Bd%7D+%5Comega=%5Cfrac%7B%5Cmathrm%7Bd%7D+A%7D%7Br%5E%7B2%7D%7D" alt="[公式]">，除以着色点x与光源采样点x’距离的平方即可。于是根据图中二者的关系可将渲染方程改写如下：</p><p><img src="https://www.zhihu.com/equation?tex=%5Cbegin%7Baligned%7D+L_%7Bo%7D%5Cleft(x,+%5Comega_%7Bo%7D%5Cright)+&=%5Cint_%7B%5COmega%5E%7B+%7D%7D+L_%7Bi%7D%5Cleft(x,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(x,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)+%5Ccos+%5Ctheta+%5Cmathrm%7Bd%7D+%5Comega_%7Bi%7D+%5C%5C+&=%5Cint_%7BA%7D+L_%7Bi%7D%5Cleft(x,+%5Comega_%7Bi%7D%5Cright)+f_%7Br%7D%5Cleft(x,+%5Comega_%7Bi%7D,+%5Comega_%7Bo%7D%5Cright)+%5Cfrac%7B%5Ccos+%5Ctheta+%5Ccos+%5Ctheta%5E%7B%5Cprime%7D%7D%7B%5Cleft%5C%7Cx%5E%7B%5Cprime%7D-x%5Cright%5C%7C%5E%7B2%7D%7D+%5Cmathrm%7Bd%7D+A+%5Cend%7Baligned%7D%5C%5C" alt="[公式]"></p><p>这样便成功从<img src="https://www.zhihu.com/equation?tex=%5Comega_i" alt="[公式]">积分转到了对光源面积A的积分，就可以利用蒙特卡洛的方法对光源进行采样从而计算直接光照的积分值了，对于间接光照，依然采用先前的方法进行光线方向的均匀采样。最终伪代码如下，分直接光照和间接光照两部分计算： </p><p><img src="https://pic4.zhimg.com/v2-3fb23eece40f6f50e4a9be56dddbb363_b.jpg" alt="img"></p><p>tips:计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可，如图所示: </p><p><img src="https://pic1.zhimg.com/v2-7c17994605220a196d57e8e6cecdbb2c_b.jpg" alt="img"></p><p>最后以一张闫老师课程的path tracing作业的截图作为结束！ </p><p><img src="https://pic4.zhimg.com/v2-dd78fa7aa518b8427a1d8e737e3f0f0f_b.jpg" alt="img"></p><h4 id="遗留问题探索"><a href="#遗留问题探索" class="headerlink" title="遗留问题探索"></a>遗留问题探索</h4><ul><li>怎样去在半球面上去采样呢？采样方法？</li><li>PDF函数的选取，目前用的最简单的均匀PDF，怎么选最合理的，重要性采样原理</li><li>随机数的生成 low discrepancy sequences</li><li>将半球采样和光源采样结合起来 multiple imp sampling 混合采样</li><li>像素平均加权问题</li><li>radiance和颜色的映射，gamma矫正 HDR 颜色空间</li></ul><hr><h3 id="材质和外观"><a href="#材质和外观" class="headerlink" title="材质和外观"></a>材质和外观</h3><p>Materials and Appearances</p><p>以前只有Blinn Phong的时候，通过非物理的方式模拟出各种材质。Material == BRDF 决定光如何被反射</p><h4 id="漫反射、镜面反射、折射材质"><a href="#漫反射、镜面反射、折射材质" class="headerlink" title="漫反射、镜面反射、折射材质"></a>漫反射、镜面反射、折射材质</h4><ul><li><strong>Diffuse / Lambertian Material (BRDF) 漫反射材质</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220619133822.png"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20220619134005.png"></p><ul><li><p><strong>Glossy material (BRDF)</strong></p><p>有一些镜面效果，但不是完全镜面的材质</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Games101-光追部分&quot;&gt;&lt;a href=&quot;#Games101-光追部分&quot; class=&quot;headerlink&quot; title=&quot;Games101 光追部分&quot;&gt;&lt;/a&gt;Games101 光追部分&lt;/h1&gt;&lt;h2 id=&quot;Ray-Tracing&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Rasterizer" scheme="http://icecorn.github.io/tags/Rasterizer/"/>
    
    <category term="Games-101" scheme="http://icecorn.github.io/tags/Games-101/"/>
    
  </entry>
  
  <entry>
    <title>Games-101|光栅化渲染部分</title>
    <link href="http://icecorn.github.io/2022/03/18/Games-101/Games101-%E5%85%89%E6%A0%85%E5%8C%96%E9%83%A8%E5%88%86/"/>
    <id>http://icecorn.github.io/2022/03/18/Games-101/Games101-%E5%85%89%E6%A0%85%E5%8C%96%E9%83%A8%E5%88%86/</id>
    <published>2022-03-18T09:25:10.000Z</published>
    <updated>2022-06-29T14:59:15.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Game-101"><a href="#Game-101" class="headerlink" title="Game-101"></a>Game-101</h1><h2 id="二-向量与线性代数"><a href="#二-向量与线性代数" class="headerlink" title="二 向量与线性代数"></a>二 向量与线性代数</h2><h3 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h3><p>vector表示的向量，包括向量的长度，方向，单位向量等。</p><p>向量加法（平行四边形，三角形法则），用笛卡尔坐标系直接坐标相加</p><p><strong>向量点乘：</strong></p><p>a*b = |a||b|cosθ，得到的是一个数</p><p>作用：</p><ul><li>算向量的夹角</li><li>算b向量在a向量上的投影</li><li>衡量两个方向是不是接近的</li><li>分解一个向量（到两个垂直方向上）</li><li>通过点成&gt;0或&lt;0判断方向性</li></ul><p><strong>向量叉乘：</strong></p><p>|axb| = |a||b|sinθ</p><p>axb = -bxa</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629224913916.png" alt="image-20220629224913916"></p><p>作用：</p><ul><li>算法向量的方向</li><li>判断左右</li><li>判断内外（经典问题，判断点在三角形内外）</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/2.png" alt="2"></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><p>矩阵乘法是没有<strong>交换律</strong>的，AB！=BA</p><p>有<strong>结合律</strong>和<strong>分配律</strong></p><p>矩阵求<strong>逆矩阵</strong>，求<strong>转置</strong></p><p>向量的乘积写成矩阵形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/3.png" alt="3"></p><h2 id="三-变换（二维和三维）"><a href="#三-变换（二维和三维）" class="headerlink" title="三 变换（二维和三维）"></a>三 变换（二维和三维）</h2><h3 id="缩放变换"><a href="#缩放变换" class="headerlink" title="缩放变换"></a>缩放变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629224946363.png" alt="image-20220629224946363"></p><h3 id="反转变换"><a href="#反转变换" class="headerlink" title="反转变换"></a>反转变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/5.png" alt="5"></p><h3 id="切变换（Shear）"><a href="#切变换（Shear）" class="headerlink" title="切变换（Shear）"></a>切变换（Shear）</h3><p>找到对应关系，这里其实相当于在x方向上进行一个线性插值</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629224959521.png" alt="image-20220629224959521"></p><h3 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h3><p>旋转方向默认逆时针</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225022067.png" alt="image-20220629225022067"></p><p>旋转-sinθ</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225045408.png" alt="image-20220629225045408"></p><h3 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/8.png" alt="8"></p><h3 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h3><p>需要线性变化+常数项</p><p><strong>平移变换不属于线性变换</strong></p><p><strong>将平移变换转变成矩阵乘法：</strong></p><p>通过给二维点和向量增加一个维度从而实现（齐次坐标）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225058336.png" alt="image-20220629225058336"></p><p>点+点表示的是这两个点的中点</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/10.png" alt="10"></p><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11.png" alt="11"></p><p>总结：通过齐次坐标实现仿射变换，它们的任何变换操作都可以变成左乘一个变换矩阵来表示</p><h3 id="逆变换"><a href="#逆变换" class="headerlink" title="逆变换"></a>逆变换</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/12.png" alt="12"></p><p>实现上就是左乘M矩阵的逆矩阵</p><h3 id="变换的合成与分解"><a href="#变换的合成与分解" class="headerlink" title="变换的合成与分解"></a>变换的合成与分解</h3><p>通过左乘很多矩阵实现变换的合成，同时也可以左乘逆矩阵实现变换的分解</p><h3 id="三维变换"><a href="#三维变换" class="headerlink" title="三维变换"></a>三维变换</h3><p>类比二维的，多加一为，用4x4的矩阵表示各种变换矩阵</p><p>对于三维的旋转有很多种方法：</p><p>比如欧拉角和四元数</p><hr><h2 id="四-变换（MVP变换，模型，视图，投影）"><a href="#四-变换（MVP变换，模型，视图，投影）" class="headerlink" title="四 变换（MVP变换，模型，视图，投影）"></a>四 变换（MVP变换，模型，视图，投影）</h2><p>以拍照来类比：</p><p>Model：人拍pose</p><p>View：确定相机的位置，和镜头朝向等等</p><p>Projection：按下快门，把三维场景投影到照片上</p><h3 id="视图变换"><a href="#视图变换" class="headerlink" title="视图变换"></a>视图变换</h3><p>首先要固定相机在（0，0，0）的位置上，并且看下-Z方向，向上方向（想想摄像机上有一根草，相机歪着的话，草也是歪着的，这就是向上方向）为Y方向因为这样之后好处理。</p><p>那么在移动过程中，就是先移动相机的位置，然后所有的物体都做同样的变换，保持相对变换就可以了</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14.png" alt="14"></p><p>先平移，在旋转</p><p>因为要把任意的（x,y,z）旋转到（1，0，0）不好写，所以可以先求逆变换，然后因为旋转矩阵是正交矩阵，它的转置就是它的逆，所以之后再转置就可以得到正常的旋转变化了。</p><p>这样的操作（平移+旋转）就叫视图变换</p><hr><h3 id="投影变换"><a href="#投影变换" class="headerlink" title="投影变换"></a>投影变换</h3><p>3D to 2D的变化方式，分为正交投影和透视投影</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>并不会近大远小</p><p>简单方法：</p><ul><li>设置相机（0，0，0），-Z，向上Y</li><li>丢掉Z坐标</li><li>变换到【-1，1】的平方这块矩形上</li></ul><p>常规方法（图形学上）：</p><p>先把物体中心平移到【-1，1】的立方这个小正方体上，在进行缩放变换</p><ul><li>平移中心</li><li>缩放到单位正方体</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225134866.png" alt="image-20220629225134866"></p><p>写成数学形式：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/17.png" alt="17"></p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>会有近大远小的特性，符合人眼，用途广泛</p><p>实现方法：</p><p>分成两步：</p><ul><li>将中间和远平面的所有点都“挤压”到单位平面上</li><li>再做正交投影</li></ul><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/18.png" alt="18"></p><p>由相似三角形，可以得到被挤压后的位置应该在哪里</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225151670.png" alt="image-20220629225151670"></p><p>由此可以反推出来变换矩阵</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/20.png" alt="20"></p><p>根据近平面点和远平面中点的不变性，用待定系数法，推出M矩阵的第三行</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/21.png" alt="21"></p><hr><h2 id="五-光栅化（三角形的离散化）"><a href="#五-光栅化（三角形的离散化）" class="headerlink" title="五  光栅化（三角形的离散化）"></a>五  光栅化（三角形的离散化）</h2><p>将【-1，1】的单位立方体，呈现到屏幕上，屏幕是由像素组成的比如1980*1080</p><p><strong>视口变换：</strong></p><ul><li>先把中心平移到屏幕的中心</li><li>进行M变换</li></ul><p>整个过程我们先不考虑Z轴的问题</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/22.png" alt="22"></p><h3 id="三角网格的优势"><a href="#三角网格的优势" class="headerlink" title="三角网格的优势"></a>三角网格的优势</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225209123.png" alt="image-20220629225209123"></p><p><strong>怎样判断一个像素是在三角形内部还是外部？</strong></p><p>三个向量叉乘同号</p><h3 id="采样光栅化（Sampling）"><a href="#采样光栅化（Sampling）" class="headerlink" title="采样光栅化（Sampling）"></a>采样光栅化（Sampling）</h3><p>采样其实就是把函数离散化的过程</p><p>例子：</p><p>首先写一个函数 inside（tri，x，y）；表示点是否在三角形内，然后遍历像素把每个像素的值写入结果image【x】【y】中</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/24.png" alt="24"></p><p>判断点是否在三角形内很重要，有时间写一下代码</p><p><strong>优化：</strong></p><p>为了避免每个三角形离散都要遍历所有像素，可以进行优化</p><ul><li>包围盒，找到min_x,min_y,max_x,max_y这样就可以确定包围盒</li><li>一行一行遍历里边的像素（适合窄的三角形）</li></ul><h2 id="六-光栅化（深度测试与抗锯齿）"><a href="#六-光栅化（深度测试与抗锯齿）" class="headerlink" title="六 光栅化（深度测试与抗锯齿）"></a>六 光栅化（深度测试与抗锯齿）</h2><h3 id="反走样-MSAA（抗锯齿）"><a href="#反走样-MSAA（抗锯齿）" class="headerlink" title="反走样-MSAA（抗锯齿）"></a>反走样-MSAA（抗锯齿）</h3><p><strong>需要先做模糊（卷积）再采样</strong></p><p>具体的原因是根据信号与系统中时域和频域的知识，简单理解去掉高频信息可以使得采样更接近（想象一下颜色都相近情况下，采样的间隔当然可以变小，换句话说同样的采样间隔，颜色相近，频率更低的函数采样起来肯定更准确）</p><h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>通过一个卷积核对单位像素周围的一圈像素（一环领域）平均算值，从而实现模糊的效果</p><h3 id="超采样MSAA"><a href="#超采样MSAA" class="headerlink" title="超采样MSAA"></a>超采样MSAA</h3><p>将每个像素点分割成4个或16个或更多个小单元，判断一个像素中有几个单元在三角形内，然后计算比例，通过这种方式实现模糊操作</p><p><strong>注意这里的采样方式不是规规整整的4个格子，是其他有效的采样方式，比如斐波那契采样之类的，而且有一些相邻的采样点还会被相邻像素复用</strong></p><h3 id="快速近似抗锯齿-FXAA"><a href="#快速近似抗锯齿-FXAA" class="headerlink" title="快速近似抗锯齿-FXAA"></a>快速近似抗锯齿-FXAA</h3><p>得到有锯齿的图，找到锯齿的边界，换成没有锯齿的图</p><h3 id="Temporal-AA-TAA"><a href="#Temporal-AA-TAA" class="headerlink" title="Temporal AA-TAA"></a>Temporal AA-TAA</h3><p>复用上一帧的抗锯齿效果，这一帧再进行处理</p><hr><h3 id="可见性（遮挡）"><a href="#可见性（遮挡）" class="headerlink" title="可见性（遮挡）"></a>可见性（遮挡）</h3><p>要把很多物体放在屏幕上，如何呈现的问题</p><h4 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h4><p>从远到近，一个一个画，后画的遮挡前边画的</p><h4 id="深度缓存（Z-Buffer）"><a href="#深度缓存（Z-Buffer）" class="headerlink" title="深度缓存（Z-Buffer）"></a>深度缓存（Z-Buffer）</h4><p>从像素考虑，像素永远保存里屏幕最近的元素</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/25.png" alt="25"></p><p>同时要维护两张图，一张是最后的结果图，一张是深度图</p><p>对每一个三角形（物体），遍历它的采样（像素），如果它的深度比深度图中的小，那就要更新结果图和深度图，否则什么都不做</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/26.png" alt="26"></p><hr><h2 id="七-九-着色（光照与基本着色模型）"><a href="#七-九-着色（光照与基本着色模型）" class="headerlink" title="七-九  着色（光照与基本着色模型）"></a>七-九  着色（光照与基本着色模型）</h2><h3 id="布林-冯模型"><a href="#布林-冯模型" class="headerlink" title="布林-冯模型"></a>布林-冯模型</h3><p>就是在一种光源下，一个着色点如何着色的问题</p><p>全反射（高光）</p><p>漫反射</p><p>环境光照（间接光照）</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/27.png" alt="27"></p><p>着色点，光源方向，观察方向等一些参数的设置</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/28.png" alt="28"></p><h3 id="漫反射"><a href="#漫反射" class="headerlink" title="漫反射"></a>漫反射</h3><p>考虑光是离散的，根据光照射到着色点，着色点接收到光的能量来计算漫反射的实际光照</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225230444.png" alt="image-20220629225230444"></p><p>n点乘l，计算夹角的cos值</p><p><strong>漫反射和观测角度没关系</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/30.png" alt="30"></p><hr><h3 id="高光"><a href="#高光" class="headerlink" title="高光"></a>高光</h3><p>镜面反射，和观测方向有关</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/31.png" alt="31"></p><h3 id="环境光"><a href="#环境光" class="headerlink" title="环境光"></a>环境光</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/32.png" alt="32"></p><h3 id="着色频率"><a href="#着色频率" class="headerlink" title="着色频率"></a>着色频率</h3><p>按照粒度不同可分为，按照面着色（flat shading)，按照点着色(Gouraud shading)，按照像素着色(phong shading)</p><p>Gouraud shading:渲染点，求出每个点法向，然后算出点的颜色，三角形内部点颜色插值得到</p><p>phong shading:像素渲染，每个像素插值法向，然后逐像素着色</p><p><strong>算点的法向量：是点周围的面的法向量加权平均</strong></p><hr><h3 id="实时渲染管线"><a href="#实时渲染管线" class="headerlink" title="实时渲染管线"></a>实时渲染管线</h3><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/33.png" alt="33"></p><ul><li>顶点的投影 MVP变换</li><li>光栅化，包括Z-buffer操作</li><li>着色，可分为顶点着色，或者像素着色</li></ul><p><strong>Shader 程序</strong></p><p>shader是在硬件中实现的，可以定义顶点着色或者像素着色</p><p>不用写for循环，一个shader写好可以应用在所有像素或者顶点上</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/34.png" alt="34"></p><h3 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h3><p>纹理贴图，uv映射</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/35.png" alt="35"></p><h3 id="三角形内属性插值"><a href="#三角形内属性插值" class="headerlink" title="三角形内属性插值"></a>三角形内属性插值</h3><p>通过重心坐标实现插值</p><p><strong>重点：重心坐标在投影下是会变的，也就是说，我们要插值三维属性（比如说深度，法向）就必须在世界空间（投影前的三维空间）下进行插值。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225248914.png" alt="image-20220629225248914"></p><p>点在三角形要保证三个参数非负</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/37.png" alt="37"></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/38.png" alt="38"></p><p>纹理就是漫反射系数</p><h4 id="纹理太小"><a href="#纹理太小" class="headerlink" title="纹理太小"></a>纹理太小</h4><p>纹理太小，可以使用双线性插值，双三次插值等</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225303891.png" alt="image-20220629225303891"></p><h4 id="纹理太大"><a href="#纹理太大" class="headerlink" title="纹理太大"></a>纹理太大</h4><p>纹理太大会引起摩尔纹等走样问题</p><p>解决方法：</p><p><strong>Mipmap</strong></p><p><strong>三线性插值</strong></p><p>mipmap做近似的正方形的范围查询</p><p>其实就是一张图生成一系列分辨率不同的图</p><p>这里有个问题是远处的点采样小分辨率的图，会覆盖很多像素，那么就会做模糊，可能会引起远处全糊的情况，可以使用<strong>各向异性过滤</strong>的方法解决</p><h3 id="凹凸贴图"><a href="#凹凸贴图" class="headerlink" title="凹凸贴图"></a>凹凸贴图</h3><p>通过凹凸贴图在<strong>切线空间</strong>重新计算扰动后的法向量，能够达到视觉上的trick</p><hr><h2 id="十-几何（基本表示方法）"><a href="#十-几何（基本表示方法）" class="headerlink" title="十 几何（基本表示方法）"></a>十 几何（基本表示方法）</h2><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p>几何有很多表示方法，大体分为隐式表示和显示表示</p><p>隐式表示就是通过一系列的函数来描述几何体，比如一个球</p><p>水平集，分形等</p><p><strong>优点：表示起来比较容易，一个公式描述一个形状，并且判断点在几何体内外很容易</strong></p><p><strong>缺点：难以描述复杂模型</strong></p><h3 id="曲线和曲面"><a href="#曲线和曲面" class="headerlink" title="曲线和曲面"></a>曲线和曲面</h3><p><strong>贝塞尔曲线</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629225316434.png" alt="image-20220629225316434"></p><p>B样条，曲面表示等等</p><h3 id="网格处理"><a href="#网格处理" class="headerlink" title="网格处理"></a>网格处理</h3><p><strong>网格简化，网格正规化，网格细分</strong></p><h4 id="Loop-细分（加密）"><a href="#Loop-细分（加密）" class="headerlink" title="Loop 细分（加密）"></a>Loop 细分（加密）</h4><p>只能用在三角形网格</p><ul><li>先递归分解，每个面片分成几个小面片</li><li>调整点的位置（光滑处理）</li></ul><h4 id="Catmull-Clark-细分"><a href="#Catmull-Clark-细分" class="headerlink" title="Catmull-Clark 细分"></a>Catmull-Clark 细分</h4><p>通过增加非四边形面的奇异点，来使网格都变成四边形面</p><p>然后再光滑处理</p><h3 id="Shadow-Mapping"><a href="#Shadow-Mapping" class="headerlink" title="Shadow Mapping"></a>Shadow Mapping</h3><p>只能处理点光源</p><p>核心思想是一个点既能被相机看到也能被光源看到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Game-101&quot;&gt;&lt;a href=&quot;#Game-101&quot; class=&quot;headerlink&quot; title=&quot;Game-101&quot;&gt;&lt;/a&gt;Game-101&lt;/h1&gt;&lt;h2 id=&quot;二-向量与线性代数&quot;&gt;&lt;a href=&quot;#二-向量与线性代数&quot; class=&quot;he</summary>
      
    
    
    
    <category term="图形学" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
    <category term="渲染" scheme="http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"/>
    
    
    <category term="Rasterizer" scheme="http://icecorn.github.io/tags/Rasterizer/"/>
    
    <category term="Games-101" scheme="http://icecorn.github.io/tags/Games-101/"/>
    
  </entry>
  
  <entry>
    <title>操作系统思维导图</title>
    <link href="http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-03-16T11:37:26.000Z</published>
    <updated>2022-06-29T14:18:13.925Z</updated>
    
    <content type="html"><![CDATA[<div class="row">    <embed src="http://icecorn.github.io/file/os.pdf" width="100%" height="550" type="application/pdf"></div><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>线程是os能调度的最小单位，它包含在进程中，是进程的实际运作单位，但是它不拥有资源（实际上就是为了将进程拥有资源和接受os调度这两个事分开才有的线程，同时一个进程可拥有多个线程，可以是进程并发的处理任务）</li></ul><h3 id="有什么？"><a href="#有什么？" class="headerlink" title="有什么？"></a>有什么？</h3><ul><li>一个线程执行状态（运行，就绪等）</li><li>线程上下文，一个独立的程序计数器（记录下一条指令地址）</li><li>用于局部变量的一些静态存储空间（栈空间）要注意这个栈空间是私有的</li><li>与进程内其他线程共享的内存和资源的访问权限</li></ul><h3 id="好处？"><a href="#好处？" class="headerlink" title="好处？"></a>好处？</h3><ul><li>使cpu的调度时间片粒度更小，运行一个进程时，可以分成更小的时间片给进程的各个线程</li><li>线程间切换时间要小于进程间切换</li><li>提高了不同执行程序通信的效率，因为进程内的线程共享内存，直接改就行，而不用内核接入切换进程再通信来完成</li></ul><h3 id="两种线程"><a href="#两种线程" class="headerlink" title="两种线程"></a>两种线程</h3><ul><li><p>用户态线程</p><ul><li>这种线程对os来说是未知的，切换线程不需要状态切换，但一个进程同时只能运行一个线程。一个线程阻塞，进程就阻塞。</li></ul></li><li><p>内核态线程</p><ul><li>这种线程实际上就是mini进程，线程切换和进程一样会触发中断进行状态切换。当然它们也就可以再多个处理器上真正的并行执行。</li></ul></li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="是什么？-1"><a href="#是什么？-1" class="headerlink" title="是什么？"></a>是什么？</h3><ul><li>一个能分配给处理器执行的程序实体</li></ul><h3 id="有什么？-1"><a href="#有什么？-1" class="headerlink" title="有什么？"></a>有什么？</h3><ul><li>1.程序代码</li><li>2.数据集（系统资源）</li><li>3.进程控制块</li></ul><h3 id="进程控制块（由os创建和管理）"><a href="#进程控制块（由os创建和管理）" class="headerlink" title="进程控制块（由os创建和管理）"></a>进程控制块（由os创建和管理）</h3><ul><li>标识符：进程唯一标识符</li><li>状态：执行状态</li><li>优先级：相对其他进程的优先顺序</li><li>程序计数器：程序中即将执行的下一条指令地址</li><li>内存指针：相关代码和数据集以及和其他进程共享内存块的指针</li><li>上下文：执行时处理器寄存器中的数据</li><li>IO信息：IO请求，使用的文件列表等</li><li>记账信息：包括处理器时间总和，时钟数总和等</li></ul><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><ul><li>运行态：进程执行中，单核的话只有一个进程为运行态</li><li>就绪态：准备好了，有机会就执行</li><li>阻塞态：在某事发生前不能执行，如IO完成</li><li>新建态：刚创建的进程，通常进程控制块建好了，但没有加载到内存中</li><li>退出态：释放了的进程</li><li>挂起态：不属于上述5个标准的状态，挂起态是把阻塞长的进程换到磁盘中，把能直接执行的进程换到内存中，避免让cpu闲下来</li></ul><h3 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h3><ul><li><p>中断</p><ul><li>时钟中断：就是时间片到点了</li><li>IO中断：要等打印机了==</li><li>内存失效：要使用到虚存了，要从磁盘里调</li></ul></li><li><p>陷阱：处理一个错误或异常条件</p></li><li><p>系统调用：调用操作系统函数</p></li><li><p>以上三种发生了，处理器都会执行一次模式切换（用户态转到内核态），将控制权交给os例程，os处理完，可以恢复被中断的进程或切换到其他进程</p></li></ul><h2 id="如何控制资源？通过维护一些表。"><a href="#如何控制资源？通过维护一些表。" class="headerlink" title="如何控制资源？通过维护一些表。"></a>如何控制资源？通过维护一些表。</h2><h3 id="内存表"><a href="#内存表" class="headerlink" title="内存表"></a>内存表</h3><ul><li>页表</li><li>段表</li></ul><h3 id="进程表"><a href="#进程表" class="headerlink" title="进程表"></a>进程表</h3><ul><li>主进程表：包含每个进程的表项（至少包含一个指向进程映像的指针）</li><li>进程映像：包括程序，数据，栈，属性</li><li>进程可以一部分存在内存，一部分放在外存，这些信息都要存在进程表里。一切目的都是让cpu能够找到而已</li></ul><h3 id="IO表"><a href="#IO表" class="headerlink" title="IO表"></a>IO表</h3><h3 id="文件表"><a href="#文件表" class="headerlink" title="文件表"></a>文件表</h3><h2 id="并发性：互斥和同步"><a href="#并发性：互斥和同步" class="headerlink" title="并发性：互斥和同步"></a>并发性：互斥和同步</h2><h3 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h3><ul><li><p>通过编程语言来实现</p><ul><li>信号量机制（实际的实现还是硬件或软件方法）</li><li>消息机制</li><li>管程</li><li>生产者/消费者问题</li><li>读/写者问题</li></ul></li><li><p>硬件实现</p><ul><li>中断禁用（临界区禁用中断）</li><li>专用的机器指令</li></ul></li><li><p>软件实现</p><ul><li>通过进程来实现</li></ul></li></ul><h2 id="并发性：死锁和饥饿"><a href="#并发性：死锁和饥饿" class="headerlink" title="并发性：死锁和饥饿"></a>并发性：死锁和饥饿</h2><h3 id="死锁是什么？"><a href="#死锁是什么？" class="headerlink" title="死锁是什么？"></a>死锁是什么？</h3><ul><li><p>产生死锁的3个必要非充分条件</p><ul><li>互斥</li><li>占有且等待</li><li>不可抢占</li></ul></li><li><p>充分条件：循环等待（是上边3个必要条件导致的结果）</p></li></ul><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><ul><li>可重用资源（IO，内存等等）</li><li>可消耗资源（中断，IO缓冲区消息等）</li></ul><h3 id="解决死锁的方法"><a href="#解决死锁的方法" class="headerlink" title="解决死锁的方法"></a>解决死锁的方法</h3><ul><li><p>预防</p><ul><li><p>一次性请求所有资源</p><ul><li>缺点：</li></ul></li></ul></li></ul><p>1.因阻塞导致占有这么多资源都不能用，别的进程也不能用<br>2.事先不知道需要哪些资源</p><pre><code>- 抢占    - 缺点：</code></pre><p>1.要求两个进程优先级不同<br>2.资源状态要容易保存和恢复</p><pre><code>- 资源排序    - 缺点：</code></pre><p>1.和一次性请求所有资源一样，会拒绝资源访问，浪费资源可使用的时间</p><ul><li><p>避免</p><ul><li>操作以便发现至少一条安全路径</li></ul></li></ul><p>1.若一个进程请求会导致死锁，则不启动该进程<br>2.若一个进程增加资源请求会导致死锁，则不允许这一资源分配</p><pre><code>    - 资源分配拒绝策略</code></pre><p>（银行家算法）</p><pre><code>        - 优点：</code></pre><p>无需死锁预防中的抢占和回滚进程<br>            - 限制：<br>1.必须事先声明每个进程请求的最大资源<br>2.所讨论的进程必须是无关的，即它们的执行顺序没有任何同步要求的限制<br>3.分配的资源数量必须是固定的<br>4.在占有资源时，进程不能退出</p><ul><li><p>检测</p><ul><li><p>周期性检测死锁的存在</p></li><li><p>恢复</p><ul><li>1.取消所有死锁进程（os最常用方法）</li></ul></li></ul></li></ul><p>2.每个死锁进程回滚，并重启所有进程<br>3.连续取消死锁进程直到不再存在死锁<br>4.连续抢占资源直到不在存在死锁</p><h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><ul><li>重定位</li><li>保护</li><li>共享</li><li>逻辑组织</li><li>物理组织</li></ul><h3 id="内存分区"><a href="#内存分区" class="headerlink" title="内存分区"></a>内存分区</h3><ul><li><p>固定分区</p></li><li><p>动态分区</p></li><li><p>伙伴系统</p></li><li><p>分页</p><ul><li>进程分成页<br>内存分成页框（大小相等）<br>每一页很小，windows是4kb<br>进程可以拥有不连续的很多页，通过维护一个页表来找到它们</li></ul></li><li><p>分段</p><ul><li><p>进程和内存被分成很多段<br>段的大小可以不相等</p><ul><li>特点：<br>可以由程序员控制，一般将每个段定义一组逻辑信息，然后映射到内存中去。而分页是定死的，程序员控制不了</li></ul></li></ul></li><li><p>分段和分页区别</p><ul><li><p>1.页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要.</p></li><li><p>2.页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分.</p></li><li><p>3.分页的作业地址空间是一维的.分段的地址空间是二维的.</p><ul><li>意思是分页的话，给个虚拟地址就能找到物理地址（因为页是一样大的，可以算出来），而分段的话，需要给段号和虚拟地址才能算出来物理地址，因为段是不定长的嘛</li></ul></li></ul></li><li><p>段页式</p><ul><li>首先将进程按逻辑分成段<br>再将每段分成页<br>查找需要段号，页号，偏移量</li></ul></li></ul><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>好处：</li></ul><p>1.可以使有限的内存存放更多进程<br>2.可以使程序比整个内存都大，比如某些游戏<br>3.不需要程序的所有页或段都在内存之中</p><h3 id="操作系统处理"><a href="#操作系统处理" class="headerlink" title="操作系统处理"></a>操作系统处理</h3><ul><li><p>为了防止缺页中断太过频繁，os有很多算法来进行内存调度</p><ul><li><p>读取策略：<br>进程页可以在请求时读取，或预先分页，按簇一次读取多页</p></li><li><p>放置策略：<br>对纯分段系统，读取的段必须匹配内存的空间</p></li><li><p>置换策略：<br>内存装满后，必须决定置换哪些页</p></li><li><p>驻留集管理：<br>换入特定进程时，os决定给他分配多少内存，既可以静态分配，也可以动态地变化</p></li><li><p>清除策略：<br>修改过的进程页可在置换时写出，或使用预约式清楚策略，按簇一次写出多页</p></li><li><p>加载控制：<br>主要关注任何给定时刻驻留在内存中的进程数量</p></li></ul></li></ul><h2 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h2><h3 id="单处理器调度"><a href="#单处理器调度" class="headerlink" title="单处理器调度"></a>单处理器调度</h3><ul><li><p>处理器调度类型</p><ul><li>长程调度：<br>决定哪些进程可以进入系统中处理（读入内存）</li><li>中程调度：<br>是交换功能的一部分，就是决定进程的一部分读入内存或换出到磁盘</li><li>短程调度：<br>真正决定当前cpu处理哪个进程（运行态）的调度</li></ul></li></ul><h3 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h3><ul><li><p>粒度</p></li><li><p>进程调度</p></li><li><p>线程调度</p><ul><li><p>负载分配</p><ul><li>先来先服务</li><li>最少线程数优先</li><li>可抢占的最少线程数优先</li></ul></li><li><p>组调度</p></li><li><p>专用处理器分配</p></li><li><p>动态调度</p></li></ul></li><li><p>多核线程调度</p></li></ul><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><h3 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h3><ul><li><p>进程优先级</p></li><li><p>决策模式：抢占/非抢占</p></li><li><p>调度策略</p><ul><li>先来先服务</li><li>轮转</li><li>最短进程优先</li><li>最短剩余时间</li><li>最高响应比优先</li><li>反馈法</li><li>公平共享调度（进程组）</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;http://icecorn.github.io/file/os.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;
	&lt;/div&gt;




&lt;h1</summary>
      
    
    
    
    <category term="操作系统" scheme="http://icecorn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://icecorn.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="思维导图" scheme="http://icecorn.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|专题-四种类型转换的使用</title>
    <link href="http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-03-10T12:25:30.000Z</published>
    <updated>2022-06-29T13:24:31.104Z</updated>
    
    <content type="html"><![CDATA[<h2 id="专题-四种类型转换的使用"><a href="#专题-四种类型转换的使用" class="headerlink" title="专题 -四种类型转换的使用"></a>专题 -四种类型转换的使用</h2><h3 id="运行时类型识别（Run-Time-Type-Identification）"><a href="#运行时类型识别（Run-Time-Type-Identification）" class="headerlink" title="运行时类型识别（Run-Time Type Identification）"></a>运行时类型识别（Run-Time Type Identification）</h3><p>运行时类型识别（RTTI）的功能由两个运算符实现：</p><ul><li><code>typeid</code>运算符，用于返回表达式的类型。</li><li><code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。</li></ul><p>RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。</p><h3 id="dynamic-cast运算符（The-dynamic-cast-Operator）"><a href="#dynamic-cast运算符（The-dynamic-cast-Operator）" class="headerlink" title="dynamic_cast运算符（The dynamic_cast Operator）"></a>dynamic_cast运算符（The dynamic_cast Operator）</h3><p><code>dynamic_cast</code>运算符的形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dynamic_cast</span>&lt;type*&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&gt;(e)</span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e)</span><br></pre></td></tr></table></figure><p>其中<em>type</em>是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，<em>e</em>必须是一个有效指针；在第二种形式中，<em>e</em>必须是一个左值；在第三种形式中，<em>e</em>不能是左值。在所有形式中，<em>e</em>的类型必须符合以下条件之一：</p><ul><li><em>e</em>是<em>type</em>的公有派生类。</li><li><em>e</em>是<em>type</em>的公有基类。</li><li><em>e</em>和<em>type</em>类型相同。</li></ul><p>如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果：</p><ul><li><p>如果<code>dynamic_cast</code>语句的转换目标是指针类型，则结果为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Derived *dp = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(bp))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// use the Derived object to which dp points</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;   <span class="comment">// bp points at a Base object</span></span><br><span class="line">    <span class="comment">// use the Base object to which bp points</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果<code>dynamic_cast</code>语句的转换目标是引用类型，则抛出<code>bad_cast</code>异常（定义在头文件<em>typeinfo</em>中）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> Base &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> Derived &amp;d = <span class="built_in">dynamic_cast</span>&lt;<span class="type">const</span> Derived&amp;&gt;(b);</span><br><span class="line">        <span class="comment">// use the Derived object to which b referred</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (bad_cast)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle the fact that the cast failed</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在条件判断部分执行<code>dynamic_cast</code>可以确保类型转换和结果检查在同一条表达式中完成。</p><p>可以对一个空指针执行<code>dynamic_cast</code>，结果是所需类型的空指针。</p><hr><h3 id="四种强制类型转换"><a href="#四种强制类型转换" class="headerlink" title="四种强制类型转换"></a>四种强制类型转换</h3><p><strong>强制类型转换解决的问题：</strong></p><p>强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成<a href="http://c.biancheng.net/c/80/">指针</a>，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。</p><p><strong>1) 没有从形式上体现转换功能和风险的不同。</strong></p><p>例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。</p><p><strong>2) 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。</strong></p><p><strong>3) 难以在程序中寻找到底什么地方进行了强制类型转换。</strong></p><p>强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。</p><p>如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。</p><p>而用 C++ 的方式，则只需要查找**<code>_cast</code>**字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找<code>reinterpret_cast</code>字符串。</p><p>C++ 强制类型转换运算符的用法如下：</p><p>*<em>强制类型转换运算符 &lt;**要转换到的类型**&gt; (*<em>待转换的表达式*</em>)</em>*</p><p>例如：</p><p>double d = static_cast <double> (3<em>5); //将 3</em>5 的值转换成实数</p><hr><p><strong>下面分别介绍四种强制类型转换运算符。</strong></p><h4 id="const-cast-常量转换"><a href="#const-cast-常量转换" class="headerlink" title="const_cast 常量转换"></a>const_cast 常量转换</h4><p>const_cast 运算符仅用于进行<strong>去除 const 属性的转换</strong>，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。</p><p>将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string s = <span class="string">&quot;Inception&quot;</span>;</span><br><span class="line">string&amp; p = <span class="keyword">const_cast</span> &lt;string&amp;&gt; (s);</span><br><span class="line">string* ps = <span class="keyword">const_cast</span> &lt;string*&gt; (&amp;s);  <span class="comment">// &amp;s 的类型是 const string*</span></span><br></pre></td></tr></table></figure><p>const int* p; //p可变,p指向的内容不可变<br>int const* p; //p可变,p指向的内容不可变<br>int* const p; //p不可变,p指向的内容可变</p><p>const修饰函数返回值表示返回值不可改变,多用于返回指针的情形<br>volatile可理解为编译器警告指示字<br>volatile用于告诉编译器必须每次去内存中取变量值<br>volatile主要修饰可能被多个线程访问的变量<br>volatile也可以修饰可能被未知因数更改的变量</p><p>1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；<br>2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；<br>3、const_cast一般用于修改指针。如const char *p形式；</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211182748443.png" alt="image-20211211182748443"></p><p>未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 <em>c_val , use_val , ptr_val</em> 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的<em>c_val</em> 会被改变.也有可能编译器对这类行为直接 <em>error</em> 或 <em>warning</em>.</p><h4 id="static-cast-静态类型转换"><a href="#static-cast-静态类型转换" class="headerlink" title="static_cast 静态类型转换"></a><strong>static_cast 静态类型转换</strong></h4><p>1、static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。<br>2、用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。<br>3、用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。                               4、static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除)                                5、在c++ primer 中说道：c++ 的任何的隐式转换都是使用 <em>static_cast</em> 来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="keyword">operator</span> <span class="type">char</span>*() &#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">char</span>* p = <span class="string">&quot;New Dragon Inn&quot;</span>;</span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (<span class="number">3.14</span>);  <span class="comment">// n 的值变为 3</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (a);  <span class="comment">//调用 a.operator int，n 的值变为 1</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (a);  <span class="comment">//调用 a.operator char*，p 的值变为 NULL</span></span><br><span class="line">    n = <span class="keyword">static_cast</span> &lt;<span class="type">int</span>&gt; (p);  <span class="comment">//编译错误，static_cast不能将指针转换成整型</span></span><br><span class="line">    p = <span class="keyword">static_cast</span> &lt;<span class="type">char</span>*&gt; (n);  <span class="comment">//编译错误，static_cast 不能将整型转换成指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dynamic-cast-动态类型转换"><a href="#dynamic-cast-动态类型转换" class="headerlink" title="dynamic_cast 动态类型转换"></a>dynamic_cast 动态类型转换</h4><p>用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。</p><p>dynamic_cast 是通过“<strong>运行时类型检查</strong>”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;  <span class="comment">//有虚函数，因此是多态基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base b;</span><br><span class="line">    Derived d;</span><br><span class="line">    Derived* pd;</span><br><span class="line">    pd = <span class="keyword">reinterpret_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">//此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe reinterpret_cast&quot;</span> &lt;&lt; endl; <span class="comment">//不会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;b);</span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast1&quot;</span> &lt;&lt; endl;  <span class="comment">//会执行</span></span><br><span class="line">    pd = <span class="keyword">dynamic_cast</span> &lt;Derived*&gt; (&amp;d);  <span class="comment">//安全的转换</span></span><br><span class="line">    <span class="keyword">if</span> (pd == <span class="literal">NULL</span>)  <span class="comment">//此处 pd 不会为 NULL</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unsafe dynamic_cast2&quot;</span> &lt;&lt; endl;  <span class="comment">//不会执行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>unsafe dynamic_cast1</p><p>第 20 行，通过判断 pd 的值是否为 NULL，就能知道第 19 行进行的转换是否是安全的。第 23 行同理。</p><p>如果上面的程序中出现了下面的语句：</p><p>Derived &amp; r = dynamic_cast &lt;Derived &amp;&gt; (b);</p><p>那该如何判断该转换是否安全呢？不存在空引用，因此不能通过返回值来判断转换是否安全。C++ 的解决办法是：dynamic_cast 在进行引用的强制转换时，如果发现转换不安全，就会拋出一个异常，通过处理异常，就能发现不安全的转换。</p><hr><p><em>dynamic_cast</em>强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换.</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211183405628.png" alt="image-20211211183405628"></p><p>对于<em>从子类到基类的指针转换</em> ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果，</p><p>而<em>从基类到子类的转换</em> , dynamic_cast 在转换时也没有报错,但是输出给 <em>base2sub</em> 是一个 <em>nullptr</em> ,说明dynami_cast 在程序运行时对类型转换对<em>“运行期类型信息”（Runtime type information，RTTI）</em>进行了检查. </p><p>这个检查主要来自<em>虚函数(virtual function)</em> 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。*因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数</p><h4 id="reinterpret-cast-重新解释（类型的比特位）"><a href="#reinterpret-cast-重新解释（类型的比特位）" class="headerlink" title="reinterpret_cast 重新解释（类型的比特位）"></a><strong>reinterpret_cast 重新解释（类型的比特位）</strong></h4><p>reinterpret_cast 用于进行各种不同类型的<strong>指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换</strong>。转换时，执行的是<strong>逐个比特复制</strong>的操作。</p><p>这种转换提供了很强的灵活性，但<strong>转换的安全性只能由程序员的细心来保证了</strong>。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> n):<span class="built_in">i</span>(n),<span class="built_in">j</span>(n) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> &amp;r = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>&amp;&gt;(a); <span class="comment">//强行让 r 引用 a（即a的首地址）</span></span><br><span class="line">    r = <span class="number">200</span>;  <span class="comment">//把 a.i 变成了 200</span></span><br><span class="line">    cout &lt;&lt; a.i &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; a.j &lt;&lt; endl;  <span class="comment">// 输出 200,100</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">300</span>;</span><br><span class="line">    A *pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt; (&amp;n); <span class="comment">//强行让 pa 指向 n</span></span><br><span class="line">    pa-&gt;i = <span class="number">400</span>;  <span class="comment">// n 变成 400</span></span><br><span class="line">    pa-&gt;j = <span class="number">500</span>;  <span class="comment">//此条语句不安全，很可能导致程序崩溃</span></span><br><span class="line">    cout &lt;&lt; n &lt;&lt; endl;  <span class="comment">// 输出 400</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> la = <span class="number">0x12345678abcd</span>LL;</span><br><span class="line">    pa = <span class="built_in">reinterpret_cast</span>&lt;A*&gt;(la); <span class="comment">//la太长，只取低32位0x5678abcd拷贝给pa</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> u = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(pa);<span class="comment">//pa逐个比特拷贝到u</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl;  <span class="comment">//输出 5678abcd</span></span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(* PF1)</span> <span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(* PF2)</span> <span class="params">(<span class="type">int</span>,<span class="type">char</span> *)</span></span>;</span><br><span class="line">    PF1 pf1;  PF2 pf2;</span><br><span class="line">    pf2 = <span class="built_in">reinterpret_cast</span>&lt;PF2&gt;(pf1); <span class="comment">//两个不同类型的函数指针之间可以互相转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果是：<br>200, 100<br>400<br>5678abcd</p><p>第 19 行的代码不安全，<strong>因为在编译器看来，pa-&gt;j 的存放位置就是 n 后面的 4 个字节</strong>。 本条语句会向这 4 个字节中写入 500。**但这 4 个字节不知道是用来存放什么的（*<em>因为i和j不一定连续存储*<em>），贸然向其中写入可能会导致程序错误甚至崩溃。</em></em></p><p>上面程序中的各种转换都没有实际意义，只是为了演示 reinteipret_cast 的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。</p><p><strong>reinterpret_cast体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。</strong></p><p>提供下IBM C++ 对 reinterpret_cast 推荐使用的地方<br>A pointer to any integral type large enough to hold it （指针转向足够大的整数类型）<br>A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针）<br>A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针）<br>A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针）<br>A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;专题-四种类型转换的使用&quot;&gt;&lt;a href=&quot;#专题-四种类型转换的使用&quot; class=&quot;headerlink&quot; title=&quot;专题 -四种类型转换的使用&quot;&gt;&lt;/a&gt;专题 -四种类型转换的使用&lt;/h2&gt;&lt;h3 id=&quot;运行时类型识别（Run-Time-Type-I</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十五章-面向对象程序设计</title>
    <link href="http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
    <id>http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-03-10T12:25:30.000Z</published>
    <updated>2022-06-29T13:21:19.003Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十五章-面向对象程序设计"><a href="#第十五章-面向对象程序设计" class="headerlink" title="第十五章 面向对象程序设计"></a>第十五章 面向对象程序设计</h2><h3 id="基类和派生类"><a href="#基类和派生类" class="headerlink" title="基类和派生类"></a>基类和派生类</h3><p>成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。</p><p>派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。</p><p><strong>C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。</strong></p><p>因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Quote item;         <span class="comment">// object of base type</span></span><br><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line">Quote *p = &amp;item;   <span class="comment">// p points to a Quote object</span></span><br><span class="line">p = &amp;bulk;          <span class="comment">// p points to the Quote part of bulk</span></span><br><span class="line">Quote &amp;r = bulk;    <span class="comment">// r bound to the Quote part of bulk</span></span><br></pre></td></tr></table></figure><p>每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Bulk_quote</span>(<span class="type">const</span> std::string&amp; book, <span class="type">double</span> p, </span><br><span class="line">            std::<span class="type">size_t</span> qty, <span class="type">double</span> disc) :</span><br><span class="line">    <span class="built_in">Quote</span>(book, p), <span class="built_in">min_qty</span>(qty), <span class="built_in">discount</span>(disc) &#123; &#125;</span><br></pre></td></tr></table></figure><p>除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</p><p><strong>派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。</strong></p><p>派生类可以访问基类的公有成员和受保护成员。</p><p>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。</p><p>已经完整定义的类才能被用作基类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* ... */</span> &#125; ;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D1</span>: <span class="keyword">public</span> Base &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D2</span>: <span class="keyword">public</span> D1 &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure><p><em>Base</em>是<em>D1</em>的直接基类（direct base），是<em>D2</em>的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。</p><p>C++11中，在类名后面添加<code>final</code>关键字可以禁止其他类继承它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NoDerived</span> <span class="keyword">final</span> &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// NoDerived can&#x27;t be a base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="comment">/* */</span> &#125;;</span><br><span class="line"><span class="comment">// Last is final; we cannot inherit from Last</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Last</span> <span class="keyword">final</span> : Base &#123; <span class="comment">/* */</span> &#125;;  <span class="comment">// Last can&#x27;t be a base class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span> : NoDerived &#123; <span class="comment">/* */</span> &#125;;    <span class="comment">// error: NoDerived is final</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad2</span> : Last &#123; <span class="comment">/* */</span> &#125;;        <span class="comment">// error: Last is final</span></span><br></pre></td></tr></table></figure><h3 id="类型转换与继承"><a href="#类型转换与继承" class="headerlink" title="类型转换与继承"></a>类型转换与继承</h3><p>和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。</p><p>表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。</p><p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p><p>不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote* bulkP = &amp;base;   <span class="comment">// error: can&#x27;t convert base to derived</span></span><br><span class="line">Bulk_quote&amp; bulkRef = base;  <span class="comment">// error: can&#x27;t convert base to derived</span></span><br></pre></td></tr></table></figure><p>如果在基类中含有一个或多个虚函数，可以使用<code>dynamic_cast</code>运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。</p><p>如果已知某个基类到派生类的转换是安全的，可以使用<code>static_cast</code>强制覆盖掉编译器的检查工作。</p><p>派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。</p><p>派生类到基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bulk_quote bulk;    <span class="comment">// object of derived type</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>;   <span class="comment">// uses the Quote::Quote(const Quote&amp;) constructor</span></span><br><span class="line">item = bulk;        <span class="comment">// calls Quote::operator=(const Quote&amp;)</span></span><br></pre></td></tr></table></figure><p>用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。</p><h3 id="虚函数（Virtual-Functions）"><a href="#虚函数（Virtual-Functions）" class="headerlink" title="虚函数（Virtual Functions）"></a>虚函数（Virtual Functions）</h3><p>当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。</p><p>在派生类中覆盖某个虚函数时，可以再次使用<code>virtual</code>关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。</p><p>在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p><p>派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。</p><p>C++11允许派生类使用<code>override</code>关键字显式地注明虚函数。如果<code>override</code>标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。<code>override</code>位于函数参数列表之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">D1</span> : B </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">override</span></span>;    <span class="comment">// ok: f1 matches f1 in the base</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">override</span></span>;      <span class="comment">// error: B has no f2(int) function</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: f3 not virtual</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;     <span class="comment">// error: B doesn&#x27;t have a function named f4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与禁止类继承类似，函数也可以通过添加<code>final</code>关键字来禁止覆盖操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">D2</span> : B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// inherits f2() and f3() from B and overrides f1(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> <span class="keyword">final</span></span>;   <span class="comment">// subsequent classes can&#x27;t override f1(int)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>final</code>和<code>override</code>关键字出现在形参列表（包括任何<code>const</code>或引用修饰符）以及尾置返回类型之后。</p><p><strong>虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。</strong></p><p>如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。</p><p>使用作用域运算符<code>::</code>可以强制执行虚函数的某个版本，不进行动态绑定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calls the version from the base class regardless of the dynamic type of baseP</span></span><br><span class="line"><span class="type">double</span> undiscounted = baseP-&gt;Quote::<span class="built_in">net_price</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure><p>通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。</p><p>如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。</p><hr><h3 id="抽象基类（Abstract-Base-Classes）"><a href="#抽象基类（Abstract-Base-Classes）" class="headerlink" title="抽象基类（Abstract Base Classes）"></a>抽象基类（Abstract Base Classes）</h3><p>在类内部虚函数声明语句的分号前添加<code>=0</code>可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">net_price</span><span class="params">(std::<span class="type">size_t</span>)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以为纯虚函数提供定义，但函数体必须定义在类的外部。</p><p>含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。</p><p><strong>不能创建抽象基类的对象。</strong></p><p>派生类构造函数只初始化它的直接基类。</p><p>重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。</p><hr><h3 id="关于多继承和虚继承"><a href="#关于多继承和虚继承" class="headerlink" title="关于多继承和虚继承"></a>关于多继承和虚继承</h3><p>多继承很简单就是一个子类可以继承多个父类，且对于一个子类对象，它里面其实包含每个父类的对象各一个，那么怎么协调好变量和函数的继承关系，理解记忆就好了，关键是不产生冲突</p><p>虚继承是为了解决菱形继承出现的，因为如果不是菱形继承，一个子类对象就会有两个一样的爷爷类的对象，这是不对的，而有了虚继承，就是让一个子对象只拥有一个爷爷类对象，不会产生冲突。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十五章-面向对象程序设计&quot;&gt;&lt;a href=&quot;#第十五章-面向对象程序设计&quot; class=&quot;headerlink&quot; title=&quot;第十五章 面向对象程序设计&quot;&gt;&lt;/a&gt;第十五章 面向对象程序设计&lt;/h2&gt;&lt;h3 id=&quot;基类和派生类&quot;&gt;&lt;a href=&quot;#基类和</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十四章 重载运算与类型转换</title>
    <link href="http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</id>
    <published>2022-03-08T12:25:30.000Z</published>
    <updated>2022-06-29T13:33:20.515Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第14章-重载运算与类型转换"><a href="#第14章-重载运算与类型转换" class="headerlink" title="第14章 重载运算与类型转换"></a>第14章 重载运算与类型转换</h1><h2 id="基本概念（Basic-Concepts）"><a href="#基本概念（Basic-Concepts）" class="headerlink" title="基本概念（Basic Concepts）"></a>基本概念（Basic Concepts）</h2><p>重载的运算符是具有特殊名字的函数，它们的名字由关键字<code>operator</code>和其后要定义的运算符号组成。</p><p>重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符<code>operator()</code>之外，其他重载运算符不能含有默认实参。</p><p>如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的<code>this</code>指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。</p><p>当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。</p><p>只能重载大多数已有的运算符，无权声明新的运算符号。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-1.png" alt="14-1"></p><p>重载运算符的优先级和结合律与对应的内置运算符一致。</p><p>可以像调用普通函数一样直接调用运算符函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent calls to a nonmember operator function</span></span><br><span class="line">data1 + data2;              <span class="comment">// normal expression</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);    <span class="comment">// equivalent function call</span></span><br><span class="line">data1 += data2;             <span class="comment">// expression-based &#x27;&#x27;call&#x27;&#x27;</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);    <span class="comment">// equivalent call to a member operator function</span></span><br></pre></td></tr></table></figure><p>通常情况下，不应该重载逗号<code>,</code>、取地址<code>&amp;</code>、逻辑与<code>&amp;&amp;</code>和逻辑或<code>||</code>运算符。</p><p>建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。</p><p>如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。</p><p>把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">string t = s + <span class="string">&quot;!&quot;</span>;     <span class="comment">// ok: we can add a const char* to a string</span></span><br><span class="line">string u = <span class="string">&quot;hi&quot;</span> + s;    <span class="comment">// would be an error if + were a member of string</span></span><br></pre></td></tr></table></figure><p>如何选择将运算符定义为成员函数还是普通函数：</p><ul><li>赋值<code>=</code>、下标<code>[]</code>、调用<code>()</code>和成员访问箭头<code>-&gt;</code>运算符必须是成员函数。</li><li>复合赋值运算符一般是成员函数，但并非必须。</li><li>改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。</li><li>具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。</li></ul><h2 id="输入和输出运算符（Input-and-Output-Operators）"><a href="#输入和输出运算符（Input-and-Output-Operators）" class="headerlink" title="输入和输出运算符（Input and Output Operators）"></a>输入和输出运算符（Input and Output Operators）</h2><h3 id="重载输出运算符-lt-lt-（Overloading-the-Output-Operator-lt-lt-）"><a href="#重载输出运算符-lt-lt-（Overloading-the-Output-Operator-lt-lt-）" class="headerlink" title="重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）"></a>重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）</h3><p>通常情况下，输出运算符的第一个形参是<code>ostream</code>类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的<code>ostream</code>形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; item.<span class="built_in">isbn</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.units_sold &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">        &lt;&lt; item.revenue &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; item.<span class="built_in">avg_price</span>();</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出运算符应该尽量减少格式化操作。</p><p>输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。</p><h3 id="重载输入运算符-gt-gt-（Overloading-the-Input-Operator-gt-gt-）"><a href="#重载输入运算符-gt-gt-（Overloading-the-Input-Operator-gt-gt-）" class="headerlink" title="重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）"></a>重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）</h3><p>通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;is, Sales_data &amp;item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> price;   <span class="comment">// no need to initialize; we&#x27;ll read into price before we use it</span></span><br><span class="line">    is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price;</span><br><span class="line">    <span class="keyword">if</span> (is)    <span class="comment">// check that the inputs succeeded</span></span><br><span class="line">        item.revenue = item.units_sold * price;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        item = <span class="built_in">Sales_data</span>();    <span class="comment">// input failed: give the object the default state</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入运算符必须处理输入失败的情况，而输出运算符不需要。</p><p>以下情况可能导致读取操作失败：</p><ul><li>读取了错误类型的数据。</li><li>读取操作到达文件末尾。</li><li>遇到输入流的其他错误。</li></ul><p>当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。</p><p>如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置<code>failbit</code>状态。<code>eofbit</code>、<code>badbit</code>等错误最好由IO标准库自己标示。</p><h2 id="算术和关系运算符（Arithmetic-and-Relational-Operators）"><a href="#算术和关系运算符（Arithmetic-and-Relational-Operators）" class="headerlink" title="算术和关系运算符（Arithmetic and Relational Operators）"></a>算术和关系运算符（Arithmetic and Relational Operators）</h2><p>通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。</p><p>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的<code>const</code>类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs;   <span class="comment">// copy data members from lhs into sum</span></span><br><span class="line">    sum += rhs;     <span class="comment">// add rhs into sum</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。</p><h3 id="相等运算符（Equality-Operators）"><a href="#相等运算符（Equality-Operators）" class="headerlink" title="相等运算符（Equality Operators）"></a>相等运算符（Equality Operators）</h3><p>相等运算符设计准则：</p><ul><li><p>如果类在逻辑上有相等性的含义，则应该定义<code>operator==</code>而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。</p></li><li><p>通常情况下，<code>operator==</code>应该具有传递性。</p></li><li><p>如果类定义了<code>operator==</code>，则也应该定义<code>operator!=</code>。</p></li><li><p><code>operator==</code>和<code>operator!=</code>中的一个应该把具体工作委托给另一个。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>() &amp;&amp;</span><br><span class="line">        lhs.units_sold == rhs.units_sold &amp;&amp;</span><br><span class="line">        lhs.revenue == rhs.revenue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> !(lhs == rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="关系运算符（Relational-Operators）"><a href="#关系运算符（Relational-Operators）" class="headerlink" title="关系运算符（Relational Operators）"></a>关系运算符（Relational Operators）</h3><p>定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义<code>operator&lt;</code>会比较实用。</p><p>关系运算符设计准则：</p><ul><li>定义顺序关系，令其与关联容器中对关键字的要求保持一致。</li><li>如果类定义了<code>operator==</code>，则关系运算符的定义应该与<code>operator==</code>保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。</li><li>只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义<code>operator&lt;</code>。</li></ul><h2 id="赋值运算符（Assignment-Operators）"><a href="#赋值运算符（Assignment-Operators）" class="headerlink" title="赋值运算符（Assignment Operators）"></a>赋值运算符（Assignment Operators）</h2><p>赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(initializer_list&lt;string&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// alloc_n_copy allocates space and copies elements from the given range</span></span><br><span class="line">    <span class="keyword">auto</span> data = <span class="built_in">alloc_n_copy</span>(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();     <span class="comment">// destroy the elements in this object and free the space</span></span><br><span class="line">    elements = data.first;      <span class="comment">// update data members to point to the new</span></span><br><span class="line">    space</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// member binary operator: left-hand operand is bound to the implicit this pointer</span></span><br><span class="line"><span class="comment">// assumes that both objects refer to the same book</span></span><br><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>+=(<span class="type">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下标运算符（Subscript-Operator）"><a href="#下标运算符（Subscript-Operator）" class="headerlink" title="下标运算符（Subscript Operator）"></a>下标运算符（Subscript Operator）</h2><p>下标运算符必须定义为成员函数。</p><p>类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> n) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string *elements;  <span class="comment">// pointer to the first element in the array</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递增和递减运算符（Increment-and-Decrement-Operators）"><a href="#递增和递减运算符（Increment-and-Decrement-Operators）" class="headerlink" title="递增和递减运算符（Increment and Decrement Operators）"></a>递增和递减运算符（Increment and Decrement Operators）</h2><p>定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。</p><p>为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// prefix: return a reference to the incremented/decremented object</span></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    ++curr;     <span class="comment">// advance the current state</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后置递增或递减运算符接受一个额外的（不被使用）<code>int</code>类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// increment and decrement</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>++();    <span class="comment">// prefix operators</span></span><br><span class="line">    StrBlobPtr&amp; <span class="keyword">operator</span>--();</span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>++(<span class="type">int</span>);  <span class="comment">// postfix operators</span></span><br><span class="line">    StrBlobPtr <span class="keyword">operator</span>--(<span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的<code>const</code>类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;    <span class="comment">// save the current value</span></span><br><span class="line">    ++*<span class="keyword">this</span>;      <span class="comment">// advance one element; prefix ++ checks the increment</span></span><br><span class="line">    <span class="keyword">return</span> ret;   <span class="comment">// return the saved state</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;   <span class="comment">// p points to the vector inside a1</span></span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);    <span class="comment">// call postfix operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();     <span class="comment">// call prefix operator++</span></span><br></pre></td></tr></table></figure><h2 id="成员访问运算符（Member-Access-Operators）"><a href="#成员访问运算符（Member-Access-Operators）" class="headerlink" title="成员访问运算符（Member Access Operators）"></a>成员访问运算符（Member Access Operators）</h2><p>箭头运算符必须定义为成员函数，解引用运算符通常也是如此。</p><p>重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrBlobPtr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string&amp; <span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr];   <span class="comment">// (*p) is the vector to which this object points</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::string* <span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;   <span class="comment">// delegate the real work to the dereference operator</span></span><br><span class="line">        <span class="keyword">return</span> &amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于形如<code>point-&gt;mem</code>的表达式来说，<em>point</em>必须是指向类对象的指针或者是一个重载了<code>operator-&gt;</code>的类的对象。<em>point</em>类型不同，<code>point-&gt;mem</code>的含义也不同。</p><ul><li>如果<em>point</em>是指针，则调用内置箭头运算符，表达式等价于<code>(*point).mem</code>。</li><li>如果<em>point</em>是重载了<code>operator-&gt;</code>的类的对象，则使用<code>point.operator-&gt;()</code>的结果来获取<em>mem</em>，表达式等价于<code>(point.operator-&gt;())-&gt;mem</code>。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。</li></ul><h2 id="函数调用运算符（Function-Call-Operator）"><a href="#函数调用运算符（Function-Call-Operator）" class="headerlink" title="函数调用运算符（Function-Call Operator）"></a>函数调用运算符（Function-Call Operator）</h2><p>函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrintString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrintString</span>(ostream &amp;o = cout, <span class="type">char</span> c = <span class="string">&#x27; &#x27;</span>):</span><br><span class="line">        <span class="built_in">os</span>(o), <span class="built_in">sep</span>(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; s &lt;&lt; sep;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream &amp;os;   <span class="comment">// stream on which to write</span></span><br><span class="line">    <span class="type">char</span> sep;      <span class="comment">// character to print after each output</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PrintString printer;  <span class="comment">// uses the defaults; prints to cout</span></span><br><span class="line"><span class="built_in">printer</span>(s);     <span class="comment">// prints s followed by a space on cout</span></span><br></pre></td></tr></table></figure><p>如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for_each(vs.<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), <span class="built_in">PrintString</span>(cerr, <span class="string">&#x27;\n&#x27;</span>));</span><br></pre></td></tr></table></figure><h3 id="lambda是函数对象（Lambdas-Are-Function-Objects）"><a href="#lambda是函数对象（Lambdas-Are-Function-Objects）" class="headerlink" title="lambda是函数对象（Lambdas Are Function Objects）"></a>lambda是函数对象（Lambdas Are Function Objects）</h3><p>编写一个<code>lambda</code>后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort words by size, but maintain alphabetical order for words of the same size</span></span><br><span class="line"><span class="built_in">stable_sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">    [](<span class="type">const</span> string &amp;a, <span class="type">const</span> string &amp;b) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &lt; b.<span class="built_in">size</span>(); &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// acts like an unnamed object of a class that would look something like</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ShorterString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>默认不能改变它捕获的变量。因此在默认情况下，由<code>lambda</code>产生的类中的函数调用运算符是一个<code>const</code>成员函数。如果<code>lambda</code>被声明为可变的，则调用运算符就不再是<code>const</code>函数了。</p><p><code>lambda</code>通过引用捕获变量时，由程序负责确保<code>lambda</code>执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在<code>lambda</code>产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到<code>lambda</code>中，此时<code>lambda</code>产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to the first element whose size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [sz](<span class="type">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// would generate a class that looks something like</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SizeComp</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SizeComp</span>(<span class="type">size_t</span> n): <span class="built_in">sz</span>(n) &#123; &#125;   <span class="comment">// parameter for each captured variable</span></span><br><span class="line">    <span class="comment">// call operator with the same return type, parameters, and body as the lambda</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> string &amp;s)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> sz;   <span class="comment">// a data member for each variable captured by value</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>lambda</code>产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数则通常要视捕获的变量类型而定。</p><h3 id="标准库定义的函数对象（Library-Defined-Function-Objects）"><a href="#标准库定义的函数对象（Library-Defined-Function-Objects）" class="headerlink" title="标准库定义的函数对象（Library-Defined Function Objects）"></a>标准库定义的函数对象（Library-Defined Function Objects）</h3><p>标准库在头文件<em>functional</em>中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-2.png" alt="14-2"></p><p>关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string *&gt; nameTable;    <span class="comment">// vector of pointers</span></span><br><span class="line"><span class="comment">// error: the pointers in nameTable are unrelated, so &lt; is undefined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(),</span><br><span class="line">        [](string *a, string *b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="comment">// ok: library guarantees that less on pointer types is well defined</span></span><br><span class="line"><span class="built_in">sort</span>(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), <span class="built_in">less</span>&lt;string*&gt;());</span><br></pre></td></tr></table></figure><h3 id="可调用对象与function（Callable-Objects-and-function）"><a href="#可调用对象与function（Callable-Objects-and-function）" class="headerlink" title="可调用对象与function（Callable Objects and function）"></a>可调用对象与function（Callable Objects and function）</h3><p>调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。</p><p>标准库<code>function</code>类型是一个模板，定义在头文件<em>functional</em>中，用来表示对象的调用形式。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/14-3.png" alt="14-3"></p><p>创建一个具体的<code>function</code>类型时必须提供其所表示的对象的调用形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ordinary function</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="comment">// function-object class</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">div</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> denominator, <span class="type">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f1 = add;      <span class="comment">// function pointer</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f2 = <span class="built_in">div</span>();    <span class="comment">// object of a function-object class</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; f3 = [](<span class="type">int</span> i, <span class="type">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;;  <span class="comment">// lambda</span></span><br><span class="line">                                   </span><br><span class="line">cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 6</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 2</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">f3</span>(<span class="number">4</span>,<span class="number">2</span>) &lt;&lt; endl;   <span class="comment">// prints 8</span></span><br></pre></td></tr></table></figure><p>不能直接将重载函数的名字存入<code>function</code>类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用<code>lambda</code>或者存储函数指针而非函数名字。</p><p>C++11新标准库中的<code>function</code>类与旧版本中的<code>unary_function</code>和<code>binary_function</code>没有关系，后两个类已经被<code>bind</code>函数代替。</p><h2 id="重载、类型转换与运算符（Overloading，Conversions，and-Operators）"><a href="#重载、类型转换与运算符（Overloading，Conversions，and-Operators）" class="headerlink" title="重载、类型转换与运算符（Overloading，Conversions，and Operators）"></a>重载、类型转换与运算符（Overloading，Conversions，and Operators）</h2><p>转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。</p><h3 id="类型转换运算符（Conversion-Operators）"><a href="#类型转换运算符（Conversion-Operators）" class="headerlink" title="类型转换运算符（Conversion Operators）"></a>类型转换运算符（Conversion Operators）</h3><p>类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>类型转换运算符可以面向除了<code>void</code>以外的任意类型（该类型要能作为函数的返回类型）进行定义。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> i = <span class="number">0</span>): <span class="built_in">val</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Bad SmallInt value&quot;</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the double argument is converted to int using the built-in conversion</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>;     <span class="comment">// calls the SmallInt(int) constructor</span></span><br><span class="line"><span class="comment">// the SmallInt conversion operator converts si to int;</span></span><br><span class="line">si + <span class="number">3.14</span>;     <span class="comment">// that int is converted to double using the built-in conversion</span></span><br></pre></td></tr></table></figure><p>应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。</p><p>C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// the compiler won&#x27;t automatically apply this conversion</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt si = <span class="number">3</span>;    <span class="comment">// ok: the SmallInt constructor is not explicit</span></span><br><span class="line">si + <span class="number">3</span>;     <span class="comment">// error: implicit is conversion required, but operator int is explicit</span></span><br><span class="line"><span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(si) + <span class="number">3</span>;    <span class="comment">// ok: explicitly request the conversion</span></span><br></pre></td></tr></table></figure><p>如果表达式被用作条件，则编译器会隐式地执行显式类型转换。</p><ul><li><code>if</code>、<code>while</code>、<code>do-while</code>语句的条件部分。</li><li><code>for</code>语句头的条件表达式。</li><li>条件运算符<code>? :</code>的条件表达式。</li><li>逻辑非运算符<code>!</code>、逻辑或运算符<code>||</code>、逻辑与运算符<code>&amp;&amp;</code>的运算对象。</li></ul><p>类类型向<code>bool</code>的类型转换通常用在条件部分，因此<code>operator bool</code>一般被定义为显式的。</p><h3 id="避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）"><a href="#避免有二义性的类型转换（Avoiding-Ambiguous-Conversions）" class="headerlink" title="避免有二义性的类型转换（Avoiding Ambiguous Conversions）"></a>避免有二义性的类型转换（Avoiding Ambiguous Conversions）</h3><p>在两种情况下可能产生多重转换路径：</p><ul><li><p><em>A</em>类定义了一个接受<em>B</em>类对象的转换构造函数，同时<em>B</em>类定义了一个转换目标是<em>A</em>类的类型转换运算符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usually a bad idea to have mutual conversions between two class types</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> B&amp;); <span class="comment">// converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="type">const</span></span>; <span class="comment">// also converts a B to an A</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="type">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = <span class="built_in">f</span>(b);    <span class="comment">// error ambiguous: f(B::operator A())</span></span><br><span class="line">               <span class="comment">// or f(A::A(const B&amp;))</span></span><br></pre></td></tr></table></figure></li><li><p>类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> = <span class="number">0</span>);     <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="built_in">A</span>(<span class="type">double</span>);      <span class="comment">// conversions from arithmetic types</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span></span>;       <span class="comment">// usually a bad idea to have two</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// conversions to arithmetic types</span></span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">long</span> <span class="type">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">f2</span>(a);    <span class="comment">// error ambiguous: f(A::operator int())</span></span><br><span class="line">          <span class="comment">// or f(A::operator double())</span></span><br><span class="line"><span class="type">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>;   <span class="comment">// error ambiguous: A::A(int) or A::A(double)</span></span><br></pre></td></tr></table></figure></li></ul><p>可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1 = <span class="built_in">f</span>(b.<span class="keyword">operator</span> <span class="built_in">A</span>());    <span class="comment">// ok: use B&#x27;s conversion operator</span></span><br><span class="line">A a2 = <span class="built_in">f</span>(<span class="built_in">A</span>(b));     <span class="comment">// ok: use A&#x27;s constructor</span></span><br></pre></td></tr></table></figure><p>通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。</p><p>使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。</p><p>如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。</p><p>调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">E</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">E</span>(<span class="type">double</span>);</span><br><span class="line">    <span class="comment">// other members</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> C&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manip2</span><span class="params">(<span class="type">const</span> E&amp;)</span></span>;</span><br><span class="line"><span class="comment">// error ambiguous: two different user-defined conversions could be used</span></span><br><span class="line"><span class="built_in">manip2</span>(<span class="number">10</span>);    <span class="comment">// manip2(C(10) or manip2(E(double(10)))</span></span><br></pre></td></tr></table></figure><h3 id="函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）"><a href="#函数匹配与重载运算符（Function-Matching-and-Overloaded-Operators）" class="headerlink" title="函数匹配与重载运算符（Function Matching and Overloaded Operators）"></a>函数匹配与重载运算符（Function Matching and Overloaded Operators）</h3><p>表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SmallInt</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> SmallInt <span class="keyword">operator</span>+(<span class="type">const</span> SmallInt&amp;, <span class="type">const</span> SmallInt&amp;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SmallInt</span>(<span class="type">int</span> = <span class="number">0</span>);    <span class="comment">// conversion from int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;    <span class="comment">// conversion to int</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::<span class="type">size_t</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SmallInt s1, s2;</span><br><span class="line">SmallInt s3 = s1 + s2;    <span class="comment">// uses overloaded operator+</span></span><br><span class="line"><span class="type">int</span> i = s3 + <span class="number">0</span>;    <span class="comment">// error: ambiguous</span></span><br></pre></td></tr></table></figure><p>如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第14章-重载运算与类型转换&quot;&gt;&lt;a href=&quot;#第14章-重载运算与类型转换&quot; class=&quot;headerlink&quot; title=&quot;第14章 重载运算与类型转换&quot;&gt;&lt;/a&gt;第14章 重载运算与类型转换&lt;/h1&gt;&lt;h2 id=&quot;基本概念（Basic-Concep</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十三章-拷贝控制</title>
    <link href="http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <id>http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</id>
    <published>2022-03-07T12:25:30.000Z</published>
    <updated>2022-06-29T13:17:34.702Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十三章-拷贝控制"><a href="#第十三章-拷贝控制" class="headerlink" title="第十三章 拷贝控制"></a>第十三章 拷贝控制</h2><p>主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。</p><p><strong>关于拷贝不在赘述，主要要记得当一个类里有指针类型时，要注意深拷贝和浅拷贝的问题，比如Myclass b = a；就是如果是浅拷贝的话，b中拷贝过来的指针和a中原来的指针指向的是同一块位置，那么就要考虑要析构b的时候，a对象是否还再用，如果还在用就不能析构指针指向这块内存，防止出现a对象这个指针指向未定义的情况发生。如果是深拷贝的话，就是说a对象和b对象的指针指向的东西也不是在一块内存上，所以可以正常析构。具体要深拷贝还是浅拷贝还是要看业务类型来实现处理。</strong></p><h4 id="对象移动（Moving-Objects）"><a href="#对象移动（Moving-Objects）" class="headerlink" title="对象移动（Moving Objects）"></a>对象移动（Moving Objects）</h4><p>某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。</p><p>在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。</p><p>标准库容器、<code>string</code>和<code>shared_ptr</code>类既支持移动也支持拷贝。IO类和<code>unique_ptr</code>类可以移动但不能拷贝。</p><h4 id="右值引用（Rvalue-Reference）"><a href="#右值引用（Rvalue-Reference）" class="headerlink" title="右值引用（Rvalue Reference）"></a>右值引用（Rvalue Reference）</h4><p>为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过<code>&amp;&amp;</code>来获得右值引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;r = i;         <span class="comment">// ok: r refers to i</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr = i;       <span class="comment">// error: cannot bind an rvalue reference to an</span></span><br><span class="line"><span class="type">int</span> &amp;r2 = i * <span class="number">42</span>;   <span class="comment">// error: i * 42 is an rvalue</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r3 = i * <span class="number">42</span>;    <span class="comment">// ok: we can bind a reference to const to an rvalue</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;        <span class="comment">// ok: bind rr2 to the result of the multiplication</span></span><br></pre></td></tr></table></figure><p>右值引用只能绑定到<strong>即将被销毁，并且没有其他用户的临时对象</strong>上。使用右值引用的代码可以自由地接管所引用对象的资源。</p><p>变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr1 = <span class="number">42</span>;     <span class="comment">// ok: literals are rvalues</span></span><br><span class="line"><span class="type">int</span> &amp;&amp;rr2 = rr1;    <span class="comment">// error: the expression rr1 is an lvalue!</span></span><br></pre></td></tr></table></figure><p>调用<code>move</code>函数可以获得绑定在左值上的右值引用，此函数定义在头文件<em>utility</em>中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp;rr3 = std::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure><p>调用<code>move</code>函数的代码应该使用<code>std::move</code>而非<code>move</code>，这样做可以避免潜在的名字冲突。</p><hr><h4 id="移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）"><a href="#移动构造函数和移动赋值运算符（Move-Constructor-and-Move-Assignment）" class="headerlink" title="移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）"></a>移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）</h4><p>移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。</p><p>除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。</p><p>在函数的形参列表后面添加关键字<code>noexcept</code>可以指明该函数不会抛出任何异常。</p><p>对于构造函数，<code>noexcept</code>位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定<code>noexcept</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StrVec</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StrVec</span>(StrVec&amp;&amp;) <span class="keyword">noexcept</span>;  <span class="comment">// move constructor</span></span><br><span class="line">    <span class="comment">// other members as before</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">StrVec::<span class="built_in">StrVec</span>(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> : <span class="comment">/* member initializers */</span></span><br><span class="line">&#123; <span class="comment">/* constructor body */</span> &#125;</span><br></pre></td></tr></table></figure><p>标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。</p><p>不抛出异常的移动构造函数和移动赋值运算符必须标记为<code>noexcept</code>。</p><p>在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// direct test for self-assignment</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();     <span class="comment">// free existing elements</span></span><br><span class="line">        elements = rhs.elements;    <span class="comment">// take over resources from rhs</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// leave rhs in a destructible state</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有当一个类没有定义任何拷贝控制成员，且类的每个非<code>static</code>数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the compiler will synthesize the move operations for X and hasX</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;   <span class="comment">// built-in types can be moved</span></span><br><span class="line">    std::string s;   <span class="comment">// string defines its own move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hasX</span></span><br><span class="line">&#123;</span><br><span class="line">    X mem; <span class="comment">// X has synthesized move operations</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">X x, x2 = std::<span class="built_in">move</span>(x);         <span class="comment">// uses the synthesized move constructor</span></span><br><span class="line">hasX hx, hx2 = std::<span class="built_in">move</span>(hx);   <span class="comment">// uses the synthesized move constructor</span></span><br></pre></td></tr></table></figure><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成<code>=default</code>的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。</p><p>定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。</p><p>如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用<code>move</code>函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo&amp;);    <span class="comment">// copy constructor</span></span><br><span class="line">    <span class="comment">// other members, but Foo does not define a move constructor</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;   <span class="comment">// copy constructor; x is an lvalue</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(std::move(x))</span></span>;    <span class="comment">// copy constructor, because there is no move constructor</span></span><br></pre></td></tr></table></figure><p>使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// assignment operator is both the move- and copy-assignment operator</span></span><br><span class="line">HasPtr&amp; <span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(*<span class="keyword">this</span>, rhs);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hp = hp2;   <span class="comment">// hp2 is an lvalue; copy constructor used to copy hp2</span></span><br><span class="line">hp = std::<span class="built_in">move</span>(hp2);    <span class="comment">// move constructor moves hp2</span></span><br></pre></td></tr></table></figure><p>建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。</p><p>移动赋值运算符可以直接检查自赋值情况。</p><p>C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。</p><p>调用<code>make_move_iterator</code>函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。</p><p>最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用<code>move</code>操作。</p><h4 id="右值引用和成员函数（Rvalue-References-and-Member-Functions）"><a href="#右值引用和成员函数（Rvalue-References-and-Member-Functions）" class="headerlink" title="右值引用和成员函数（Rvalue References and Member Functions）"></a>右值引用和成员函数（Rvalue References and Member Functions）</h4><p>区分移动和拷贝的重载函数通常有一个版本接受一个<code>const T&amp;</code>参数，另一个版本接受一个<code>T&amp;&amp;</code>参数（<em>T</em>为类型）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(<span class="type">const</span> X&amp;)</span></span>;   <span class="comment">// copy: binds to any kind of X</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;        <span class="comment">// move: binds only to modifiable rvalues of type X</span></span><br></pre></td></tr></table></figure><p>有时可以对右值赋值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s1, s2;</span><br><span class="line">s1 + s2 = <span class="string">&quot;wow!&quot;</span>;</span><br></pre></td></tr></table></figure><p>在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即<code>this</code>指向的对象）必须是一个左值。</p><p>在非<code>static</code>成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定<code>this</code>的左值/右值属性。引用限定符可以是<code>&amp;</code>或者<code>&amp;&amp;</code>，分别表示<code>this</code>可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo&amp;) &amp;; <span class="comment">// may assign only to modifiable lvalues</span></span><br><span class="line">    <span class="comment">// other members of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;rhs) &amp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do whatever is needed to assign rhs to this object</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个非<code>static</code>成员函数可以同时使用<code>const</code>和引用限定符，此时引用限定符跟在<code>const</code>限定符之后。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="type">const</span></span>;      <span class="comment">// error: const qualifier must come first</span></span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// ok: const qualifier comes first</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>引用限定符也可以区分成员函数的重载版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;        <span class="comment">// may run on modifiable rvalues</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span> &amp;</span>;   <span class="comment">// may run on any kind of Foo</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">retVal</span>().<span class="built_in">sorted</span>();   <span class="comment">// retVal() is an rvalue, calls Foo::sorted() &amp;&amp;</span></span><br><span class="line"><span class="built_in">retFoo</span>().<span class="built_in">sorted</span>();   <span class="comment">// retFoo() is an lvalue, calls Foo::sorted() const &amp;</span></span><br></pre></td></tr></table></figure><p>如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="type">const</span></span>;    <span class="comment">// error: must have reference qualifier</span></span><br><span class="line">    <span class="comment">// Comp is type alias for the function type</span></span><br><span class="line">    <span class="comment">// that can be used to compare int values</span></span><br><span class="line">    <span class="keyword">using</span> Comp = <span class="built_in">bool</span>(<span class="type">const</span> <span class="type">int</span>&amp;, <span class="type">const</span> <span class="type">int</span>&amp;);</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp*)</span></span>;  <span class="comment">// ok: different parameter list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><strong>理解move</strong></p><p>这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。</p><p><strong>注意：使用move不会释放源对象，所以一定要确保源对象不会再使用了，才能用move</strong></p><p>详细帖子：</p><p><a href="https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c+++%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c%2B%2B+%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十三章-拷贝控制&quot;&gt;&lt;a href=&quot;#第十三章-拷贝控制&quot; class=&quot;headerlink&quot; title=&quot;第十三章 拷贝控制&quot;&gt;&lt;/a&gt;第十三章 拷贝控制&lt;/h2&gt;&lt;p&gt;主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。&lt;/p&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十二章 动态内存</title>
    <link href="http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    <id>http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</id>
    <published>2022-03-05T12:25:30.000Z</published>
    <updated>2022-06-29T13:22:36.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第十二章-动态内存"><a href="#第十二章-动态内存" class="headerlink" title="第十二章 动态内存"></a>第十二章 动态内存</h2><p>程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。</p><h3 id="动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）"><a href="#动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）" class="headerlink" title="动态内存与智能指针（Dynamic Memory and Smart Pointers）"></a>动态内存与智能指针（Dynamic Memory and Smart Pointers）</h3><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p><p>新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<em>memory</em>中。</p><h4 id="shared-ptr类（The-shared-ptr-Class）"><a href="#shared-ptr类（The-shared-ptr-Class）" class="headerlink" title="shared_ptr类（The shared_ptr Class）"></a>shared_ptr类（The shared_ptr Class）</h4><p>智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;      <span class="comment">// shared_ptr that can point at a string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;   <span class="comment">// shared_ptr that can point at a list of ints</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211518263.png" alt="image-20220629211518263"></p><p><code>shared_ptr</code>独有的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20211211141442645.png" alt="image-20211211141442645"></p><p><code>make_shared</code>函数（定义在头文件<em>memory</em>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>shared_ptr</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr that points to an int with value 42</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 points to a string with value 9999999999</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// p5 points to an int that is value initialized</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure><p>进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// object to which p points has one user</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  <span class="comment">// p and q point to the same object</span></span><br><span class="line">            <span class="comment">// object to which p and q point has two users</span></span><br></pre></td></tr></table></figure><p>每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// int to which r points has one user</span></span><br><span class="line">r = q;  <span class="comment">// assign to r, making it point to a different address</span></span><br><span class="line">        <span class="comment">// increase the use count for the object to which q points</span></span><br><span class="line">        <span class="comment">// reduce the use count of the object to which r had pointed</span></span><br><span class="line">        <span class="comment">// the object r had pointed to has no users; that object is automatically freed</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数会销毁对象并释放空间。</p><p>如果将<code>shared_ptr</code>存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用<code>erase</code>删除不再需要的元素。</p><p>程序使用动态内存通常出于以下三种原因之一：</p><ul><li>不确定需要使用多少对象。</li><li>不确定所需对象的准确类型。</li><li>需要在多个对象间共享数据。</li></ul><h4 id="shared-ptr和new结合使用（Using-shared-ptrs-with-new）"><a href="#shared-ptr和new结合使用（Using-shared-ptrs-with-new）" class="headerlink" title="shared_ptr和new结合使用（Using shared_ptrs with new）"></a>shared_ptr和new结合使用（Using shared_ptrs with new）</h4><p>可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">// error: must use direct initialization</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;     <span class="comment">// ok: uses direct initialization</span></span><br></pre></td></tr></table></figure><p>默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211535799.png" alt="image-20220629211535799"></p><p>不要混合使用内置指针和智能指针。当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr is created and initialized when process is called</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use ptr</span></span><br><span class="line">&#125;   <span class="comment">// ptr goes out of scope and is destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">// dangerous: x is a plain pointer, not a smart pointer</span></span><br><span class="line"><span class="built_in">process</span>(x);     <span class="comment">// error: cannot convert int* to shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));    <span class="comment">// legal, but the memory will be deleted!</span></span><br><span class="line"><span class="type">int</span> j = *x;     <span class="comment">// undefined: x is a dangling pointer!</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;   <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="built_in">process</span>(p);     <span class="comment">// copying p increments its count; in process the reference count is 2</span></span><br><span class="line"><span class="type">int</span> i = *p;     <span class="comment">// ok: reference count is 1</span></span><br></pre></td></tr></table></figure><p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p><p>不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();   <span class="comment">// ok: but don&#x27;t use q in any way that might delete its pointer</span></span><br><span class="line">&#123;   <span class="comment">// new block</span></span><br><span class="line">    <span class="comment">// undefined: two independent shared_ptrs point to the same memory</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(q);</span><br><span class="line">&#125; <span class="comment">// block ends, q is destroyed, and the memory to which q points is freed</span></span><br><span class="line"><span class="type">int</span> foo = *p;   <span class="comment">// undefined; the memory to which p points was freed</span></span><br></pre></td></tr></table></figure><p>可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));   <span class="comment">// we aren&#x27;t alone; allocate a new copy</span></span><br><span class="line">*p += newVal;   <span class="comment">// now that we know we&#x27;re the only pointer, okay to change this object</span></span><br></pre></td></tr></table></figure><h4 id="智能指针和异常（Smart-Pointers-and-Exceptions）"><a href="#智能指针和异常（Smart-Pointers-and-Exceptions）" class="headerlink" title="智能指针和异常（Smart Pointers and Exceptions）"></a>智能指针和异常（Smart Pointers and Exceptions）</h4><p>如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ip = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);    <span class="comment">// dynamically allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">    <span class="keyword">delete</span> ip;     <span class="comment">// free the memory before exiting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">&#125; <span class="comment">// shared_ptr freed automatically when the function ends</span></span><br></pre></td></tr></table></figure><p>默认情况下<code>shared_ptr</code>假定其指向动态内存，使用<code>delete</code>释放对象。创建<code>shared_ptr</code>时可以传递一个（可选）指向删除函数的指针参数，用来代替<code>delete</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;    <span class="comment">// represents what we are connecting to</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;     <span class="comment">// information needed to use the connection</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;   <span class="comment">// open the connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;    <span class="comment">// close the given connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other parameters */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// use the connection</span></span><br><span class="line">    <span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>智能指针规范：</p><ul><li>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</li><li>不释放<code>get</code>返回的指针。</li><li>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</li><li>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</li><li>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</li></ul><hr><h4 id="深度理解智能指针"><a href="#深度理解智能指针" class="headerlink" title="深度理解智能指针"></a>深度理解智能指针</h4><p><strong>1.智能指针的作用</strong></p><p>​    C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。</p><p>理解智能指针需要从下面三个层次：</p><ol><li>从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。</li><li>智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。</li><li>智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同，在Java里面下列代码：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　<span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">　　<span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>   你当然知道，这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal a;</span><br><span class="line">Animal b = a;</span><br></pre></td></tr></table></figure><p>   这里却是就是生成了两个对象。</p><p>2.智能指针的实质</p><p>   前面已经说过了，<strong>智能指针是一个类对象（类似迭代器，其实也是用类对象来模拟指针的作用）</strong>，这样在被调函数执行完，程序过期时，对象将会被删除（对象的名字保存在栈变量中），这样不仅对象会被删除，它指向的内存也会被删除的。</p><p>智能指针在C++11版本之后提供，包含在头文件<memory>中，shared_ptr、unique_ptr、auto_ptr</p><p>建议：</p><p>​      1-每种指针都有不同的使用范围，unique_ptr指针优于其它两种类型，除非对象需要共享时用shared_ptr。</p><p>​      2- 建议– 如果你没有打算在多个线程之间来共享资源的话，那么就请使用unique_ptr。</p><p>​      3 -建议- 使用make_shared而不是裸指针来初始化共享指针。</p><p>​      4 -建议 – 在设计类的时候，当不需要资源的所有权，而且你不想指定这个对象的生命周期时，可以考虑使用weak_ptr代替shared_ptr。</p><p>使用智能指针的时候，只需要将new出的地址值赋值给这种对象，也就是将new出的地址作为实参！</p><p><strong>总结：智能指针其实就是类对象，来模拟指针的效果，从而实现更安全的管理内存的操作，实现了自动释放内存等功能。<br>智能指针分类，最简单实用的是unique_ptr,如果要多个指针指向同一个对象的话，要使用shared_ptr，同时因为多个指针<br>操作一个对象，一定会带来多线程那种读写脏数据的问题，这时候就要加锁，而这里加锁的方式就是通过使用weak_ptr的<br>lock()函数来进行的。而对于shared_ptr的数据结构，其实就是里边有一个count计数的类，并且重载了&gt;和*以及=等操作，<br>并且根据实际需要实现维护count和释放内存的操作。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第十二章-动态内存&quot;&gt;&lt;a href=&quot;#第十二章-动态内存&quot; class=&quot;headerlink&quot; title=&quot;第十二章 动态内存&quot;&gt;&lt;/a&gt;第十二章 动态内存&lt;/h2&gt;&lt;p&gt;程序用堆（heap）来存储动态分配（dynamically allocate）的对象</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
  <entry>
    <title>C++ Primer笔记|第十一章-关联容器</title>
    <link href="http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</id>
    <published>2022-03-02T12:25:30.000Z</published>
    <updated>2022-06-29T13:11:59.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第11章-关联容器"><a href="#第11章-关联容器" class="headerlink" title="第11章 关联容器"></a>第11章 关联容器</h1><p>关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是<code>map</code>和<code>set</code>。</p><ul><li><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</li><li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</li></ul><p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p><ul><li>是<code>map</code>还是<code>set</code>类型。</li><li>是否允许保存重复的关键字。</li><li>是否按顺序保存元素。</li></ul><p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-1.png" alt="11-1"></p><p><code>map</code>和<code>multimap</code>类型定义在头文件<em>map</em>中；<code>set</code>和<code>multiset</code>类型定义在头文件<em>set</em>中；无序容器定义在头文件<em>unordered_map</em>和<em>unordered_set</em>中。</p><h2 id="使用关联容器（Using-an-Associative-Container）"><a href="#使用关联容器（Using-an-Associative-Container）" class="headerlink" title="使用关联容器（Using an Associative Container）"></a>使用关联容器（Using an Associative Container）</h2><p><code>map</code>类型通常被称为关联数组（associative array）。</p><p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count the number of times each word occurs in the input</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;     <span class="comment">// empty map from string to size_t</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];     <span class="comment">// fetch and increment the counter for word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)    <span class="comment">// for each element in the map</span></span><br><span class="line">    <span class="comment">// print the results</span></span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p><h2 id="关联容器概述（Overview-of-the-Associative-Containers）"><a href="#关联容器概述（Overview-of-the-Associative-Containers）" class="headerlink" title="关联容器概述（Overview of the Associative Containers）"></a>关联容器概述（Overview of the Associative Containers）</h2><h3 id="定义关联容器（Defining-an-Associative-Container）"><a href="#定义关联容器（Defining-an-Associative-Container）" class="headerlink" title="定义关联容器（Defining an Associative Container）"></a>定义关联容器（Defining an Associative Container）</h3><p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p><p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;   <span class="comment">// empty</span></span><br><span class="line"><span class="comment">// list initialization</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// three elements; authors maps last name to first</span></span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p><h3 id="关键字类型的要求（Requirements-on-Key-Type）"><a href="#关键字类型的要求（Requirements-on-Key-Type）" class="headerlink" title="关键字类型的要求（Requirements on Key Type）"></a>关键字类型的要求（Requirements on Key Type）</h3><p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p><p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bookstore can have several transactions with the same ISBN</span></span><br><span class="line"><span class="comment">// elements in bookstore will be in ISBN order</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="pair类型（The-pair-Type）"><a href="#pair类型（The-pair-Type）" class="headerlink" title="pair类型（The pair Type）"></a>pair类型（The pair Type）</h3><p><code>pair</code>定义在头文件<em>utility</em>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// holds two strings</span></span><br><span class="line">pair&lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">// holds a string and an size_t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; line;   <span class="comment">// holds string and vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure><p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p><p><code>pair</code>支持的操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-2.png" alt="11-2"></p><p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="comment">// list initialize</span></span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// explicitly constructed return value</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关联容器操作（Operations-on-Associative-Containers）"><a href="#关联容器操作（Operations-on-Associative-Containers）" class="headerlink" title="关联容器操作（Operations on Associative Containers）"></a>关联容器操作（Operations on Associative Containers）</h2><p>关联容器定义了类型别名来表示容器关键字和值的类型：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-3.png" alt="11-3"></p><p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是关键字-值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure><h3 id="关联容器迭代器（Associative-Container-Iterators）"><a href="#关联容器迭代器（Associative-Container-Iterators）" class="headerlink" title="关联容器迭代器（Associative Container Iterators）"></a>关联容器迭代器（Associative Container Iterators）</h3><p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to an element in word_count</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// *map_it is a reference to a pair&lt;const string, size_t&gt; object</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;first;          <span class="comment">// prints the key for this element</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; map_it-&gt;second;  <span class="comment">// prints the value of the element</span></span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;      <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second;               <span class="comment">// ok: we can change the value through an iterator</span></span><br></pre></td></tr></table></figure><p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error: keys in a set are read-only</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok: can read the key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p><p>通常不对关联容器使用泛型算法。</p><h3 id="添加元素（Adding-Elements）"><a href="#添加元素（Adding-Elements）" class="headerlink" title="添加元素（Adding Elements）"></a>添加元素（Adding Elements）</h3><p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p><p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// four ways to add word to word_count</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>关联容器的<code>insert</code>操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/image-20220629211132789.png" alt="image-20220629211132789"></p><p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p><ul><li>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</li><li>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</li></ul><h3 id="删除元素（Erasing-Elements）"><a href="#删除元素（Erasing-Elements）" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>关联容器的删除操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-5.png" alt="11-5"></p><p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p><h3 id="map的下标操作（Subscripting-a-map）"><a href="#map的下标操作（Subscripting-a-map）" class="headerlink" title="map的下标操作（Subscripting a map）"></a>map的下标操作（Subscripting a map）</h3><p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p><p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p><p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p><h3 id="访问元素（Accessing-Elements）"><a href="#访问元素（Accessing-Elements）" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><p>关联容器的查找操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-7.png" alt="11-7"></p><p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">// adds the first element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// ok: adds the second element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;      <span class="comment">// author we&#x27;ll look for</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_item);  <span class="comment">// number of elements</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);      <span class="comment">// first entry for this author</span></span><br><span class="line"><span class="comment">// loop through the number of entries there are for this author</span></span><br><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;   <span class="comment">// print each title</span></span><br><span class="line">    ++iter;      <span class="comment">// advance to the next title</span></span><br><span class="line">    --entries;   <span class="comment">// keep track of how many we&#x27;ve printed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// beg and end denote the range of elements for this author</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;    <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure><p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p><p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// pos holds iterators that denote the range of elements for this key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure><h2 id="无序容器（The-Unordered-Containers）"><a href="#无序容器（The-Unordered-Containers）" class="headerlink" title="无序容器（The Unordered Containers）"></a>无序容器（The Unordered Containers）</h2><p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p><p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p><p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p><p>无序容器管理操作：</p><p><img src="https://cdn.jsdelivr.net/gh/Icecorn/icecorn-pic/img/11-8.png" alt="11-8"></p><p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第11章-关联容器&quot;&gt;&lt;a href=&quot;#第11章-关联容器&quot; class=&quot;headerlink&quot; title=&quot;第11章 关联容器&quot;&gt;&lt;/a&gt;第11章 关联容器&lt;/h1&gt;&lt;p&gt;关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-</summary>
      
    
    
    
    <category term="ReadingNotes" scheme="http://icecorn.github.io/categories/ReadingNotes/"/>
    
    <category term="C++" scheme="http://icecorn.github.io/categories/ReadingNotes/C/"/>
    
    
    <category term="C++ Primer" scheme="http://icecorn.github.io/tags/C-Primer/"/>
    
  </entry>
  
</feed>
