{"meta":{"title":"Blog of Icecorn","subtitle":"","description":"","author":"Icecorn","url":"http://Icecorn.github.io","root":"/"},"pages":[{"title":"about","date":"2022-02-10T10:57:28.000Z","updated":"2022-06-29T10:57:55.898Z","comments":true,"path":"about/index.html","permalink":"http://icecorn.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-02-09T10:56:06.000Z","updated":"2022-06-29T10:56:40.411Z","comments":true,"path":"categories/index.html","permalink":"http://icecorn.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-02-09T10:53:15.000Z","updated":"2022-06-29T10:53:59.303Z","comments":true,"path":"tags/index.html","permalink":"http://icecorn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"单例模式|一文搞懂单例模式！","slug":"设计模式/一文搞定单例模式","date":"2022-06-29T09:25:10.000Z","updated":"2022-07-01T06:17:38.760Z","comments":true,"path":"2022/06/29/设计模式/一文搞定单例模式/","link":"","permalink":"http://icecorn.github.io/2022/06/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%80%E6%96%87%E6%90%9E%E5%AE%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"一文搞定单例模式简介通过单例模式， 可以做到：确保一个类只有一个实例被建立 ，也就是C++中定义全局的东西的一个通用做法。 在实现单例的过程中要注意如下问题： 构造函数应该声明为非公有，从而禁止外界创建实例 拷贝操作和移动操作也该禁止 只能通过singleton的共有特定类操作访问它的唯一实例（c++中的一个公有静态成员函数） 本文实现常见的饿汉式及懒汉式，以及多线程懒汉式的单例模式 饿汉式饿汉式顾名思义，就是我先准备好一个全局的实例，等到你需要getInstance的时候就直接获取就行了，普通的饿汉式的缺点就是以”空间换时间”，就是说在编译阶段已经给这个类在全局数据区分配好了内存并初始化了。 C98的饿汉模式在C++98版本，为了实现线程安全，要把istance实现成一个类内的成员变量，并且要在类外初始化它，不然编译器会报错。 1234567891011121314151617181920//-------------C98饿汉模式单例-----------------------------------class CSingleton98 &#123; private: CSingleton98() &#123; a = 98; cout &lt;&lt; &quot;c98饿汉模式单例使用全局静态对象，在编译时已经调用单例类构造函数分配内存并实例化出来了！&quot; &lt;&lt; endl; &#125; public: static CSingleton98 * GetInstance() &#123; return &amp;instance; &#125; private: static CSingleton98 instance;public: int a; //类中其他变量,这里懒得写get/set方法&#125;; CSingleton98 CSingleton98:: instance;//在类外初始化 我们在main函数中什么都不做打印试试看： 可以看到执行了单例类的构造函数，说明这种饿汉模式是在编译阶段已经在全局数据区分配了内存并初始化 12int main()&#123;&#125; 接着我们用如下代码测试，可以看到两次获取实例对象的地址是一致的，单例ok！ 123456int main()&#123; CSingleton98* inst98= CSingleton98::GetInstance(); CSingleton98* inst981= CSingleton98::GetInstance(); cout &lt;&lt; inst98-&gt;a &lt;&lt; endl; cout &lt;&lt; &amp;(*inst98) &lt;&lt; &quot; &quot; &lt;&lt; &amp;(*inst981) &lt;&lt; endl;&#125; C11的饿汉模式C11的饿汉模式表现在我们是将单例的instance作为一个局部static变量处理的（在函数内） 优点： 只有在程序第一次执行到GetInstance()函数的时候才会在全局数据区开辟内存并且初始化，也就是说我们没有在编译的时候就开辟内存，节省了不必要的空间开销！ 解决了static变量初始化的问题 C++只能保证在同一个文件中声明的static变量的初始化顺序与其变量声明的顺序一致。但是不能保证不同的文件中的static变量的初始化顺序。 然后对于单例模式而言，不同的单例对象之间进行调用也是常见的场景。比如我有一个单例，存储了程序启动时加载的配置文件的内容。另外有一个单例，掌管着一个全局唯一的日志管理器。在日志管理初始化的时候，要通过配置文件的单例对象来获取到某个配置项，实现日志打印。 这时候两个单例在不同文件中各自实现，很有可能在日志管理器的单例使用配置文件单例的时候，配置文件的单例对象是没有被初始化的。这个未初始化可能产生的风险指的是C++变量的未初始化，而不是说配置文件未加载的之类业务逻辑上的未初始化导致的问题。 而Meyers&#39; Singleton写法中，单例对象是第一次访问的时候（也就是第一次调用getInstance()函数的时候）才初始化的，但也是恰恰因为如此，因而能保证如果没有初始化，在该函数调用的时候，是能完成初始化的。所以先getInstance()再访问 这种形式的单例 其关键并不是在于这个形式。而是在于其内容，局部static变量能保证通过函数来获取static变量的时候，该函数返回的对象是肯定完成了初始化的！ 讲到这，我们对Meyers&#39; Singleton的盲目鼓吹也需冷静一下，因为C++同样能保证所有文件内（非函数内）的static变量在main()函数开始运行之后肯定是都能做完初始化的。所以如果你是在main()函数运行之后，用日志管理器的单例访问配置文件的单例，那么其实也是没有问题的… 这就引出Meyers&#39; Singleton的第二个优势，那就是当产生继承的时候。 这里有一个遗留问题：就是编译器在编译阶段如何决定先编译哪一个单例文件呢，由此产生的文件依赖问题怎么解决呢？ 解决了单例的继承问题 123456789101112131415161718class Singleton &#123;public: static void on() &#123;Singleton::isOn = true;&#125; static void off() &#123;Singleton::isOn = false;&#125; static bool state() &#123;return Singleton::isOn;&#125;private: static bool isOn;&#125;;class Monitor: public Singleton &#123;public: static void addBrightness(int val) &#123; brightness += val;&#125; static void subBrightness(int val) &#123; brightness -= val;&#125; static int getBrightness() &#123; return brightness;&#125;private: static int brightness;&#125;; 如果有子类继承这一父类，来拓展成新的子类，比如Monitor显示器类有开关状态，同时扩展了一个亮度的成员。但是父子类的static成员变量是共享的，其isOn成员会有问题。 场景：比如一个显示器类，一个灯类。他们都是singleton的子类。但是灯是否打开，不应该影响显示器是否打开 静态局部对象： 在程序执行到该对象的定义处时，创建对象并调用相应的构造函数！ 如果在定义对象时没有提供初始指，则会暗中调用默认构造函数，如果没有默认构造函数，则自动初始化为0。 如果在定义对象时提供了初始值，则会暗中调用类型匹配的带参的构造函数（包括拷贝构造函数），如果没有定义这样的构造函数，编译器可能报错！ 直到main（）结束后才会调用析构函数！ 静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化！ 123456789101112131415161718class CSingleton11 &#123; private: CSingleton11() &#123; a = 11; cout &lt;&lt; &quot;C11饿汉模式使用的是局部static变量，是在调用的时候分配到全局存储区的，不是在编译时就分配哦！&quot; &lt;&lt; endl; cout &lt;&lt; &quot;这是因为C11的编译器可以帮我们保证线程安全，俺们就不用操心啦！&quot; &lt;&lt; endl; &#125; public: static CSingleton11 * GetInstance() &#123; //静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化； static CSingleton11 instance; return &amp;instance; &#125; int a;&#125;; 以下是测试： 首先是main函数什么都不做： 结果就是什么都不会发生（笑，想起了莫里亚篇索隆对山治说的话，和最近的CP0段子哈哈哈） 调用GetInstance： 此时会在全局数据区开辟内存，并调用构造函数初始化 12CSingleton11* inst11= CSingleton11::GetInstance();cout &lt;&lt; inst11-&gt;a &lt;&lt; endl; 调用两次GetInstance： 此时只会调用一次构造函数，这正是局部static变量的特性（静态局部变量在程序执行到该对象的声明处时被首次初始化，即以后的函数调用不再进行初始化） 1234CSingleton11* inst11= CSingleton11::GetInstance(); CSingleton11* inst112= CSingleton11::GetInstance();cout &lt;&lt; inst11-&gt;a &lt;&lt; endl;cout &lt;&lt; &amp;(*inst11) &lt;&lt; &quot; &quot; &lt;&lt; &amp;(*inst112) &lt;&lt; endl; 这里顺便加深下记忆： 如果是全局static变量声明两次的话，编译器会报错的！ 1234static int a;std::cout &lt;&lt; &amp;a &lt;&lt; std::endl;static int a; //打咩！std::cout &lt;&lt; &amp;a &lt;&lt; std::endl; 这是C11下优化的饿汉模式单例，至于怎么保证线程安全的（不用加锁），这是C11编译器保证的！以后有时间再看！ 懒汉式懒汉式的特点就是延迟加载，只有到用到的时候才实例化instance 这里又有一个疑问：这么考虑的话上文的C11饿汉模式不应该是懒汉模式嘛？ 注意这里最下边一行实际上在编译之前实例化一个指针变量，但是相比于类变量，一个指针才4个字节而已，who cares！ 12345678910111213141516class CSingletonL &#123; public: static CSingletonL* GetInstance() &#123; if ( m_pInstance == nullptr ) m_pInstance = new CSingletonL(); return m_pInstance; &#125; private: CSingletonL()&#123;lazy = 3;&#125; static CSingletonL* m_pInstance; public: int lazy;&#125;;CSingletonL* CSingletonL::m_pInstance; 测试： 1234CSingletonL* instlazy = CSingletonL::GetInstance();CSingletonL* instlazy1 = CSingletonL::GetInstance();cout &lt;&lt; instlazy-&gt;lazy &lt;&lt; endl;cout &lt;&lt; &amp; (*instlazy) &lt;&lt; &quot; &quot; &lt;&lt; &amp; (*instlazy1) &lt;&lt; endl; 懒汉模式存在的问题在懒汉式的单例类中，其实有两个状态，单例未初始化和单例已经初始化。假设单例还未初始化，有两个线程同时调用GetInstance方法，这时执行 m_pInstance == NULL 肯定为真，然后两个线程都初始化一个单例，最后得到的指针并不是指向同一个地方，不满足单例类的定义了，所以懒汉式的写法会出现线程安全的问题！在多线程环境下，要对其进行修改。 深入的理解懒汉和饿汉其实就是看定义的事静态成员对象变量还是静态成员对象指针变量，因为如果定义了静态成员对象变量，程序在运行之初已经分配了空间，就要调用构造函数了，而你在调用getinstance的时候，不会再调用构造函数了，因为之前已经调用过了，你就是用的现成的，就是所谓的饿汉模式，上来先把吃的准备好了，因为饿怕了，怕后期准备会挨饿。 而定义了静态成员对象指针变量，程序运行之初也会分配空间，但是那个是指针的空间，而不是对象的空间，所以不会调用对象的构造函数，而只有调用getinstance进行new操作的时候，才会对其调用构造函数，就是现上轿现扎耳朵眼，比较懒惰，所以叫懒汉模式。 线程安全的懒汉模式使用double-check来保证不会每次进来都去获取锁，来提高性能，先判断不为空的话，直接返回了数据。 12345678910111213141516171819202122class Singleton &#123; private: static Singleton* m_instance; Singleton()&#123;&#125; public: static Singleton* getInstance(); &#125;; Singleton* Singleton::getInstance() &#123; if(NULL == m_instance) &#123; Lock();//借用其它类来实现，如boost if(NULL == m_instance) &#123; m_instance = new Singleton; &#125; UnLock(); &#125; return m_instance; &#125; 面试单例代码最后是面试的简单单例代码，用C11饿汉实现哦！ 123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;class singletonPractice&#123;public: static singletonPractice* getInstance()&#123; static singletonPractice m_instance; return &amp;m_instance; &#125; singletonPractice(const singletonPractice&amp;) = delete; singletonPractice&amp; operator=(const singletonPractice&amp;) = delete;private: singletonPractice()&#123;&#125;&#125;;int main()&#123; singletonPractice* in1 = singletonPractice:: getInstance(); singletonPractice* in2 = singletonPractice:: getInstance(); cout &lt;&lt; &amp;(*in1) &lt;&lt; &quot; &quot; &lt;&lt; &amp;(*in2) &lt;&lt; endl; system(&quot;pause&quot;);&#125; 参考资料：https://blog.csdn.net/zhanghuaichao/article/details/79459130https://mp.weixin.qq.com/s/8oZT_4AOzjSOkBP9EvSPoA","categories":[{"name":"C++","slug":"C","permalink":"http://icecorn.github.io/categories/C/"},{"name":"设计模式","slug":"C/设计模式","permalink":"http://icecorn.github.io/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://icecorn.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"}]},{"title":"算法系列（四）|排序合集","slug":"算法/算法系列（四）排序算法","date":"2022-06-28T09:25:10.000Z","updated":"2022-07-09T08:02:01.512Z","comments":true,"path":"2022/06/28/算法/算法系列（四）排序算法/","link":"","permalink":"http://icecorn.github.io/2022/06/28/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序算法常见排序算法 https://blog.csdn.net/qq_54850622/article/details/115729733 快速排序快速排序的基本思想：快速排序使用分治的思想，通过一趟排序将待排序列分割成两部分，其中一部分记录的关键字均比另一部分记录的关键字小。之后分别对这两部分记录继续进行排序，以达到整个序列有序的目的。 快速排序的三个步骤：(1)选择基准：在待排序列中，按照某种方式挑出一个元素，作为 “基准”（pivot）(2)分割操作：以该基准在序列中的实际位置，把序列分成两个子序列。此时，在基准左边的元素都比该基准小，在基准右边的元素都比基准大(3)递归地对两个序列进行快速排序，直到序列为空或者只有一个元素。 选择基准的方式：对于分治算法，当每次划分时，算法若都能分成两个等长的子序列时，那么分治算法效率会达到最大。也就是说，基准的选择是很重要的。选择基准的方式决定了两个分割后两个子序列的长度，进而对整个算法的效率产生决定性影响。 最理想的方法是，选择的基准恰好能把待排序序列分成两个等长的子序列这里选择基准可以采用固定位置，随机选取，选三个数取中间的 1234567891011121314151617void QuickSort(vector&lt;int&gt; &amp;nums,int l,int r)&#123; if(l&gt;r) return; int left = l,right = r; int pivot = nums[l]; while(left&lt;right) &#123; //这里必须从右边开始，因为我们选择的pivot是左边第一个 while(left&lt;right &amp;&amp; nums[right]&gt;=pivot) right--; nums[left] = nums[right]; while(left&lt;right &amp;&amp; nums[left]&lt;=pivot) left++; nums[right] = nums[left]; &#125; nums[left] = pivot; QuickSort(nums,l,left-1);//左闭右闭的方式，要排除已经排序好的元素 QuickSort(nums,left+1,r);&#125; 快排的空间复杂度是O(1)的，在原来的vector上排序就行，不需要新开空间平均时间复杂度是O（nlogn）最坏时间复杂度是O（n2）|举例：{1,2,3,4,5,6,7,8,9,10} 就要n2，原因在于每次分治划分不均匀，当然和pivot的选取也有关系。 快速选择对于要找数组中第k大或第k小的问题，不需要完整的快排，只需要快速选择的方法即可 方法1：快速排序的分区思想，快排的思想是一次找出一个数的正确位置，并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。 方法二：堆排序，在pop k个 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;public: void quickPartition(vector&lt;int&gt;&amp; nums, int start, int end, int target) &#123; // 随机取一个数作为基准 srand(time(nullptr)); int random = rand() % (end - start + 1) + start; int base = nums[random]; // 将该数放到待快排区间开头第一个元素 swap(nums[start], nums[random]); int index = start; // 从待快排区间的第二个元素开始，依次与base比较，如果大于等于base则将该元素 // 交换到index + 1位置，index++，使得最终index前面的元素都比base大。 for (int i = start + 1; i &lt;= end; ++i) &#123; if (nums[i] &gt;= base) &#123; swap(nums[index + 1], nums[i]); index++; &#125; &#125; // base存放在区间开头，现在需要把它交换到index位置，这就是它在整个有序数组中的位置。 swap(nums[index], nums[start]); // 如果index小于target，需要在右边区间继续快排查找，否则到在边区间查找， // 如果等于已经找到目标值不需要递归，这里这么做优化了传统快排的复杂度。 if (index &lt; target) &#123; quickPartition(nums, index + 1, end, target); &#125; else if (index &gt; target) &#123; quickPartition(nums, start, index - 1, target); &#125; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; // 方法1. 快速排序的分区思想，快排的思想是一次找出一个数的正确位置， // 并使得该数左边的元素都比它小，该数右边的元素都比它大，要找出第k // 大的元素，只需要在快排的时候采用降序排序，找到下标为k-1的元素即可。 quickPartition(nums, 0, nums.size() - 1, k - 1); return nums[k - 1]; &#125;&#125;; 归并排序同样是分治的思想，利用分治+二分，将整个数组分到最小粒度再进行处理 重点是归并需要新开一个与原来数组等长的数组，空间复杂度为O(n),时间复杂度O(logn) 12345678910111213141516171819202122void merge_sort(vector&lt;int&gt;&amp; nums, int l, int r, vector&lt;int&gt;&amp; temp) &#123; if (l + 1 &gt;= r) &#123; return; &#125; // divide int m = l + (r - l) / 2; merge_sort(nums, l, m, temp); merge_sort(nums, m, r, temp); // conquer int p = l, q = m, i = l; while (i&lt;=r) &#123; if (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123; temp[i++] = nums[p++]; &#125; else &#123; temp[i++] = nums[q++]; &#125; &#125; for (i = l; i &lt; r; ++i) &#123; nums[i] = temp[i]; &#125;&#125; 插入排序复杂度O（n2)，就类似抓扑克牌 ：） 1234567891011//插入排序void insertion_sort(vector&lt;int&gt; &amp;nums, int n)&#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j - 1]; --j) &#123; swap(nums[j], nums[j - 1]); &#125; &#125;&#125; 冒泡排序复杂度O(n2)，相邻的比较交换，是稳定的排序 123456789101112131415//冒泡排序void bubble_sort(vector&lt;int&gt; &amp;nums, int n)&#123; for (int i = 1; i &lt; n; ++i) &#123; for (int j = 1; j &lt; n - i + 1; ++j) &#123; if (nums[j] &lt; nums[j - 1]) &#123; swap(nums[j], nums[j - 1]); &#125; &#125; &#125;&#125; 选择排序每次选出最小的 1234567891011121314151617//選擇排序void selection_sort(vector&lt;int&gt; &amp;nums, int n)&#123; int mid; for (int i = 0; i &lt; n - 1; ++i) &#123; mid = i; for (int j = i + 1; j &lt; n; ++j) &#123; if (nums[j] &lt; nums[mid]) &#123; mid = j; &#125; &#125; swap(nums[mid], nums[i]); &#125;&#125; 堆排序大顶堆：根节点大于等于自己的两个孩子节点。小顶堆：根节点小于等于自己的两个孩子节点。 堆排序总共分为两步：1、初始化建堆：找到一个树的最后一个非叶节点， 计算公式为 (n-1)/2 -1， 然后遍历树的每个非叶节点，使其符合堆的规则。 2、排序重建堆：将堆的顶部，与最后一个元素交换，然后将数组长度减一，将剩下的元素重新建成一个堆。 时间复杂度：初始化建堆的时间复杂度为O(n)，排序重建堆的时间复杂度为nlog(n)，所以总的时间复杂度为O(n+nlogn)=O(nlogn)。 空间复杂度：O(1)。 堆排序 建堆，初始化二叉树，上浮和下沉操作维护堆的性质（小根堆：父节点要比子节点小，大根堆相反） 123456789101112131415161718192021222324void adjust_heap(vector&lt;int&gt; &amp; nums, int root, int length)&#123; int left = 2*root + 1; int right = 2*root + 2; int max = root; if( left &lt; length &amp;&amp; nums[left] &gt; nums[max]) max = left; if( right &lt; length &amp;&amp; nums[right] &gt; nums[max]) max = right; if(max != root)&#123; swap( nums[max], nums[root]); adjust_heap(nums, max, length); &#125;&#125;void heap_sort(vector&lt;int&gt; &amp; nums, int len)&#123; //初始化建堆： for(int i = len/2 -1; i &gt;= 0; --i) adjust_heap(nums, i, len); //排序重建堆 for(int i = len - 1; i &gt;= 0; i--)&#123; swap(nums[0], nums[i]); //堆顶元素和末尾元素进行交换 adjust_heap(nums, 0 , i); // 对顶点进行一次堆排序 &#125;&#125; 桶排序 顾名思义，桶排序的意思是为每个值设立一个桶，桶内记录这个值出现的次数（或其它属 性），然后对桶进行排序。针对样例来说，我们先通过桶排序得到三个桶 [1,2,3,4]，它们的值分别 为 [4,2,1,1]，表示每个数字出现的次数。 紧接着，我们对桶的频次进行排序，前 k 大个桶即是前 k 个频繁的数。这里我们可以使用各种 排序算法，甚至可以再进行一次桶排序，把每个旧桶根据频次放在不同的新桶内。针对样例来说， 因为目前最大的频次是 4，我们建立 [1,2,3,4] 四个新桶，它们分别放入的旧桶为 [[3,4],[2],[],[1]]， 表示不同数字出现的频率。最后，我们从后往前遍历，直到找到 k 个旧桶。 123456789101112131415161718192021222324252627vector&lt;int&gt; topKFrequent(vector&lt;int&gt; &amp;nums, int k)&#123; unordered_map&lt;int, int&gt; counts; int max_count = 0; for (const int &amp;num : nums) &#123; max_count = max(max_count, ++counts[num]); &#125; vector&lt;vector&lt;int&gt;&gt; buckets(max_count + 1); for (const auto &amp;p : counts) &#123; buckets[p.second].push_back(p.first); &#125; vector&lt;int&gt; ans; for (int i = max_count; i &gt;= 0 &amp;&amp; ans.size() &lt; k; --i) &#123; for (const int &amp;num : buckets[i]) &#123; ans.push_back(num); if (ans.size() == k) &#123; break; &#125; &#125; &#125; return ans;&#125; 排序的适用场景（1）当数据规模较小时候，可以使用简单的直接插入排序或者直接选择排序。 （2）当文件的初态已经基本有序，可以用直接插入排序和冒泡排序。 （3）当数据规模较大时，应用速度最快的排序算法，可以考虑使用快速排序。当记录随机分布的时候，快速排序平均时间最短，但是出现最坏的情况，这个时候的时间复杂度是O(n^2)，且递归深度为n,所需的占空间为O(n)。 （4）堆排序不会出现快排那样最坏情况，且堆排序所需的辅助空间比快排要少，但是这两种算法都不是稳定的，要求排序时是稳定的，可以考虑用归并排序。 （5）归并排序可以用于内部排序，也可以使用于外部排序。在外部排序时，通常采用多路归并，并且通过解决长顺串的合并，缠上长的初始串，提高主机与外设并行能力等，以减少访问外存额外次数，提高外排的效率。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://icecorn.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"算法系列（三）|分治法","slug":"算法/算法系列（三）分治","date":"2022-06-27T09:25:10.000Z","updated":"2022-07-07T14:56:51.500Z","comments":true,"path":"2022/06/27/算法/算法系列（三）分治/","link":"","permalink":"http://icecorn.github.io/2022/06/27/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%E5%88%86%E6%B2%BB/","excerpt":"","text":"分治算法详解算法思想分治发的基本思想是自上而下的去处理问题，将一个复杂问题分成一些子问题分解成规模较小的问题处理。本质就是先分，再治，至于算法的时间复杂度可以通过主定理求解，暂不叙述 divide 解题时找到divide的方式后，不要考虑太多，比如说处理一个字符串s，我们第一步将它分成left和right两段，那么就相当于我们有了left和right两个字串的求解结果，直接用就行，这样依次divide直到划分到最小为止（常常可以结合二分和dfs） conquer 分完之后就要治了，考虑两个方面 其一是有了左右两个结果，怎么通过这两个来得到当前（最终）的结果 其二是考虑边界情况，分到最小粒度了，有没有特殊处理 总结起来就一句话，画图求解和dfs一样直接干，不要想太多，你的脑袋才能压几个栈啊！ 归并排序归并排序就是经典的分治问题： https://blog.csdn.net/qq_35344198/article/details/106857042 利用二分进行divide，conquer时注意细节即可 需要注意的是归并排序空间复杂度是O（n）的，需要开辟一个与原数组等长的数组 12345678910111213141516171819202122void merge_sort(vector&lt;int&gt;&amp; nums, int l, int r, vector&lt;int&gt;&amp; temp) &#123; if (l + 1 &gt;= r) &#123; return; &#125; // divide int m = l + (r - l) / 2; merge_sort(nums, l, m, temp); merge_sort(nums, m, r, temp); // conquer int p = l, q = m, i = l; while (i&lt;=r) &#123; if (q &gt;= r || (p &lt; m &amp;&amp; nums[p] &lt;= nums[q])) &#123; temp[i++] = nums[p++]; &#125; else &#123; temp[i++] = nums[q++]; &#125; &#125; for (i = l; i &lt; r; ++i) &#123; nums[i] = temp[i]; &#125;&#125; 表达式问题Lc-241 这种问题一般是给一个字符串，有各种算式，问你加括号的方式有多少种。我们可以以每个算符作为分割点进行divide，算出左右两边的值的个数，然后在conquer 这里要注意的是，分到最小粒度的时候我们直接把它作为结果存进去 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string expression) &#123; vector&lt;int&gt; res; int n = expression.size(); for(int i=0;i&lt;n;++i) &#123; if(expression[i]==&#x27;+&#x27;||expression[i]==&#x27;-&#x27;||expression[i]==&#x27;*&#x27;) &#123; vector&lt;int&gt; left = diffWaysToCompute(expression.substr(0,i)); vector&lt;int&gt; right = diffWaysToCompute(expression.substr(i+1)); for(auto l:left) for(auto r:right) &#123; char c = expression[i]; switch(c) &#123; case &#x27;+&#x27;: res.push_back(l+r);break; case &#x27;-&#x27;: res.push_back(l-r);break; case &#x27;*&#x27;: res.push_back(l*r);break; &#125; &#125; &#125; &#125; if(res.empty())&#123; res.push_back(stoi(expression)); &#125; return res; &#125;&#125;; 当然因为在递归过程中我们有很多重复计算，可以使用记忆化搜索来优化一下：实际上就是用一个hashmap来记录当前字符串s的返回结果 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: unordered_map&lt;string,vector&lt;int&gt;&gt; memo; vector&lt;int&gt; diffWaysToCompute(string expression) &#123; if(memo.find(expression)!=memo.end()) return memo[expression]; vector&lt;int&gt; res; int n = expression.size(); for(int i=0;i&lt;n;++i) &#123; if(expression[i]==&#x27;+&#x27;||expression[i]==&#x27;-&#x27;||expression[i]==&#x27;*&#x27;) &#123; vector&lt;int&gt; left = diffWaysToCompute(expression.substr(0,i)); vector&lt;int&gt; right = diffWaysToCompute(expression.substr(i+1)); for(auto l:left) for(auto r:right) &#123; char c = expression[i]; switch(c) &#123; case &#x27;+&#x27;: res.push_back(l+r);break; case &#x27;-&#x27;: res.push_back(l-r);break; case &#x27;*&#x27;: res.push_back(l*r);break; &#125; &#125; &#125; &#125; if(res.empty())&#123; res.push_back(stoi(expression)); &#125; memo[expression] = res; return res; &#125;&#125;; 平面点集最短距离问题https://blog.csdn.net/weixin_44772995/article/details/93749863 题目描述有一天，小明得到了二维平面上的若干个点，他现在想知道这些点中距离最近的两个点之间的距离是多少？ 输入第一行输入一个整数T，共有T组测试数据（T&lt;=30)。每组输入数据第一行输入一个n，表示有n个点。第二行有n*2的数字，相邻两个数代表一个点的x,y坐标。1&lt;n&lt;=100, -100000000=&lt;x,y&lt;=100000000 输出输出有T行，每行包括一个整数，代表所有距离的最小值（因为小明不在意小数，所以结果向下取整）。 样例输入 Copy220 0 1 120 0 100000000 100000000样例输出 Copy1141421356 核心思路就是分治，divide使用二分法，conquer的技巧在于分割线两边的点之间的距离，另外还要注意的事划分到最小粒度是一边只有两个点或三个点","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"divide&conquer","slug":"divide-conquer","permalink":"http://icecorn.github.io/tags/divide-conquer/"}]},{"title":"算法系列（二）|动态规划专题","slug":"算法/算法系列（二）动态规划","date":"2022-06-25T09:25:10.000Z","updated":"2022-07-07T09:39:42.330Z","comments":true,"path":"2022/06/25/算法/算法系列（二）动态规划/","link":"","permalink":"http://icecorn.github.io/2022/06/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/","excerpt":"","text":"详解动态规划基本思想动态规划是一种自下而上的思想，每一个问题，把它们转化成相同原理的更小的子问题，解题关键主要有两点： 找到状态转移方程 初始值的设置，这里可以开辟一个大一些的数组，防止段错误 另外还有一个重点是，一定要细心，通常解题中会有dp数组和原始的数据数组，什么时候用什么下标一定要仔细考虑，比如dp数组大小设置成了n+1,那么i=1时，原始数据数组应该用nums[0],虽然很弱智，但不注意搞错了debug就会很难受 基本DP：一维典型的就是青蛙跳这种，比较简单，状态转移方程类似： 1dp[i] = dp[i-1] + dp[i-2]; 另一种比较特殊的，我们不能用dp[i]来存储最终结果，我们要用dp[i]来存储以当前i节点结尾的满足题意的状态，然后对整个dp数组求和。 比如： 这里我们用dp[i]来表示以该位置结尾的等差数列个数，因为等差数列随时可能会断掉，断掉的位置i的dp[i]就设置为0。 123456789101112int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 3) return 0; vector&lt;int&gt; dp(n, 0); for (int i = 2; i &lt; n; ++i) &#123; if (nums[i] - nums[i-1] == nums[i-1] - nums[i-2]) &#123; dp[i] = dp[i-1] + 1; &#125; &#125; return accumulate(dp.begin(), dp.end(), 0);&#125; 基本DP：二维这里比较代表性的就是给一个二维矩阵，机器人从左上到右下经过的最短路径： 1dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]; 特殊一些的比如lc-221题，算最大全是1的正方形面积，这种题就需要找到题目的一些规律性，寻找状态转移方程： 1dp[i][j] = min(dp[i-1][j-1], min(dp[i][j-1], dp[i-1][j])) + 1; 分割类问题代表例子lc-279，lc-139，核心思路就是在dp遍历里边套一层枚举，就是说dp的每一个元素有很多种可能，我们要枚举出来，然后根据题意选最大或最小之类的 lc-139给定一个字符串和一个字符串集合，求是否存在一种分割方式，使得原字符串分割后的子字 符串都可以在集合内找到。 12Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: true 123456789101112131415bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; int n = s.length(); vector&lt;bool&gt; dp(n + 1, false); dp[0] = true; for (int i = 1; i &lt;= n; ++i) &#123; for (const string &amp; word: wordDict) &#123; int len = word.length(); if (i &gt;= len &amp;&amp; s.substr(i - len, len) == word) &#123; dp[i] = dp[i] || dp[i - len]; &#125; &#125; &#125; return dp[n];&#125; 对每一个dp[i]，从后往前减去一段，把它变成一个子问题再处理，类似用硬币组成数字问题。 子序列问题最长递增子序列还是一样的思路，dp[i]表示以i结尾的数组的最长递增子序列，里边枚举一下i之前的所有dp，如果nums[i] &gt; nums[j]就是长度+1，如果&lt;=则dp[i] = 0; 要注意的是此题有很多种其他的问法比如给一个数组，让你去掉k个数，使之变成单调递增的数组，其实就是求最长递增子序列，再用总数n-最长递增子序列=k还有变成单调递减，先递增再递减 1234567891011121314int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int max_length = 0, n = nums.size(); if (n &lt;= 1) return n; vector&lt;int&gt; dp(n, 1); for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; i; ++j) &#123; if (nums[i] &gt; nums[j]) &#123; dp[i] = max(dp[i], dp[j] + 1); &#125; &#125; max_length = max(max_length, dp[i]); &#125; return max_length;&#125; 此题for循环内还可以改成二分法加快速度 就是在已经有的递增数组里边找dp[i]的位置，再替换即可 公共元素问题最长公共子串问题这种题目思路就是我们要开一个二维数组，dp【i】【j】，代表以i，j结尾的两个a，b的子字符串从后往前有几个公共的字符。 12a = &quot;abcbced&quot;;b = &quot;acbcbce&quot;; 然后相同的地方设置为1，不同的地方设置为0，然后我们最后就是找最长的连续的对角线的长度就是最长的公共子串了 很容易得到状态转移方程： 123456if(a[i] == b[j])&#123; dp[i][j] = dp[i-1][j-1] + 1;&#125;else&#123; dp[i][j] = 0;&#125; 当然题目可能是让你返回最长的长度，或者最长字符串，因题返回就好。 注意这里的最长子串需要遍历dp才能得到，而不是直接返回最后的元素 最长公共子序列问题子序列和子字符串不同的地方在于它不那么严格，就是不连续的也可以，所以它的转移方程为： 123456if(a[i] == b[j])&#123; dp[i][j] = dp[i-1][j-1] + 1;&#125;else&#123; dp[i][j] = max(dp[i-1][j],dp[i][j-1]);&#125; 背包问题01背包 如图所示，得到状态转移方程：i是有多少种物品，j是背包的容积核心思想就是对一个dp元素，我们有两种选择，一种是选当前的i物品，一种是不选。 1234567if(j&gt;=V[i-1])&#123; dp[i][j] = max(dp[i-1][j],dp[i-1][j-V[i-1]]+ W[i-1]); &#125;else&#123; dp[i][j] = dp[i-1][j]; &#125; 全部代码： 我们可以发现状态转移方程只和上一行有关，那么很自然的想到可以将二维dp矩阵优化成一位来进行处理。 这里的问题是，如果我们还是从前往后处理的话，那么后边元素所依赖的“上一行”的结果就会被覆盖掉，所以要从后往前遍历，而且对于不选的情况，直接使用上一行的结果就行了，不用特殊处理。 123456for (int i = 1; i &lt;= N; ++i) &#123; int w = weights[i-1], v = values[i-1]; for (int j = W; j &gt;= w; --j) &#123; dp[j] = max(dp[j], dp[j-w] + v); &#125;&#125; 完全背包可以在01背包的基础上考虑，01是每一行物品只有一个，要么拿，要么不拿，完全背包呢，是一个东西可以无限拿，那么自然的想到，在每个dp里加一个循环，枚举出拿几个当前物品，一直到拿爆为止。 首先写一个二维dp基础版本的： 这里要注意的是k取0的时候其实就把“不取”这个情况给做了。 需要注意的是这种没优化过的超级暴力代码，有三层循环，1000*1000的用例是没法过的。 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1050;int dp[N][N];int V[N];int W[N];int main()&#123; int n,v; while(cin&gt;&gt;n&gt;&gt;v) &#123; int v1,w; for(int i=1;i&lt;n+1;++i) &#123; cin&gt;&gt;v1&gt;&gt;w; V[i] = v1; W[i] = w; &#125; for(int i=1;i&lt;n+1;++i) &#123; for(int j=1;j&lt;v+1;++j) &#123; for(int k=0;k*V[i]&lt;=j;++k) &#123; dp[i][j] = max(dp[i][j],max(dp[i-1][j],dp[i-1][j-k*V[i]]+k*W[i])); &#125; &#125; &#125; cout&lt;&lt;dp[n][v]&lt;&lt;endl; &#125; return 0;&#125; 接下来优化成用一维数组，同样要倒序进行： 12345678910111213for(int i=1;i&lt;n+1;++i)&#123; for(int j=v;j&gt;=0;--j) &#123; for(int k=0;k*V[i]&lt;=j;++k) &#123; dp[j] = max(dp[j],dp[j-k*V[i]]+k*W[i]); &#125; &#125;&#125;cout&lt;&lt;dp[v]&lt;&lt;endl; 以上代码只是空间上优化了一丢丢，本质上还是O（n3）的，要想办法在时间复杂度上进行优化。 想一下，我们不从后往前进行，直接从前往后进行处理，这样后一个dp[j]状态转移获取dp[j-x]的时候，其实dp[i-x]已经“拿了一些该物品的状态“，也就是说dp[j-x]在它的那个位置已经达到了一个最优解，那么到dp[j]的位置的时候我们实际上只要考虑再拿一次物品i，或者不拿物品i 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1050;int dp[N];int V[N];int W[N];int main()&#123; int n,v; while(cin&gt;&gt;n&gt;&gt;v) &#123; int v1,w; for(int i=1;i&lt;n+1;++i) &#123; cin&gt;&gt;v1&gt;&gt;w; V[i] = v1; W[i] = w; &#125; for(int i=1;i&lt;n+1;++i) &#123; for(int j=1;j&lt;v+1;++j) &#123; if(j&gt;=V[i]) //这里一定要注意要判断当前的空间j能不能装下物品V[i] &#123; dp[j] = max(dp[j],dp[j-V[i]]+W[i]); &#125; &#125; &#125; cout&lt;&lt;dp[v]&lt;&lt;endl; &#125; return 0;&#125; 可以发现完全背包和01背包在优化到最后的形态其实只有正序处理和反序处理之分，这里我们清楚知道它的原理就行，笔试直接写优化后的简单形式，简单粗暴！ 多重背包多重背包实际上就是完全背包的拓展，或者说完全背包是多重背包的一种特殊情况，区别于完全背包，多重背包显示的告诉了我们一个物品最多拿几次，那么我们只需要枚举每种可能就好啦~ 当然也是要逆向处理 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1050;int dp[N];int V[N];int W[N];int num[N];int main()&#123; int n,v; while(cin&gt;&gt;n&gt;&gt;v) &#123; int v1,w,t; for(int i=1;i&lt;n+1;++i) &#123; cin&gt;&gt;v1&gt;&gt;w&gt;&gt;t; V[i] = v1; W[i] = w; num[i] = t; &#125; for(int i=1;i&lt;n+1;++i) &#123; for(int j=v;j&gt;=0;--j) &#123; for(int k=0;k&lt;=num[i];++k) &#123; if(k*V[i]&lt;=j)//需要我们判断不要拿爆了！ &#123; dp[j] = max(dp[j],dp[j-k*V[i]]+k*W[i]); &#125; &#125; &#125; &#125; cout&lt;&lt;dp[v]&lt;&lt;endl; &#125; return 0;&#125; 多重背包的优化 一种是用二进制优化，核心思路是把多重背包拆成很多个01背包 单调队列优化 这里先不写了，毕竟是面向找工作学算法：），已经过了打ACM的年纪了55555 关于背包还有一些变种问题： 混合背包，二维费用背包，分组背包，有依赖的背包，背包求方案数等等，都先不考虑了，留个指针之后看： https://www.cnblogs.com/jbelial/articles/2116074.html https://www.bilibili.com/video/BV1qt411Z7nE?p=2&amp;vd_source=9002427521e0ebdeb1694e942abd7317 https://www.acwing.com/problem/ 字符串编辑Lc-72： 给定两个字符串，已知你可以删除、替换和插入任意字符串的任意字符，求最少编辑几步可 以将两个字符串变成相同 想法就是用dp每一位代表的是当前word1串截止到i的长度和word2串截止到j的长度，它们转换的最小次数。 打字问题 这个题想法就是对于该字符串的任意长度，该位置都有两种情况（大写字母或者小写字母），在打这个字母之前的状态可能是caps的大写或小写，同时打完这个字母之后caps的状态也可以是大写或小写,需要分类讨论 股票交易这个先放着，之后单独算一个专题来写吧","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"动态规划","slug":"动态规划","permalink":"http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"}]},{"title":"Games-104|第七课-渲染管线-后处理-其他渲染知识","slug":"Games-104/Games104--渲染系统-渲染管线后处理等7","date":"2022-06-19T09:25:10.000Z","updated":"2022-06-29T16:26:46.061Z","comments":true,"path":"2022/06/19/Games-104/Games104--渲染系统-渲染管线后处理等7/","link":"","permalink":"http://icecorn.github.io/2022/06/19/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%E5%90%8E%E5%A4%84%E7%90%86%E7%AD%897/","excerpt":"","text":"第七课 渲染管线-后处理–其他渲染知识环境光遮蔽 AO 预计算出AO贴图 SSAO 在屏幕上存储深度信息，设置一些采样点，根据采样点和z-buffer的深度比较来计算最终的光强 SSAO+ HBAO GTAO 雾效 Fog简单的fog，根据深度Z从近到远透明度逐渐减小 考虑到高度信息时，简单的fog公式就不起作用了 抗锯齿采样率不够就会导致走样 SSAA和MSAASSAA就是最简单朴素的横竖都扩大一倍采样率，带来的性能代价是很高的。MSAA相比SSAA有一个改动就是在最后pixel shading的时候把一些不必要的shading’去掉了，减少最后shading的次数。 FXAA因为锯齿大多发生在边缘轮廓，所以从轮廓着手找到轮廓线再用一个滤波器去插值，已达到抗锯齿的效果。 注意这里阈值是0.05，这个卷积核和sobel卷积核不一样，不是常规意义上的提取轮廓。 混合附近像素的颜色，算插值 TAA时序反走样 同时可做鬼影，拖尾等效果 后处理Bloom，Tone mapping（曝光），ColornGrading（调色） Bloom首先把图片亮度高的地方提取出来（注意是RGB，不是灰度） 加一个模糊效果 这里针对光晕大但是不能使高斯核太大的情况，采用downsample几次再upsample的hack，大概和dualkawase模糊差不多？ 最后叠加在原图上 Tone Mapping因为真实世界的光照强度range很宽，假设是0-50，那么要把0-50的range映射到0-1这就是Tone Mapping 一个映射曲线的shader 电影工业界的颜色曝光曲线 这个东西其实都是人为根据经验来拟合出来的曲线 Color GradingLUT映射 一般lut不用存256*256那么大，因为颜色是连续的，可以只存32 * 32的采样，然后插值即可 渲染管线 Forward Rendering前向渲染两个问题 处理透明物体的渲染顺序会出问题。一般是由远及近来渲染。 处理多光源很吃性能。 Deferred Rendering就是分两个pass，第一个pass渲染一遍所有的物体但是不考虑光照，把物体材质信息存储到G-buffer里 第二个pass在像素级别上处理光照就好 怎样减少读写G-buffer消耗的资源？ 可以把屏幕分成一个个小块（Tiles），这样每个像素只要读对应的小块纹理而不用整张g-buffer都读进去。这样还有另一个好处是光源也不用每次都遍历所有的了，如下图所示。 更进一步，可以做Early-Z，就是说在世界空间下，我们就能知道每个光源所能照到的深度信息，从而在渲染光的时候进行剪枝。 Visibility Buffer现代渲染中，很多时候模型的面片比像素还多，这时候可以存VisibilityBuffer存几何信息反向查找材质信息。 Frame Graph现代游戏pipline过于复杂，要借助Frame Graph工具将每个步骤算法所用的内存之类的管理起来，方便开发，定位bug","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Games-104","slug":"Games-104","permalink":"http://icecorn.github.io/tags/Games-104/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"Games-104|第六课-渲染系统-地形大气和云的渲染","slug":"Games-104/Games104--渲染系统-地形大气和云6","date":"2022-06-16T09:25:10.000Z","updated":"2022-06-29T16:26:59.931Z","comments":true,"path":"2022/06/16/Games-104/Games104--渲染系统-地形大气和云6/","link":"","permalink":"http://icecorn.github.io/2022/06/16/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%9C%B0%E5%BD%A2%E5%A4%A7%E6%B0%94%E5%92%8C%E4%BA%916/","excerpt":"","text":"第六课 地形大气和云的渲染地形的几何Heightfield数学上的分形方法 每隔1m画一个10000*1000的网格，然后根据高度场，轮廓场等进行映射就可以 LOD技术 就是根据距离远近应用不同分辨率的网格，这里要根据FOV视角的范围进行各向异性的加密或简化网格。 细分方法 注意T-Junctions的问题 三角形剖分 四叉树细分 解决T-Junction问题，就把剖分次数多的一边中间的节点平滑到另一边的角点上是两个点重合，这样实际上就产生了一个面积为0的三角形，也就是网格的退化，一般面积为0的三角形在渲染时直接不渲染。 TIN方法Triangulated Irregular Network 就是直接用不规则的三角形来表达地形，简化不必要的顶点，并加上需要的特征 好处是可以减少很多三角形，比之前的方法少了一个数量级 显卡架构，有细分着色器，domainshader等等，可以直接再gpu里边生成细分网格甚至能完成映射扰动的实现。 最新的显卡架构把以上这些着色器整合成了MeshShader更加方便，有了gpu的加持，甚至可以实现runtime的事实地形交互，比如炮弹打到地上使得网格发生形变出现个坑。 制作山洞的一个hack方法直接把山体网格要打洞的顶点那里给一个属性把他的position设置成NAN，这样再显卡中就会把所有包含这个顶点的三角形都忽略掉不渲染 体素化表达虽然目前游戏引擎还没有大规模应用，但是其实可以考虑直接用体素来表达地形模型，而不是二维流形网格，这样实际上就直接有了三维的信息，也就是说地形山体等都不是空心的了，可以跟直接的操作打洞等等。 地形的材质就用之前的MR材质，存一些东西 Height贴图的作用，就是这种地形需要沙子和石头之间渐变的时候，根据高度信息进行混合。 当然这种渐变过程中因为数值精度可能会有一些抖动，这时可以设置一些扰动保证稳定性。 通过不同的权重和不同的材质来混合得到想要的效果 视差贴图parallax mapping就是扰动法线贴图使视觉上具有更强的凹凸感，而displacement mapping则是更彻底的用高度信息直接更改地形网格面片 问题：性能代价 因为纹理采样实际上是一个很费的操作，如果每一个像素都混合4张纹理，那么就需要重复采样很多次，性能爆炸 解决办法：虚拟纹理 这里就是和虚拟内存一样的概念，就是把纹理分块，实际用到哪块就读哪块进入内存而不是整个纹理都读进来，因为我们在游戏中视锥呈现的范围实际上只有纹理中的一小块。 新的技术传统的读纹理都是cpu读进内存，然后解压，然后传给gpu。 而DirectStorage技术就是cpu读进内存不解压直接传到gpu在gpu中完成解压，提高性能 而更牛逼的DMA技术就是直接从硬盘读到gpu显存里去了 浮点数精度问题网格数量越大，越精细就会引起精度不够用的问题，因为float使用32个bit组成的，这样就会出现摩尔纹和锯齿问题 解决方法： 粗暴的方法就是扩展精度，比如用double来存 还可以用下图中把相机重置到gameobject坐标中，搞成相对距离解决这个问题 植被道路贴花树专门的LOD方法，近处用网格，远处就插片，越远越稀疏 Decorator Rendering 渲染小石头，草，灌木丛等等，一般用小面片，也有很专门的技术 道路系统渲染 用样条曲线编辑道路 大气散射理论简单的模型根据物理规律拟合一个模型，需要两个参数一个是向上看的角度到天顶的夹角（一般是0-Π），另一个是现在看到高度和太阳的夹角。根据这两个夹角去查表LUT 粒子媒介使用更加精细的模型渲染天空，大气由很多粒子，气溶胶组成 光在大气中的规律用四个参数描述： 从左到右依次为：吸收多少光，像四面八法散射多少，自发光强度，其他粒子对该粒子入射的光 实际上就是4中不同的梯度 VRE：对上边梯度进行积分 Transmittance：通透度，意思就是在远处看到一个东西，它有多少能透视到当前点。 Scattering part：光路打到路径上的气体分子发生一些散射，这些散射路径返回了多少能量。 大气物理学真是的大气物理，主要的元素是太阳，向外辐射不同波长的光，然后大气中有气体分子（它们的大小一般小于阳光波长），还有气溶胶分子（它们的大小一般和阳光波长差不多）。 两种 //TODO mark以下，下次再看这一块","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Games-104","slug":"Games-104","permalink":"http://icecorn.github.io/tags/Games-104/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"Games-104|第五课-渲染系统-光照与材质","slug":"Games-104/Games104--渲染系统-光照和材质5","date":"2022-06-10T09:25:10.000Z","updated":"2022-06-29T16:11:21.639Z","comments":true,"path":"2022/06/10/Games-104/Games104--渲染系统-光照和材质5/","link":"","permalink":"http://icecorn.github.io/2022/06/10/Games-104/Games104--%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E5%85%89%E7%85%A7%E5%92%8C%E6%9D%90%E8%B4%A85/","excerpt":"","text":"第五课 渲染系统–光照和材质渲染方程与挑战渲染方程渲染方程就是一个解积分的过程，一个点最终的光照=它本身的发光强度+所有其他方向的入射光在对应角度的投影 挑战 阴影效果 一个点是否能看得见，是否被遮挡时很难判断处理的 光源本身很复杂 比如面光源 积分怎么做 渲染方程里的积分部分怎么处理，光和材质的卷积如何计算 光的不断反射形成复杂的光影效果 基础光照解决方案使用点光源等简单光源当做主光，其他光源用低频环境光来模拟 使用环境光贴图来模拟反射光等等 布林-冯模型环境光+漫反射+镜面反射 一个问题是它的能量不守恒，渲染什么东西都像塑料：） shadow处理shadow map 思路就是从像素位置反向追踪到每个光源，看看到下一次反射的距离是否等于到光源的距离，从而判断出这个像素对这个光源来说是否可见 总结通过以上方法将复杂的渲染抽象简化，解决几个挑战，当然效果不是特别理想 基于预计算的全局光照预计算：就是空间换时间的一种手段，把一些场景中不动的地方全部预计算存储起来 全局光照：就是考虑间接光照对场景的影响，也就是说要算光的几次反射，迭代收敛 那么如果迭代计算几次光照，这样产生的计算量是指数增加的，所以要找一个高效的方法来计算 傅里叶变换把时域信息转到频域信息上去处理，这样可以大幅度压缩信息的数据 球面调和函数是一组sin cos的函数集组成的基函数 这块和下边的部分没听懂，大概目的是为了把数据降维参数化到低维进行处理简化计算，具体的方法用到时再查吧 Lightmap预计算光照贴图，把整个场景的光照烘焙到一张纹理上 这里也有参数化（展UV）的问题 本质上就是离线baking然后存储下来，在runtime时直接拿纹理用 Light Probes 和 Reflection Probes对动态的物体采样光，没看懂存个指针== 基于物理的材质微平面理论 光打在表面后只有两种情况，一种时反射出去（镜面反射），一种是射到物体里面在里边弹弹弹然后随机方向射出去（漫反射） 针对镜面反射来讲，有DFG理论，每一个字母代表一种光学现象 D == Normal Distribution Fuction 描述发现的发散程度，引入roughness粗糙度的参数 G == Geometric attenuation term（self-shadowing） F == Fresnel Equation 菲涅尔项 描述不同材质的反射程度，大牛推出的5次方 迪士尼准则 参数要由艺术家的直觉决定 参数越少越好 所有参数最好都是0-1 只有当参数超出门限是有实际意义的时候才可以超出0-1 所有的参数组合后需要足够鲁棒，不能有奇奇怪怪的结果 主流PBR模型Specular Glossiness模型这个模型一切参数存在图里 Diffuse 存在diffuse图里 菲涅尔项存在Specular图里 roughness项存在Glossiness图里 然后就可以通过+-*/运算写shader进行渲染 Metallic Roughness模型相当于在SG模型上包了一层，在外边加了一些判断防止使用错误，比如说有一个参数判断模型是金属还是非金属，如果是金属就把颜色传递，非金属就不传递颜色 基于图像的光照IBL的基本思想就是通过预计算的方式提前将环境光照算出来然后直接和环境中的材质进行卷积算出结果，本质上也是空间换时间的。 这个和全局光照的区别我理解就是全局光照只预计算到光照那一步，而IBL继续预计算到光照和材质卷积完的结果 这里也是分diffuse和specular两种情况，本质上就是预计算再LUT的情况，至于怎么搞的，用时再看把：（ 经典阴影方法cascade shadow 主要思想就是根据远近进行shadow map分级管理，就类似mipmap 软阴影PCF PCSS方法 具体去看Games 202 总结3A游戏的渲染 Lightmap + Lightprobe PBR + IBL CascadeShadow + VSSM 前沿技术实时光追 Shader管理因为GPU是并发的，对于判断语句会执行等待然后一起结束，所以shader中最好没有判断，那么在游戏中就会有上万数量级的shader资产，而在软件工程中这些零散的东西显然是不好维护的，这是就可以开发一个UberShader工具，其实就可以理解为一类shader有一个父类，当我要修改时，会重新生成子类shader 同时面对不同图形API要做好处理","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Games-104","slug":"Games-104","permalink":"http://icecorn.github.io/tags/Games-104/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"Games-104|第四课-渲染数据组织","slug":"Games-104/Games104-渲染系统-渲染数据组织4","date":"2022-06-07T09:25:10.000Z","updated":"2022-06-29T16:09:25.361Z","comments":true,"path":"2022/06/07/Games-104/Games104-渲染系统-渲染数据组织4/","link":"","permalink":"http://icecorn.github.io/2022/06/07/Games-104/Games104-%E6%B8%B2%E6%9F%93%E7%B3%BB%E7%BB%9F-%E6%B8%B2%E6%9F%93%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%874/","excerpt":"","text":"第四课 渲染数据组织游戏中的渲染面临的挑战： 大量的GO渲染，所用到的渲染算法不一样，比如水体，人物，毛发 适配硬件，不同的CPU和GPU 帧率要稳定，比如塞尔达的呀哈哈森林疯狂掉帧体验感很差，所以渲染一帧必须在一个固定的非常短的时间里 渲染所分配的资源不能占全部cpu和内存，还要分给gameplay，logic 渲染系统的对象光栅化管线 将一系列的顶点进行MVP变换，并且裁剪，然后光栅化，最后进行着色。 纹理对象的渲染，涉及到采样频率小引发的摩尔纹，锯齿等现象，所以引出了抗锯齿技术等 GPU架构SIMD：单指令多数据，一条指令可以发给很多单元同时处理数据，就是显卡里的SM SIMT：单指令多线程，一条指令分给好多个线程并发执行 SM就是最基础的单元用于并行计算 Texture Units是处理纹理的单元 SMU：sin cos 向量运算等比较高阶的运算单元 Warp：warp是逻辑上的单位不是物理上的，一个warp可能包含32个线程，每个线程交给一个SM去执行，但是显卡中一组SM可能只有8个，那么就是说一个warp要控制这8个SM执行4次 CPU-&gt;GPU 数据的交互 cpu发送数据到gpu的显存上，这一步比较耗费时间，同时一般情况下最好只是单向的数据传递，也就是说尽量不要gpu处理完数据传回cpu 高速缓存cache cathe是很快的，比普通内存速度高出一个数量级，所以我们处理数据最后一次把要用到的所有数据同时放进cathe而不用再去内存中去取，这样可以提高速度 可渲染物体GO上基础的可渲染的对象，比如人身体的网格，材质等等 模型mesh类的构造，这里有不同的数据结构，比如半边数据结构等等 为了节省cpu传到gpu显存上的数据量，一位一个三角形有三个点，相邻三角形会共用顶点，所以可以只存一次，然后再存一个索引值，这样来节省内存 要存的内容可能有：顶点位置，法向，颜色等等 材质视觉上的材质 phone Model，PBR Model 纹理，shaderCode shader虽然是代码，但是也算是render需要数据的一种，是一些已经编译好的二进制文件，可以应用在不同的渲染对象上 渲染流程把vertexBuffer,indexBuffer，纹理，shader传递给显卡，显卡就会渲染对应物体 由于将一个3维中的2维流形映射回2维参数化的过程（展uv）会有扭曲的情况发生，也就是说模型不同位置对应到二维的纹理上可能会重叠也可能一部分曲率大顶点多的地方映射的面积会很小，这样会导致精度不够的问题，所以目前业界一般会把一个模型分割成几个小部分，比如头，四肢这样。当然分成submesh还有另一个重要原因是因为一个模型通常有很多不同的材质，比如人的皮肤和衣服 但是从cpu像gpu传递数据时还是一整个模型一起传递，只不过我们可以标记index，比如1-100是头，101-200是胳膊这种。 在游戏中，会有很多一样的GO，比如小兵，这样每一个小兵GO的网格，纹理材质信息都是一样的，为了避免内存浪费，我们可能建立一个Pool，一个东西只存一遍，公用就行了 因为渲染流程实际上是一个状态机的模式，参考opengl，也就是说显卡一次处理一个东西，比如先渲染物体A它使用的是材质1，然后渲染物体B使用的是材质2，然后渲染物体C使用的也是材质1，这就会导致切换了两次材质造成性能下降，所以我们可以用材质来排序，一次性把材质1的GO（submesh）都渲染完，在切换材质2去渲染 针对完全重复的同一个对象，比如一堆树，可以在GPU中加一个offerset，一次drawcall全部渲染完毕，节省了重新传递vbo，ibo，drawcall的时间 可见性裁剪culling在游戏过程中，要使用事件锥来裁剪可见的对象 这里就要用包围盒来判断一个GO是否在事件锥的范围内 包围盒的种类：球，AABB，OBB，凸包等等 然后还要结合8叉树，BVH等空间划分算法来计算 BVH的优点是对运动的物体culling很快 PVS算法：主要思路就是根据所在位置看，能看到那些块就渲染哪些块 利用光线追踪来判断哪些是可见的 PVS算法比Octree等算法快很多，并且一个更大的优点是可以判断哪些资源需要加载 目前的算力已经很高了，显卡可以直接计算出哪些物体能看见，哪些被挡住了 Early Z：这个就是根据深度信息，可以提前判断好多物体不可见不用渲染，舍弃掉把它们光栅化的过程，节省性能 纹理压缩图片的存储格式不能够随机访问，所以游戏引擎必须对都进来的图片进行转化，记得opengl里好像有一个函数叫gl_readpixel,这个就是用来读图的，而且有按照1字节读和4字节读的接口（RGBA通道） 压缩纹理的方法 先找一个4*4块的最亮和最暗的值，其他值都可以插值出来 建模工具blender，3dsMax，Houdini 一些建模方法： 样条模型，贝塞尔曲线 点云扫描 雕刻建模 AI辅助建模 新的模型管线时代发展，算力膨胀，有了GPU驱动的渲染 因为有了几何着色器，细分着色器，可以凭空生成很多的三角形，可以根据相机的远近来生成不同分辨率的模型（类似QEM） 所以可以把gpu每个sm处理的粒度变得更小，像下图中的龙一样，一个patch只有32个小三角形这种 总结 游戏引擎和硬件架构和算力息息相关 针对多材质的模型使用submesh分割 在绘制中尽可能的使要渲染的东西少，culling裁剪看不见的东西 Gpu越来越牛逼，未来可能直接靠算力就可以搞定很多东西","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Games-104","slug":"Games-104","permalink":"http://icecorn.github.io/tags/Games-104/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"Games-104|第1-3课-引擎架构分层&数据组织管理","slug":"Games-104/Games104--游戏引擎导论与架构(1-3)","date":"2022-06-05T09:25:10.000Z","updated":"2022-06-29T16:08:22.273Z","comments":true,"path":"2022/06/05/Games-104/Games104--游戏引擎导论与架构(1-3)/","link":"","permalink":"http://icecorn.github.io/2022/06/05/Games-104/Games104--%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%AF%BC%E8%AE%BA%E4%B8%8E%E6%9E%B6%E6%9E%84(1-3)/","excerpt":"","text":"第一课： 现代游戏引擎导论游戏引擎架构与层级 基础元素构建 了解游戏引擎的分层，以及为什么采用这样的架构 渲染系统 Model，Material, Shader, Texture 渲染管线，光影 学习对渲染对象组合不同算法进行渲染 动画系统 学习从3dsmax等导出的动画，如何把它们组装起来，构建工具 物理系统 学习游戏中的物理系统（刚体，软体，流体） GamePlay 游戏中的核心玩法部分 其他系统 特效系统，寻路系统，相机系统 工具链 C++反射机制，数据库模式 网络游戏 数据同步 前沿技术 动态捕捉，面向数据变成DOP，任务系统Job System 全局光照Lumen，多面片Nanite 第二课 引擎架构分层，整体Pipeline游戏引擎主要分成5个架构分层以及第三方库，自顶向下分别是：工具层，功能层，资源层，核心层，平台层 工具层引擎最直观的，可以直接交互的层级，及引擎编辑器UI显示，可以直接利用GUI操作编辑一些游戏内容。 工具层通常以编辑器的形式存在，可用多种编程语言，开发效率优先，更加强调用户的便捷性。由于很多游戏资源是在Maya、3ds Max、Houdini等DCC（别人工具生成的资产）中完成的，工具层通常包含导入、导出器用于导入、导出游戏资源为统一的assets。 工具链是数据之间的互导。 功能层为了使游戏呈现在屏幕上，需要渲染系统对虚拟世界进行渲染。动画系统将艺术家设计的动作动画在引擎中进行组合、过渡，让游戏人物在游戏动起来。逼真的虚拟世界也离不开物理，物理系统将使用刚体、软体、流体等去表达世界，使得人与人、人与物不会发生碰撞。游戏中的玩法以及NPC人物，也都离不开脚本、事件、AI系统等。为了实现游戏中的人机交互，还需要与输入、输出设备连接。（Rending、Camera、 Animation、physics、Script,FSM and AI） 功能层将使得整个虚拟世界变得栩栩如生：每隔tick时间，分别执行逻辑与绘制–tickLogic与tickRender。tickLogic主要用于模拟世界，包括处理输入输出，计算物理并进行碰撞检测等；tickRender将tickLogic计算的结果（人物位置等）进行绘制。考虑到功能层需要实现大量功能并对运行时间存在要求，功能层复杂性高，并通常需要借助多线程计算。 在功能层，一定要区分开tickLogic和tickRender，不要耦合在一起 复杂性：功能层非常复杂、庞大，提供了游戏引擎中大部分功能模块，但哪些功能属于游戏，哪些功能属于引擎，界限不明确。 多线程：现代计算机CPU通常有多个核心，主流引擎将拆分适合并行计算的任务，分配到多个线程运算，但一些计算互相依赖，不适用于并行执行。在未来，引擎将所有任务变为原子计算，将任务分配到每个核上。 拆分成更小的粒度，最大限度压榨多核CPU 资源层游戏引擎中通常包含大量数据和文件，这些文件通常以不同的形式存在，例如Photoshop中的专用格式psd文件或者3ds Max中的max文件，上万、上十万的数据文件由资源层进行加载与管理。 Photoshop中的psd、3ds Max中的max等数据格式比较复杂， 包含大量与引擎无关的数据，如psd格式将保存Photoshop中所有的图层，包含通道、参考线、注解和颜色模式等信息。为了避免在使用资源时频繁调度并减少不必要的内存消耗，在导入资源时进行转换，将不同资源（纹理、模型几何、动画等）都转换为资产文件，即assest文件（.ast）。 比如引擎中最常使用的贴图数据，可使用png、jpg格式进行存储，上述格式对应相应的压缩算法，但这些压缩算法不是GPU高效的算法，直接在GPU中使用会浪费性能，通常在引擎中被转换成dds格式。dds格式针对纹理设计，支持很多其他图像格式不支持的功能，如Mipmap等。对于一个游戏人物，可能需要绑定网格、动画、贴图、材质等资源，定义Composite asset文件（如XML）关联不同资源，并使用Guid唯一识别号对资产进行管理。 在游戏实际运行时，需要使用**资产管理器*（Asset Manager）*根据资产生命周期*（Asset Life Cycle）***对资产进行管理，包括资产实时加载卸载、资源池分配、垃圾回收与延迟加载等。 资源管理很重要，因为硬件资源显存内存永远是有限的，所以就要把资源合理利用，类似虚拟内存这种，塞尔达每次场景切换都很慢，也许就是垃圾回收部分不太高效？ 核心层工具层、功能层、资源层会频繁调用底层代码，使用容器创建、内存分配、数学库、多线程等底层功能，而核心层能够提供上述功能。 核心层是游戏引擎的基础，提供各种功能模块所需的工具，包括数学库、数据结构与容器、内存管理等。对于数学库，当前已有很多成熟的第三方库，例如Eigen。但游戏引擎需要为效率服务，可使用近似计算或者SIMD（单指令多数据流，可并行处理多个数据的指令）提高运算效率。对于数据结构与容器，编程语言中的数据结构可能不满足要求，比如C++一些标准实现会产生内存空洞，引擎中实现的数据结构更加方便内存管理，提高访问效率。对于内存管理，引擎内存管理与操作系统类似，内存性能瓶颈主要在内存池（分配器）、缓存缺失、内存对齐等 平台层引擎或者游戏需要发布在不同平台上，可能需要使用不同的图形API。此外，用户使用的输入设备、硬件设备可能也完全不同，这都需要平台层进行处理。平台层使得游戏能兼容不同平台、不同硬件设备，为上层提供平台无关的服务和信息。对于图形API（如OpenGL、DirectX、Vulkan等），平台层需要使用RHI（Render Hardware Interface）去除不同API的差异，上层使用时无需关心渲染使用的是何种API。 第三方库第三方库或中间件通过SDK的形式或者文件格式转化，各种软件比如PS，3ds Max这些做出资产然后导入游戏引擎变成asset 为什么要分层？为了将游戏引擎解耦并降低复杂度，每一层都将独立，底层提供基础服务，顶层无需知道底层的具体实现，也有利于开发与版本迭代。 总结 游戏引擎分5层架构 在架构分层中，越往上越灵活，越往下越稳定 只能上层调用下层，反过来不行 虚拟世界由一系列tick时间组成 第三课 数据组织和管理Dynamic Game Objects – 可交互动态物体（人物，坦克等） Static Game Objects – 不可交互的静态物体（房子） Environments – 环境 Sky天空、Vegetation植被、Terrain地形 Other Game Obhects – TriggerArea触发检测体、AirWall空气墙、NavigationMesh导航网格、Ruler游戏规则 这些都可以统一抽象为GameObject（GO） 面向对象与GOGO都可以由属性Property和行为Behaviour组成。可以使用继承的方式来不断的扩展一个GO的新属性。 组件系统与GO但是对于另外的一些GameObject，通过继承方式不理想，比如一个水陆两栖坦克，既有船的能力，也有坦克的能力，那么它应该继承自谁呢？可以利用组合的方式，通过Component来自定义的组合他们的能力；使用组件化思想，用组合代替继承。用组件的方式另外一个好处就是灵活，可替换，需要哪个能力就用哪个组件，不需要就卸掉。 以无人机为例，此时各种能力和属性都可以抽成一个个的组件，如 TransformComp（位置），ModelComp（外形），MotorComp（运动），AIComp，PhysicsComp 等，此时无人机里只需要有一个 ComponentBase 的数组即可： **这里注意可能组件也好，面向对象也好，最上层可能都是有一个基类，里面属性和方法都没有，但是也很有必要，因为这类似于句柄，在释放和管理的时候会需要。***注意 Unreal 和 Unity 中的 Object 与上述的 GameObject 并不相同。Unreal 中 AActor 是类似 GameObject 的概念，UObject 更类似于高级语言中的 Object。 组件模式有什么缺点？ 效率没有直接写一个class高,ECS很重要，就是把同样的组件放一起，后面处理很方便 组件内部还需要通信，时间代价 Tick每隔一段时间让世界向前走一步：让每个 GameObject 中的每一个 Component 去 Tick 一次。在实际中，现代游戏引擎更多的通常不是逐对象逐组件去 Tick ，而是逐系统，比如先去做所有的和碰撞相关的事情，再去做所有和动画相关的事情，这样用类似流水线的方式，更有效率。 一个 Tick 的时间过长怎么处理？ Tick 的时候将步长传入，依赖步长进行数据的补偿； 直接跳过下一个 Tick；二帧很危险 通常还是需要进行策略优化；分几批处理，化成几帧处理完毕 Event（GO之间交互）对于GameObject 间的交互，如一个炸弹爆炸，对其他不同的 GO 的影响，早期硬编码如下： 这样的代码明显违反设计模式的原则，由此引出 Event（事件），有点类似观察者模式，通过事件派发的方式进行解耦，接收/绑定了这个事件的对象再去处理该事件。 最核心的是可扩展的消息系统，开发者可以在此基础之上定制消息类型和处理消息类型的组件对事件进行处理。 如何管理GO？发生的事情如何通知到每个GO？ GO管理每个GO都有一个ID唯一标识uid和一个位置（空间位置） 场景管理 通过唯一 ID 进行标识管理； 通过 object 的位置进行管理； 每个场景中管理GO，如果不管理需要通过遍历场景中半径范围内所有的对象，进行消息的通知。例如一个GO寻找周围GO时就遍历所有的GO。通过画格子优化：将地图分为几块，每块中的物体分别管理。先找邻近的格子，没有就不再找别的格子了。缺点：如果各个格子中GO分布不均，不高效。 优化方式：四叉树，八叉树，BVH，BSP 其他复杂问题绑定问题 比如人和车，人上了车，这两个GO就绑定在一起了，这样一般先tick车，再tick人 如果按照Component类别来Tick，可能会分散到不同的CPU上，顺序是不能保证的，不同的Tick顺序会产生不同的结果。如果每次输入是一样的，那么结果也需要是一样的。比如实现游戏录像功能。 根本原因：Component在发送消息，其他Component在当前帧接收到消息还是下一帧接收到消息，接收到消息立即处理，还是等到下一帧处理。都会产生不同结果。 在实际的事件传递中，时序很重要，如游戏的回放功能，实际是记录用户的输入，如果各用户是依次执行，则没有问题，但如果用户同时进行同一事件的操作则会有问题，因此需要引入一个 “邮局”，各个操作先发到邮局，邮局去保证时序接着进行发送，常用引擎中的类似 PreTick，PostTick 的函数都是为了处理时序问题。","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"Games-104","slug":"Games-104","permalink":"http://icecorn.github.io/tags/Games-104/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"}]},{"title":"快手实习总结|渲染&shader","slug":"快手实习总结","date":"2022-05-31T09:25:10.000Z","updated":"2022-06-29T16:32:33.044Z","comments":true,"path":"2022/05/31/快手实习总结/","link":"","permalink":"http://icecorn.github.io/2022/05/31/%E5%BF%AB%E6%89%8B%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"快手实习总结零散知识混合模式及LUT：https://www.jianshu.com/p/2f188d2b79f1 ffmpeg常用命令：https://www.cnblogs.com/frost-yen/p/5848781.html shader学习：https://www.shadertoy.com 数字图像，滤波器基础：https://ai.stanford.edu/~syyeung/cvweb/tutorial1.html 火焰效果用两张噪声图，一张作为底（然后偏移），一张作为扰动 暴雪暗黑的燥波造火特效万能公式 https://youtu.be/YPy2hytwDLM?t=1504 纯数学生成水波，uv扭曲、时间循环计算、双燥波无缝混合等等数学干货 https://catlikecoding.com/unity/tutorials/flow/texture-distortion/ 对于火焰，要用大理石噪波，或者cell噪波作为底（因为这些噪波有尖锐的角，符合火焰形态），用柏林噪声作为扰动，然后smoothstep等将两张噪波偏移叠加，然后在对不同的灰度进行颜色映射，映射出外焰和内焰不同的颜色 对于云，这种用柏林噪声为底更为合适，因为它比较圆，形态像一团东西更像云彩 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960varying vec2 textureCoordinate; //fs坐标uniform sampler2D bgImage; //输入人体分割maskuniform sampler2D noiseTexture; //噪声图1uniform sampler2D lastTexture; //上一帧的mask，人体背景分割黑白图uniform sampler2D noiseTexture1; //噪声图2uniform float RATIO; //显示长宽比 默认720/1280uniform float uTime; //当前time*1000uniform float fadein; //火焰渐现参数 0-10suniform float flameSpeed; //火焰运动速度 1-10 实际值是 25000/(speed*speed)uniform float flameRadius;//火焰宽度 0.57-0.97uniform vec3 flameColorInner;//火焰内颜色uniform vec3 flameColorOuter;//火焰外颜色 vec4 blend_normal(vec4 overlay, vec4 base)&#123; return overlay + base*(1.-overlay.a);&#125;void main ()&#123; float timeSampler = float(mod(uTime, flameSpeed)) / flameSpeed; vec2 uv = vec2(textureCoordinate.x, 1.0 - textureCoordinate.y); vec2 scale = vec2(RATIO,1.2); //采样噪声1，加入time使其朝向右下方移动,这个噪声1作为噪声2的扰动 lowp vec4 noise_1 = texture2D(noiseTexture, uv * scale - timeSampler * 0.55); //采样噪声2，用噪声1作为扰动达到一个动态噪声的效果，最后*2-1是为了造出一些黑色的地带，这就是两张噪声叠加的效果 lowp vec2 noise_2 = (1.0 - texture2D(noiseTexture, uv * scale + noise_1.yx * 0.065 + timeSampler * 0.15).xy) * 2.0 - 1.0; //采样一个噪声3，这个只是为了最后混合人体mask里边的地方 lowp vec2 noise_3_tmp = noise_2 * texture2D(noiseTexture, uv * scale * 5.0 - timeSampler * 1.55).yx; lowp float noise_3 = sqrt(dot(noise_3_tmp, noise_3_tmp)); //计算火焰强度 lowp float flameIntensity = clamp(noise_1.y + 0.5, 0.0, flameRadius); //采样上一帧的纹理，这里是人体的mask图，并且加扰动是白色区域向外扩散，并且扩散区域的透明度递减 lowp vec4 lastClr = texture2D(lastTexture, textureCoordinate + noise_2 * 0.015); //每一个像素算出不同的透明度 float alpha = flameIntensity * lastClr.w; //由于采样上一帧的纹理，轮廓边缘的透明度肯定是越来越小的，这样就能体现出内焰和外焰 vec3 clr = (flameColorInner * lastClr.w + flameColorOuter * (1.0 - lastClr.w)) * alpha; lowp vec4 flameClr = vec4(clr, alpha); //这是有拿了另一张噪波图做一遍同样的操作 lowp vec4 noise1_1 = texture2D(noiseTexture1, uv * scale - timeSampler * 0.55);// lowp vec2 noise1_2 = texture2D(noiseTexture1, uv * scale + noise_1.yx * 0.065 + timeSampler * 0.15).yx * 2.0 - 1.0; lowp vec2 noise1_2 = (1.0 - texture2D(noiseTexture1, uv * scale + noise1_1.yx * 0.065 + timeSampler * 0.15).xy) * 2.0 - 1.0; lowp vec2 noise1_3_tmp = noise1_2 * texture2D(noiseTexture1, uv * scale * 5.0 - timeSampler * 1.55).yx; lowp float noise1_3 = sqrt(dot(noise1_3_tmp, noise1_3_tmp)); lowp float flameIntensity1 = clamp(noise1_1.y + 0.5, 0.0, flameRadius); lowp vec4 lastClr1 = texture2D(lastTexture, textureCoordinate + noise1_2 * 0.015); float alpha1 = flameIntensity1 * lastClr1.w; vec3 clr1 = (flameColorInner * lastClr1.w + flameColorOuter * (1.0 - lastClr1.w)) * alpha; lowp vec4 flameClr1 = vec4(clr1, alpha1);// flameClr.rgb = flameClr.rgb * flameClr1.rgb * 4.;这里可以随便叠加不同，看效果 flameClr.rgb = flameClr.rgb + flameClr1.rgb; //这里获取人体分割mask lowp vec4 bgClr = texture2D(bgImage, textureCoordinate); //最后或者一下并且后边有一个火焰渐现的效果 flameClr = (flameClr + bgClr * noise_3 * 3.5) * smoothstep(0.0,1.0,uTime/(fadein*1000.0)); gl_FragColor = flameClr;&#125; 操作纹理记得在cpu里set warp ，否则超出边界会出现硬边 12345glActiveTexture(GL_TEXTURE1)-- set warpglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);glBindTexture(GL_TEXTURE_2D, mNoiseTex) ![image-20220526151520368](/Users/jun/Library/Application Support/typora-user-images/image-20220526151520368.png) 描边效果1.边缘检测​ 描边效果的实质是边缘检测，所谓边缘是指其周围像素灰度急剧变化的那些像素的集合，即数学上图像梯度突变的区域。通过边缘检测算子即可得到边缘，常用的有Sobel算子，Canny算子，Laplacian算子等等，其本质都是高通滤波器。Sobel算子由于结构比较简单，检测效率较高比较常用。 参考：https://blog.csdn.net/linqianbi/article/details/78673903 2.图像膨胀，腐蚀​ 输入一个黑白图mask，对其进行膨胀或腐蚀，在把原图混合上去剔除留下边缘信息，实现外描边和内描边 参考：https://blog.csdn.net/Du_Shuang/article/details/82952962?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-82952962-blog-79928835.pc_relevant_antiscanv2&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3 效果： 全图描边，findcountours 物体描边 边缘线条光感Bloom，原图模糊+原图 = bloom 描边上色 彩虹描边，通过uv相对中心的位置转换为角度，再映射到颜色值 12345vec2 toCenter = vec2(0.5) - uv;float angle = atan(toCenter.y,toCenter.x);angle = (angle / PI2) + 0.5;outColor = clamp(abs(mod(angle * 6.0 + u_changeTime * 21.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0); 描边移动，滚动等，结合不同静态mask，和mask序列帧实现各种效果 噪点效果通过随机噪声映射产生噪点图，再与原图进行混合 1234567891011121314151617181920212223242526272829303132333435363738uniform sampler2D inputImageTexture;varying vec2 textureCoord;uniform float uTime;uniform float intensity;uniform int mode;float rand1(vec2 co)&#123; return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);&#125;float rand2(vec2 co)&#123; return fract(sin(dot(co.xy, vec2(72.1241, 21.5234))) * 19842.1245);&#125;float rand3(vec2 co)&#123; return fract(sin(dot(co.xy, vec2(66.1321, 9.5234))) * 1942.1245);&#125;vec3 blend(vec3 src1, vec3 src2, float alpha)&#123; return mix(src1, src1 * (alpha * src1 + (2.0 * alpha * src2 * (1.0 - src1))) + src1 * (1.0 - alpha), alpha);&#125;void main() &#123; vec4 bgColor = texture2D(inputImageTexture, textureCoord); vec3 custom; if (mode == 0) &#123; custom = vec3(rand1(vec2(rand2(textureCoord), uTime))); &#125; else &#123; custom = vec3(rand1(vec2(rand2(textureCoord), uTime)), rand2(vec2(rand3(textureCoord), uTime)), rand3(vec2(rand1(textureCoord), uTime))); &#125; vec3 after = blend(bgColor.xyz, custom, intensity); gl_FragColor = vec4(after, bgColor.a);&#125; 模糊效果高斯模糊利用高斯分布（正太分布）作为采样系数进行卷积，通常采用两个pass之间来回倒（先上下再左右）这种来优化效率，从数学上可以证明和直接卷积是等价的。 1234567891011121314151617181920212223242526 uniform vec2 direction;//采样方向 上下或左右 uniform vec2 dimensions;//屏幕分辨率 uniform float sigma; void main() &#123; float twoSigma2 = 2.0 * sigma * sigma; int halfWidth = int(ceil(2.0 * sigma)); vec4 sum = vec4(0.0); float norm = 0.0; if (halfWidth &gt; 0) &#123; for (int i = -halfWidth; i &lt;= halfWidth; ++i) &#123; vec2 pr = float(i)*direction; float kernel = exp(-dot(pr, pr) / twoSigma2); vec4 c = texture2D(inputImageTexture, textureCoordinate + pr / dimensions).rgba; sum += kernel * c; norm += kernel; &#125; &#125; else &#123; sum = texture2D(inputImageTexture, textureCoordinate).rgba; norm = 1.0; &#125; gl_FragColor = vec4(sum / norm);&#125; 移位模糊本质上就是选择一个在纵向给一个不同的采样权重 123456789101112131415161718uniform sampler2D tDiffuse;uniform float v;uniform float r;varying vec2 vUv;void main() &#123;vec4 sum = vec4( 0.0 );float vv = v * abs( r - vUv.y );sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * vv ) ) * 0.051;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * vv ) ) * 0.0918;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * vv ) ) * 0.12245;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * vv ) ) * 0.1531;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * vv ) ) * 0.1531;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * vv ) ) * 0.12245;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * vv ) ) * 0.0918;sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * vv ) ) * 0.051;gl_FragColor = sum;&#125; Tone-mapping及色彩空间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889uniform float toneMappingExposure;uniform float toneMappingWhitePoint;vec3 LinearToneMapping( vec3 color ) &#123; return toneMappingExposure * color;&#125;vec3 ReinhardToneMapping( vec3 color ) &#123; color *= toneMappingExposure; return saturate( color / ( vec3( 1.0 ) + color ) );&#125;#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )vec3 Uncharted2ToneMapping( vec3 color ) &#123; color *= toneMappingExposure; return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );&#125;vec3 OptimizedCineonToneMapping( vec3 color ) &#123; color *= toneMappingExposure; color = max( vec3( 0.0 ), color - 0.004 ); return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );&#125;vec3 toneMapping( vec3 color ) &#123; return LinearToneMapping( color ); &#125;vec4 LinearToLinear( in vec4 value ) &#123; return value;&#125;vec4 GammaToLinear( in vec4 value, in float gammaFactor ) &#123; return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );&#125;vec4 LinearToGamma( in vec4 value, in float gammaFactor ) &#123; return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );&#125;vec4 sRGBToLinear( in vec4 value ) &#123; return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );&#125;vec4 LinearTosRGB( in vec4 value ) &#123; return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );&#125;vec4 RGBEToLinear( in vec4 value ) &#123; return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );&#125;vec4 LinearToRGBE( in vec4 value ) &#123; float maxComponent = max( max( value.r, value.g ), value.b ); float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 ); return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );&#125;vec4 RGBMToLinear( in vec4 value, in float maxRange ) &#123; return vec4( value.xyz * value.w * maxRange, 1.0 );&#125;vec4 LinearToRGBM( in vec4 value, in float maxRange ) &#123; float maxRGB = max( value.x, max( value.g, value.b ) ); float M = clamp( maxRGB / maxRange, 0.0, 1.0 ); M = ceil( M * 255.0 ) / 255.0; return vec4( value.rgb / ( M * maxRange ), M );&#125;vec4 RGBDToLinear( in vec4 value, in float maxRange ) &#123; return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );&#125;vec4 LinearToRGBD( in vec4 value, in float maxRange ) &#123; float maxRGB = max( value.x, max( value.g, value.b ) ); float D = max( maxRange / maxRGB, 1.0 ); D = min( floor( D ) / 255.0, 1.0 ); return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );&#125;const mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );vec4 LinearToLogLuv( in vec4 value ) &#123; vec3 Xp_Y_XYZp = value.rgb * cLogLuvM; Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6)); vec4 vResult; vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z; float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0; vResult.w = fract(Le); vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0; return vResult;&#125;const mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );vec4 LogLuvToLinear( in vec4 value ) &#123; float Le = value.z * 255.0 + value.w; vec3 Xp_Y_XYZp; Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0); Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y; Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z; vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM; return vec4( max(vRGB, 0.0), 1.0 );&#125;vec4 mapTexelToLinear( vec4 value ) &#123; return LinearToLinear( value ); &#125;vec4 envMapTexelToLinear( vec4 value ) &#123; return LinearToLinear( value ); &#125;vec4 emissiveMapTexelToLinear( vec4 value ) &#123; return LinearToLinear( value ); &#125;vec4 linearToOutputTexel( vec4 value ) &#123; return LinearToLinear( value ); &#125; 一些后处理效果像素化123456void main() &#123; vec2 p = vUv; p.x = floor(p.x * pixelsX)/pixelsX + 0.5/pixelsX; p.y = floor(p.y * pixelsY)/pixelsY + 0.5/pixelsY; gl_FragColor = texture2D(tDiffuse, p);&#125; 震动就是抖uv，手动生成噪声常用fract，sin等函数 123456void main() &#123;vec2 p = vUv;vec2 offset = (vec2(random1d(time),random1d(time + 999.99)) - 0.5) * amount;p += offset;gl_FragColor = texture2D(tDiffuse, p);&#125; 彩虹滚动效果12345678910111213vec3 rainbow2( in float t )&#123;vec3 d = vec3(0.0,0.33,0.67);return 0.5 + 0.5*cos( 6.28318*(t+d) );&#125;void main() &#123;vec2 p = vUv;vec3 origCol = texture2D( tDiffuse, p ).rgb;vec2 off = texture2D( tDiffuse, p ).rg - 0.5;p += off * offset;vec3 rb = rainbow2( (p.x + p.y + time * 2.0) * 0.5);vec3 col = mix(origCol,rb,amount);gl_FragColor = vec4(col, 1.0);&#125; 扫描线12345678910111213141516#define PI 3.14159265359highp float rand( const in vec2 uv ) &#123;const highp float a = 12.9898, b = 78.233, c = 43758.5453;highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );return fract(sin(sn) * c);&#125;void main() &#123;vec4 cTextureScreen = texture2D( tDiffuse, vUv );float dx = rand( vUv + time );vec3 cResult = cTextureScreen.rgb * dx * noiseAmount;float lineAmount = height * 1.8 * count;vec2 sc = vec2( sin( vUv.y * lineAmount), cos( vUv.y * lineAmount) );cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * linesAmount;cResult = cTextureScreen.rgb + ( cResult );gl_FragColor = vec4( cResult, cTextureScreen.a );&#125; RGB抖动1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253uniform sampler2D tDiffuse;varying vec2 vUv;uniform float amount;uniform float speed;uniform float time;float random1d(float n)&#123;return fract(sin(n) * 43758.5453);&#125;float random2d(vec2 n) &#123; return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);&#125;float randomRange (in vec2 seed, in float min, in float max) &#123;return min + random2d(seed) * (max - min);&#125;float insideRange(float v, float bottom, float top) &#123;return step(bottom, v) - step(top, v);&#125;float rand(vec2 co)&#123;return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);&#125;void main() &#123; vec2 uv = vUv; float sTime = floor(time * speed * 6.0 * 24.0); vec3 inCol = texture2D(tDiffuse, uv).rgb; vec3 outCol = inCol; float maxOffset = amount/2.0; vec2 uvOff; for (float i = 0.0; i &lt; 10.0; i += 1.0) &#123; if (i &gt; 10.0 * amount) break; float sliceY = random2d(vec2(sTime + amount, 2345.0 + float(i))); float sliceH = random2d(vec2(sTime + amount, 9035.0 + float(i))) * 0.25; float hOffset = randomRange(vec2(sTime + amount, 9625.0 + float(i)), -maxOffset, maxOffset); uvOff = uv; uvOff.x += hOffset; vec2 uvOff = fract(uvOff); if (insideRange(uv.y, sliceY, fract(sliceY+sliceH)) == 1.0 )&#123; outCol = texture2D(tDiffuse, uvOff).rgb; &#125; &#125; float maxColOffset = amount/6.0; vec2 colOffset = vec2(randomRange(vec2(sTime + amount, 3545.0),-maxColOffset,maxColOffset), randomRange(vec2(sTime , 7205.0),-maxColOffset,maxColOffset)); uvOff = fract(uv + colOffset); float rnd = random2d(vec2(sTime + amount, 9545.0)); if (rnd &lt; 0.33)&#123; outCol.r = texture2D(tDiffuse, uvOff).r; &#125;else if (rnd &lt; 0.66)&#123; outCol.g = texture2D(tDiffuse, uvOff).g; &#125; else&#123; outCol.b = texture2D(tDiffuse, uvOff).b; &#125; gl_FragColor = vec4(outCol,1.0);&#125; 扭曲（沿着圆形轨迹）1234567void main() &#123;vec2 p = -1.0 + 2.0 * vUv; //后边加length那项额外加了一个扭曲项，相当于uv抖动把像素位置考虑进去了float pos = time * TWO_PI + length(p * size); //下边uv抖动按照圆形轨迹周期抖动，strength是强度gl_FragColor = texture2D(tDiffuse, vUv + strength * vec2(cos(pos), sin(pos)));&#125; 错位效果从上到下很多条线错位切割 123456789101112131415161718192021222324252627uniform sampler2D tDiffuse;uniform float slices;uniform float offset;uniform float time;uniform float speedV;varying vec2 vUv;float steppedVal(float v, float steps)&#123;return floor(v*steps)/steps;&#125;float random1d(float n)&#123;return fract(sin(n) * 43758.5453);&#125;float noise1d(float p)&#123;float fl = floor(p);float fc = fract(p);return mix(random1d(fl), random1d(fl + 1.0), fc);&#125;const float TWO_PI = 6.283185307179586; void main() &#123; vec2 uv = vUv; float n = noise1d(uv.y * slices + time * speedV * 3.0); float ns = steppedVal(fract(n ),slices) + 2.0; float nsr = random1d(ns); vec2 uvn = uv; uvn.x += nsr * sin(time * TWO_PI + nsr * 20.0) * offset; gl_FragColor = texture2D(tDiffuse, uvn);&#125; 边缘描边使用sobel算子 123456789101112131415161718192021222324252627uniform sampler2D tDiffuse;uniform float amount;uniform float passthru;varying vec2 vUv;vec2 texel = vec2(1.0 /512.0);mat3 G[2];const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );void main(void)&#123;mat3 I;float cnv[2];vec3 sample;G[0] = g0;G[1] = g1;for (float i=0.0; i&lt;3.0; i++)for (float j=0.0; j&lt;3.0; j++) &#123;sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;I[int(i)][int(j)] = length(sample);&#125;for (int i=0; i&lt;2; i++) &#123;float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);cnv[i] = dp3 * dp3; &#125;vec4 orig = texture2D( tDiffuse, vUv);gl_FragColor = orig * passthru + vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1])) * amount;&#125; Fibonacci采样通常我们会使用 4 个或者 8 个矩形边缘上的采样来进行扩张 / 收缩 / 模糊的效果 123456789101112131415161718uniform float r;float phi = 0.0;// 里面四个for (int i = 0; i &lt; 4; i++)&#123; phi += PI * 0.5; vec2 offset = vec2(sin(phi), cos(phi)) * r; result += texture2D(basetex, uv + offset);&#125;// 外面四个r *= sqrt(2.0);phi += PI * 0.25;for (int i = 0; i &lt; 4; i++)&#123; phi += PI * 0.5; vec2 offset = vec2(sin(phi), cos(phi)) * r; result += texture2D(basetex, uv + offset);&#125; 不过使用这种方法生成的 pattern 对水平或者垂直的边缘不是很友好。间隔稍微大一点就能看到明显的artifact，步长一大很容易出现这种一条条的情况. fibonacci采样最初是用于生成在空间中【均匀】分布的点的方法，在该平面上生成个采样点的公式 这里使用了黄金分割比的一个奇妙的性质，来让球面上的点分布更加均匀 12345678910uniform float r;float rad = 0.0;float phi = 0.0;for (float i = 0.0; i &lt; SAMPLE_CNT; i += 1.0)&#123; rad = sqrt((i + 0.5) / SAMPLE_CNT); // 简单地加个小 offset 保证不会每次都采样到原点 phi += GOLDEN_ANGLE; // 预计算的 $1 / \\phi$ vec2 offset = vec2(sin(phi), cos(phi)) * r * rad; result += texture2D(basetex, uv + offset);&#125; 加入噪声为了降低迭代次数，引入噪声来做到一个给均匀采样的效果，这种技术将走样现象转化为噪声，从而减少视觉上的怪异感。在实现上这边偷了个懒。由于计算中采样位置的值是逐次累加的，通过对它的初始值进行随机扰动就可以保证在采样的概率密度不变的情况下做出扰动了（其实就相当于转了一下采样的圆盘）。 如果让噪声动起来这样人眼就更不能发现锯齿了，但是又有一个问题是噪声太闪了。 1phi += someRandomNumberGenerator(time, uv); Temporal Denoising从时间维度入手，引入上一帧的信息，可以解决噪声每帧都在变（太闪了）的问题。 1234uniform float tfactor; // 上式中的 $\\alpha$vec4 lastcol = texture2D(lasttex, uv);vec4 currcol = texture2D(currtex, uv);gl_FragColor = mix(currcol, lastcol, tfactor); Joint Bilateral Filtering隆重介绍联合双向滤波。这一方法最开始被用于进行可以保留边缘的模糊效果，多见于对实时光线追踪进行降噪的过程中。GAMES202课程的最后一个作业实现了这样的一个算法，它利用GBuffer中的多项信息对图像进行滤波。 最基础的一种滤波方法是以颜色差异判断当前物体是否在移动。当前像素的色差超过某一阈值时就认为当前位置在运动，此时可以抛弃旧的采样以避免残影的问题。但只用这一种作为滤波手段的效果极差，很容易就会弄出更多的残影来，因此一般推荐这个滤波手段要加入更多还在使用的其它东西（比如遮罩）一同作用。 其实就是双边滤波，滤波时不止考虑远近这一维度的信息，还考虑前一帧和当前帧颜色数值的差值，如果大于阈值就直接舍弃上一帧的信息。 1234//filteringvec3 diff = abs(currcol.rgb - lastcol.rgb);float diffmax = max(max(diff.r, diff.g), diff.b);float colorfactor = 1.0 - smoothstep(max(0.0, thres - softthres), thres, diffmax); 拖尾效果Temporal还能用来实现拖尾，鬼影等效果 基本思想就是对一个运动的物体，把它前一帧的图像和当前帧的图像混合，并且根据时间因素设置透明度，比如拖尾10帧，当前帧是1，前一帧是0.9，再前一帧是0.8，这样10帧后透明度就是0了，就实现了拖尾效果。 1234567891011121314151617181920212223// draw current circlevec2 dpos = (uv - center) * canvasSize;float dist = sqrt(dot(dpos, dpos));float vcurr = dist &lt; radius ? 1.0 : 0.0;// distrub uvfloat time = t * 0.1;vec2 uv_disturb = mirroredUV(uv + time);uv_disturb = uv + (texture2D(noise, uv_disturb).xy * 2.0 - 1.0) * disturbAmp / canvasSize + speed + vec2(0.0008, 0.0004);uv_disturb = mirroredUV(uv_disturb);// spread lastfloat vlast = texture2D(last, uv_disturb).x;float phi = 0.0;for (int i = 0; i &lt; 4; i++) &#123; phi += PI * 0.5; vec2 duv = spread * vec2(sin(phi), cos(phi)); vlast = max(vlast, texture2D(last, uv_disturb + duv).x);&#125;// mix and returnfloat v = max(max(0.0, vlast - dval), vcurr);gl_FragColor = vec4(vec3(v), 1.0); 时间上的身体描边效果找到前5帧的缓存，每一帧的fbo给一个颜色，再混合，就实现了几层彩色的描边效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647varying vec2 uv;const float pi = 3.1415927;vec4 blend_normal(vec4 overlay, vec4 base)&#123; return overlay + base*(1.0 - overlay.r);&#125;vec4 getColor(sampler2D img, vec2 coord)&#123; if(coord.x &lt; 0. || coord.x &gt; 1. || coord.y &lt; 0. || coord.y &gt; 1. ) &#123; return vec4(0.); //注意此处为透明而不是黑色！ &#125; return texture2D(img, coord);&#125;void main() &#123; float time = uTime; vec4 bg_Image0 = getColor(bgImage0,uv); vec4 bg_Image1 = getColor(bgImage1,uv); vec4 bg_Image2 = getColor(bgImage2,uv); vec4 bg_Image3 = getColor(bgImage3,uv); vec4 bg_Image4 = getColor(bgImage4,uv); vec4 yan_Image = getColor(y_Image,uv); vec4 mattingColor = mix(vec4(0.,0.,0.,0.),yan_Image,bg_Image4.r); //第三层绿色拖影 vec4 color = mix(yan_Image,greenCode * 1.0,bg_Image2.a); //第二层黄色拖影 color = mix(color,yellowCode * 1.0,bg_Image1.a); //第一层粉色拖影 color = mix(color,pinkCode * 1.0,bg_Image0.a); color = mix(color,mattingColor,mattingColor.a); gl_FragColor = color;&#125;","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"渲染","slug":"图形学/渲染","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"}],"tags":[{"name":"shader","slug":"shader","permalink":"http://icecorn.github.io/tags/shader/"},{"name":"openGL","slug":"openGL","permalink":"http://icecorn.github.io/tags/openGL/"}]},{"title":"算法系列（一）|链表，树，递归，回溯","slug":"算法/算法系列（一）链表，树，递归，回溯","date":"2022-05-25T09:25:10.000Z","updated":"2022-06-29T15:58:10.034Z","comments":true,"path":"2022/05/25/算法/算法系列（一）链表，树，递归，回溯/","link":"","permalink":"http://icecorn.github.io/2022/05/25/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%E9%93%BE%E8%A1%A8%EF%BC%8C%E6%A0%91%EF%BC%8C%E9%80%92%E5%BD%92%EF%BC%8C%E5%9B%9E%E6%BA%AF/","excerpt":"","text":"算法题系列（一）主要掌握知识点，滑动窗口，双指针，动态规划，字符串，数组，二叉树，并查集，单调栈，DFS，BFS等；其中字符串操作(子串)，数组(二维数组遍历)是重点。二维数组要记住leetcode上俄罗斯套娃信封问题，里面有个排序思想能解决二维数组的很多问题，比如堆积木，快递问题，小朋友身高体重问题，主要多刷题，总结刷题思路和模板 常见算法题型递归 一个问题的解可以分解为几个子问题的解 子问题求解思路和原问题一致 存在基线/终止条件 Lc21题：合并两个有序链表Lc83题：删除链表重复元素 链表链表判断是否有环 方法：双指针，遍历，哈希Lc141题：环形链表Lc206题：反转链表Lc234题：回文链表 树一篇解决：https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/solution/yi-pian-wen-zhang-dai-ni-chi-tou-dui-che-uhgs/ 解题模板下面给出二叉树对称性递归的解题模板1、递归结束条件：特殊情况的判断如果是单树问题，一般来说只要进行以下判断： 123if(!root) return true/false;if(!root-&gt;left) return true/false/递归函数;if(!root-&gt;right) return true/false/递归函数; 如果是双树问题(根节点分别为p,q)，一般来说进行以下判断： 12if(!p &amp;&amp; !q)return true/false;if(!p || !q)return true/false; 当然也不完全是这些情况，比如有的需要加上节点值的判断，需要具体问题需要具体分析 2、返回值通常对称性递归的返回值是多个条件的复合判断语句可能是以下几种条件判断的组合：节点非空的判断节点值比较判断(单树)调用根节点左右子树的递归函数进行递归判断(双树)调用两棵树的左右子树的递归函数进行判断 字符串比较，匹配，解析重点题：回文字符串思路就是以每个字符为中心，像左右发散判断是否回文（分一个字符中心，和两个字符中心） 搜索DFS:应用：暴力搜索（其实就是枚举），检测环路dfs可以搜索到所有的解，根据题意应用一些剪枝的策略解题步骤： 找到搜索的下一个状态（往哪搜索） 考虑搜索跳出的条件 设置搜索状态（标记已经搜索过了） 考虑剪枝情况优化搜索 经典题目：迷宫路径，宝石最大价值（暴力+剪枝） BFS： 应用：bfs主要用来算最短路径，找一个“值”，火烧法，通过queue来实现 经典题：二叉树层序遍历，每层的最大值，在while循环里获取当前queue的size，for循环size次 回溯法： 一篇解决：https://leetcode.cn/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/ 回溯和dfs的区别是，dfs是无脑往下一个状态搜，回溯是搜索达到结束条件后，撤销这一步的选择，然后再继续搜，通常带有一些“状态东西“，比如一个vector之类的（想一下麻将胡牌问题） 回溯应用：一般用在要查找所有解，要维护一个和搜索过程无关的状态集合 解题步骤： 画出递归树，找到状态变量（回溯函数的参数） 根据题意，确立结束条件 找准选择列表（与函数参数相关） 判断剪枝 做出选择 递归调用 撤销选择 题型： 子集，组合 核心在于设置一个标志位int start，从而选定下一步可选集合 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) &#123; //sort(candidates.begin(),candidates.end()); backtrace(candidates,0,target); return res; &#125; //第一步 void backtrace(vector&lt;int&gt; candidates,int start,int target) &#123; //第二步 if(target==0)&#123; res.push_back(path); return; &#125; //第三步 for(int i=start;i&lt;candidates.size();++i)&#123; if(target&lt;0) return;//第四步 path.push_back(candidates[i]);//第五步 backtrace(candidates,i,target-candidates[i]);//第六步 path.pop_back();//第七步 &#125; &#125;&#125;; 全排列Lc47 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end()); int n = nums.size(); vector&lt;int&gt; visited(n,0); backTrace(nums,visited,0); return res; &#125; void backTrace(vector&lt;int&gt;&amp; nums,vector&lt;int&gt;&amp; visited,int pos)&#123; //这里可以直接path.size()==nums.size(),不用传pos if(pos==nums.size())&#123; res.push_back(path); return; &#125; for(int i=0;i&lt;nums.size();++i)&#123; if(!visited[i])&#123; //这个!visited[i-1]没想到，必须前一个也能选才要剪枝 //注意是i&gt;0,其实不用传pos if(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!visited[i-1]) continue; path.push_back(nums[i]); visited[i] = 1; backTrace(nums,visited,pos+1); visited[i] = 0; path.pop_back(); &#125; &#125; &#125;&#125;; 搜索 常用API是否是数字，字母123char a;isdigit(a); //校验字符是不是十进制数isalpha(a); //校验字符是不是英文字母 n进制字符串转换成10进制12345#include&lt;string&gt;stoi(字符串，起始位置，n进制);示例：stoi(&quot;123&quot;); //直接一个参数也行 结果123stoi(str,0,2);//将str从位置0到末尾转化为10进制 字符串转换成整数1234567int atoi(const char *nptr); //str-&gt;intlong atol(const char *nptr); //str-&gt;longlong long atoll(const char *nptr); //str-&gt;long longlong long atoq(const char *nptr); //str-&gt; long long示例：ii=atoi(&quot;123&quot;);printf(&quot;ii=%d\\n&quot;,ii); string转C风格字符串123456789s.c_str();string s = &quot;Hello World!&quot;;printf(&quot;%s&quot;, s.c_str()); //输出 &quot;Hello World!&quot;C风格转string可以直接赋值char* chstr;char arstr[];string str = chstr;string str = arstr; 字符串常用操作拼接 1234567891011121314+号拼接string str1 = &quot;hello&quot;;string str2 = &quot; world&quot;;str1 += str2; // str1 = &quot;hello world&quot;函数拼接string str1 = &quot;hello&quot;;str1.append(&quot; world&quot;); //str1 = &quot;hello world&quot;string str2 = &quot;hello&quot;;str2.append(&quot; world&quot;,3); //str1 = &quot;hello wo&quot;,参数3代表只要前3个string str3 = &quot;hello&quot;;str3.append(&quot; w orld&quot;,2,3); //str1 = &quot;hello or&quot;,参数2代表从下标2开始,参数3代表要3个字符 查找子串 1234string str1 = &quot;abcdefdef&quot;;str1.find(&quot;def&quot;); //结果是3，从左往右找str1.rfind(&quot;def&quot;); //结果是6，从右往左找str1.find(&quot;hhh&quot;); //结果为-1，没有这个子串结果就是-1 替换 12string str1 = &quot;abcdssw&quot;;str1.replace(0,2,&quot;1111&quot;); //代表主串从0的位置开始，两个字符被替换掉；此处的结果为1111cdssw 比较 1234567string str1 = &quot;hello&quot;;string str2 = &quot;hello&quot;;str1.compare(str2); //结果为0代表相等，否则为不相等string str1 = &quot;helpo&quot;;string str2 = &quot;hello&quot;;str1.compare(str2); //结果不为0，为p-l,两个字符的ASCII值求差 插入 12string str1 = &quot;hello&quot;;str1.insert(1,&quot;111&quot;); //在1的位置插入,结果为&quot;h111ello&quot; 获取子串 1234string str1 = &quot;hello world&quot;;str1.substr(1,3); //从下标为1的位置截取长度为3的子串//结果为ellstr1.substr(1) //返回的就是下标1到最后的子串 删除子串 123string str1 = &quot;hello world&quot;;str1.erase(1,3); //从下标为1的位置起，删除长度为3的子串//结果为&quot;ho world&quot; 求和函数1accumulate(v.begin(), v.end(), 0); //最后的参数是初始值，一般为0 注意点123456789101112131415//pair的使用pair&lt;int,int&gt; p = makepair(i,j);pair&lt;int,int&gt; p(i,j);pair-&gt;first; pair-&gt;second;//矩阵构造 注意右边是vector&lt;int&gt; 不要忘记泛型vector&lt;vector&lt;int,int&gt;&gt; mat = vector(m,vector&lt;int&gt;(n,0));//写递归时注意，前边return true，要在上一级的递归函数中用上backtrace()&#123; if(xxx) return true; if(backtrace)return true; ... return false;&#125; 字符串匹配cin&gt;&gt; 一次处理一行 思路是重新生成字符串，双指针处理，i指针遍历字符串，j指针跟着遍历但找到符合条件要删除的就j–，然后s[j++] = s[i]组成新的字符串，最后返回。 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;int main() &#123; int n; cin&gt;&gt;n; string s; while(n--) &#123; cin&gt;&gt;s; int j=0; for(int i=0;i&lt;s.size();i++) &#123; s[j++]=s[i]; //j还没用 if(j&gt;=3&amp;&amp;s[j-1]==s[j-2]&amp;&amp;s[j-2]==s[j-3]) j--; if(j&gt;=4&amp;&amp;s[j-1]==s[j-2]&amp;&amp;s[j-3]==s[j-4]) j--; &#125; s.erase(s.begin()+j,s.end()); cout&lt;&lt;s&lt;&lt;endl; &#125;&#125; 贪心问题n个建筑藏3个人且最大距离不超过d，处理有序数组的题目 思路： 遍历数组，找出每一次可选元素，双指针i j，v[i]-v[j]&lt;=d筛选 贪心处理，组合问题，假定每一次i的值都被选，那么count=前边的数中选2个人 回溯法麻将问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;iostream&gt;(720)#include &lt;vector&gt;using namespace std;vector&lt;int&gt; card(9);//检查剩余的牌能否组成n个顺子或刻子bool hasTrible(int n)&#123; if(n==0) return true; for(int i=0; i&lt;card.size(); ++i)&#123; //因为仍是从1开始查验，因此若检查到其牌数&gt;=3，则必定是刻子 if(card[i]&gt;2)&#123; card[i] -= 3; if(hasTrible(n-1))&#123; //检查余下的牌能否组成n-1个顺子或刻子 card[i] += 3; return true; &#125; card[i] += 3; &#125; //否则只能是顺子 else if(i&lt;card.size()-2 &amp;&amp; card[i]&gt;0 &amp;&amp; card[i+1]&gt;0 &amp;&amp; card[i+2]&gt;0)&#123; card[i]--; card[i+1]--; card[i+2]--; if(hasTrible(n-1))&#123; card[i]++; card[i+1]++; card[i+2]++; return true; &#125; card[i]++; card[i+1]++; card[i+2]++; &#125; &#125; return false;&#125;//检查14张牌能否和牌bool isWin()&#123; for(int i=0; i&lt;9; ++i)&#123; //依次把1~9作为雀头拿出来，检查剩下的12张牌能否顺或刻子 if(card[i]&lt;2) continue; card[i] -= 2; if(hasTrible(4))&#123; card[i] += 2; return true; &#125; card[i] += 2; &#125; return false;&#125;int main()&#123; vector&lt;int&gt; res; int tmp; for(int i=0; i&lt;13; ++i)&#123; cin &gt;&gt; tmp; card[tmp-1]++; &#125; for(int i=0; i&lt;9; ++i)&#123; //1~9依次添加，检查是否可以和牌 if(card[i]&gt;3) continue; card[i]++; if(isWin()) //如果添加的这张牌可以和牌，则将其加入输出结果 res.push_back(i+1); card[i]--; &#125; if(res.empty()) res.push_back(0); for(int i=0; i&lt;res.size(); ++i) cout &lt;&lt; res[i] &lt;&lt; &#x27; &#x27;; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Linux高性能服务器|第十四章-多线程编程","slug":"Linux高性能服务器/Linux高性能服务器第十四章-多线程编程","date":"2022-05-15T09:25:10.000Z","updated":"2022-06-29T15:43:07.948Z","comments":true,"path":"2022/05/15/Linux高性能服务器/Linux高性能服务器第十四章-多线程编程/","link":"","permalink":"http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"第十四章 多线程编程根据运行环境和调度者身份, 线程可以分为两种内核线程运行在内核空间, 由内核来调度.用户线程运行在用空间, 由线程库来调用 当内核线程获得CPU的使用权的时候, 他就加载并运行一个用户线程, 所以内核线程相当于用户线程的容器. 线程有三种实现方式 完全在用户空间实现-无需内核支持创建和调度线程无需内核干预, 速度很快.不占用额外的内核资源, 对系统影响较小但是无法运行在多个处理器上, 因为这些用户线程是是实现在一个内核线程上的 完全由内核调度创建和调度线程的任务都交给了内核, 运行在用户空间的线程库无需管理优缺点正好与上一个相反 双层调度结合了前两个的优点不会消耗过多的内核资源,而且线程切换快, 同时它可以充分利用多处理器的优势 线程的创建和终止1234567#include &lt;pthread.h&gt;int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_routine)(void*), void* arg);// 成功返回0 失败返回错误码// thread 用来唯一的标识一个新线程// attr用来设置新县城的属性 传递NULL表示默认线程属性// start_routine 指定新线程运行的函数// arg指定函数的参数 1234567891011121314151617181920void pthread_exit(void* retval);用来保证线程安全干净的退出, 线程函数最好结束时调用.通过`retval`参数向线程的回收者传递其退出信息执行后不会返回到调用者, 而且永远不会失败int pthread_join(pthread_t thread, void** retval)可以调用这个函数来回收其他线程 不过线程必须是可回收的该函数会一直阻塞知道被回收的线程结束.成功时返回0, 失败返回错误码等待其他线程结束thread 线程标识符retval 目标线程的退出返回信息错误码如下`EDEADLK`引起死锁, 两个线程互相针对对方调用pthread_join 或者对自身调用`EINVAL`目标线程是不可回收的, 或是其他线程在回收目标线程`ESRCH`目标线程不存在int pthread_cancel(pthread_t thread)异常终止一个线程, 即为取消线程成功返回0, 失败返回错误码 线程属性设置 123456789101112131415161718接收到取消请求的目标线程可以决定是否允许被取消以及如何取消.// 启动线程取消int pthread_setcancelstart(int state, int* oldstate)第一个参数PTHREAD_CANCEL_ENABLE 允许线程被取消, 默认状态PTHREAD_CANCEL_DISABLE 不允许被取消, 如果这种线程接收到取消请求, 则会挂起请求直到这个线程允许被取消第二个参数 返回之前设定的状态// 设置线程取消类型int pthread_setcanceltype(int type, int* oldtype)第一个参数PTHREAD_CANCEL_ASYNCHRONOUS 线程可以随时被取消PTHREAD_CANCEL_DEFERRED 允许目标现成推迟行动, 直到调用了下面几个所谓的取消点函数最好使用pthread_testcancel函数设置取消点设置取消类型(如何取消)第二个参数原来的取消类型 设置脱离线程 123456789101112// 初始化线程属性对象int pthread_attr_init(pthread_attr_t *attr);// 销毁线程属性对象, 直到再次初始化前都不能用int pthread_attr_destory(pthread_attr_t *attr)// 参数取值// -PTHREAD_CREATE_JOINABLE 线程可回收// -PTHREAD_CREATE_DETACH 脱离与进程中其他线程的同步 成为脱离线程int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);// 可以直接设置为脱离线程int pthread_detach(pthread_t thread) 线程同步机制的使用场景POSIX信号量-需要自己维护计数值, 用户空间有计数值 信号量自己又计数值两份计数值容易出错 互斥锁-对临界资源的独占式访问 条件变量-等待某个条件满足当某个共享数据达到某个值的时候, 唤醒等待这个共享数据的线程 读写锁-可以多个进程读, 读的时候不能写, 同时只能一个写 自旋锁-通过while循环频繁尝试获取锁, 适用于锁事件短, 需要快速切换的场景 POSIX信号量多线程也必须考虑线程同步的问题.虽然pthread_join()可以看做简单的线程同步方式不过它无法高效的实现复杂的同步需求比如无法实现共享资源独占式访问, 或者在某种条件下唤醒指定的指定线程. 1234567891011121314151617#include&lt;semaphore&gt;// 用于初始化一个未命名的信号量.// pshared==0 则表示是当前进程的局部信号量, 否则信号量可以在多个进程间共享// value指定参数的初始值int sem_init(sem_t* sem, int pshared, unsigned int value)// 销毁信号量, 释放其占用的系统资源int sem_destory(sem_t* sem)// 以原子操作的形式将信号量的值 -1, 如果信号量的值为0, 则sem_wait将被阻塞直到sem_wait具有非0值int sem_wait(sem_t* sem)// 跟上面的函数相同不过不会阻塞. 信号量不为0则减一操作, 为0则返回-1 errnoint sem_trywait(sem_t* sem)// 原子操作将信号量的值 +1int sem_post(sem_t* sem) 初始化已经存在的信号量会导致无法预期的结果 销毁正被其他线程等待的信号量, 将会导致无法预期的结果 例子如下 1234567891011121314151617181920212223242526272829303132333435363738394041constexpr int kNumberMax = 10;std::vector&lt;int&gt; number(kNumberMax);constexpr int kThreadNum = 10;sem_t sems[kThreadNum];pthread_t threads[kThreadNum];constexpr int kPrintTime = 1;void* t(void *no)&#123; int start_sub = *static_cast&lt;int*&gt;(no); int sub =start_sub; int time = 0; while(++time &lt;= kPrintTime) &#123; // 锁住本线程 释放下一个线程 sem_wait(&amp;sems[start_sub]); printf(&quot;%d\\n&quot;, number[sub]); sem_post(&amp;sems[(start_sub + 1) % kThreadNum]); // 计算下一次要打印的下标 sub = (sub + kThreadNum) % kNumberMax; &#125; pthread_exit(nullptr);&#125;int main()&#123; std::iota(number.begin(), number.end(), 0); sem_init(&amp;sems[0], 0, 1); for (int i = 1; i &lt; kThreadNum; ++i) &#123; sem_init(&amp;sems[i], 0, 0); &#125; for (int i = 0; i &lt; kThreadNum; ++i) &#123; pthread_create(&amp;threads[i], nullptr, t, &amp;number[i]); &#125; // 等待最后一个线程结束 pthread_join(threads[kThreadNum - 1], nullptr);&#125; kThreadNum个进程依次打印[0, kNumberMax)每个进程打印kPrintTime次最后一个进程打印完后主线程才能结束 互斥锁123456789101112131415// 初始化互斥锁// 第一个参数指向目标互斥锁, 第二个参数指定属性 nullptr则为默认int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *mutexattr);// 销毁目标互斥锁int pthread_mutex_destory(pthread_mutex_t *mutex);// 针对普通锁加锁int pthread_mutex_lock(pthread_mutex_t *mutex);// 针对普通锁立即返回 目标未加锁则加锁 如果已经加锁则返回错误码EBUSYint pthread_mutex_trylock(pthread_mutex_t *mutex);// 解锁 如果有其他线程在等待这个互斥锁, 则其中之一获得int pthread_mutex_unlock(pthread_mutex_t *mutex); 销毁一个已经加锁的互斥锁 会发生不可预期的后果也可使使用宏PTHREAD_MUTEX_INITIALIZER来初始化一个互斥锁pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 互斥锁属性设置 123456789101112131415int pthread_mutexattr_init(pthread_mutexattr_t *attr);int pthread_mutexattr_destory(pthread_mutexattr_t *attr);// PTHREAD_PROCESS_SHARED 跨进程共享// PTHREAD_PROCESS_PRIVATE 隶属同一进程的线程int pthread_mutexattr_getpshared(const pthread_mutexattr_t *attr, int *pshared);int pthread_mutexattr_setpshared(const pthread_mutexattr_t *attr, int pshared);// PTHREAD_MUTEX_NORMAL 普通锁 默认类型// PTHREAD_MUTEX_ERRORCHECK 检错锁// PTHREAD_MUTEX_RECURSVE 嵌套锁// PTHREAD_MUTEX_DEFAULT 默认锁int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);int pthread_mutexattr_settype(const pthread_mutexattr_t *attr, int type); PTHREAD_MUTEX_NORMAL一个线程对其加锁后, 其他请求该锁的进程会形成一个等待队列, 解锁后然后按照优先级获得. 保证资源分配公平A线程对一个已经加锁的普通锁再次加锁(也是A线程)-同一线程在解锁前再次加锁引发死锁对一个已经被其他线程加锁的普通锁解锁, 或者再次解锁已经解锁的普通锁–解锁-不可预期后果 PTHREAD_MUTEX_ERRORCHECK线程对已经加锁的检错锁再次加锁–加锁-加锁操作返回EDEADLK对一个已经被其他线程加锁的检错锁解锁, 或者再次解锁已经解锁的检错锁–解锁-返回EPERM PTHREAD_MUTEX_RECURSVE允许一个线程在释放锁前多次加锁 而不发生死锁.如果其他线程要获得这个锁, 则当前锁拥有者必须执行相应次数的解锁操作–加锁对于已经被其他进程加锁的嵌套锁解锁, 或者对已经解锁的再次解锁–解锁-返回EPERM PTHREAD_MUTEX_DEFAULT这种锁的实现可能为上面三种之一对已经加锁的默认锁再次加锁对被其他线程加锁的默认锁解锁再次解锁已经解锁的默认锁都将会发生不可预料后果 例子 1234567891011121314151617181920pthread_mutex_t mutex;int count = 0;void* t(void *a)&#123; pthread_mutex_lock(&amp;mutex); printf(&quot;%d\\n&quot;, count); count++; pthread_mutex_unlock(&amp;mutex);&#125;int main()&#123; pthread_mutex_init(&amp;mutex, nullptr); pthread_t thread[10]; for (int i = 0; i &lt; 10; ++i) &#123; pthread_create(&amp;thread[i], nullptr, t, nullptr); &#125; sleep(3); pthread_mutex_destroy(&amp;mutex);&#125; 条件变量12345678910111213int pthread_cond_init(pthread_cond_t *cond, const pthread_condattr *cond_attr);// 销毁一个正在被等待的条件变量 将会失败并返回EBUSYint pthread_cont_destory(pthread_cond_t *cond);// 广播式的唤醒所有等待目标条件变量的线程int pthread_cont_broadcast(pthread_cond_t *cond);// 唤醒一个等待目标条件变量的线程int pthread_cond_signal(pthread_cond_t *cond);// 等待目标条件变量int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); pthread_cond_t cond = PTHREAD_COND_INITIALIZER;将各个字段初始化为0 pthread_cond_wait的第二个参数, 用于保护条件变量的互斥锁掉用函数前必须将 mutex加锁, 否则会发生不可预料的后果.函数执行前将调用线程放入条件变量等待队列, 然后将mutex解锁 从函数调用, 到被放入等待队列的时间内, pthread_cond_signal(broadcast)不会修改条件变量的值也就是 pthread_cond_wait函数不会错过目标条件变量的任何变化,将pthread_cond_wait函数返回的时候, 互斥锁mutex将会再次锁上 例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061pthread_mutex_t mutex;pthread_cond_t cond;int good = 3;int produce_count = 0;int consume_count = 0;void* Producer(void *arg)&#123; while(produce_count &lt; 10) &#123; pthread_mutex_lock(&amp;mutex); good++; pthread_mutex_unlock(&amp;mutex); produce_count++; printf(&quot;produce a good\\n&quot;); // 通知一个线程 pthread_cond_signal(&amp;cond); sleep(2); &#125; pthread_exit(nullptr);&#125;void* Consumer(void *arg)&#123; while (consume_count &lt; 13) &#123; // 传入前需要加锁 pthread_mutex_lock(&amp;mutex); if (good &gt; 0) &#123; good--; consume_count++; printf(&quot;consume a good, reset %d\\n&quot;, good); &#125; else &#123; printf(&quot;good is 0\\n&quot;); // wait pthread_cond_signal pthread_cond_wait(&amp;cond, &amp;mutex); &#125; pthread_mutex_unlock(&amp;mutex); usleep(500 * 1000); &#125; pthread_exit(nullptr);&#125;int main()&#123; mutex = PTHREAD_MUTEX_INITIALIZER; cond = PTHREAD_COND_INITIALIZER; pthread_t producer, consumer; pthread_create(&amp;consumer, nullptr, Consumer, nullptr); pthread_create(&amp;producer, nullptr, Producer, nullptr); pthread_join(consumer, nullptr); pthread_mutex_destroy(&amp;mutex); pthread_cond_destroy(&amp;cond);&#125; 读写锁自旋锁线程同步包装类-多线程环境12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091class Sem&#123;public: Sem() &#123; if (sem_init(&amp;sem_, 0, 0) != 0) &#123; throw std::exception(); &#125; &#125; ~Sem() &#123; sem_destroy(&amp;sem_); &#125; bool Wait() &#123; return sem_wait(&amp;sem_) == 0; &#125; bool Post() &#123; return sem_post(&amp;sem_) == 0; &#125;private: sem_t sem_;&#125;;class Mutex&#123;public: Mutex() &#123; if (pthread_mutex_init(&amp;mutex_, nullptr) != 0) &#123; throw std::exception(); &#125; &#125; ~Mutex() &#123; pthread_mutex_destroy(&amp;mutex_); &#125; bool Lock() &#123; return pthread_mutex_lock(&amp;mutex_) == 0; &#125; bool Unlock() &#123; return pthread_mutex_unlock(&amp;mutex_) == 0; &#125;private: pthread_mutex_t mutex_;&#125;;class Cond&#123;public: Cond() &#123; if (pthread_mutex_init(&amp;mutex_, nullptr) != 0) &#123; throw std::exception(); &#125; if (pthread_cond_init(&amp;cond_, nullptr) != 0) &#123; // 这里我一开始没有想到.. pthread_mutex_destroy(&amp;mutex_); throw std::exception(); &#125; &#125; ~Cond() &#123; pthread_mutex_destroy(&amp;mutex_); pthread_cond_destroy(&amp;cond_); &#125;; bool Wait() &#123; int ret = 0; pthread_mutex_lock(&amp;mutex_); ret = pthread_cond_wait(&amp;cond_, &amp;mutex_); pthread_mutex_unlock(&amp;mutex_); return ret == 0; &#125; bool Signal() &#123; return pthread_cond_signal(&amp;cond_) == 0; &#125;private: pthread_cond_t cond_; pthread_mutex_t mutex_;&#125;; 线程安全或可重入函数–函数能被多个线程同时调用而不发生竞态条件 多线程程序某个线程调用fork函数, 新进程不会与父进程有相同数量的线程子进程只有一个线程-调用fork线程的完美复制 但是子进程会继承父进程的互斥锁(条件变量)的状态, 如果互斥锁被加锁了, 但不是由调用fork线程锁住的, 此时子进程再次对这个互斥锁执行加锁操作将会死锁. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465pthread_mutex_t mutex;void* another(void *arg)&#123; printf(&quot;in child thread, lock the mutex\\n&quot;); pthread_mutex_lock(&amp;mutex); sleep(5); // 解锁后 Prepare才能加锁 pthread_mutex_unlock(&amp;mutex); pthread_exit(nullptr);&#125;// 这个函数在fork创建子进程前被调用void Prepare()&#123; // 但是会阻塞 直到执行another函数的线程解锁 才能够继续执行 // 这个函数执行完毕前fork不会创建子进程 pthread_mutex_lock(&amp;mutex);&#125;// fork创建线程后 返回前 会在子进程和父进程中执行这个函数void Infork()&#123; pthread_mutex_unlock(&amp;mutex);&#125;int main()&#123; pthread_mutex_init(&amp;mutex, nullptr); pthread_t id; pthread_create(&amp;id, nullptr, another, nullptr); sleep(1); // pthread_atfork(Prepare, Infork, Infork); int pid = fork(); if (pid &lt; 0) &#123; printf(&quot;emmm????\\n&quot;); pthread_join(id, nullptr); pthread_mutex_destroy(&amp;mutex); return 1; &#125; else if (pid == 0) &#123; printf(&quot;child process, want to get the lock\\n&quot;); pthread_mutex_lock(&amp;mutex); printf(&quot;i cann&#x27;t run to here, opps....\\n&quot;); pthread_mutex_unlock(&amp;mutex); exit(0); &#125; else &#123; printf(&quot;wait start\\n&quot;); wait(nullptr); printf(&quot;wait over\\n&quot;); // 没有打印 因为子进程不会终止 &#125; pthread_join(id, nullptr); pthread_mutex_destroy(&amp;mutex); return 0;&#125;// $ in child thread, lock the mutex// $ wait start// $ child process, want to get the lock// $ in child thread, lock the mutex// $ wait start// $ child process, want to get the lock// $ i cann&#x27;t run to here, opps....// $ wait over 原版就会发生死锁, 新版(去掉注释的代码) 能够正常运行 123int pthread_atfork (void (*__prepare) (void), void (*__parent) (void), void (*__child) (void)); 第一个句柄 在fork创建子进程前执行第二个句柄 在fork创建出子进程后, fork返回前在父进程中执行第二个句柄 在fork创建出子进程后, fork返回前在子进程中执行","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"},{"name":"系统编程","slug":"ReadingNotes/Linux/系统编程","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"多线程","slug":"多线程","permalink":"http://icecorn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"Linux高性能服务器|第十三章-多进程编程","slug":"Linux高性能服务器/Linux高性能服务器第十三章-多进程编程","date":"2022-05-15T09:25:10.000Z","updated":"2022-06-29T15:41:00.095Z","comments":true,"path":"2022/05/15/Linux高性能服务器/Linux高性能服务器第十三章-多进程编程/","link":"","permalink":"http://icecorn.github.io/2022/05/15/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B/","excerpt":"","text":"第十三章多进程编程exec系列系统调用12345678910111213141516#include &lt;unistd.h&gt;// 声明这个是外部函数或外部变量extern char** environ;// path 参数指定可执行文件的完成路径 file接收文件名,具体位置在PATH中搜寻// arg-接受可变参数 和 argv用于向新的程序传递参数数组// envp用于设置新程序的环境变量, 未设置则使用全局的环境变量// exec函数是不返回的, 除非出错// 如果未报错则源程序被新的程序完全替换int execl(const char* path, const char* arg, ...);int execlp(const char* file, const char* arg, ...);int execle(const char* path, const char* arg, ..., char* const envp[])int execv(const char* path, char* const argv[]);int execvp(const char* file, char* const argv[]);int execve(const char* path, char* const argv[], char* const envp[]); fork系统调用-进程的创建123456#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;// 每次调用都返回两次, 在父进程中返回的子进程的PID, 在子进程中返回0// 次返回值用于区分是父进程还是子进程// 失败返回-1pid_t fork(viod); fork系统调用fork() 函数复制当前的进程, 在内核进程表中创建一个新的进程表项新的进程表项有很多的属性和原进程相同 堆指针 栈指针 标志寄存器的值 子进程代码与父进程完全相同 同时复制(采用了写时复制, 父进程和子进程对数据执行了写操作才会复制)父进程的数据(堆数据, 栈数据, 静态数据) 创建子进程后, 父进程打开的文件描述符默认在子进程中也是打开的 文件描述符的引用计数, 父进程的用户根目录, 当前工作目录等变量的引用计数 均加1 也存在不同的项目 该进程的PPID(标识父进程)被设置成原进程的PID, 信号位图被清除(原进程设置的信号处理函数对新进程无效) (引自维基百科-引用计数是计算机编程语言中的一种内存管理技术，是指将资源（可以是对象、内存或磁盘空间等等）的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。) The child process is an exact duplicate of the parent process exceptfor the following points: The child has its own unique process ID, and this PID does not match the ID of any existing process group (setpgid(2)) or session. 子进程拥有自己唯一的进程ID, 不与其他相同 The child’s parent process ID is the same as the parent’s process ID. 子进程的父进程ID PPID 与父进程ID PID相同 The child does not inherit its parent’s memory locks (mlock(2), mlockall(2)). 子进程不继承父进程的内存锁(保证一部分内存处于内存中, 而不是sawp分区) Process resource utilizations (getrusage(2)) and CPU time counters (times(2)) are reset to zero in the child. 进程资源使用和CPU时间计数器在子进程中重置为0 The child’s set of pending signals is initially empty (sigpending(2)). 信号位图被初始化为空 原信号处理函数对子进程无效 需重新设置 The child does not inherit semaphore adjustments from its parent (semop(2)). 不会继承semadj The child does not inherit process-associated record locks from its parent (fcntl(2)). (On the other hand, it does inherit fcntl(2) open file description locks and flock(2) locks from its parent.) The child does not inherit timers from its parent (setitimer(2), alarm(2), timer_create(2)). 不会继承定时器 The child does not inherit outstanding asynchronous I/O operations from its parent (aio_read(3), aio_write(3)), nor does it inherit any asynchronous I/O contexts from its parent (see io_setup(2)). 处理僵尸进程-进程的管理123456789101112131415161718#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;// wait进程将阻塞进程, 直到该进程的某个子进程结束运行为止. 他返回结束的子进程的PID, 并将该子进程的退出状态存储于stat_loc参数指向的内存中. sys/wait.h 头文件中定义了宏来帮助解释退出信息.pid_t wait(int* stat_loc);// 非阻塞, 只等待由pid指定的目标子进程(-1为阻塞)// options函数取值WNOHANG-waitpid立即返回// 如果目标子进程正常退出, 则返回子进程的pid// 如果还没有结束或意外终止, 则立即返回0// 调用失败返回-1pid_t waitpid(pid_t pid, int* stat_loc, int options);WIFEXITED(stat_val); // 子进程正常结束, 返回一个非0WEXITSTATUS(stat_val); // 如果WIFEXITED 非0, 它返回子进程的退出码WIFSIGNALED(stat_val);// 如果子进程是因为一个未捕获的信号而终止, 返回一个非0值WTERMSIG(stat_val);// 如果WIFSIGNALED非0 返回一个信号值WIFSTOPPED(stat_val);// 如果子进程意外终止, 它返回一个非0值WSTOPSIG(stat_val);// 如果WIFSTOPED非0, 它返回一个信号值 对于多进程程序而言, 父进程一般需要跟踪子进程的退出状态. 因此, 当子进程结束运行是, 内核不会立即释放该进程的进程表表项, 以满足父进程后续对孩子进程推出信息的查询 在子进程结束运行之后, 父进程读取其退出状态前, 我们称该子进程处于僵尸态 另外一使子进程进入僵尸态的情况 - 父进程结束或者异常终止, 而子进程继续运行. (子进程的PPID设置为1,init进程接管了子进程) 父进程结束运行之后, 子进程退出之前, 处于僵尸态 以上两种状态都是父进程没有正确处理子进程的返回信息, 子进程都停留在僵尸态, 占据着内核资源. waitpid()虽然为非阻塞, 则需要在 waitpid所监视的进程结束后再调用.SIGCHLD信号- 子进程结束后将会给父进程发送此信号 123456789static void handle_child(int sig)&#123; pid_t pid; int stat; while ((pid = waitpid(-1, &amp;stat, WNOHANG)) &gt; 0) &#123; // 善后处理emmmm &#125;&#125; 信号量-进程的锁信号量原语只支持两种操作, 等待(wait)和信号(signal) , 在LInux中等待和信号有特殊的含义, 所以又称为P(passeren, 传递就好像进入临界区)V(vrijgeven, 释放就好像退出临界区)操作.假设有信号量SV(可取任何自然数, 这本书只讨论二进制信号量), 对它的PV操作含义为 P(SV), 如果SV的值大于0, 就将它减1, 如果sv的值为0 则挂起进程的执行 V(SV), 如果其他进程因为等待SV而挂起, 则唤醒之, 如果没有则将SV加1 总结PV使用方法 使用semget获取到唯一的标识.使用semctl的SETVAL传入初始化val的sem_un联合体.来初始化val调用semop 传入唯一标识, sem_op=-1执行P(锁)操作sem_op=1执行V(开锁)操作开关锁通过当sem_op=-1,semval=0 且未指定IPC_NOWAIT等待semval被sem_op=1改为semval=1 创建信号量 1234567891011// semeget 系统调用// 创建一个全局唯一的信号量集, 或者获取一个已经存在的信号量集// key 参数是一个键值, 用来标识一个全局唯一的信号量级,可以在不同进程中获取// num_sems 参数指定要创建/获取的信号量集中信号量的数目. 如果是创建信号量-必须指定, 如果是获取-可以指定为0. 一般都是为1// sem_flags指定一组标志, 来控制权限// - 可以与IPC_CREAT 做或运算创建新的信号量集, 即使信号量集存在也不会报错// - IPC_CREAT | IPC_EXCL来创建一组唯一信号量集 如果已经存在则会返回错误 errno = EEXIST// 成功返回一个正整数, 是信号量集的标识符, 失败返回 -1int semget(key_t key, int num_sems, int sem_flags);int sem_id = semget((key_t)1234, 1, 0666 | IPC_CREAT); 初始化 12345678910111213141516171819202122232425262728293031// semctl 系统调用// sem_id 参数是由semget返回的信号量集标识符// sen_num指定被操作的信号量在信号集中的编号// command指定命令, 可以追加命令所需的参数, 不过有推荐格式// 成功返回对应command的参数, 失败返回-1 errnoint semctl(int sem_id, int sem_num, int command, ...);// 第四个参数 竟然需要手动声明...union semun&#123; int val; /* Value for SETVAL */ struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET */ unsigned short *array; /* Array for GETALL, SETALL */ struct seminfo *__buf; /* Buffer for IPC_INFO (Linux-specific) */&#125;;// 初始化信号量union semun sem_union;sem_union.val = 1;// 这里可以直接第三个参数传入1(val)if (semctl(sem_id, 0, SETVAL, sem_union) == -1)&#123; exit(0);&#125;// 删除信号量union semun sem_union&#123;&#125;;if (semctl(sem_id, 0, IPC_RMID, sem_union) == -1)&#123; exit(EXIT_FAILURE);&#125; 与semop信号量关联的一些重要的内核变量 1234unsigned short semval; // 信号量的值unsigned short semzcnt; // 等待信号量值变为0的进程数量unsigned short semncnt// 等待信号量值增加的进程数量pid_t sempid; // 最后一次执行semop操作的进程ID 操作信号量, 实际上就是对上面的内核变量操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// sem_id 是由semget调用返回的信号量集的标识符, 用以指定被操作的,目标信号量集.// sem_ops 参数指向一个sembuf结构体类型的数组// num_sem_ops 说明操作数组中哪个信号量// 成功返回0, 失败返回-1 errno. 失败的时候sem_ops[] 中的所有操作不执行int semop(int sem_id, struct sembuf* sem_ops, size_t num_sem_ops);// sem_op &lt; 0 期望获得信号量// semval-=abs(sem_op),要求调用进程对被操作信号量集有写权限// 如果semval的值大于等于sem_op的绝对值, 则操作成功, 调用进程立即获得信号量// 如果semval &lt; abs(sem_op) 则在被指定IPC_NOWAIT的时候semop立即返回error, errno=EAGIN// 如果没有指定 则 阻塞进程等待信号量可用, 且 semzcnt +=1, 等到下面三种情况唤醒// 1 发生semval &gt;= abs(sem_op), semzcnt-=1, semval-=abs(sem_op). 在SEM_UNDO设置时更新semadj// 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM (同 sem_op = 0)// 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 (同 sem_op = 0)bool P(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; // 信号量编号 第几个信号量 一般都是第0个 sem_b.sem_op = -1; // P // IPC_NOWAIT 无论信号量操作是否成功, 都立即返回 // SEM_UNDO当进程退出的时候, 取消正在进行的semop操作 PV操作系统更新进程的semadj变量 sem_b.sem_flg = SEM_UNDO; return semop(sem_id, &amp;sem_b, 1) != -1;&#125;// sem_op &gt; 0 // semval+=sem_op , 要求调用进程对被操作的信号量集有写权限// 如果此时设置了SEM_UNDO标志, 则系统将更新进程的semadj变量(用以跟踪进程对信号量的修改情况)bool V(int sem_id)&#123; struct sembuf sem_b; sem_b.sem_num = 0; sem_b.sem_op = 1; // V sem_b.sem_flg = SEM_UNDO; return semop(sem_id, &amp;sem_b, 1) != -1;&#125;// -- sem_op = 0// -- 标着这是一个`等待0`的操作, 要求调用进程对被操作信号量集有用读权限// -- 如果此时信号量的值是0, 则调用立即返回, 否则semop失败返回, 或者阻塞进程以等待信号量变为0// -- 此时如果IPC_NOWAIT 标志被设置, sem_op立即返回错误 errno=EAGAIN// -- 如果未指定此标志, 则信号量的semzcnt的值增加1, 这时进程被投入睡眠直到下列三个条件之一发生// -- 1 信号量的值samval变为0, 此时系统将该信号量的semzcnt减1// -- 2 被操作的信号量所在的信号量集被进程移除, 此时semop调用失败返回, errno=EIDRM// -- 3 调用被系统中断, 此时semop调用失败返回, errno=EINTR, 同时将该信号量的semzcnt减1 semget成功时返回一个与之关联的内核结构体semid_ds 12345678910111213141516struct semid_ds&#123; struct ipc_perm sem_perm; unsigned long int sem_nsems; // 被设置为num_sems time_t sem_otime; // 被设置为0 time_t sem_ctime; // 被设置为当前的系统时间&#125;// 用来描述权限struct ipc_perm&#123; uid_t uid; // 所有者的有效用户ID, 被semget设置为调用进程的有效用户ID gid_t gid; // 所有者的有效组ID, 被semget设置为调用进程的有效用户ID uid_t cuid; // 创建者的有效用户ID, 被semget设置为调用进程的有效用户ID gid_t cgid; // 创建者的有效组ID, 被semget设置为调用进程的有效用户ID mode_t mode;// 访问权限, 背着只为sem_flags参数的最低9位.&#125; 共享内存-进程间通信最高效的IPC(进程间通信)机制需要自己同步进程对其的访问, 否则会产生竞态条件 1234567891011// key// 与semget相同 标识一段全局唯一的共享内存// size 内存区域大小 单位字节// shmflg// IPC_CREAT 存不存在都创建新的共享内存// IPC_CREAT | IPC_EXCL 不存在则创建 存在则报错// SHM_HUGETLB 系统将使用&quot;大页面&quot;来为共享内存分配空间// SHM_NORESERVE 不为共享内存保留swap空间, 如果物理内存不足// -在执行写操作的时候将会触发`SIGSEGV`信号// -成功返回唯一标识, 失败返回-1 errnoint shmget(key_t key, size_t size, int shmflg) 123456789101112131415161718// shm_id // shmget返回的唯一标识// shm_addr // 关联到进程的哪块地址空间, 其效果还受到shmflg的可选标识SHM_RND的影响// 如果shm_addr = NULL, 则关联地址由操作系统决定, 代码可移植性强// 如果 shm_addr 非空,且没有`SHM_RND`标志 则关联到指定的地址处// 如果 shm_addr 非空, 但是设置了标志 *这里还没用到, 暂时不写*// shmflg// SHM_RDONLY 设置后内存内容变成只读, 不设置则为读写模式// SHM_REMAP 如果地址shmaddr已经关联到一段内存上则重新关联// SHM_EXEC 有执行权限// 成功返回关联到的地址, 失败返回 (void*)-1 errnovoid* shmat(int shm_id, const void* shm_addr, int shmflg)// 将共享内存关联到进程的地址空间 调用成功之后, 修改shmid_ds的部分内容// -shm_nattach +1// -更新 shm_lpid// -shm_atime设置为当前时间 123456// 将共享内存从进程地址空间中分离// 成功后// -shm_nattach -1// -更新 shm_lpid和shm_dtime设置为当前时间// 成功返回0 失败返回-1 errnoint shmdt(const void* shm_addr) 1int shm_ctl(int shm_id, int command, struct shmid_ds* buf) shmget 同时会创建对应的shmid_ds结构体 1234567891011struct shmid_ds&#123; struct ipc_perm shm_per; // 权限相关 size_t shm_segsz; // 共享内存大小 单位字节 size __time_t shm_atime; // 对这段内存最后一次调用semat的时间 0 __time_t shm_dtime; // 对这段内存最后一次调用semdt的时间 0 __time_t shm_ctime; // 对这段内存最后一次调用semctl的时间 当前时间 __pid_t shm_cpid; // 创建者PID __pid_t lpid; // 最后一次执行shmat或shmdt的进程PID shmatt_t shm_nattach // 关联到此共享内存空间的进程数量&#125; 共享内存的POSIX方法 12345678910111213int shmfd = shm_open(&quot;/shm_name&quot;, O_CREAT | O_RDWR, 0666);ERROR_IF(shmfd == -1, &quot;shm open&quot;);int ret = ftruncate(shmfd, BUFFER_SIZE);ERROR_IF(ret == -1, &quot;ftruncate&quot;);share_mem = (char*)mmap(nullptr, BUFFER_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, shmfd, 0);ERROR_IF(share_mem == MAP_FAILED, &quot;share_mem&quot;);close(shmfd);// 取消关联munmap((void*)share_mem, BUFFER_SIZE); 进程通信-管道管道可以在父,子进程间传递数据, 利用的是fork调用后两个文件描述符(fd[0]和fd[1])都保持打开. 一对这样的文件描述符只能保证父,子进程间一个方向的数据传输, 父进程和子进程必须有一个关闭fd[0], 另一个关闭fd[1]. 可以用两个管道来实现双向传输数据, 也可以用socketpair来创建管道 消息队列消息队列是两个进程之间传递二进制块数据的一种简单有效的方式.每个数据块都有自己的类型, 接收方可以根据类型有选择的接收数据 1234#include &lt;sys/msg.h&gt;// 与semget 相同, 成功返回标识符// msgflg的设置和作用域setget相同int msgget(key_t key, int msgflg); 12345678910111213// msg_ptr参数指向一个准备发送的消息, 消息必须按如下定义// msg_sz 指的是mtext的长度!!!// msgflg通常仅支持IPC_NOWAIT 以非阻塞形式发送数据int msgsnd(int msqid, const void *msg_ptr, size_t msg_sz, int msgflg);默认如果消息队列已满, 则会阻塞. 如果设置了 IPC_NOTWAIT就立即返回 设置errno=EAGIN系统自带这个结构体 不过mtext长度是1...struct msgbuf&#123; long mtype; /* 消息类型 正整数*/ char mtext[512]; /* 消息数据*/&#125; 123456789// msgtype = 0 读取消息队列第一个消息// msgtype &gt; 0 读取消息队列第一个类型是msgtype的消息 除非标志了MSG_EXCEPT// msgtype &lt; 0 读取第一个 类型值 &lt; abs(msgtype)的消息// IPC_NOWAIT 如果消息队列没有消息, 则msgrcv立即返回并设置errno=ENOMSG// MSG_EXCEPT 如果msgtype大于0, 则接收第一个非 msgtype 的数据// MSG_NOERROR 消息部分长度超过msg_sz 则将它截断int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);处于阻塞状态 当消息队列被移除(errno=EIDRM)或者程序接受到信号(errno=EINTR) 都会中断阻塞状态 123456789int msgctl(int msqid, int command, struct msqid_ds *buf);IPC_STAT 复制消息队列关联的数据结构IPC_SET 将buf中的部分成员更新到目标的内核数据IPC_RMID 立即移除消息队列, 唤醒所有等待读消息和写消息的进程IPC_INFO 获取系统消息队列资源配置信息MSG_INFO 返回已经分配的消息队列所占用资源信息MSG_STAT msgqid不再是标识符, 而是内核消息队列的数组索引 在进程间传递文件描述符IPC命令-查看进程间通信的全局唯一key","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"多进程","slug":"多进程","permalink":"http://icecorn.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"}]},{"title":"Linux服务器中的一些理解","slug":"Linux高性能服务器/Linux服务器中的一些理解","date":"2022-05-12T09:25:10.000Z","updated":"2022-06-29T16:00:39.223Z","comments":true,"path":"2022/05/12/Linux高性能服务器/Linux服务器中的一些理解/","link":"","permalink":"http://icecorn.github.io/2022/05/12/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3/","excerpt":"","text":"Linux服务器的一些理解文件描述符https://blog.csdn.net/yushuaigee/article/details/107883964 proactor和reactor区别就在于谁去处理用户socket到用户缓冲区的数据复制，因为这是一个很费的操作 reator就是主线程告诉子线程去处理，子线程完成数据复制的操作，因为这个操作很费事件，所以就相当于这个线程被阻塞掉了，假如系统有8个线程，而且都被阻塞掉了，那么epoll事件表里的其他事件就不能第一时间去处理，所以就表现为服务器并发性不高，比如8线程满了，用户再想关掉连接，就没反应 proactor模式就是主线程告诉内核线程去做数据复制的操作，这期间8个子线程都可以各自干别的事，当内核线程复制完了之后，会发送一个信号，唤醒一个休眠的子线程并且告诉它数据在的内存地址，然后子线程就去处理，只需要处理逻辑部分即可 模拟proactor模式是说用主线程充当内核线程，就是说主线程来处理数据复制的操作，然后再告诉子线程去做逻辑操作 问题： 1.复制数据这个费时间的事肯定要有人去办，内核线程去办是怎么处理的呢？ 猜想：应为数据复制的最终速度还是取决于内存和cathe之类的硬件读写速度，各种并发处理只不过是把整个http请求的粒度变小，使得服务器能够再很快的时间内承载更多的连接。 2.epoll_wait循环是多久一次呢？ 应该是很快的，应为不论是listen和in out事件，主线程实际上只是创建连接，添加请求对列这点事，没有内存数据复制操作，所以会快，当然模拟proactor模式例外，因为他用主线程模拟内核线程 3.one loop pre thread 我觉得目的应该是更进一步解放主线程，主线程只处理listenfd建立连接的操作，每个子线程维护一个epoll循环处理每个用户连接的读写操作。好处就是服务器可以并发处理更多的连接请求，猜测这里可能和TCP协议有关系？假如短时间大量请求发生，如果没有及时处理请求，那么TCP协议长时间没收到反馈会断掉之类的？ 并发模式半同步半反应堆这里的同步和异步指的是一个进程是否一路执行到底，没有中断 半同步指的是每个线程都直接执行到底 半反应堆指的是主线程维护一个epoll事件表，循环处理 要注意的是不要和上边的两种事件处理模式弄混，这里半同步半反应堆同样可以使用proactor事件处理模式 半同步半异步这里不是存粹的半同步半异步，感觉和one thread one loop是一样的，就是每个子线程都维护一个epoll事件表，用它来监听多个http连接的读写事件，这就实现了同一时间一个子线程可以处理多个http连接的读写。另外一个好处是可以减少线程加锁的开销，因为如果只有主线程一个epoll的话，就是只有一个事件队列，这样不管是主线程加入新的socket还是子线程处理读写socket都要对这个事件队列进行加锁，而one thread one loop就可以避免这种情况","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Linux高性能服务器|第九章-IO复用","slug":"Linux高性能服务器/Linux高性能服务器第九章-IO复用","date":"2022-05-09T09:25:10.000Z","updated":"2022-06-29T15:36:48.246Z","comments":true,"path":"2022/05/09/Linux高性能服务器/Linux高性能服务器第九章-IO复用/","link":"","permalink":"http://icecorn.github.io/2022/05/09/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%B9%9D%E7%AB%A0-IO%E5%A4%8D%E7%94%A8/","excerpt":"","text":"第九章 I/O复用I/O复用使得程序能同时监听多个文件描述符. 客户端程序需要同时处理多个socket 非阻塞connect技术 客户端程序同时处理用户输入和网络连接 聊天室程序 TCP服务器要同时处理监听socket和连接socket 同时处理TCP和UDP请求 - 回射服务器 同时监听多个端口, 或者处理多种服务 - xinetd服务器 常用手段select, poll, epoll select123456789101112131415161718#include &lt;sys/select.h&gt;// nfds - 被监听的文件描述符总数// 后面三个分别指向 可读, 可写, 异常等事件对应的文件描述符集合// timeval select超时时间 如果传递0 则为非阻塞, 设置为NULL则为阻塞// 成功返回就绪(可读, 可写, 异常)文件描述符的总数, 没有则返回0 失败返回-1int select (int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);//操作fd_set的宏FD_ZERO(fd_set* fdset);FD_SET(int fd, fd_set* fdset);FD_CLR(int fd, fd_set* fdset);FD_ISSET(int fd, fd_set* fdset);// 设置 timeval 超时时间struct timeval&#123; long tv_sec; // 秒 long tv_usec; // 微秒&#125; select 文件描述符就绪条件 socket内核接收缓存区中的字节数大于或等于 其低水位标记 socket通信的对方关闭连接, 对socket的读操作返回0 监听socket上有新的连接请求 socket上有未处理的错误, 可以使用getsockopt来读取和清除错误 socket内核的发送缓冲区的可用字节数大于或等于 其低水位标记 socket的写操作被关闭, 对被关闭的socket执行写操作将会触发一个SIGPIPE信号 socket使用非阻塞connect 连接成功或失败后 pollpoll 123456789101112#include &lt;poll.h&gt;// fds 结构体类型数组 指定我们感兴趣的文件描述符上发生的可读可写和异常事件\\// nfds 遍历结合大小 左闭右开// timeout 单位为毫秒 -1 为阻塞 0 为立即返回int poll(struct pollfd* fds, nfds_t nfds, int timeout);struct pollfd&#123; int fd; short events; //注册的事件, 告知poll监听fd上的哪些事件 short revents; // 实际发生的事件&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#define exit_if(r, ...) \\&#123; \\ if (r) \\ &#123; \\ printf(__VA_ARGS__); \\ printf(&quot;errno no: %d, error msg is %s&quot;, errno, strerror(errno)); \\ exit(1); \\ &#125; \\&#125; \\struct client_info&#123; char *ip_; int port_;&#125;;int main(int argc, char* argv[])&#123; int port = 8001; char ip[] = &quot;127.0.0.1&quot;; struct sockaddr_in address; address.sin_port = htons(port); address.sin_family = AF_INET; address.sin_addr.s_addr = htons(INADDR_ANY); int listenfd = socket(PF_INET, SOCK_STREAM, 0); exit_if(listenfd &lt; 0, &quot;socket error\\n&quot;); int ret = bind(listenfd, (struct sockaddr*)&amp;address, sizeof(address)); exit_if(ret == -1, &quot;bind error\\n&quot;); ret = listen(listenfd, 5); exit_if(ret == -1, &quot;listen error\\n&quot;); constexpr int MAX_CLIENTS = 1024; struct pollfd polls[MAX_CLIENTS] = &#123;&#125;; struct client_info clientsinfo[MAX_CLIENTS] = &#123;&#125;; polls[3].fd = listenfd; polls[3].events = POLLIN | POLLRDHUP; while (true) &#123; ret = poll(polls, MAX_CLIENTS + 1, -1); exit_if(ret == -1, &quot;poll error\\n&quot;); for (int i = 3; i &lt;= MAX_CLIENTS; ++i) &#123; int fd = polls[i].fd; if (polls[i].revents &amp; POLLRDHUP) &#123; polls[i].events = 0; printf(&quot;close fd-%d from %s:%d\\n&quot;, fd, clientsinfo[fd].ip_, clientsinfo[fd].port_); &#125; if (polls[i].revents &amp; POLLIN) &#123; if (fd == listenfd) &#123; struct sockaddr_in client_address; socklen_t client_addresslen = sizeof(client_address); int clientfd = accept(listenfd, (struct sockaddr*)&amp;client_address, &amp;client_addresslen); struct client_info *clientinfo = &amp;clientsinfo[clientfd]; clientinfo-&gt;ip_ = inet_ntoa(client_address.sin_addr); clientinfo-&gt;port_ = ntohs(client_address.sin_port); exit_if(clientfd &lt; 0, &quot;accpet error, from %s:%d\\n&quot;, clientinfo-&gt;ip_, clientinfo-&gt;port_); printf(&quot;accept from %s:%d\\n&quot;, clientinfo-&gt;ip_, clientinfo-&gt;port_); polls[clientfd].fd = clientfd; polls[clientfd].events = POLLIN | POLLRDHUP; &#125; else &#123; char buffer[1024]; memset(buffer, &#x27;\\0&#x27;, sizeof(buffer)); ret = read(fd, buffer, 1024); if(ret == 0) &#123; close(fd); &#125; else &#123; printf(&quot;recv from %s:%d:\\n%s\\n&quot;, clientsinfo[fd].ip_, clientsinfo[fd].port_, buffer); &#125; &#125; &#125; &#125; &#125;&#125; epollepoll epoll是Linux特有的I/O复用函数, 实现上与select,poll有很大的差异 epoll使用一组函数完成任务 epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中 epoll无需每次调用都传入文件描述符集或事件集. 有特定的文件描述符创建函数, 来标识这个事件表epoll_create()epoll_ctl() 用来操作这个内核事件表epoll_wait() 为主要函数 成功返回就绪的文件描述符个数 失败返回-1如果epoll_wait()函数检测到事件,就将所有就绪的事件从内核事件表(由第一个参数, epoll_create返回的结果) 中复制到第二个参数event指向的数组中, 这个数组只用于输出epoll_wait检测到的就绪事件. event不同于select和poll的数组参数 既用于传入用户注册的事件, 又用于输出内核检测到的就绪事件, 提高了效率 123456789101112131415// 索引poll返回的就绪文件描述符int ret = poll(fds, MAX_EVENT_NUMBER - 1);// 遍历for(int i = 0; i &lt; MAX_EVENT_NUMBER; ++i) &#123; if(fds[i].revents &amp; POLLIN) &#123; int sockfd = fds[i].fd; &#125;&#125;// 索引epoll返回的就绪文件描述符int ret = epoll_wait(epoll_fd, events, MAX_EVENT_NUMBER, -1);for(int i = 0; i &lt; ret; i++) &#123; int sockfd = events[i].data.fd; // sockfd 一定就绪 ?????&#125; LT和ET模式LT(电平触发, 默认的工作模式)LT模式下的epoll相当于一个效率较高的pollepoll_wait将会一只通知一个事件知道这个事件被处理 ET(边沿触发, epoll的高效工作模式)模式当向epoll内核事件表中注册一个文件描述符上的EPOLLET事件的时候, epoll将用ET模式来操作这个文件描述符epoll_wait只会通知一次, 不论这个事件有没有完成 ET模式 1234567-&gt; 123456789-123456789-123456789event trigger onceget 9bytes of content: 123456789get 9bytes of content: -12345678get 9bytes of content: 9-1234567get 4bytes of content: 89read later LT模式 123456789-&gt; 123456789-123456789-123456789event trigger onceget 9bytes of contents: 123456789event trigger onceget 9bytes of contents: -12345678event trigger onceget 9bytes of contents: 9-1234567event trigger onceget 4bytes of contents: 89 ET模式有任务到来就必须做完, 因为后续将不会继续通知这个事件, 所以ET是epoll的高效工作模式LT模式只要事件没被处理就会一直通知 12345678910111213141516171819202122232425262728293031#include &lt;epoll.h&gt;// size 参数只是给内核一个提示, 事件表需要多大// 函数返回其他所有epoll系统调用的第一个参数, 来指定要访问的内核事件表int epoll_create(int size);// epfd 为 epoll_create的返回值// op为操作类型// - EPOLL_CTL_ADD 向事件表中注册fd上的事件// - EPOLL_CTL_MOD 修改fd上的注册事件// - EPOLL_CTL_DEL 删除fd上的注册事件// fd 为要操作的文件描述符int epoll_ctl(int epfd, int op, int fd, struct epoll_event* event);struct epoll_event&#123; _uint32_t events; // epoll事件 epoll_data_t data; // 用户数据 是一个联合体&#125;typedef union epoll_data&#123; void* ptr; // ptr fd 不能同时使用 int fd; uint32_t u32; uint64_t u64;&#125;epoll_data_t// maxevents监听事件数 必须大于0// timeout 为-1 表示阻塞// 成功返回就绪的文件描述符个数 失败返回-1int epoll_wait(int epfd, struct epoll_event* events, int maxevents, int timeout); 三种IO复用的比较select以及poll和epoll相同 都能同时监听多个文件描述符, 都将等待timeout参数指定的超时时间, 直到一个或多个文件描述符上有事件发生. 返回值为就绪的文件描述符数量, 返回0则表示没有事件发生 I/O 复用的高级应用, 非阻塞connectconnect出错的时候会返回一个errno值 EINPROGRESS - 表示对非阻塞socket调用connect, 连接又没有立即建立的时候, 这时可以调用select和poll函数来监听这个连接失败的socket上的可写事件. 当函数返回的时候, 可以用getsockopt来读取错误码, 并清楚该socket上的错误. 错误码为0表示成功","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"socket编程","slug":"socket编程","permalink":"http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"}]},{"title":"Linux高性能服务器|第八章-Linux高性能服务器框架","slug":"Linux高性能服务器/Linux高性能服务器第八章-Linux高性能服务器框架","date":"2022-05-05T09:25:10.000Z","updated":"2022-06-29T15:34:50.041Z","comments":true,"path":"2022/05/05/Linux高性能服务器/Linux高性能服务器第八章-Linux高性能服务器框架/","link":"","permalink":"http://icecorn.github.io/2022/05/05/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E5%85%AB%E7%AB%A0-Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/","excerpt":"","text":"第八章高性能服务器程序框架服务器模型-CS模型 优点 实现起来简单缺点 服务器是通信的中心, 访问过大的时候会导致响应过慢 模式图 编写的demo 没有用到fork函数. 后续待完善 服务器框架 IO模型 这个模型大概能够理解, 自己也算是学了半年的Javaweb. socket在创建的时候默认是阻塞的, 不过可以通过传SOCK_NONBLOCK参解决非阻塞调用都会立即返回 但可能事件没有发生(recv没有接收到信息), 没有发生和出错都会返回-1 所以需要通过errno来区分这些错误.事件未发生accept, send,recv errno被设置为 EAGAIN(再来一次)或EWOULDBLOCK(期望阻塞)connect 被设置为 EINPROGRESS(正在处理中) 需要在事件已经发生的情况下 去调用非阻塞IO, 才能提高性能 常用IO复用函数 select poll epoll_wait 将在第九章后面说明信号将在第十章说明 两种高效的事件处理模式和并发模式 程序分为计算密集型(CPU使用很多, IO资源使用很少)和IO密集型(反过来).前者使用并发编程反而会降低效率, 后者则会提升效率并发编程有多进程和多线程两种方式 并发模式 - IO单元和多个逻辑单元之间协调完成任务的方法.服务器主要有两种并发模式 半同步/半异步模式 领导者/追随者模式 半同步/半异步模式在IO模型中, 异步和同步的区分是内核向应用程序通知的是何种IO事件(就绪事件还是完成事件), 以及由谁来完成IO读写(应用程序还是内核) 而在这里(并发模式)同步指的是完全按照代码序列的顺序执行 - 按照同步方式运行的线程称为同步线程异步需要系统事件(中断, 信号)来驱动 - 按照异步方式运行的线程称为异步线程 服务器(需要较好的实时性且能同时处理多个客户请求) - 一般使用同步线程和异步线程来实现,即为半同步/半异步模式同步线程 - 处理客户逻辑, 处理请求队列中的对象异步线程 - 处理IO事件, 接收到客户请求后将其封装成请求对象并插入请求队列 半同步/半异步模式 存在变体 半同步/半反应堆模式 异步线程 - 主线程 - 负责监听所有socket上的事件 领导者/追随者模式略 高效编程方法 - 有限状态机 123456789101112131415161718192021222324252627282930313233// 状态独立的有限状态机STATE_MACHINE(Package _pack) &#123; PackageType _type = _pack.GetType(); switch(_type) &#123; case type_A: xxxx; break; case type_B: xxxx; break; &#125;&#125;// 带状态转移的有限状态机STATE_MACHINE() &#123; State cur_State = type_A; while(cur_State != type_C) &#123; Package _pack = getNewPackage(); switch(cur_State) &#123; case type_A: process_package_state_A(_pack); cur_State = type_B; break; case type_B: xxxx; cur_State = type_C; break; &#125; &#125;&#125; 提高服务器性能的其他建议 池 数据复制 上下文切换和锁池 - 用空间换取时间进程池和线程池 数据复制 - 高性能的服务器应该尽量避免不必要的复制 上下文切换和锁减少锁的作用区域. 不应该创建太多的工作进程, 而是使用专门的业务逻辑线程.","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"socket编程","slug":"socket编程","permalink":"http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"}]},{"title":"Linux高性能服务器|第6-7章-Linux高级IO函数&Linux服务器程序规范","slug":"Linux高性能服务器/Linux高性能服务器第6-7章-Linux高级IO函数&Linux服务器程序规范","date":"2022-05-03T09:25:10.000Z","updated":"2022-06-29T15:30:17.308Z","comments":true,"path":"2022/05/03/Linux高性能服务器/Linux高性能服务器第6-7章-Linux高级IO函数&Linux服务器程序规范/","link":"","permalink":"http://icecorn.github.io/2022/05/03/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC6-7%E7%AB%A0-Linux%E9%AB%98%E7%BA%A7IO%E5%87%BD%E6%95%B0&Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83/","excerpt":"","text":"第六章高级IO函数Linux提供的高级IO函数, 自然是特定条件下能力更强, 不然要他干啥, 特定条件自然限制了他的使用频率文件描述符文件描述符在是一个非负整数。是一个索引值,指向内核为每一个进程所维护的该进程打开文件的记录表。STDOUT_FILENO(值为1)- 值为1的文件描述符为标准输出, 关闭STDOUT_FILENO后用dup即可返回最小可用值(目前为, 1) 这样输出就重定向到了调用dup的参数指向的文件 创建文件描述符 - pipe dup dup2 splice selectpipe函数这个函数可用于创建一个管道, 实现进程间的通信. 123456// 函数定义// 参数文件描述符数组 fd[0] 读出 fd[1]写入 单向管道// 成功返回0, 并将一对打开的文件描述符填入其参数指向的数组// 失败返回-1 errno#include &lt;unistd.h&gt;int pipe(int fd[2]); 12345// 双向管道// 第一个参数为 协议PF_UNIX(书上是AF_UNIX)感觉这里指明协议使用PF更好一些#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;int socketpair(int domain, int type, int protocol, int fd[2]); 学习了后面的内容了解到了进程间通信, 回来补上一个例子 12345678910111213141516171819int main()&#123; int fds[2]; socketpair(PF_UNIX, SOCK_STREAM, 0, fds); int pid = fork(); if (pid == 0) &#123; close(fds[0]); char a[] = &quot;123&quot;; send(fds[1], a, strlen(a), 0); &#125; else if (pid &gt; 0) &#123; close(fds[1]); char b[20] &#123;&#125;; recv(fds[0], b, 20, 0); printf(&quot;%s&quot;, b); &#125;&#125; dup和dup2函数复制一个现有的文件描述符 123456#include &lt;unistd.h&gt;// 返回的文件描述符总是取系统当前可用的最小整数值int dup(int oldfd);// 可以用newfd来制定新的文件描述符, 如果newfd已经被打开则先关闭// 如果newfd==oldfd 则不关闭newfd直接返回int dup2(int oldfd, int newfd); dup函数创建一个新的文件描述符, 新的文件描述符和原有的file_descriptor共同指向相同的目标.回来补上例子, 这个例子由于关掉了STDOUT_FILENOdup最小的即为STDOUT_FILENO所以标准输出都到了这个文件之中 12345678int main()&#123; int filefd = open(&quot;/home/lsmg/1.txt&quot;, O_WRONLY); close(STDOUT_FILENO); dup(filefd); printf(&quot;123\\n&quot;); exit(0);&#125; 读写数据 - readv writev mmap munmapreadv/writev 12345678910#include &lt;sys/uio.h&gt;// count 为 vector的长度, 即为有多少块内存// 成功时返回写入\\读取的长度 失败返回-1ssize_t readv(int fd, const struct iovec* vector, int count);ssize_t writev(int fd, const struct iovec* vector, int count);struct iovec &#123; void* iov_base /* 内存起始地址*/ size_t iov_len /* 这块内存长度*/&#125; 回来补上一个使用例子, 这个例子将一个int的内存表示写入到了文件之中使用hexdump查看这个文件0000000 86a0 0001可以看到186a0即为100000 12345678910// 2020年1月7日16:52:11int main()&#123; int file = open(&quot;/home/lsmg/1.txt&quot;, O_WRONLY); int temp = 100000; iovec temp_iovec&#123;&#125;; temp_iovec.iov_base = &amp;temp; temp_iovec.iov_len = sizeof(temp); writev(file, &amp;temp_iovec, 1);&#125; sendfile函数 12345678#include &lt;sys/sendfile.h&gt;// offset为指定输入流从哪里开始读, 如果为NULL 则从开头读取ssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);O_RDONLY只读模式O_WRONLY只写模式O_RDWR读写模式int open(file_name, flag); stat结构体, 可用fstat生成, 简直就是文件的身份证 1234567891011121314151617#include &lt;sys/stat.h&gt;struct stat&#123; dev_t st_dev; /* ID of device containing file -文件所在设备的ID*/ ino_t st_ino; /* inode number -inode节点号*/ mode_t st_mode; /* protection -保护模式?*/ nlink_t st_nlink; /* number of hard links -链向此文件的连接数(硬连接)*/ uid_t st_uid; /* user ID of owner -user id*/ gid_t st_gid; /* group ID of owner - group id*/ dev_t st_rdev; /* device ID (if special file) -设备号，针对设备文件*/ off_t st_size; /* total size, in bytes -文件大小，字节为单位*/ blksize_t st_blksize; /* blocksize for filesystem I/O -系统块的大小*/ blkcnt_t st_blocks; /* number of blocks allocated -文件所占块数*/ time_t st_atime; /* time of last access -最近存取时间*/ time_t st_mtime; /* time of last modification -最近修改时间*/ time_t st_ctime; /* time of last status change - */&#125;; 身份证生成函数 123456789101112131415// 第一个参数需要调用open生成文件描述符// 下面其他两个为文件全路径int fstat(int filedes, struct stat *buf);// 当路径指向为符号链接的时候, lstat为符号链接的信息. stat为符号链接指向文件信息int stat(const char *path, struct stat *buf);int lstat(const char *path, struct stat *buf);/** ln -s source dist 建立软连接, 类似快捷方式, 也叫符号链接* ln source dist 建立硬链接, 同一个文件使用多个不同的别名, 指向同一个文件数据块, 只要硬链接不被完全* 删除就可以正常访问* 文件数据块 - 文件的真正数据是一个文件数据块, 打开的`文件`指向这个数据块, 就是说* `文件`本身就类似快捷方式, 指向文件存在的区域.*/ mmap和munmap函数 mmap创建一块进程通讯共享的内存(可以将文件映射入其中), munmap释放这块内存 123456789101112#include &lt;sys/mman.h&gt;// start 内存起始位置, 如果为NULL则系统分配一个地址 length为长度// port参数 PROT_READ(可读) PROT_WRITE(可写) PROT_EXEC(可执行), PROT_NONE(不可访问)// flag参数 内存被修改后的行为// - MAP_SHARED 进程间共享内存, 对内存的修改反映到映射文件中// - MAP_PRIVATE 为调用进程私有, 对该内存段的修改不会反映到文件中// - MAP_ANONUMOUS 不是从文件映射而来, 内容被初始化为0, 最后两个参数被忽略// 成功返回区域指针, 失败返回 -1void* mmap(void* start, size_t length, int port, int flags, int fd, off_t offset);// 成功返回0 失败返回-1int munmap(void* start, size_t length); splice函数用于在两个文件名描述符之间移动数据, 0拷贝操作 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;fcntl.h&gt;// fd_in 为文件描述符, 如果为管道文件描述符则 off_in必须为NULL, 否则为读取开始偏移位置// len为指定移动的数据长度, flags参数控制数据如何移动.// - SPLICE_F_NONBLOCK 非阻塞splice操作, 但会受文件描述符自身的阻塞// - SPLICE_F_MORE 给内核一个提示, 后续的splice调用将读取更多的数据???????ssize_t splice(int fd_in, loff_t* off_in, int fd_out, loff_t* off_out, size_t len, unsigned int flags);// 使用splice函数 实现echo服务器int main(int argc, char* argv[])&#123; if (argc &lt;= 2) &#123; printf(&quot;the parmerters is wrong\\n&quot;); exit(errno); &#125; char *ip = argv[1]; int port = atoi(argv[2]); printf(&quot;the port is %d the ip is %s\\n&quot;, port, ip); int sockfd = socket(PF_INET, SOCK_STREAM, 0); assert(sockfd &gt;= 0); struct sockaddr_in address&#123;&#125;; address.sin_family = AF_INET; address.sin_port = htons(port); inet_pton(AF_INET, ip, &amp;address.sin_addr); int ret = bind(sockfd, (sockaddr*)&amp;address, sizeof(address)); assert(ret != -1); ret = listen(sockfd, 5); int clientfd&#123;&#125;; sockaddr_in client_address&#123;&#125;; socklen_t client_addrlen = sizeof(client_address); clientfd = accept(sockfd, (sockaddr*)&amp;client_address, &amp;client_addrlen); if (clientfd &lt; 0) &#123; printf(&quot;accept error\\n&quot;); &#125; else &#123; printf(&quot;a new connection from %s:%d success\\n&quot;, inet_ntoa(client_address.sin_addr), ntohs(client_address.sin_port)); int fds[2]; pipe(fds); ret = splice(clientfd, nullptr, fds[1], nullptr, 32768, SPLICE_F_MORE); assert(ret != -1); ret = splice(fds[0], nullptr, clientfd, nullptr, 32768, SPLICE_F_MORE); assert(ret != -1); close(clientfd); &#125; close(sockfd); exit(0);&#125; select 函数select函数在第二个参数列表 可读的时候返回或者是等到了规定的时间返回 返回之后 第二个参数指向fdset的集合 被修改为可读的fd列表这就需要每次返回后都更新 fdset集合 返回后 此函数的返回值为可读的fd数量, 遍历fdset集合 同时使用FD_ISSET判断fdset[i] 是否在其中然后判断此fd是否为listenfd 如果是则接受新的连接 如果不是说明是已经接受的其他fd 判断是有数据可读还是此连接断开 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;fcntl.h&gt; // maxfdp 最大数 FD_SETSIZE// struct fd_set 一个集合,可以存储多个文件描述符// - FD_ZERO(&amp;fd_set) 清空 -FD_SET(fd, &amp;fd_set) 放入fd FD_CLR(fd, &amp;fd_set)从其中清除fd// - FD_ISSET(fd, &amp;fd_set) 判断是否在其中// readfds 需要监视的文件描述符读变化, 其中的文件描述符可读的时候返回// writefds 需要监视的文件描述符写变化, 其中的文件描述符可写的时候返回// errorfds 错误// timeout 传入NULL为阻塞, 设置为0秒0微秒则变为非阻塞函数// 返回值 负值为错误 等待超时说明文件无变化返回0 有变化返回正值int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval*timeout); #define exit_if(r, ...) \\&#123; \\ if (r) \\ &#123; \\ printf(__VA_ARGS__); \\ printf(&quot;errno no: %d, error msg is %s&quot;, errno, strerror(errno)); \\ exit(1); \\ &#125; \\&#125; \\int main(int argc, char* argv[])&#123; int keyboard_fd = open(&quot;/dev/tty&quot;, O_RDONLY | O_NONBLOCK); exit_if(keyboard_fd &lt; 0, &quot;open keyboard fd error\\n&quot;); fd_set readfd; char recv_buffer = 0; while (true) &#123; FD_ZERO(&amp;readfd); FD_SET(0, &amp;readfd); timeval timeout &#123;5, 0&#125;; int ret = select(keyboard_fd + 1, &amp;readfd, nullptr, nullptr, &amp;timeout); exit_if(ret == -1, &quot;select error\\n&quot;); if (ret &gt; 0) &#123; if (FD_ISSET(keyboard_fd, &amp;readfd)) &#123; recv_buffer = 0; read(keyboard_fd, &amp;recv_buffer, 1); if (&#x27;\\n&#x27; == recv_buffer) &#123; continue; &#125; if (&#x27;q&#x27; == recv_buffer) &#123; break; &#125; printf(&quot;the input is %c\\n&quot;, recv_buffer); &#125; &#125; if (ret == 0) &#123; printf(&quot;timeout\\n&quot;); &#125; &#125;&#125; 第七章Linux服务器程序规范 Linux程序服务器 一般以后台进程形式运行. 后台进程又称为守护进程(daemon). 他没有控制终端, 因而不会意外的接收到用户输入. 守护进程的父进程通常都是init进程(PID为1的进程) Linux服务器程序有一套日志系统, 他至少能输出日志到文件. 日志这东西太重要了,排错对比全靠它. Linux服务器程序一般以某个专门的非root身份运行. 比如mysqld有自己的账户mysql. Linux服务器程序一般都有自己的配置文件, 而不是把所有配置都写死在代码里面, 方便后续的更改. Linux服务器程序通常在启动的时候生成一个PID文件并存入/var/run 目录中, 以记录改后台进程的PID. Linux服务器程序通常需要考虑系统资源和限制, 预测自己的承受能力 日志1sudo service rsyslog restart // 启动守护进程 123456789101112131415161718192021222324252627282930#include &lt;syslog.h&gt;// priority参数是所谓的设施值(记录日志信息来源, 默认为LOG_USER)与日志级别的按位或// - 0 LOG_EMERG /* 系统不可用*/// - 1 LOG_ALERT /* 报警需要立即采取行动*/// - 2 LOG_CRIT /* 非常严重的情况*/// - 3 LOG_ERR /* 错误*/// - 4 LOG_WARNING /* 警告*/// - 5 LOG_NOTICE /* 通知*/// - 6 LOG_INFO /* 信息*/// -7 LOG_DEBUG /* 调试*/void syslog(int priority, const char* message, .....);// ident 位于日志的时间后 通常为名字// logopt 对后续 syslog调用的行为进行配置// - 0x01 LOG_PID /* 在日志信息中包含程序PID*/// - 0x02 LOG_CONS /* 如果信息不能记录到日志文件, 则打印到终端*/// - 0x04 LOG_ODELAY /* 延迟打开日志功能直到第一次调用syslog*/// - 0x08 LOG_NDELAY /* 不延迟打开日志功能*/// facility参数可以修改syslog函数中的默认设施值void openlog(const char* ident, int logopt, int facility);// maskpri 一共八位 0000-0000// 如果将最后一个0置为1 表示 记录0级别的日志// 如果将最后两个0都置为1 表示记录0和1级别的日志// 可以通过LOG_MASK() 宏设定 比如LOG_MASK(LOG_CRIT) 表示将倒数第三个0置为1, 表示只记录LOG_CRIT// 如果直接设置setlogmask(3); 3的二进制最后两个数均为1 则记录 0和1级别的日志int setlogmask(int maskpri);// 关闭日志功能void closelog(); 用户信息, 切换用户UID - 真实用户IDEUID - 有效用户ID - 方便资源访问GID - 真实组IDEGID - 有效组ID 1234567891011#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;uid_t getuid();uid_t geteuid();gid_t getgid();gid_t getegid();int setuid(uid_t uid);int seteuid(uid_t euid);int setgid(gid_t gid);int setegid(gid_t gid); 可以通过 setuid和setgid切换用户 root用户uid和gid均为0 进程间关系PGID - 进程组ID(Linux下每个进程隶属于一个进程组) #include &lt;unistd.h&gt;pid_t getpgid(pid_t pid); 成功时返回pid所属的pgid 失败返回-1int setpgid(pid_t pid, pid_t pgid); 会话一些有关联的进程组将形成一个会话","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"socket编程","slug":"socket编程","permalink":"http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"}]},{"title":"Linux高性能服务器|第五章-Linux网络编程基础API","slug":"Linux高性能服务器/Linux高性能服务器第五章-Linux网络编程基础API","date":"2022-04-30T09:25:10.000Z","updated":"2022-06-29T15:27:08.635Z","comments":true,"path":"2022/04/30/Linux高性能服务器/Linux高性能服务器第五章-Linux网络编程基础API/","link":"","permalink":"http://icecorn.github.io/2022/04/30/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AC%AC%E4%BA%94%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API/","excerpt":"","text":"第五章Linux网络编程基础APIsocket基础api位于 sys/socket.h 头文件中socket最开始的含义是 一个IP地址和端口对. 唯一的表示了TCP通信的一段网络信息api netdb.h头文件中 主机字节序和网络字节序字节序分为 大端字节序和小端字节序由于大多数PC采用小端字节序(高位存在高地址处), 所以小端字节序又称为主机字节序 为了防止不同机器字节序不同导致的错乱问题. 规定传输的时候统一为 大端字节序(网络字节序).这样主机会根据自己的情况决定 - 是否转换接收到的数据的字节序 API基础连接 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 主机序和网络字节序转换#include &lt;netinet/in.h&gt;unsigned long int htonl (unsigned long int hostlong); // host to network longunsigned short int htons (unsigned short int hostlong); // host to network shortunsigned long int htonl (unsigned long int netlong);unsigned short int htons (unsigned short int netlong);// IP地址转换函数#include &lt;arpa/inet.h&gt;// 将点分十进制字符串的IPv4地址, 转换为网络字节序整数表示的IPv4地址. 失败返回INADDR_NONEin_addr_t inet_addr( const char* strptr);// 功能相同不过转换结果存在 inp指向的结构体中. 成功返回1 反之返回0int inet_aton( const char* cp, struct in_addr* inp);// 函数返回一个静态变量地址值, 所以多次调用会导致覆盖char* inet_ntoa(struct in_addr in); // src为 点分十进制字符串的IPv4地址 或 十六进制字符串表示的IPv6地址 存入dst的内存中 af指定地址族// 可以为 AF_INET AF_INET6 成功返回1 失败返回-1int inet_pton(int af, const char * src, void* dst);// 协议名, 需要转换的ip, 存储地址, 长度(有两个常量 INET_ADDRSTRLEN, INET6_ADDRSTRLEN)const char* inet_ntop(int af, const void* src, char* dst, socklen_t cnt);// 创建 命名 监听 socket# include &lt;sys/types.h&gt;# include &lt;sys/socket.h&gt;// domain指定使用那个协议族 PF_INET PF_INET6// type指定服务类型 SOCK_STREAM (TCP协议) SOCK_DGRAM(UDP协议)// protocol设置为默认的0// 成功返回socket文件描述符(linux一切皆文件), 失败返回-1int socket(int domain, int type, int protocol);// socket为socket文件描述符// my_addr 为地址信息// addrlen为socket地址长度// 成功返回0 失败返回 -1int bind(int socket, const struct sockaddr* my_addr, socklen_t addrlen);// backlog表示队列最大的长度int listen(int socket, int backlog);// 接受连接 失败返回-1 成功时返回socketint accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen) 客户端 123456789101112131415161718192021// 发起连接#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;// 第三个参数为 地址指定的长度// 成功返回0 失败返回-1int connect(int sockfd, const struct sockaddr * serv_addr, socklen_t addrlen);// 关闭连接#include &lt;unistd.h&gt;// 参数为保存的socket// 并非立即关闭, 将socket的引用计数-1, 当fd的引用计数为0, 才能关闭(需要查阅)int close(int fd);// 立即关闭#include &lt;sys/socket.h&gt;// 第二个参数为可选值 // SHUT_RD 关闭读, socket的接收缓冲区的数据全部丢弃// SHUT_WR 关闭写 socket的发送缓冲区全部在关闭前发送出去// SHUT_RDWR 同时关闭读和写// 成功返回0 失败为-1 设置errnoint shutdown(int sockfd, int howto) 基础TCP 1234567891011#include&lt;sys/socket.h&gt;#include&lt;sys/types.h&gt;// 读取sockfd的数据// buf 指定读缓冲区的位置// len 指定读缓冲区的大小// flags 参数较多// 成功的时候返回读取到的长度, 可能小于预期长度, 需要多次读取. 读取到0 通信对方已经关闭连接, 错误返回-1ssize_t recv(int sockfd, void *buf, size_t len, int flags);// 发送ssize_t send(int sockfd, const void *buf, size_t len, int flags); 选项名 含义 可用于发送 可用于接收 MSG_CONFIRM 指示链路层协议持续监听, 直到得到答复.(仅能用于SOCK_DGRAM和SOCK_RAW类型的socket) Y N MSG_DONTROUTE 不查看路由表, 直接将数据发送给本地的局域网络的主机(代表发送者知道目标主机就在本地网络中) Y N MSG_DONTWAIT 非阻塞 Y Y MSG_MORE 告知内核有更多的数据要发送, 等到数据写入缓冲区完毕后,一并发送.减少短小的报文提高传输效率 Y N MSG_WAITALL 读操作一直等待到读取到指定字节后才会返回 N Y MSG_PEEK 看一下内缓存数据, 并不会影响数据 N Y MSG_OOB 发送或接收紧急数据 Y Y MSG_NOSIGNAL 向读关闭的管道或者socket连接中写入数据不会触发SIGPIPE信号 Y N 基础UDP 1234567#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;// 由于UDP不保存状态, 每次发送数据都需要 加入目标地址.// 不过recvfrom和sendto 也可以用于 面向STREAM的连接, 这样可以省略发送和接收端的socket地址ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr* src_addr, socklen_t* addrlen);ssize_t sendto(int sockfd, const void* buf, size_t len, ing flags, const struct sockaddr* dest_addr, socklen_t addrlen); 通用读写函数 12345678910111213141516171819202122232425262728#inclued &lt;sys/socket.h&gt;ssize_t recvmsg(int sockfd, struct msghdr* msg, int flags);ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags);struct msghdr&#123;/* socket address --- 指向socket地址结构变量, 对于TCP连接需要设置为NULL*/ void* msg_name; socklen_t msg_namelen; /* 分散的内存块 --- 对于 recvmsg来说数据被读取后将存放在这里的块内存中, 内存的位置和长度由 * msg_iov指向的数组指定, 称为分散读(scatter read) ---对于sendmsg而言, msg_iovlen块的分散内存中 * 的数据将一并发送称为集中写(gather write); */ struct iovec* msg_iov; int msg_iovlen; /* 分散内存块的数量*/ void* msg_control; /* 指向辅助数据的起始位置*/ socklen_t msg_controllen; /* 辅助数据的大小*/ int msg_flags; /* 复制函数的flags参数, 并在调用过程中更新*/&#125;;struct iovec&#123; void* iov_base /* 内存起始地址*/ size_t iov_len /* 这块内存长度*/&#125; 其他Api 12345678910111213141516171819#include &lt;sys/socket.h&gt;// 用于判断 sockfd是否处于带外标记, 即下一个被读取到的数据是否是带外数据, // 是的话返回1, 不是返回0// 这样就可以选择带MSG_OOB标志的recv调用来接收带外数据. int sockatmark(int sockfd);// getsockname 获取sockfd对应的本端socket地址, 存入address指定的内存中, 长度存入address_len中 成功返回0失败返回-1// getpeername 获取远端的信息, 同上int getsockname(int sockfd, struct sockaddr* address, socklen_t* address_len);int getpeername(int sockfd, struct sockaddr* address, socklen_t* address_len);/* 以下函数头文件均相同*/// sockfd 目标socket, level执行操作协议(IPv4, IPv6, TCP) option_name 参数指定了选项的名字. 后面值和长度// 成功时返回0 失败返回-1int getsockopt(int sockfd, int level, int option_name, void* option_value, socklen_t restrict option_len);int setsockopt(int sockfd, int level, int option_name, void* option_value, socklen_t restrict option_len); SO_REUSEADDR 重用本地地址 sock被设置此属性后, 即使sock在被bind()后处于TIME_WAIT状态, 此时与他绑定的socket地址依然能够立即重用来绑定新的sock SO_RCVBUF TCP接收缓冲区大小 最小值为256字节. 设置完后系统会自动加倍你所设定的值. 多出来的一倍将用用作空闲缓冲区处理拥塞 SO_SNDBUF TCP发送缓冲区大小 最小值为2048字节 SO_RCVLOWAT 接收的低水位标记 默认为1字节, 当TCP接收缓冲区中可读数据的总数大于其低水位标记时, IO复用系统调用将通知应用程序可以从对应的socket上读取数据 SO_SNDLOWAT 发送的高水位标记 默认为1字节, 当TCP发送缓冲区中空闲空间大于低水位标记的时候可以写入数据 SO_LINGER 1234567891011struct linger&#123; int l_onoff /* 开启非0, 关闭为0*/ int l_linger; /* 滞留时间*/ /* * 当onoff为0的时候此项不起作用, close调用默认行为关闭socket * 当onoff不为0 且linger为0, close将立即返回, TCP将丢弃发送缓冲区的残留数据, 同时发送一个复位报文段 * 当onoff不为0 且linger大于0 . 当socket阻塞的时候close将会等待TCP模块发送完残留数据并得到确认后关 * 闭, 如果是处于非阻塞则立即关闭 */&#125;; 网络信息API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;netdb.h&gt;// 通过主机名查找ipstruct hostent* gethostbyname(const char* name);// 通过ip获取主机完整信息 // type为IP地址类型 AF_INET和AF_INET6struct hostent* gethostbyaddr(const void* addr, size_t len, int type);struct hostent&#123; char *h_name; /* Official name of host. */ char **h_aliases; /* Alias list. */ int h_addrtype; /* Host address type. */ int h_length; /* Length of address. */ char **h_addr_list; /* List of addresses from name server. */&#125;int main(int argc, char* argv[])&#123; if (argc != 2) &#123; printf(&quot;非法输入\\n&quot;); exit(0); &#125; char* name = argv[1]; struct hostent *hostptr&#123;&#125;; hostptr = gethostbyname(name); if (hostptr == nullptr) &#123; printf(&quot;输入存在错误 或无法获取\\n&quot;); exit(0); &#125; printf(&quot;Official name of hostptr: %s\\n&quot;, hostptr-&gt;h_name); char **pptr; char inet_addr[INET_ADDRSTRLEN]; printf(&quot;Alias list:\\n&quot;); for (pptr = hostptr-&gt;h_aliases; *pptr != nullptr; ++pptr) &#123; printf(&quot;\\t%s\\n&quot;, *pptr); &#125; switch (hostptr-&gt;h_addrtype) &#123; case AF_INET: &#123; printf(&quot;List of addresses from name server:\\n&quot;); for (pptr = hostptr-&gt;h_addr_list; *pptr != nullptr; ++pptr) &#123; printf(&quot;\\t%s\\n&quot;, inet_ntop(hostptr-&gt;h_addrtype, *pptr, inet_addr, sizeof(inet_addr))); &#125; break; &#125; default: &#123; printf(&quot;unknow address type\\n&quot;); exit(0); &#125; &#125; return 0;&#125;/*./run baidu.comOfficial name of hostptr: baidu.comAlias list:List of addresses from name server: 39.156.69.79 220.181.38.148*/ 以下两个函数通过读取/etc/services文件 来获取服务信息 以下内容来自维基百科 Service文件是现代操作系统在etc目录下的一个配置文件，记录网络服务名对应的端口号与协议 其用途如下 通过TCP/IP的API函数（声明在netdb.h中）直接查到网络服务名与端口号、使用协议的对应关系。如getservbyname(“serve”,”tcp”)获取端口号;getservbyport（htons（port），“tcp”）获取端口和协议上的服务名 如果用户在这个文件中维护所有使用的网络服务名字、端口、协议，那么可以一目了然的获悉哪些端口号用于哪个服务，哪些端口号是空闲的 1234567891011121314#include &lt;netdb.h&gt;// 根据名称获取某个服务的完整信息struct servent getservbyname(const char* name, const char* proto);// 根据端口号获取服务信息struct servent getservbyport(int port, const char* proto);struct servent&#123; char* s_name; /* 服务名称*/ char ** s_aliases; /* 服务的别名列表*/ int s_port; /* 端口号*/ char* s_proto; /* 服务类型, 通常为TCP或UDP*/&#125; 12345678910111213141516171819202122#include &lt;netdb.h&gt;// 内部使用的gethostbyname 和 getserverbyname// hostname 用于接收主机名, 也可以用来接收字符串表示的IP地址(点分十进制, 十六进制字符串)// service 用于接收服务名, 字符串表示的十进制端口号// hints参数 对getaddrinfo的输出进行更准确的控制, 可以设置为NULL, 允许反馈各种有用的结果// result 指向一个链表, 用于存储getaddrinfo的反馈结果int getaddrinfo(const char* hostname, const char* service, const struct addrinfo* hints, struct addrinfo** result)struct addrinfo&#123; int ai_flags; int ai_family; int ai_socktype; /* 服务类型, SOCK_STREAM或者SOCK_DGRAM*/ int ai_protocol; socklen_t ai_addrlen; char* ai_canonname; /* 主机的别名*/ struct sockaddr* ai_addr; /* 指向socket地址*/ struct addrinfo* ai_next; /* 指向下一个结构体*/&#125;// 需要手动的释放堆内存void freeaddrinfo(struct addrinfo* res); 1234567#include &lt;netdb.h&gt;// host 存储返回的主机名// serv存储返回的服务名int getnameinfo(const struct sockaddr* sockaddr, socklen_t addrlen, char* host, socklen_t hostlen, char* serv socklen_t servlen, int flags); 测试使用 12telnet ip port #来连接服务器的此端口netstat -nt | grep port #来查看此端口的监听","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"socket编程","slug":"socket编程","permalink":"http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"}]},{"title":"Linux高性能服务器|第1-3章-计算机网络部分","slug":"Linux高性能服务器/Linux高性能服务器-计网部分-1-3章","date":"2022-04-27T09:25:10.000Z","updated":"2022-06-29T15:22:52.187Z","comments":true,"path":"2022/04/27/Linux高性能服务器/Linux高性能服务器-计网部分-1-3章/","link":"","permalink":"http://icecorn.github.io/2022/04/27/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8-%E8%AE%A1%E7%BD%91%E9%83%A8%E5%88%86-1-3%E7%AB%A0/","excerpt":"","text":"第一章 TCP/IP协议族TCP/IP协议族体系结构和主要协议协议族中协议众多, 这本书只选取了IP和TCP协议 - 对网络编程影响最直接 同样七层是osi参考模型, 简化后得到四层不同层次之间, 通过接口互相交流, 这样方便了各层次的修改 应用层负责处理应用程序的逻辑 表示层定义了数据的格式及加密 会话层它定义了如何开始、控制和结束一个会话，包括对多个双向消息的控制和管理，以便在只完成连续消息的一部分时可以通知应用，从而使表示层看到的数据是连续的 传输层为两台主机的应用提供端到端(end to end)的通信. 与网络层使用的下一跳不同, 他只关心起始和终止, 中转过程交给下层处理.此层存在两大协议TCP协议和UDP协议TCP协议(Transmission Control Protocol 传输控制协议) 为应用层提供可靠的, 面向连接, 基于流的服务 通过超时重传和数据确认等确保数据正常送达. TCP需要存储一些必要的状态, 连接的状态, 读写缓冲区, 诸多定时器UPD协议(User Datagram Protocol 用户数据报协议) 为应用层提供不可靠的, 无连接的, 基于数据报的服务 一般需要自己处理数据确认和超时重传的问题 通信两者不存储状态, 每次发送都需要指定地址信息. 有自己的长度 网络层实现了数据包的选路和转发. 只有数据包到不了目标地址, 就下一跳(hop by hop), 选择最近的.IP协议(Internet Protocol) 以及 ICMP协议(Internet Control Message Protocol)后者协议是IP协议的补充, 用来检测网络连接 1. 差错报文, 用来回应状态 2. 查询报文(ping程序就是使用的此报文来判断信息是否送达) 数据链路层实现了网卡接口的网络驱动程序. 这里驱动程序方便了厂商的下层修改, 只需要向上层提供规定的接口即可.存在两个协议 ARP协议(Address Resolve Protocol, 地址解析协议). 还有RARP(Reverse ~, 逆地址解析协议). 由于网络层使用IP地址寻址机器, 但是数据链路层使用物理地址(通常为MAC地址), 之间的转化涉及到ARP协议ARP欺骗, 可能与这个有关, 目前不去学习 封装上层协议发送到下层协议. 通过封装实现, 层与层之间传输的时候, 加上自己的头部信息.被TCP封装的数据成为 TCP报文段 内核部分发送成功后删除数据 被UDP封装的数据成为 UDP数据报 发送后即删除 再经IP封装后成为IP数据报最后经过数据链路层封装后为 帧 以太网最大数据帧1518字节 抛去14头部 帧尾4校验MTU: 帧的最大传输单元 一般为1500字节MSS: TCP数据包最大的数据载量 1460字节 = 1500字节 - 20Ip头-20TCP头 还有额外的40字节可选部分 ARPARP协议能实现任意网络层地址到任意物理地址的转换 第二章 IP协议详解IP协议是TCP/IP协议簇的核心协议, 是socket网络编程的基础之一IP协议为上层协议提供无状态, 无连接, 不可靠的服务 IP数据报最大长度是65535(2^16 - 1)字节, 但是有MTU的限制 当IP数据报的长度超过MTU 将会被分片传输. 分片可能发生在发送端, 也可能发生在中转路由器, 还可能被多次分片. 只有在最终的目标机器上, 这些分片才会被内核中的ip模块重新组装 路由机制 给定了目标IP地址后, 将会匹配路由表中的哪一项呢? 分三个步骤 查找路由表中和数据报的目标IP地址完全匹配的主机IP地址. 如果找到就使用该路由项. 否则下一步 查找路由表中和数据报的目标IP地址具有相同网路ID的网络IP地址 找到……. 否则下一步 选择默认路由项, 通常意味着下一跳路由是网关 第三章 TCP协议详解Tcp读写都是针对缓冲区来说, 所以没有固定的读写次数对应关系. UDP没有缓冲区, 必须及时接受数据否则会丢包, 或者接收缓冲区过小就会造成数据报截断 ISN-初始序号值32位序号 后续的TCP报文段中序号值 seq = ISN + 报文段首字节在整个字节流中的偏移32位确认号 收到的TCP报文序号值+1. 这个32位确认号每次发送的是上一次的应答 ACK标志: 表示确认号是否有效. 携带ACK标志的报文段称为确认报文段PSH标志: 提示接收端应用程序从TCP接受缓冲区中读走数据, 为后续数据腾出空间RST标志: 要求对方重新建立连接 携带……复位报文段SYN标志: 标志请求建立一个连接 携带……同步报文段FIN标志: 通知对方本端连接要关闭了, 携带..结束报文段 16位窗口大小: 窗口指的是接收通告窗口, 告诉对方本端的TCP 接收缓冲区还能容纳多少字节的数据16位校验和: 可靠传输的重要保障发送端填充, 接收端执行CRC算法校验是否损坏, 同时校验TCP头部和数据部分 TCP连接的建立和关闭 1234567891011121314151617181920212223242526272829303132333435# 三次握手# 客户端发送请求连接 ISN=seq + 0 = 3683340920# mss 最大数据载量1460IP 192.168.80.1.7467 &gt; ubuntu.8000: Flags [S], seq 3683340920, win 64240, options [mss 1460,nop,wscale 8,nop,nop,sackOK], length 0# 同意客户端连接# ack = 客户端发送 seq + 1# 同时发送服务端的seqIP ubuntu.8000 &gt; 192.168.80.1.7467: Flags [S.], seq 938535101, ack 3683340921, win 64240, options [mss 1460,nop,nop,sackOK,nop,wscale 7], length 0# 虽然这个报文段没有字节 但由于是同步报文段 需要占用一个序号值# 这里是tcpdump的处理 ack显示相对值 即 3683340921 - 3683340920 = 1IP 192.168.80.1.7467 &gt; ubuntu.8000: Flags [.], ack 938535102, win 4106, length 0# 包含FIN标志 说明要求结束连接 也需要占用一个序号值IP 192.168.80.1.7467 &gt; ubuntu.8000: Flags [F.], seq 1, ack 1, win 4106, length 0# 服务端确认关闭连接IP ubuntu.8000 &gt; 192.168.80.1.7467: Flags [.], ack 2, win 502, length 0# 服务端发送关闭连接IP ubuntu.8000 &gt; 192.168.80.1.7467: Flags [F.], seq 1, ack 2, win 4105, length 0# 客户端确认IP 192.168.80.1.7467 &gt; ubuntu.8000: Flags [.], ack 2, win 503, length 0","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"C++内存管理机制|第四讲-分配器/new&delete","slug":"C++ 内存管理机制/第四讲-其他内容","date":"2022-04-16T09:25:10.000Z","updated":"2022-06-29T15:50:29.412Z","comments":true,"path":"2022/04/16/C++ 内存管理机制/第四讲-其他内容/","link":"","permalink":"http://icecorn.github.io/2022/04/16/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E5%9B%9B%E8%AE%B2-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/","excerpt":"","text":"C++内存管理七种分配器 new_allocator 没做什么事，直接调用malloc/free，包装了一层而已 malloc_allocator 和new_allocator一样 array_allocator 分配一个静态的内存空间，不需要考虑归还的事情，其实就是c++的array debug_allocator 其实就是每分配一块内存都多加一个M_extra的内存来占一个元素的大小用于debug pool_allocator 就是第二讲讲的内存池的实现，16个自由链表挂载不同粒度的内存块，缺点是没有动态free,但不能算作内存泄漏，因为那些内存还在分配器的掌控之下 bitmap_allocator 用一个索引以 2 的指数倍数成长的桶子(exponentially increasing power-of-two-sized buckets)的思路。先捋一捋bitmap_allocator实现当中的相关数据结构的概念： blocks：即是进行分配的内存区块，每个block size一般取8bytes，是super-block的一部分；super-blocks：表示一个__mini_vector所管理的整个内存空间，bitmap_allocator进行管理内存空间扩容/缩减的操作就是通过增加或减少super-blocks的数目来实现的，是 bitmap_allocator 进行内存管理的基本单位；bitmap：记录一个__mini_vector所管理的内存空间所属的64个 blocks 的分配情况(依据增长情况，不一定是64个，也可能是128/256，block数目是2的幂次增长的)，所以为64bit，8bytes(0表示分配出去了，1表示未分配出去；若是全未分配出去则为0x FFFF FFFF FFFF FFFF，若是第一个分配出去则为 0x FFFF FFFF FFFF FFFE(1110)，即bitmap字节序从低位到高位表示的是block序号从63到0)，是super-block的一部分；mini-vector：该数据结构的实现是为了避免作为容器的分配其还嵌套容器所造成的先有鸡还是先有蛋的困扰，实现过程也即和vector的实现思路相似，见 vector 容器。含有三个成员变量_M_start；(表示所管理的block的起始位置，即block0的内存地址)，_M_finish；(表示第一个可分配的block的内存位置)，_M_end_of_storage;(类似于vector当中的capacity概念)。其作用是对 super-block 进行存储、访问和管理。 mt_allocator 针对多线程的分配器 关于Constconst放在成员函数后，是告诉编译器这个成员函数不改变这个类的data 记住non_const obj可以调用const函数，反过来则不行，如果const和non_const函数都有的话，就各调用各的 上图右边两个函数名称一样，只是一个多了const，所以const是算在函数签名里边的。 举例 string s1 = “abc”; s1[0] = ‘d’;这样就发生了写操作，这里s1实际调用的就是重载[]的非const版本，同时这里要考虑COW，就是有多个线程同时共有s1的话，要加锁，不要发生重写，脏数据等情况 const string s2 = “abc”; s2是常量，所以s2[0]访问的就是const版本的重载[]函数，且无需考虑COW 关于new，deletenew： 1.调用operator new(),这个函数是可以重载的，可以实现内存池，这个函数默认就是调用malloc（）分配一块内存 2.static_cast&lt;T*&gt; 将1中分配的内存强制转型成想new的数据类型 3.调用new的类的构造函数 delete： 1.调用该对象的析构函数，这里要注意的是，如果这个对象没有指针类型的data，那么其实不析构也没啥事，有的话就一定要析构 2.调用delete释放这块内存，这里实际就是调用free（）","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++内存管理机制","slug":"C-内存管理机制","permalink":"http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"}]},{"title":"C++内存管理机制|第三讲-malloc/free","slug":"C++ 内存管理机制/第三讲malloc_free","date":"2022-04-11T09:25:10.000Z","updated":"2022-06-29T15:50:22.659Z","comments":true,"path":"2022/04/11/C++ 内存管理机制/第三讲malloc_free/","link":"","permalink":"http://icecorn.github.io/2022/04/11/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%89%E8%AE%B2malloc_free/","excerpt":"","text":"C++内存管理malloc/free一、VC6内存分配下图左边是函数调用栈，最下方是操作系统 SBH：VC6 malloc对小区块（1016）的分配有特殊处理。在后续的版本VC10 取消了SBH的实现，全部交给操作系统来做（HeapAlloc()函数，OS对小区快内存的分配也和VC6类似） 下图是VC10的call stack，红×是相对VC6去掉的，最大区别就是取消了SBH，全部移交OS分配 SBH之始以下内容核心的目的，就是通过组织一些数据结构和算法来管理1MB的内存的灵活分配和释放（因为超过1MB就不用SBH，直接交给OS管理） 首先call OS的系统函数HeapCreate（），申请一块4096bits的内存(_crtheap)供后续使用， 即__cdecl_heap_init()，创建了16个Header CRT：C Run Time Header里边包括下边这些东西，具体干什么用的下文再说 debug模式会多增加一些内存用于跟踪我们使用的内存，这就是VS debug模式能显示堆栈中变量及地址的原因 ioinit（）函数是首次分配内存的函数，而且必定是256个字节（16进制为100） 接着往下调用到**_heap_alloc_dbg(),这个函数的参数是下图中的blocksize= debug模式需要的内存（下图上方灰色部分）+ 上下两个“无人区”（下图深绿部分，一个4字节）+ 实际内存大小（下图浅绿部分，256字节）补充一点：上下无人区实际也属于debug模式的信息，release模式就没有了** 无人区起到一个栏杆的作用，从而调试器可以检测出内存越界行为 pBlockHeaderNext;pBlockHeaderPrev这两个指针的作用就是将SBH分配的所有的内存区块全部串联起来，从而来管理 接下来调用**_heap_alloc_base()**这个函数就是在加完debug这些内存之后，判断有没有超过1016个字节，没超过就SBH，超过了就OS分配 接下来调用**__sbh_alloc_block()**,这个函数作用： 下图add 8 bytes就是加入了上下cookies，然后进行对齐操作，将这个带着上下cookies的内存块上调为16 bytes对齐 这些整个的大小是0X130，但是cookies里却存的是00000131，这里是用了个trick，因为内存块是16位对齐的，那么最后一位必然是0，所以这里cookies那里就用结尾存0或1来表示这个内存块的状态（使用，释放） 以上这些内容都是在计算所需内存大小，还没有实际分配内存，自然更谈不上初始化内容 下面将进入实际分配内存的环节： 之前讲过有16个Header，它们每个控制1MB的内存（通过win API申请的Virtual melloc（）） 下图就是将它们控制的region是怎么玩的，细节是一个header的一个group维护了64个指针（双向链表）来控制这1MB，这些指针消耗大概16K 32个group分1MB，一个32K，再分成8分，一份4K称为一个page，看到这里恍然大悟，和OS连上了，这个就是OS里的分页，目的就是最大程度的里用零散的小内存 所以这里实际上就看出来SBH就是类似上一讲的内存池那样挖出一块大内存1MB然后手动画好格子32group * 8page，并且搞一堆指针形成链表让他们能找到，然后就可以分配管理了 另外，这个header控制的1MB实际上只是逻辑上的地址空间，因为win系统的虚拟内存机制，前边也说了它是用Virtual malloc申请的，这里联想以下OS里的虚内存机制就可以了。所以这里不是直接再物理空间上挖1MB，而是最小只用分配1page 4k就可以了，为什么呢？这里联想下虚内存和硬盘的交互，恰恰就是按page的粒度来进行换入换出的！ 上图中一个group的64根指针实际上就像第二讲的allocator内存池一样，第一个用来挂在8字节，第二个16字节，这样一直到最后一个指针是挂载1KB及1KB以上的 下面是实际切的情况： VC6的内存管理分配情况： 其实就和内存池的分配差不多，把一个group用64个指针管理，按照所需分配的内存大小选择挂载在哪个指针下边，每一次分配从下往上长 收回内存，就是把这块内存挂载到对应的链表上（例下图是35号链表），然后把group的标志数组对应的35号位子置为1，表示这个底下有闲置的内存可以分配 下一次再分配内存，算出要挂载在25号指针，但是它的group标志位是0，那么就往后找比它大的最近的指针标志位为1的，这里是35号链表，所以这次分配的内存实际上就是在上一次回收的35号内存上切一刀再分配给当前申请内存的程序。这里相比第二讲allocate简陋的内存池，就有了一个很大的好处，可以将这一个group32K的内存的压榨的很满。 区块合并 一个区块要被free的情况，在直接挂载到group对应的指针下之前，可以先看这个区块的上下区块是不是也是free的状态，如果是，那么可以将它们合并成一个大区块（上下cookies的最后一位是0表示是free状态的区块，可以合并，这也是上下cookies的作用之一） Free（p）挂载内存到指针上 确定哪一个Header-&gt;确定哪一个group-&gt;最后确定是64个指针中的哪一个 至于怎么找，就用指针的地址减去头的地址就行 总结SBH实际上就是将内存分成不同的粒度大小，16个Header每个管理1MB，1MB又分成了32个group每个32K，32K用分成8个page每个4K，这实际上就是OS内存的段页式管理，目的就是为了最大化合理利用内存碎片，从最大的内存一层一层找到最后内存所在的page就是句柄？ 全回收判断 因为是链表的结构，所以不容易判断内存是否全部回收完毕，所以设置了一个cntEntires参数每次melloc就+1，free就-1，如果为0就表示全回收啦（就是最后8个page全部挂在最后一个链表上，因为最后一个链表指针控制1KB以上的字节） 另外这里有个buffer机制，就是有个defer指针，当有第一个全回收的group时先不回收（还给OS），出现第二个全回收的group再把第一个回收掉，这样就减少了像OS申请虚拟内存的次数（当没有第二个group时，又有进程申请内存，这时直接分配defer指针下全回收的group就行） allocator内存池的设计其实只是为了减少cookies内存的占用，而不是减少malloc的调用次数，因为malloc其实很快 在下图中各层级的调用栈中，确实存在一些冗余，但因为过于庞大且不是一拨开发人员所以没办法，但VC因为是微软自家的，所以在VC10就取消了SBH的设计，将小区块内存也一并交给下层OS来管理了","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++内存管理机制","slug":"C-内存管理机制","permalink":"http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"}]},{"title":"C++内存管理机制|第二讲-std_allocator-内存池","slug":"C++ 内存管理机制/第二讲std_allocator","date":"2022-04-08T09:25:10.000Z","updated":"2022-06-29T15:50:03.450Z","comments":true,"path":"2022/04/08/C++ 内存管理机制/第二讲std_allocator/","link":"","permalink":"http://icecorn.github.io/2022/04/08/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%BA%8C%E8%AE%B2std_allocator/","excerpt":"","text":"C++内存管理std::allocator一、malloc()内部原理1、VC6.0 malloc 从上图可见，VC6中的malloc()函数分配的内存里面除了我们需要申请的内存空间外还有cookie，debug信息和pad，其中cookie是我们不需要的，如果大量调用malloc的话cookie总和会增多，这回造成较大的浪费。 从上面可以看出，VC6.0的allocate()函数只是对malloc的二次封装，并没有做什么很特殊的操作，它是以类型字节长度为单位分配内存的，上图就分配了512个int类型空间。 2、BC5 malloc BC5的allocate()函数和VC6.0本质一样。 3、G2.9 malloc GCC 2.9版本的allocator如上图所示，但是在实际中该部分却没有被包含使用，从下图容器使用的Alloc可以看到，实际的分配器是使用了一个叫alloc的类，该类分配内存是以字节为单位的，而不是以对象为单位。下图右边灰色部分分配的是512字节，而不是512个对象。 4、__pool_alloc在GCC 4.9版本，2.9版本的allocate不属于正式使用的那个版本，而是变成了__pool_alloc： 从上面两张图可以对比看出，2.9版本的allocate和4.9版本的__pool_alloc做的事是一样的，只是修改了变量名和一些细小操作而已。 测试的代码如所示： #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;ext\\pool_allocator.h&gt; using namespace std; template&lt;typename Alloc&gt; void cookie_test(Alloc alloc, size_t n) &#123; typename Alloc::value_type *p1, *p2, *p3; //需有 typename p1 = alloc.allocate(n); //allocate() and deallocate() 是 non-static, 需以 object 呼叫之. p2 = alloc.allocate(n); p3 = alloc.allocate(n); cout &lt;&lt; &quot;p1= &quot; &lt;&lt; p1 &lt;&lt; &#39;\\t&#39; &lt;&lt; &quot;p2= &quot; &lt;&lt; p2 &lt;&lt; &#39;\\t&#39; &lt;&lt; &quot;p3= &quot; &lt;&lt; p3 &lt;&lt; &#39;\\n&#39;; alloc.deallocate(p1,sizeof(typename Alloc::value_type)); //需有 typename alloc.deallocate(p2,sizeof(typename Alloc::value_type)); //有些 allocator 對於 2nd argument 的值無所謂 alloc.deallocate(p3,sizeof(typename Alloc::value_type)); &#125; int main(void) &#123; cout &lt;&lt; sizeof(__gnu_cxx::__pool_alloc&lt;double&gt;) &lt;&lt; endl; vector&lt;int, __gnu_cxx::__pool_alloc&lt;double&gt; &gt; vecPool; cookie_test(__gnu_cxx::__pool_alloc&lt;double&gt;(), 1); cout &lt;&lt; &quot;----------------------&quot; &lt;&lt; endl; cout &lt;&lt; sizeof(std::allocator&lt;double&gt;) &lt;&lt; endl; vector&lt;int, std::allocator&lt;double&gt; &gt; vecPool2; cookie_test(std::allocator&lt;double&gt;(), 1); return 0; &#125; 测试环境是Dev C++5.1.1版本，GCC 4.9，测试结果如下： 从上面的测试结果可以看出，如果使用了__pool_alloc的话，连续两块内存之间的距离是8，而一个double类型变量的大小也是8个字节，说明这连续几块内存之间是不带cookie的（即使这几块内存在物理上也是不连续的）。如果使用std的allocator，那么相邻两块内存之间距离为18个字节，每块内存带有一个4字节的头和4字节的尾。 二、std::alloc1、std:alloc运作模式 std::alloc使用一个16个元素的数组来管理内存链表，而我们上一章只是用了一条链表。数组不同的元素管理不同的区块管理，例如#3号元素负责管理32bytes为一小块的链表。 假设现在用户需要32字节的内存，std::allloc先申请一块区间，为32202大小，用一条链表管理，然后让数组的#3元素管理这条链表。接着讲该以32为一个单元的链表的一个单元（32字节）分给用户。为什么是32202？前面3220空间是分配给用户的，但是后面的3220空间是预留的，如果这时用户需要一个64字节的空间，那么剩下的3220空间将变成6410，然后将其中64字节分配给用户，而不用再一次地构建链表和申请空间。 但是也有上限。如果该链表组维护的链表最大的一个小块为128byte，但是用户申请内存块超过了128byte，那么std::alloc将调用malloc给用户分配空间，然后该块将带上cookie头和尾。 在真正的商业级的内存分配器中，一般都会使用嵌入式指针，将每一个小块的前四个字节用作指针连接下一块可用的内存块。 2、std::alloc运行一瞥 3、std::alloc源码剖析侯杰老师的ppt上总结的很好，在看这部分内容时需要结合老师的ppt，为了方便分析，这里结合老师的课程，使用“倒叙”的方式，先介绍中间的几张ppt，然后跳回前面，顺序和原版ppt不一样。 原版ppt的1-3张介绍的是GCC 2.9的std::alloc的第一级分配器，这里先从第二级开始分析，然后再到第一级。 该分配器为__default_alloc_template，一开始默认使用的分配器，在该类中定义了ROUND_UP函数，用来将申请内存数量做16字节对齐。定义了union free_list_link，在后面会介绍它的作用，在上一章中我们构建的一个小的分配器中也定义了该联合体，作用类似，该联合体可以使用struct代替。free_list是一个有16个obj*元素的数组，在前面讲过，GCC 2.9的分配器用一个16字节数组管理16条链表，free_list便是该管理数组。refill和chunk_alloc在后面再介绍。start_free和end_free分别指向该内存池的头和尾。 首先看allocate函数，在函数的一开始便定义了: obj* volatile *my_free_list; 结合上图右侧的链表图和上上一张图片内容，my_free_list指向的是free_list中16个元素中的任何一个，*my_free_list则取出free_list某元素中的值，该值指向一条分配内存的链表。所以my_free_list要定义为二级指针。 result则保存分配给用户的一块内存的地址。 首先： if (n &gt; (size_t)__MAX_BYTES) &#123; return(malloc_alloc::allocate(n)); &#125; 检查用户申请内存块大小，如果大于__MAX_BYTES（128）那么将调用malloc_alloc::allocate()，这便是第一级分配器，这在后面分析。现在假设用户申请内存小于128字节，那么将根据用户申请内存大小分配对应的内存，由于内存池使用free_list链表管理的，每个free_list链表元素管理不同的内存块大小，这在前面介绍过了。于是有： my_free_list = free_list + FREELIST_INDEX(n); 定位到该内存块的位置，这时my_free_list指向的是管理该内存块的空间的地址，使用*my_free_list便可以取到该内存块的地址： result = *my_free_list; 然后判断result是否为空： if (result == 0) &#123; void* r = refill(ROUND_UP(n)); return r; &#125; 如果为空，说明系统内存不够用了，将使用refill()函数分配内存，这部分在后面会介绍。 如果情况正常，那么将该链表中下一个可以使用的空间设置为当前分配给用户空间指向的下一个、在逻辑上连续的空间，最后将result返回给用户： *my_free_list = result-&gt;free_list_link; return (result); 下面的这张图很形象地演示了内存分配的过程： 接下来分析释放内存。 static void deallocate(void *p, size_t n) //p may not be 0 &#123; obj* q = (obj*)p; obj* volatile *my_free_list; //obj** my_free_list; if (n &gt; (size_t) __MAX_BYTES) &#123; malloc_alloc::deallocate(p, n); return; &#125; my_free_list = free_list + FREELIST_INDEX(n); q-&gt;free_list_link = *my_free_list; *my_free_list = q; &#125; 释放内存的代码也不难理解，找到需要释放内存的那块空间的地址，然后将当前可分配给用户的空间地址设置为需要释放的该内存空间，一开始指向的可分配的内存空间地址赋值给需要释放空间地址的逻辑连续的下一个内存地址。感觉十分拗口，图和代码更能体现这一过程： 上面说到，不论是分配内存还是释放内存，则有： if (n &gt; (size_t)__MAX_BYTES) &#123; return(malloc_alloc::allocate(n)); &#125; 和： if (n &gt; (size_t) __MAX_BYTES) &#123; malloc_alloc::deallocate(p, n); return; &#125; 也就是将内存分配与释放操作放到第一级allocator中： 从上图中可以看到，第一级分配器叫做： class __malloc_alloc_template 其实有： typedef __malloc_alloc_template&lt;0&gt; malloc_alloc; 这在后面会介绍。 分配器的allocate函数如下： static void* allocate(size_t n) &#123; void *result = malloc(n); //直接使用 malloc() if (0 == result) result = oom_malloc(n); return result; &#125; 直接调用malloc函数分配内存，如果分配失败则调用oom_malloc函数。 同样地，reallocate也是如此： static void* reallocate(void *p, size_t /* old_sz */, size_t new_sz) &#123; void * result = realloc(p, new_sz); //直接使用 realloc() if (0 == result) result = oom_realloc(p, new_sz); return result; &#125; 如果重新要求内存失败，则调用oom_realloc函数，这两个函数在后续会介绍。 deallocate操作则直接释放内存： static void deallocate(void *p, size_t /* n */) &#123; free(p); //直接使用 free() &#125; set_malloc_handler是个函数指针，里面传入一个void (*f)()类型函数： static void (*set_malloc_handler(void (*f)()))() &#123; //類似 C++ 的 set_new_handler(). void (*old)() = __malloc_alloc_oom_handler; __malloc_alloc_oom_handler = f; return(old); &#125; 该函数设置的是内存分配不够情况下的错误处理函数，这个需要交给用户来管理，首先保存先前的处理函数，然后再将新的处理函数f赋值给__malloc_alloc_oom_handler，然后返回旧的错误处理函数，这也在下一张图片中会介绍： 可以看到oom_malloc函数内部做的事： template &lt;int inst&gt; void* __malloc_alloc_template&lt;inst&gt;::oom_malloc(size_t n) &#123; void (*my_malloc_handler)(); void* result; for (;;) &#123; //不斷嘗試釋放、配置、再釋放、再配置… my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //呼叫處理常式，企圖釋放記憶體 result = malloc(n); //再次嘗試配置記憶體 if (result) return(result); &#125; &#125; 该函数不断调用__malloc_alloc_oom_handler和malloc函数，直到内存分配成功才返回。oom_realloc也是如此： template &lt;int inst&gt; void * __malloc_alloc_template&lt;inst&gt;::oom_realloc(void *p, size_t n) &#123; void (*my_malloc_handler)(); void* result; for (;;) &#123; //不斷嘗試釋放、配置、再釋放、再配置… my_malloc_handler = __malloc_alloc_oom_handler; if (0 == my_malloc_handler) &#123; __THROW_BAD_ALLOC; &#125; (*my_malloc_handler)(); //呼叫處理常式，企圖釋放記憶體。 result = realloc(p, n); //再次嘗試配置記憶體。 if (result) return(result); &#125; &#125; 到这里，分配器只剩下refill函数没有分析了，下面将重点讨论该函数。不过在讨论refill函数之前有必要分析chunk_alloc函数： 该函数声明如下： template &lt;bool threads, int inst&gt; char* __default_alloc_template&lt;threads, inst&gt;:: chunk_alloc(size_t size, int&amp; nobjs) 函数一开始计算了一些需要的值： char* result; size_t total_bytes = size * nobjs; size_t bytes_left = end_free - start_free; result指向分配给用户的内存，total_bytes为需要分配的内存块的大小，bytes_left则是当前内存池中剩余的空间大小。 然后： if (bytes_left &gt;= total_bytes) &#123; result = start_free; start_free += total_bytes; return(result); &#125; 判断如果内存池剩余的内存大小多余需要分配的内存块大小，那么将内存池的首地址start_free直接赋值给result，然后将start_free指针下移total_bytes距离，将当下的result~start_free之间的空间返回给用户。 当然，如果bytes_left比total_bytes小，但是却比size大： else if (bytes_left &gt;= size) &#123; nobjs = bytes_left / size; total_bytes = size * nobjs; result = start_free; start_free += total_bytes; return(result); &#125; 这意味着不能直接分配size * nobjs大小内存给用户，那么可以先看看内存池当下的空间能分配多少个size大小的块给用户，然后将该块分配给用户，start_free指针移动total_bytes长度。 size_t bytes_to_get = 2 * total_bytes + ROUND_UP(heap_size &gt;&gt; 4); // Try to make use of the left-over piece. if (bytes_left &gt; 0) &#123; obj* volatile *my_free_list = free_list + FREELIST_INDEX(bytes_left); ((obj*)start_free)-&gt;free_list_link = *my_free_list; *my_free_list = (obj*)start_free; &#125; 这部分查看内存池里面还有没有多余的内存，如果有，就充分利用。然后就是不断地获取内存块，将这些内存块不断切割用链表连接起来，递归这些过程： start_free = (char*)malloc(bytes_to_get); if (0 == start_free) &#123; int i; obj* volatile *my_free_list, *p; //Try to make do with what we have. That can&#39;t //hurt. We do not try smaller requests, since that tends //to result in disaster on multi-process machines. for (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123; my_free_list = free_list + FREELIST_INDEX(i); p = *my_free_list; if (0 != p) &#123; *my_free_list = p -&gt; free_list_link; start_free = (char*)p; end_free = start_free + i; return(chunk_alloc(size, nobjs)); //Any leftover piece will eventually make it to the //right free list. &#125; &#125; end_free = 0; //In case of exception. start_free = (char*)malloc_alloc::allocate(bytes_to_get); //This should either throw an exception or //remedy the situation. Thus we assume it //succeeded. &#125; heap_size += bytes_to_get; end_free = start_free + bytes_to_get; return(chunk_alloc(size, nobjs));","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++内存管理机制","slug":"C-内存管理机制","permalink":"http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"},{"name":"内存池","slug":"内存池","permalink":"http://icecorn.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"}]},{"title":"C++内存管理机制|第一讲-primitives","slug":"C++ 内存管理机制/第一讲primitives","date":"2022-04-05T09:25:10.000Z","updated":"2022-06-29T15:50:37.549Z","comments":true,"path":"2022/04/05/C++ 内存管理机制/第一讲primitives/","link":"","permalink":"http://icecorn.github.io/2022/04/05/C++%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/%E7%AC%AC%E4%B8%80%E8%AE%B2primitives/","excerpt":"","text":"C++内存管理一、四种内存分配和释放方法 在编程时可以通过上图的几种方法直接或间接地操作内存。下面将介绍四种C++内存操作方法： 通常可以使用malloc和new来分配内存，当然也可以使用::operator new()和分配器allocator来操作内存，下面将具体介绍这些函数的使用方法。对于不同的编译器，其allocate函数的接口也有所不同： 对于GNU C，不同版本又有所不同： 这张图中的__gnu_cxx::__pool_alloc().allocate()对应于上张图中的allocator().allocate()。 通过malloc和new分配内存、通过free和delete释放内存是十分常用的，通过::operator new操作内存比较少见，allocator分配器操作内存在STL源码中使用较多，对于不同的编译环境使用也有所不同。下面这个例子是基与VS2013环境做测试的: #include &lt;iostream&gt; #include &lt;complex&gt; #include &lt;memory&gt; //std::allocator //#include &lt;ext\\pool_allocator.h&gt; //GCC使用，欲使用 std::allocator 以外的 allocator, 就得自行 #include &lt;ext/...&gt; using namespace std; namespace jj01 &#123; void test_primitives() &#123; cout &lt;&lt; &quot;\\ntest_primitives().......... \\n&quot;; void* p1 = malloc(512); //512 bytes free(p1); complex&lt;int&gt;* p2 = new complex&lt;int&gt;; //one object delete p2; void* p3 = ::operator new(512); //512 bytes ::operator delete(p3); //以下使用 C++ 標準庫提供的 allocators。 //其接口雖有標準規格，但實現廠商並未完全遵守；下面三者形式略異。 #ifdef _MSC_VER //以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints. int* p4 = allocator&lt;int&gt;().allocate(3, (int*)0); p4[0] = 666; p4[1] = 999; p4[2] = 888; cout &lt;&lt; &quot;p4[0] = &quot; &lt;&lt; p4[0] &lt;&lt; endl; cout &lt;&lt; &quot;p4[1] = &quot; &lt;&lt; p4[1] &lt;&lt; endl; cout &lt;&lt; &quot;p4[2] = &quot; &lt;&lt; p4[2] &lt;&lt; endl; allocator&lt;int&gt;().deallocate(p4, 3); #endif #ifdef __BORLANDC__ //以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints. int* p4 = allocator&lt;int&gt;().allocate(5); allocator&lt;int&gt;().deallocate(p4, 5); #endif #ifdef __GNUC__ //以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes. //void* p4 = alloc::allocate(512); //alloc::deallocate(p4,512); //以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints. void* p4 = allocator&lt;int&gt;().allocate(7); allocator&lt;int&gt;().deallocate((int*)p4, 7); //以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints. void* p5 = __gnu_cxx::__pool_alloc&lt;int&gt;().allocate(9); __gnu_cxx::__pool_alloc&lt;int&gt;().deallocate((int*)p5, 9); #endif &#125; &#125; //namespace int main(void) &#123; jj01::test_primitives(); return 0; &#125; 编译运行结果如下： 可见 int* p4 = allocator().allocate(3, (int*)0) 操作成功申请了三个int的空间。 二、基本构件之 new/delete expression1、内存申请 上面这张图揭示了new操作背后编译器做的事： 1、第一步通过operator new()操作分配一个目标类型的内存大小，这里是Complex的大小； 2、第二步通过static_cast将得到的内存块强制转换为目标类型指针，这里是Complex* 3、第三版调用目标类型的构造方法，但是需要注意的是，直接通过pc-&gt;Complex::Complex(1, 2)这样的方法调用构造函数只有编译器可以做，用户这样做将产生错误。 值得注意的是，operator new()操作的内部是调用了malloc()函数。 2、内存释放 同样地，delete操作第一步也是调用了对象的析构函数，然后再通过operator delete()函数释放内存，本质上也是调用了free函数。 3、模拟编译器直接调用构造和析构函数下面的代码测试环节为VS2013： #include &lt;iostream&gt; #include &lt;string&gt; //#include &lt;memory&gt; //std::allocator using namespace std; namespace jj02 &#123; class A &#123; public: int id; A() : id(0) &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125; A(int i) : id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125; &#125;; void test_call_ctor_directly() &#123; cout &lt;&lt; &quot;\\ntest_call_ctor_directly().......... \\n&quot;; string* pstr = new string; cout &lt;&lt; &quot;str= &quot; &lt;&lt; *pstr &lt;&lt; endl; //! pstr-&gt;string::string(&quot;jjhou&quot;); //[Error] &#39;class std::basic_string&lt;char&gt;&#39; has no member named &#39;string&#39; //! pstr-&gt;~string(); //crash -- 其語法語意都是正確的, crash 只因為上一行被 remark 起來嘛. cout &lt;&lt; &quot;str= &quot; &lt;&lt; *pstr &lt;&lt; endl; ​​ //————​​ A* pA = new A(1); //ctor. this=000307A8 id=1​ cout &lt;&lt; pA-&gt;id &lt;&lt; endl; //1​ pA-&gt;A::A(3);​ cout &lt;&lt; pA-&gt;id &lt;&lt; endl;​ //! pA-&gt;A::A(3); //in VC6 : ctor. this=000307A8 id=3​ //in GCC : [Error] cannot call constructor ‘jj02::A::A’ directly​ A::A(5); //! A::A(5); //in VC6 : ctor. this=0013FF60 id=5 // dtor. this=0013FF60 //in GCC : [Error] cannot call constructor ‘jj02::A::A’ directly // [Note] for a function-style cast, remove the redundant ‘::A’ cout &lt;&lt; pA-&gt;id &lt;&lt; endl; //in VC6 : 3 //in GCC : 1 delete pA; //dtor. this=000307A8 //simulate new void* p = ::operator new(sizeof(A)); cout &lt;&lt; &quot;p=&quot; &lt;&lt; p &lt;&lt; endl; //p=000307A8 pA = static_cast&lt;A*&gt;(p); pA-&gt;A::A(2); //! pA-&gt;A::A(2); //in VC6 : ctor. this=000307A8 id=2 //in GCC : [Error] cannot call constructor &#39;jj02::A::A&#39; directly cout &lt;&lt; pA-&gt;id &lt;&lt; endl; //in VC6 : 2 //in GCC : 0 //simulate delete pA-&gt;~A(); //dtor. this=000307A8 ::operator delete(pA); //free() &#125; &#125; //namespace int main(void) &#123; jj02::test_call_ctor_directly(); return 0; &#125; 编译运行结果如下： VS下可以直接通过内存空间调用构造函数，但侯杰测试在GNU C下无法通过，具体的内容可见代码注解和打印效果。 三、Array new 上图主要展示的是关于new array内存分配的大致情况。当new一个数组对象时（例如 new Complex[3]），编译器将分配一块内存，这块内存首部是关于对象内存分配的一些标记，然后下面会分配三个连续的对象内存，在使用delete释放内存时需要使用delete[]。如果不使用delete[]，只是使用delete只会将分配的三块内存空间释放，但不会调用对象的析构函数，如果对象内部还使用了new指向其他空间，如果指向的该空间里的对象的析构函数没有意义，那么不会造成问题，如果有意义，那么由于该部分对象析构函数不会调用，那么将会导致内存泄漏。图中new string[3]便是一个例子，虽然str[0]、str[1]、str[2]被析构了，但只是调用了str[0]的析构函数，其他对象的析构函数不被调用，这里就会出问题。 下面将演示数组对象创建与析构过程： #include &lt;iostream&gt; #include &lt;new&gt; //placement new using namespace std; namespace jj03 &#123; class A &#123; public: int id; A() : id(0) &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125; A(int i) : id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125; ~A() &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; id &lt;&lt; endl; &#125; &#125;; void test_array_new_and_placement_new() &#123; cout &lt;&lt; &quot;\\ntest_placement_new().......... \\n&quot;; size_t size = 3; &#123; //case 1 //模擬 memory pool 的作法, array new + placement new. 崩潰 A* buf = (A*)(new char[sizeof(A)*size]); A* tmp = buf; cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot; tmp=&quot; &lt;&lt; tmp &lt;&lt; endl; for (int i = 0; i &lt; size; ++i) new (tmp++) A(i); //3次 调用ctor cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot; tmp=&quot; &lt;&lt; tmp &lt;&lt; endl; //! delete [] buf; //crash. why? //因為這其實是個 char array，看到 delete [] buf; 編譯器會企圖喚起多次 A::~A. // 但 array memory layout 中找不到與 array 元素個數 (本例 3) 相關的信息, // -- 整個格局都錯亂 (從我對 VC 的認識而言)，於是崩潰。 delete buf; //dtor just one time, ~[0] cout &lt;&lt; &quot;\\n\\n&quot;; &#125; &#123; //case 2 //回頭測試單純的 array new A* buf = new A[size]; //default ctor 3 次. [0]先於[1]先於[2]) //A必須有 default ctor, 否則 [Error] no matching function for call to &#39;jj02::A::A()&#39; A* tmp = buf; cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot; tmp=&quot; &lt;&lt; tmp &lt;&lt; endl; for (int i = 0; i &lt; size; ++i) new (tmp++) A(i); //3次 ctor cout &lt;&lt; &quot;buf=&quot; &lt;&lt; buf &lt;&lt; &quot; tmp=&quot; &lt;&lt; tmp &lt;&lt; endl; delete[] buf; //dtor three times (次序逆反, [2]先於[1]先於[0]) &#125; &#123; //case 3 //掌握崩潰原因, 再次模擬 memory pool作法, array new + placement new. //不, 不做了, 因為 memory pool 只是供應 memory, 它並不管 construction, //也不管 destruction. 它只負責回收 memory. //所以它是以 void* 或 char* 取得 memory, 釋放 (刪除)的也是 void* or char*. //不像本例 case 1 釋放 (刪除) 的是 A*. // //事實上 memory pool 形式如 jj04::test &#125; &#125; &#125; //namespace int main(void) &#123; jj03::test_array_new_and_placement_new(); return 0; &#125; 编译运行结果如下： 构造函数调用顺序是按照构建对象顺序来执行的，但是析构函数执行却相反。值得注意的是，在调用了delete的大括号代码段中，数组有三个元素，但最后只调用了第一个对象的析构函数。 接下来将更具体地展示new array对象的内存分配情况： 如果使用new分配十个内存的int，内存空间如上图所示，首先内存块会有一个头和尾，黄色部分为debug信息，灰色部分才是真正使用到的内存，蓝色部分的12bytes是为了让该内存块以16字节对齐。在这个例子中delete pi和delete[] pi效果是一样的，因为int没有析构函数。但是下面的例子就不一样了： 上图通过new申请三个Demo空间大小，内存块使用了96byte，这里是这样计算得到的:黄色部分调试信息32 + 4 = 36byte；黄色部分下面的“3”用于标记实际分配给对象内存个数，这里是三个所以里面内容为3，消耗4byte；Demo内有三个int类型成员变量，一个Demo消耗内存3 * 4 = 12byte，由于有三个Demo，所以消耗了12 * 3 = 36byte空间；到目前为止消耗36 + 4 + 36 = 76byte，加上头尾cookie一共8byte一共消耗84byte，由于需要16位对齐，所以填充蓝色部分为12byte，一共消耗了84 + 12 = 96byte。这里释放内存时需要加上delete[]，上面分配内存中有个标记“3”，所以编译器将释放三个Demo对象空间，如果不加就会报错。 四、placement new 五、重载1、C++内存分配的途径 如果是正常情况下，调用new之后走的是第二条路线，如果在类中重载了operator new()，那么走的是第一条路线，但最后还是要调用到系统的::operator new()函数，这在后续的例子中会体现。 对于GNU C，背后使用的allocate()函数最后也是调用了系统的::operator new()函数。 2、重载new 和 delete 上面这张图演示了如何重载系统的::operator new()函数，该方法最后也是模拟了系统的做法，效果和系统的方法一样，但一般不推荐重载::operator new()函数，因为它对全局有影响，如果使用不当将造成很大的问题。 如果是在类中重载operator new()方法，那么该方法有N多种形式，但必须保证函数参数列表第一个参数是size_t类型变量；对于operator delete()，第一个参数必须是void* 类型，第二个size_t是可选项，可以去掉。 对于operator new[]和operator delete[]函数的重载，和前面类似。 3、测试案例测试一： #include &lt;cstddef&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; namespace jj06 &#123; class Foo &#123; public: int _id; long _data; string _str; public: static void* operator new(size_t size); static void operator delete(void* deadObject, size_t size); static void* operator new[](size_t size); static void operator delete[](void* deadObject, size_t size); Foo() : _id(0) &#123; cout &lt;&lt; &quot;default ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125; Foo(int i) : _id(i) &#123; cout &lt;&lt; &quot;ctor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125; //virtual ~Foo() &#123; cout &lt;&lt; &quot;dtor. this=&quot; &lt;&lt; this &lt;&lt; &quot; id=&quot; &lt;&lt; _id &lt;&lt; endl; &#125; //不加 virtual dtor, sizeof = 12, new Foo[5] =&gt; operator new[]() 的 size 參數是 64, //加了 virtual dtor, sizeof = 16, new Foo[5] =&gt; operator new[]() 的 size 參數是 84, //上述二例，多出來的 4 可能就是個 size_t 欄位用來放置 array size. &#125;; void* Foo::operator new(size_t size) &#123; Foo* p = (Foo*)malloc(size); cout &lt;&lt; &quot;Foo::operator new(), size=&quot; &lt;&lt; size &lt;&lt; &quot;\\t return: &quot; &lt;&lt; p &lt;&lt; endl; return p; &#125; void Foo::operator delete(void* pdead, size_t size) &#123; cout &lt;&lt; &quot;Foo::operator delete(), pdead= &quot; &lt;&lt; pdead &lt;&lt; &quot; size= &quot; &lt;&lt; size &lt;&lt; endl; free(pdead); &#125; void* Foo::operator new[](size_t size) &#123; Foo* p = (Foo*)malloc(size); //crash, 問題可能出在這兒 cout &lt;&lt; &quot;Foo::operator new[](), size=&quot; &lt;&lt; size &lt;&lt; &quot;\\t return: &quot; &lt;&lt; p &lt;&lt; endl; return p; &#125; void Foo::operator delete[](void* pdead, size_t size) &#123; cout &lt;&lt; &quot;Foo::operator delete[](), pdead= &quot; &lt;&lt; pdead &lt;&lt; &quot; size= &quot; &lt;&lt; size &lt;&lt; endl; free(pdead); &#125; //------------- void test_overload_operator_new_and_array_new() &#123; cout &lt;&lt; &quot;\\ntest_overload_operator_new_and_array_new().......... \\n&quot;; cout &lt;&lt; &quot;sizeof(Foo)= &quot; &lt;&lt; sizeof(Foo) &lt;&lt; endl; &#123; Foo* p = new Foo(7); delete p; Foo* pArray = new Foo[5]; //無法給 array elements 以 initializer delete[] pArray; &#125; &#123; cout &lt;&lt; &quot;testing global expression ::new and ::new[] \\n&quot;; // 這會繞過 overloaded new(), delete(), new[](), delete[]() // 但當然 ctor, dtor 都會被正常呼叫. Foo* p = ::new Foo(7); ::delete p; Foo* pArray = ::new Foo[5]; ::delete[] pArray; &#125; &#125; &#125; //namespace int main(void) &#123; jj06::test_overload_operator_new_and_array_new(); return 0; &#125; 编译运行结果如下： 测试二： #include &lt;vector&gt; //for test #include &lt;cstddef&gt; #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; namespace jj07 &#123; class Bad &#123; &#125;; class Foo &#123; public: Foo() &#123; cout &lt;&lt; &quot;Foo::Foo()&quot; &lt;&lt; endl; &#125; Foo(int) &#123; cout &lt;&lt; &quot;Foo::Foo(int)&quot; &lt;&lt; endl; // throw Bad(); &#125; //(1) 這個就是一般的 operator new() 的重載 void* operator new(size_t size)&#123; cout &lt;&lt; &quot;operator new(size_t size), size= &quot; &lt;&lt; size &lt;&lt; endl; return malloc(size); &#125; //(2) 這個就是標準庫已經提供的 placement new() 的重載 (形式) // (所以我也模擬 standard placement new 的動作, just return ptr) void* operator new(size_t size, void* start)&#123; cout &lt;&lt; &quot;operator new(size_t size, void* start), size= &quot; &lt;&lt; size &lt;&lt; &quot; start= &quot; &lt;&lt; start &lt;&lt; endl; return start; &#125; //(3) 這個才是嶄新的 placement new void* operator new(size_t size, long extra)&#123; cout &lt;&lt; &quot;operator new(size_t size, long extra) &quot; &lt;&lt; size &lt;&lt; &#39; &#39; &lt;&lt; extra &lt;&lt; endl; return malloc(size + extra); &#125; //(4) 這又是一個 placement new void* operator new(size_t size, long extra, char init)&#123; cout &lt;&lt; &quot;operator new(size_t size, long extra, char init) &quot; &lt;&lt; size &lt;&lt; &#39; &#39; &lt;&lt; extra &lt;&lt; &#39; &#39; &lt;&lt; init &lt;&lt; endl; return malloc(size + extra); &#125; //(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new) //! void* operator new(long extra, char init) &#123; //[Error] &#39;operator new&#39; takes type &#39;size_t&#39; (&#39;unsigned int&#39;) as first parameter [-fpermissive] //! cout &lt;&lt; &quot;op-new(long,char)&quot; &lt;&lt; endl; //! return malloc(extra); //! &#125; //以下是搭配上述 placement new 的各個 called placement delete. //當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起. //應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory. //(1) 這個就是一般的 operator delete() 的重載 void operator delete(void*, size_t) &#123; cout &lt;&lt; &quot;operator delete(void*,size_t) &quot; &lt;&lt; endl; &#125; //(2) 這是對應上述的 (2) void operator delete(void*, void*) &#123; cout &lt;&lt; &quot;operator delete(void*,void*) &quot; &lt;&lt; endl; &#125; //(3) 這是對應上述的 (3) void operator delete(void*, long) &#123; cout &lt;&lt; &quot;operator delete(void*,long) &quot; &lt;&lt; endl; &#125; //(4) 這是對應上述的 (4) //如果沒有一一對應, 也不會有任何編譯報錯 void operator delete(void*, long, char) &#123; cout &lt;&lt; &quot;operator delete(void*,long,char) &quot; &lt;&lt; endl; &#125; private: int m_i; &#125;; ​​ //————-​ void test_overload_placement_new()​ {​ cout &lt;&lt; “\\n\\n\\ntest_overload_placement_new()………. \\n”;​​ Foo start; //Foo::Foo​ Foo* p1 = new Foo; //op-new(size_t) Foo* p2 = new (&amp;start) Foo; //op-new(size_t,void*) Foo* p3 = new (100) Foo; //op-new(size_t,long) Foo* p4 = new (100, ‘a’) Foo; //op-new(size_t,long,char) Foo* p5 = new (100) Foo(1); //op-new(size_t,long) op-del(void*,long) Foo* p6 = new (100, &#39;a&#39;) Foo(1); // Foo* p7 = new (&amp;start) Foo(1); // Foo* p8 = new Foo(1); // //VC6 warning C4291: &#39;void *__cdecl Foo::operator new(unsigned int)&#39; //no matching operator delete found; memory will not be freed if //initialization throws an exception &#125; &#125; //namespace int main(void) &#123; jj07::test_overload_placement_new(); return 0; &#125; 编译运行结果如下： 五、pre-class allocator 案例如下： #include &lt;cstddef&gt; #include &lt;iostream&gt; using namespace std; namespace jj04 &#123; //ref. C++Primer 3/e, p.765 //per-class allocator class Screen &#123; public: Screen(int x) : i(x) &#123; &#125;; int get() &#123; return i; &#125; void* operator new(size_t); void operator delete(void*, size_t); //(2) //! void operator delete(void*); //(1) 二擇一. 若(1)(2)並存,會有很奇怪的報錯 (摸不著頭緒) private: Screen* next; static Screen* freeStore; static const int screenChunk; private: int i; &#125;; Screen* Screen::freeStore = 0; const int Screen::screenChunk = 24; void* Screen::operator new(size_t size) &#123; Screen *p; if (!freeStore) &#123; //linked list 是空的，所以攫取一大塊 memory //以下呼叫的是 global operator new size_t chunk = screenChunk * size; freeStore = p = reinterpret_cast&lt;Screen*&gt;(new char[chunk]); //將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來 for (; p != &amp;freeStore[screenChunk - 1]; ++p) p-&gt;next = p + 1; p-&gt;next = 0; &#125; p = freeStore; freeStore = freeStore-&gt;next; return p; &#125; ​​ //! void Screen::operator delete(void *p) //(1)​ void Screen::operator delete(void *p, size_t) //(2)二擇一​ {​ //將 deleted object 收回插入 free list 前端​ (static_cast&lt;Screen*&gt;(p))-&gt;next = freeStore;​ freeStore = static_cast&lt;Screen*&gt;(p);​ }​​ //————-​ void test_per_class_allocator_1()​ {​ cout &lt;&lt; “\\ntest_per_class_allocator_1()………. \\n”;​ cout &lt;&lt; sizeof(Screen) &lt;&lt; endl; //8 size_t const N = 100; Screen* p[N]; for (int i = 0; i&lt; N; ++i) p[i] = new Screen(i); //輸出前 10 個 pointers, 用以比較其間隔 for (int i = 0; i&lt; 10; ++i) cout &lt;&lt; p[i] &lt;&lt; endl; for (int i = 0; i&lt; N; ++i) delete p[i]; &#125; &#125; //namespace int main(void) &#123; jj04::test_per_class_allocator_1(); return 0; &#125; 编译运行结果如下： 每个对象以8byte对齐。内存池本质上是分配了一大块内存，然后将该内存分割为多个小块通过链表拼接起来，所以物理上不一定连续但是逻辑上是连续的。 案例如下： #include &lt;cstddef&gt; #include &lt;iostream&gt; using namespace std; namespace jj05 &#123; //ref. Effective C++ 2e, item10 //per-class allocator class Airplane &#123; //支援 customized memory management private: struct AirplaneRep &#123; unsigned long miles; char type; &#125;; private: union &#123; AirplaneRep rep; //此針對 used object Airplane* next; //此針對 free list &#125;; public: unsigned long getMiles() &#123; return rep.miles; &#125; char getType() &#123; return rep.type; &#125; void set(unsigned long m, char t) &#123; rep.miles = m; rep.type = t; &#125; public: static void* operator new(size_t size); static void operator delete(void* deadObject, size_t size); private: static const int BLOCK_SIZE; static Airplane* headOfFreeList; &#125;; Airplane* Airplane::headOfFreeList; const int Airplane::BLOCK_SIZE = 512; void* Airplane::operator new(size_t size) &#123; //如果大小錯誤，轉交給 ::operator new() if (size != sizeof(Airplane)) return ::operator new(size); Airplane* p = headOfFreeList; //如果 p 有效，就把list頭部移往下一個元素 if (p) headOfFreeList = p-&gt;next; else &#123; //free list 已空。配置一塊夠大記憶體， //令足夠容納 BLOCK_SIZE 個 Airplanes Airplane* newBlock = static_cast&lt;Airplane*&gt; (::operator new(BLOCK_SIZE * sizeof(Airplane))); //組成一個新的 free list：將小區塊串在一起，但跳過 //#0 元素，因為要將它傳回給呼叫者。 for (int i = 1; i &lt; BLOCK_SIZE - 1; ++i) newBlock[i].next = &amp;newBlock[i + 1]; newBlock[BLOCK_SIZE - 1].next = 0; //以null結束 // 將 p 設至頭部，將 headOfFreeList 設至 // 下一個可被運用的小區塊。 p = newBlock; headOfFreeList = &amp;newBlock[1]; &#125; return p; &#125; // operator delete 接獲一塊記憶體。 // 如果它的大小正確，就把它加到 free list 的前端 void Airplane::operator delete(void* deadObject, size_t size) &#123; if (deadObject == 0) return; if (size != sizeof(Airplane)) &#123; ::operator delete(deadObject); return; &#125; Airplane *carcass = static_cast&lt;Airplane*&gt;(deadObject); carcass-&gt;next = headOfFreeList; headOfFreeList = carcass; &#125; //------------- void test_per_class_allocator_2() &#123; cout &lt;&lt; &quot;\\ntest_per_class_allocator_2().......... \\n&quot;; cout &lt;&lt; sizeof(Airplane) &lt;&lt; endl; //8 size_t const N = 100; Airplane* p[N]; for (int i = 0; i&lt; N; ++i) p[i] = new Airplane; ​​ //隨機測試 object 正常否​ p[1]-&gt;set(1000, ‘A’);​ p[5]-&gt;set(2000, ‘B’);​ p[9]-&gt;set(500000, ‘C’);​ cout &lt;&lt; p[1] &lt;&lt; ‘ ‘ &lt;&lt; p[1]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[1]-&gt;getMiles() &lt;&lt; endl;​ cout &lt;&lt; p[5] &lt;&lt; ‘ ‘ &lt;&lt; p[5]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[5]-&gt;getMiles() &lt;&lt; endl;​ cout &lt;&lt; p[9] &lt;&lt; ‘ ‘ &lt;&lt; p[9]-&gt;getType() &lt;&lt; ‘ ‘ &lt;&lt; p[9]-&gt;getMiles() &lt;&lt; endl;​​ //輸出前 10 個 pointers, 用以比較其間隔​ for (int i = 0; i&lt; 10; ++i)​ cout &lt;&lt; p[i] &lt;&lt; endl;​ for (int i = 0; i&lt; N; ++i) delete p[i]; } } //namespace int main(void) &#123; jj05::test_per_class_allocator_2(); return 0; &#125; 编译运行结果如下： 这种做法有几点比较有意思，首先是使用了union保存链表元素的next指针，这样整体上可以节省空间；其次是delete函数，它并没有直接将目标元素删除，而是将它当作下一个可分配的内存空间，也就是说如果delete某元素，那么该元素占有的内存空间不会被free掉，而是在下一次调用new时分配给新的对象。 六、static allocator 代码如下： #include &lt;cstddef&gt; #include &lt;iostream&gt; #include &lt;complex&gt; using namespace std; namespace jj09 &#123; class allocator &#123; private: struct obj &#123; struct obj* next; //embedded pointer &#125;; public: void* allocate(size_t); void deallocate(void*, size_t); void check(); private: obj* freeStore = nullptr; const int CHUNK = 5; //小一點方便觀察 &#125;; void* allocator::allocate(size_t size) &#123; obj* p; if (!freeStore) &#123; //linked list 是空的，所以攫取一大塊 memory size_t chunk = CHUNK * size; freeStore = p = (obj*)malloc(chunk); //cout &lt;&lt; &quot;empty. malloc: &quot; &lt;&lt; chunk &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; endl; //將分配得來的一大塊當做 linked list 般小塊小塊串接起來 for (int i = 0; i &lt; (CHUNK - 1); ++i) &#123; //沒寫很漂亮, 不是重點無所謂. p-&gt;next = (obj*)((char*)p + size); p = p-&gt;next; &#125; p-&gt;next = nullptr; //last &#125; p = freeStore; freeStore = freeStore-&gt;next; //cout &lt;&lt; &quot;p= &quot; &lt;&lt; p &lt;&lt; &quot; freeStore= &quot; &lt;&lt; freeStore &lt;&lt; endl; return p; &#125; void allocator::deallocate(void* p, size_t) &#123; //將 deleted object 收回插入 free list 前端 ((obj*)p)-&gt;next = freeStore; freeStore = (obj*)p; &#125; void allocator::check() &#123; obj* p = freeStore; int count = 0; while (p) &#123; cout &lt;&lt; p &lt;&lt; endl; p = p-&gt;next; count++; &#125; cout &lt;&lt; count &lt;&lt; endl; &#125; //-------------- class Foo &#123; public: long L; string str; static allocator myAlloc; public: Foo(long l) : L(l) &#123; &#125; static void* operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; static void operator delete(void* pdead, size_t size) &#123; return myAlloc.deallocate(pdead, size); &#125; &#125;; allocator Foo::myAlloc; ​​ class Goo {​ public:​ complex c;​ string str;​ static allocator myAlloc;​ public:​ Goo(const complex&amp; x) : c(x) { }​ static void* operator new(size_t size)​ { return myAlloc.allocate(size); }​ static void operator delete(void* pdead, size_t size)​ {​ return myAlloc.deallocate(pdead, size);​ }​ };​ allocator Goo::myAlloc;​​ //————-​ void test_static_allocator_3()​ {​ cout &lt;&lt; “\\n\\n\\ntest_static_allocator()………. \\n”;​ { Foo* p[100]; cout &lt;&lt; &quot;sizeof(Foo)= &quot; &lt;&lt; sizeof(Foo) &lt;&lt; endl; for (int i = 0; i&lt;23; ++i) &#123; //23,任意數, 隨意看看結果 p[i] = new Foo(i); cout &lt;&lt; p[i] &lt;&lt; &#39; &#39; &lt;&lt; p[i]-&gt;L &lt;&lt; endl; &#125; //Foo::myAlloc.check(); for (int i = 0; i&lt;23; ++i) &#123; delete p[i]; &#125; //Foo::myAlloc.check(); &#125; &#123; Goo* p[100]; cout &lt;&lt; &quot;sizeof(Goo)= &quot; &lt;&lt; sizeof(Goo) &lt;&lt; endl; for (int i = 0; i&lt;17; ++i) &#123; //17,任意數, 隨意看看結果 p[i] = new Goo(complex&lt;double&gt;(i, i)); cout &lt;&lt; p[i] &lt;&lt; &#39; &#39; &lt;&lt; p[i]-&gt;c &lt;&lt; endl; &#125; //Goo::myAlloc.check(); for (int i = 0; i&lt;17; ++i) &#123; delete p[i]; &#125; //Goo::myAlloc.check(); &#125; &#125; &#125; //namespace int main(void) &#123; jj09::test_static_allocator_3(); return 0; &#125; 编译运行结果如下： 之前的几个版本都是在类的内部重载了operator new()和operator delete()函数，这些版本都将分配内存的工作放在这些函数中，但现在的这个版本将这些分配内存的操作放在了allocator类中，这就渐渐接近了标准库的方法。从上面的代码中可以看到，两个类Foo和Goo中operator new()和operator delete()函数等很多部分代码类似，于是可以使用宏来将这些高度相似的代码提取出来，简化类的内部结构，但最后达到的结果是一样的： 七、global allocator上面我们自己定义的分配器使用了一条链表来管理内存的，但标准库却用了多条链表来管理，这在后续会详细介绍： 八、new handler 如果用户调用new申请一块内存，如果由于系统原因或者申请内存过大导致申请失败，这时将抛出异常，在一些老的编译器中可能会直接返回0，可以参考上图右边代码，当无法分配内存时，operator new()函数内部将调用_calnewh()函数，这个函数通过左边的typedef传入，看程序员是否能自己写一个handler处理函数来处理该问题。一般有两个选择，让更多的Memory可用或者直接abort()或exit()。下面是测试的一个结果： 该部分中自定义了处理函数noMoreMemory()并通过set_new_handler来注册该处理函数，在BCB4编译器中会调用到自定义的noMoreMemory()函数，但在右边的dev c++中却没有调用，这个还要看平台。 九、=default和=delete 更加详细的内容可以参考下面这篇文章: https://blog.csdn.net/u012333003/article/details/25299939","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++内存管理机制","slug":"C-内存管理机制","permalink":"http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"}]},{"title":"Games-101|光线追踪部分","slug":"Games-101/Games101-光追部分","date":"2022-03-25T09:25:10.000Z","updated":"2022-06-29T14:59:01.221Z","comments":true,"path":"2022/03/25/Games-101/Games101-光追部分/","link":"","permalink":"http://icecorn.github.io/2022/03/25/Games-101/Games101-%E5%85%89%E8%BF%BD%E9%83%A8%E5%88%86/","excerpt":"","text":"Games101 光追部分Ray Tracing光栅化是局部光照模型，无法体现出全局光照的效果（比如软阴影，全局光照，glossy reflection) 所以出现了光线追踪技术，但是光追相比光栅化很慢 从每个像素射出一根光线，打到好多物体，这里可以很方便的得到深度信息 有了焦点，将焦点和光源连接，如果没有遮挡就着色，如果有遮挡说明这个位置在这个光源形成的阴影里 Whitted-Style Ray Tracing递归处理的光追 模拟光的折射和反射，然后将下图中的红色框住的点分别进行着色，然后在进行加权最后作为该像素的颜色，当然还要考虑阴影信息，判断某一个点是否要进入加权。这里我们可以控制反射/折射的次数 光线和物体求交点Ray-Surface Intersection 定义射线，有点O和方向d来表示 隐式表面求光线和球的交点 交点P既在射线上又在球上，只有t未知，联立求解 t必须是正的 针对复杂的隐式表达的曲面，都可以用这种方法求解，数值计算 显示表面光线和三角网格求交点，遍历每个三角面片求角点（必然为0或1个交点） 先求光线和三角面片所在平面的角点，在判断交点是否在三角形内 平面可以用一个点+平面法向来定义 另一种直接算交点的方法 直接用重心坐标进行联立等式求解 加速求交点光线和每个面片都算一遍求交太慢了，需要进行加速 利用包围盒和空间、物体划分方法加速光追轴对齐包围盒Axis-Aligned Bounding Box 思想就是将模型包围起来，如果一个光线和包围盒都没有交点，那么它一定和模型没有交点，这样只用考虑6个面就好了 判断光线和盒子是否相交 求三组tmin和tmax的交集得出tenter和texit 当且仅当下方红框，光线和包围盒有交点 另外要说的一点是这个盒子其实都是和着色空间轴平行的盒子，这样方便计算 空间划分算法利用AABB包围盒的空间划分加速算法 均匀空间划分Uniform Spatial Partitions(Grids) 对每个物体求一个包围盒，在与三角形面求交之前先对包围盒求交，这样不是已经可以达到不错加速效果了吗？作者认为可以考虑这样两个极端情况： 1 整个场景只有一个极其复杂的单一人物模型，那么只对这一个物体做包围盒的话，相当于对效率没有任何提升 2 整个场景充斥着大量的细小模型，如草，花之类的，每个模型可能只有很少的面，如果此时对每个物体求包围盒，得到的包围盒数量会相当之多，对于光线追踪效率来说效率提升有限 基于以上两点考虑，AABB并不应只局限于以物体模型为单位，可以更加精细的考虑到以三角面为单位。另外对于场景的许许多多包围盒来说应该要有一种数据结构将其统领起来。 因此如何更好的划分场景形成不同的AABB，使得划分之后的AABB能够更好的加速光线追踪，这就是接下来要考虑的问题关键！ (以下的划分形成的AABB更是一种general的概念，可能不会严格包围物体，读者不必纠结) 那么接下来就从最简单的划分方法，均匀空间划分开始介绍。 第一步对所要考虑的场景找一个包围盒： 找包围盒 画网格 在每个格子上存储物体模型 紧接着，根据光线的方向与判断出所有相交的方格(这一步可以利用bresenham算法，就是如何光栅化一条线)，倘若方格中存储有物体，再进一步与方格中的物体模型或是三角形面求交。 光线和格子求交点是非常快的 以上就是均匀空间划分的全部过程了，简单来说就是将空间划分为多个均匀的小的AABB，再根据光线方向找出相交grid(这一步并不需要判断所有方格，正如上文提示，可以用brenham类似的方法来做)，再判断grid中是否存储了模型信息，若有则进一步求交。（这种划分方法假设了找出相交方格要比直接判断与物体求交相对容易，因此划分方格数的多少也是性能的关键，方格太少，没有加速效果，方格太多，判断与方格的求交可能会拖累效率） 因此这种方法最适合的场景就是空间中均匀布满了三角形面，如果说场景较为空旷，物体较小且分离得比较开，那么均匀分割的效果就会很差了，因为会有很多无效的方格与光线的求交过程。 KD-Tree空间划分几种空间划分算法： 第一种Oct-Tree，也就是八叉树，每次将空间分为8个相等的部分，再递归的对子空间进行划分，因为图中是2维例子，所以只划分了4部分。当划分的子空间足够小或是空间中三角形面的数量很少的时候会停止划分。这种方法的显著缺点是，随着维度的上升划分的空间数量会呈指数级增长。 第二种KD-Tree，也是本小节将要主要介绍的方法，其每次将空间划分为两部分，且划分依次沿着x-axis，y-axis，z-axis，即如图中所示，第一次横着将2维空间分为上下，第二次再竖着将上下两个子空间分别划分为左右部分，依次递归划分，终止条件与八叉树类似，细节问题之后按具体例子详解。 第三种BSP-Tree，其与KD-Tree类似，唯一不同的是划分不再沿着固定一轴，可以任意方向划分，缺点自然是划分的空间没有规则性，求交困难。 接下来从一个例子具体介绍KD-Tree 第一步将空间分为两部分 第二步对左右两个子空间换个方向再分为两部分(这里只画出了有半部分，其实左边也是一样) 如此递归的划分下去，且在划分过程当中遵循这样几点： 1 依次沿着x-axis,y-axis,z-axis划分，使得空间被划分的更加平衡 2 划分的位置由空间中三角面的分布决定，具体细节不展开 3 叶子节点存储对应空间的所有物体或三角面信息，中间节点仅存储指针指向两个子空间 4 当划分空间太小或是子空间内只有少量三角形则停止划分 当KD-Tree建立完成之后，如何进行光线与物体求交判断呢？过程如下： 第一步判断光线是否与最外层的包围盒相交 如果相交进一步判断是否与对应的两个子空间相交 注意！因图中做了简化，最大包围盒的左半边并没继续进行划分(实际上应该要划分的)，所以左半部分对应的1号空间是叶子节点，如果光线与之相交，进一步判断与存储与叶子节点的物体信息求交。左半边判断完之后，接着判断右半部分 同样如果对于有半部分存在相交情况，则对于右半部分的所有子空间，递归的执行这个步骤即可 更加具体的过程不再展开。 优点： 利用KD-Tree的结构来构建AABB的好处是倘若光线与哪一部分空间不相交，那么则可以省略该部分空间所有子空间的判断过程，在原始的纯粹的AABB之上更进一步提升了加速效率。 缺点： 缺点是判断包围盒与三角面的是否相交较难，因此划分的过程不是那么想象的简单 其次同一个三角面可能被不同的包围盒同时占有，这两个不同包围盒内的叶节点会同时存储这一个三角形面 综上所述，我们详细介绍了利用AABB的均匀划分方法，KD-Tree划分方法，也简略提及了Oct-Tree以及BSP-Tree。但其实这些技术在业界之中以及逐渐不再被多使用，但依然有很多借鉴参考价值，在下面一节会介绍一种现在被广泛使用的加速光线追踪的方法，即Bounding Volume Hierarchy。 BVH划分(对物体的划分)Bounding Volume Hierarchy BVH与前几种方法最显著的区别 就是，不再以空间作为划分依据，而是从对象的角度考虑，即三角形面，过程如下： 第一步同样找出场景的整体包围盒作为根节点 第二步找到合适的划分点，将最大包围盒内的三角形面分为两部分，再分别重新就算新的包围盒 注意到这里，包围盒会重叠，但一个三角形面只会被存储在唯一的包围盒内，而这也就解决了KD-Tree的缺点！ 接下来与KD-Tree的建立类似，递归的对所有子空间重复该步骤 最终可以建立出如上图的所示的树形结构，同样为了画图方便，只进行了左半部分的划分，右半部分其实同理。 tips： 每次划分一般选择最长的那一轴划分，假设是x轴，那么划分点选择所有三角面的重心坐标在x坐标上的中位数进行划分（快排思想二分，O(n）)，如此便能保证划分的三角形左右两边三角形数量尽可能差不多，当然也就使得树形结构建立的更加平衡，深度更小，平均搜索次数更少，提高了效率，这些都是数据结构的知识，相信大家掌握的都不错，就不多赘述了。 与KD-Tree一样，中间节点不存储物体三角面信息，只在叶节点中存储，终止条件可设定为当前包围盒内三角形数量足够少 （e.g. 5个） 最后给出这样一个BVH加速结构遍历节点的伪代码参考： 基于物理渲染的基础知识首先要说明的是通过上文的处理我们获得了交点，并且简单的使用blinn-Phong模型加权平均来着色，这显然是不准确的，而PBR就是在如何正确处理着色的方法。 为什么需要辐射度量学？首先，想一想到目前为止我们对光线亮度的定义是什么？只是简单的用3维(R,G,B)向量来描述，但却没有任何的单位，如果想要一个完全正确的模型，这显然是不应该的，必须用合适的物理量来描述光线！ 其次，考虑在前两篇文章中提到的whited-style光线追踪模型，它真的是一个正确的模型吗？显然不是，原因如下： 1 whited-style光线追踪并没有对漫反射的光线进行追踪，而是直接返回当前着色点颜色 2 在计算光源直接照射的贡献时，使用了Blinn-Phong模型，而Blinn-Phong模型本身就是一个不准确的经验模型，使用的这种模型的whited-style光线追踪自身自然也是不正确的 而就以上的各种缺点而言，所有的问题都能在辐射度量学之中得到完美解决！ 辐射度量学辐射度量学其实是对光照的一套测量系统和单位，它能够准确的描述光线的物理性质。 几个基本概念： 辐射能量(Radiant energy) 辐射通量(Radiant flux) 辐射强度(Radiant intensity) irradiance radiance 辐射能量和辐射通量Radiant energy定义： 所谓辐射能量其实非常直观，就是辐射出来的电磁能量，单位为焦耳。可以用物理当中的做功的大小来进行类比。 接下来是Radiant flux(power)： 所谓辐射通量或者说辐射功率，其实就是在辐射能量的基础之上除以时间，也就是单位时间的能量。同样也可以用物理当中的功率来进行类比。在光学中能量的单位通常用lumen流明 (tips: 具体来说一般偏向用radiant flux来衡量光线的亮度，因为我们更关心的是单位时间的效果，事实上也是这么做的，想想在说白炽灯泡的时候也是说60W亮度，80W亮度) 辐射强度在进行具体的数学定义之前，先借助如下一张图建立对剩下3个概念的一些直观的理解： Radiant itensity其实就是指从一个光源出发某一方向上的亮度 Irradiance指某一微小平面所接受到的光线亮度 radiance衡量的是一条传播光线所具有的亮度(不受传播方向影响而改变) （这里的亮度也可以理解为radiant flux(power)。） 好了，接下来首先看Radiant intensity的数学定义： Radiant intensity一句话来说就是从光源发出的每单位立体角上的功率，关于辐射功率的定义在上文已经解释，这里唯一还不知道的就是立体角(solid angle)了。 solid angle其实就是对应二维空间中圆的弧度在三维空间中球上的拓展。 首先看在二维计算弧度公式如下： 即 (至于为什么这么算，中学知识这里就不展开了。) 那么对应在三维上的球的弧度(立体角)，只需进行一个简单的扩展如下： 即立体角度所对应球上的投影面积比上半径的平方，整个球的立体角为。 那么对于Radiant intensity的定义当中，微分立体角计算如下： 首先确定空间中一个方向(通过)，在这两个角度上分别增加一个微分值，则可以计算出如图中所示的对应到球上的投影面积。其中就是微分面积元的高，是微分面积元的宽，二者相乘，自然就是面积了，再根据立体角的定义除以 即可得到微分立体角了。 在此还可以验证下，对在整个球上积分： 与之前所讲的球的立体角为一致。 tips： 注意在计算微分立体角之前，我们其实选定了空间当中的一个方向（由所确定），称这个方向为，然后才在此基础之上分别对增加经计算得到最终的，因此Radiant intensity的物理含义此时就很清楚了，为光源向某一方向所发射出的单位立体角的功率，简而言之就是光源在某个方向上的亮度如何！ 最后举一个对各向同性点光源计算Radiant intensity的例子： 因为各项同性点光源所有方向上的亮度都与方向无关，因此立体角可以直接积分出来为，最终计算得。 (如果不是各项同性的话这里的应该为一个关于方向的的函数) 以上就已经详细介绍完了关于Radiant intensity的定义，接下来给出irradiance的相关定义 irradiance 同样用一句话来说，irradiance是指每单位照射面积所接收到的power，单位如图中所示。 借助于irradiance，可以很轻松的解释在Blinn-Phong所提到的Lambert’s Law,即光线亮度在计算时需要乘上一个，如下图所示： 当光线垂直照射平面时，如上图左边所示，照射到平面上的面积与光线本身的“宽度一致”。但当光线斜着照射到平面时，此时的照射面积就不再是光线本身的“宽度”了，具体来说此时的照射面积。 那么针对右边情况的irradiance的计算就应该为： ，相对于多了一个。 而这其实也就解释了Lambert’s Law要乘以一个的原因了。 此外，回想一下也是在Blinn-Phong模型所提到的光线越远会越加衰减： 该现象也完全可以用irradiance解释，因为光的功率始终一致，离点光源所照射到的圆球面积也就越大，因此根据irradiance的式子，分母的面积值也就越大，irradiance也就越小。 radiance最后，我们终于来到了最后一条概念了，这条概念也是所有辐射度量学的概念当中最为重要的一个，那么首先直接就来看他的数学定义是怎么样的： 用一句话概述的话，所谓radiance就是指每单位立体角，每单位垂直面积的功率，直观来看的话，很像是Intensity和irradiance的结合。它同时指定了光的方向与照射到的表面所接受到的亮度。 但这里有一个细微的区别，在irradiance中定义的每单位照射面积，而在radiance当中，为了更好的使其成为描述一条光线传播中的亮度，且在传播过程当中大小不随方向改变，所以在定义中关于接收面积的部分是每单位垂直面积，而这一点的不同也正解释了图中式子分母上的，具体可以观察如下图： 即图中的是irradiance中定义所对应的，而才是radiance中所定义的面积。二者之间的关系为。 (以上各项定义确实比较绕，我在闫老师的讲解上又去借鉴了PBR书中的定义，对这些概念加以了自己的解释，希望能对大家有帮助！) 好了，在理解了radiance和irradiance的定义之后，再讨论讨论它们之间的关系，通过二者的定义式子，不难得出如下结果： 进一步推导得到： 观察一下积分后的式子，就是点p的irradiance，其物理含义是上文所提到过的点p上每单位照射面积的功率，而指入射光每立体角，每垂直面积的功率，因此积分式子右边的解释了面积上定义的差异，而对积分，则是相当于对所有不同角度的入射光线做一个求和，那么该积分式子的物理含义便是，一个点(微分面积元)所接收到的亮度(irradiance)，由所有不同方向的入射光线亮度(radiance)共同贡献得到。 双向反射分布函数(BRDF)Bidirectional Scattering Distribution Function 通过上述所有辐射度量学各种概念的定义之后，我们可以从这样一个角度理解光线的反射，如下图所示： 一个点(微分面积元)在接受到一定方向上的亮度()之后，再向不同方向把能量辐射出去() 从直观的理解来说，不同物体表面材质自然会把一定方向上的入射亮度(反射到不同的方向的光线上()， 如理想光滑表面会把入射光线完全反射到镜面反射方向，其它方向则完全没有。如理想粗糙表面会把入射光线均匀的反射到所有方向。因此所谓BRDF就是描述这样一个从不同方向入射之后，反射光线分布情况的函数，定义如下： 上图中下方的式子即为BRDF，它接收两个参数，入射光方向,反射光方向，函数值为反射光的radiance与入射光的iiradiance的比值。(从某个方向接受到的光能有多少反射到另外一个方向) 借助BRDF，可以定义出反射方程如下： 即摄像机所接受到的方向上的反射光，是由所有不同方向上入射光线的irradiance贡献得到的(即图中式子的)，而不同方向入射光线的irradiance对反射方向的贡献程度则由物体表面材质决定，所以乘上了一个BRDF函数。 到这里，通过辐射度量学，以及BRDF最终得到的反射方程正是一个完全正确的光线传播模型了，解决了在第一章提到的现有模型的所有缺点！（渲染方程只是在反射方程的基础之上加了一个自发光项，关于渲染方程会在下一章仔细去了解)。 在进入到渲染方程之前，再仔细观察一下反射方程： 不难发现正如上图中所说的，入射光线的radiance不仅仅是光源所引起的，还有可能是其他物体上着色点的反射光线的radiance，恰好反射到当前的着色点p(即间接光照)，同时其他物体上的反射光线的radiance依然也是由直接光照和间接光照构成，因此这与whitted-style当中的光线追踪过程十分类似，也是一个递归的过程。所以说想要解这样一个方程还是比较难的。 接下来，在最后一章我们会引入渲染方程，并对渲染方程做一些直观上的物理解释，对于反射方程或者说是渲染方程的具体求解，留在下一篇文章里面去说。 渲染方程及其物理含义解释正如在上一节中提到的，渲染方程知识在反射方程的基础之上添加了一个自发光项(Emission term)，从而使得反射方程更加的general： 其中为自发光项，反射方程中的用，代替。 (tips：所有光线方向均指向外) 接下来从一个点光源和单个物体的场景开始理解渲染方程： (点光源对一个点来说自然只有一个方向有入射光，所以这里没有了积分) 多个点光源一个物体的情况： 将这些所有的点光源的贡献全部求和即可，那么如果点光源变成了面光源呢？如下图所示： 其实面光源就相当于无穷多个点光源的集合，只需要对 面光源所在的立体角范围进行积分，并且能够确定不同立体角方向的面光源的入射光radiance即可。 那么更进一步的，再在场景当中加入其它物体，使得物体之间发生光线交互之后是什么情况呢： 如上图所示，可以把其它物体同样考虑成面光源，对其所占立体角进行积分即可，只不过对其它物体的立体角积分不像是面光源所有入射方向都有radiance，物体的立体角可能只有个别几个方向有入射的radiance(即多次物体间光线反射之后恰好照射到着色点x)，其它方向没有，但本质上都可以视作是面光源。 观察一下图中的渲染方程可以发现除了两个radiance，其它所有项都是知道的，可以将上式进一步写成如下图下方所示的式子： 其中各项与原渲染方程中一一对应，(这里其实是有数学严格推导的，不过我们只是为了接下来构建直观的物理解释，对于这些推导不必在意，默认成立即可)，再接着，可以把该式子离散化写为线性代数的形式： 呼，经过两步我们不是很清楚但其实是正确的数学推导之后，得到了这样一个式子： 其中L其实就是想要求得的反射光，E是自发光其实就是光源的发光项，K可以理解为对光线进行反射的一种算子操作(因为它由BRDF化来的)。那么利用线性代数的知识很容易就可以推导出L的结果如下： 其中为单位矩阵，再接着对使用广义二项式定理得到： 仔细观察这个式子，注意E是光源所发出的光，K为反射算子，这样一个式子的物理含义如下图所示： E为光源发出的光，KE则代表对光源反射一次的结果，即直接光照，那么前两项之和就是光栅化当中着色所考虑的结果，对于全局光照来说，还考虑了，即一次弹射的间接照明，就是两次弹射的间接照明，依次类推。 这样来看整个结果是不是就很清晰了，就是光源发光加上直接光照与多次间接光照的结果！而这一切都是从渲染方程推导而来的，因此这也正是渲染方程的物理意义！ 最后以几张基于物理渲染的图片作为本篇文章的结束 一次反射直接光照： 两次反射，考虑到一次弹射的间接光照： 3次反射，考虑到两次弹射的间接光照： (考虑次数越多越接近真实图片效果,趋近收敛) 以上就是所有的关于PBR的一些相关基础知识了，我们从辐射度量学入手，掌握了正确衡量光线属性的方法，由此定义出了BRDF，来表示物体的材质，即它对于光线的反射能量分布，最后结合辐射度量学与BRDF得到渲染方程，一个个真正完全正确的光线传播模型！ 概率密度函数概率密度函数值为1 全局光照蒙特卡洛积分求解渲染方程 我们通过对辐射度量学当中一系列概念的定义，引入了渲染方程，一个正确的光线传播模型，但并没有去涉及如何解出该渲染方程，或者说如何通过该渲染方程计算出屏幕上每一个坐标的像素值。 蒙特卡洛积分Monte Carlo Integration 首先让我们先搞懂蒙特卡洛路径追踪的这个“蒙特卡洛”的前缀到底指什么。 蒙特卡洛积分的目的： 其实就是用一种数值方法求解定积分，当一个积分很难通过解析的方式得到答案的时候可以通过蒙特卡洛的方式近似得到积分结果，如下图所示： 显然对于这样一个函数，很难去用一个数学式子去表示，因此无法用一般解析的方法直接求得积分值，而这时候就可以采用蒙特卡洛的思想了。 蒙特卡洛积分的原理及做法： 对函数值进行多次采样求均值作为积分值的近似 该做法十分容易理解，想象一下如果对上图这个函数值进行均匀采样的话，其实就相当于将整个积分面积切成了许许多多个长方形，然后将这些小长方形的面积全部加起来。没错，该做法其实就与黎曼积分的想法几乎一致。但蒙特卡洛积分更加的general，因为它可以指定一个分布来对被积分的值进行采样，定义如下： 如图所示，我们希望求出一个函数在积分域上的积分值，选定一个采样的分布，通过对该分布来进行多次的函数值采样，最后估计的值如图中最下方式子所示。 这里对该式子进行一个简单的推导。相信大家都知道，求均值的做法其实也是对期望的逼近，因此： 那么对于这样一个服从某一分布的期望的计算套公式直接计算得： 通过以上推导即可明白蒙特卡洛的近似正是对积分值的一个无偏估计。 但在本文中为了方便，所有的采样都使用均匀采样，因此很容易推出： 因此，蒙特卡洛在此来说就是一个帮助求得困难积分值的方法。 蒙特卡洛路径追踪Monte Carlo Path Tracing 回顾一下上篇文章中所得到的渲染方程： 要想解出以上方程的解主要有两个难点： 积分的计算 递归形式 而解决这些难点自然就要利用上节中所提到的蒙特卡洛积分方法了。 在进入具体计算之前，对渲染方程做出一点小修改，即舍弃一下自发光项(因为除了光源其他物体不会发光), 以方便进行计算推导： 从具体例子出发，首先仅仅考虑直接光照： 再次观察该修改过之后的方程其实就只是一个单纯的积分计算了，其物理含义为着色点p到摄像机或人眼的Radiance值。 回想第一章所提的，对于一个困难积分只要选定一个被积分变量的采样分布即可通过蒙特卡洛的方法得到积分结果的近似值，而此时的被积分值为，选定，不难得出积分近似结果如下： 正如一开始所说，先单独考虑直接光照，因此只有当采样的方向击中光源的时候，光源才会对该着色点有贡献，计算伪代码如下： 显而易见的，单独仅仅考虑直接光照自然是不够的，还需要间接光照，即当采样的方向碰撞到了别的物体，如下图所示： 此时采样的光线碰撞到了另一个物体的Q点，那么该条路径对着色点P的贡献是多少呢？自然是在点Q的直接光照再乘上反射到该方向上的百分比了！显然这是一个类似光线追踪的递归过程，不同在于该方法通过对光线方向的采样从而找出一条条可行的路径，这也正是为什么叫路径追踪的原因，伪代码如下： 至此，我们成功通过蒙特卡洛的方式解出了渲染方程的积分值，也通过考虑直接光照与间接光照解决了递归的问题。但该方法至此有一个非常致命的缺陷： 我们通过每次对光线方向的采样从而解出方程，假设每次采样100条，那么从人眼出发的第一次采样就是100条，在进行第二次反射之后就是10000条，依次类推，反射越多次光线数量便会爆炸增长，计算量会无法负担，那么如何才能使得光线数量不爆炸增长呢？唯有每次只采样一个方向！N=1 每次如果只采样一个方向那么所带来的问题也是显而易见的，积分计算的结果会非常的noisy，虽然蒙特卡洛积分是无偏估计，但样本越少显然偏差越大。但该问题很好解决，如果每次只去寻找一条路径结果不好，那么重复多次寻找到多条路径，将多条路径的结果求得平均即可！如下图所示： 改良之后的Path Tracing伪代码如下： 通过对经过像素的光线重复采样，每次在反射的时候只按分布随机选取一个方向，解决了只对经过像素的光线采样一次，而对反射光线按分布采样多次所导致的光线爆炸问题。 那么现在所有的问题都解决了吗？还没有！因为shade函数的递归没有出口，永远不会停下。 但这里并不没有采用类似光线追踪当中设定反射深度显示的给出递归出口的方法，而是非常精妙的采用了**俄罗斯轮盘赌(Russian Roulette)**。 给你一把左轮，两发子弹，你不知道哪一发会真正的射出子弹，因此拿这把左轮射自己，你有4/6的概率活下来，这就是俄罗斯轮盘赌的概念。 将其应用在路径追踪当中，首先设定一个概率, 有P的概率光线会继续递归并设置返回值为，有的概率光线停止递归，并返回0。这样巧妙的设定之下光线一定会在某次反射之后停止递归，并且计算的结果依然是无偏的，因为Radiance的期望不变，证明如下： shade函数的伪代码变更如下，使得可以停止递归了： 至此，我们的路径追踪算法已经完成大半，只差最后一个小问题！现在的路径追踪效率非常的低下，如图所示： 在每次计算直接光照的时候，通过均匀采样任选一个方向，但很少会的光线可以hit光源，尤其当光源较小的时候，这种现象越明显，大量采样的光线都被浪费了。 因此在计算直接光照的时候改进为直接对光源进行采样！这样所有采样的光线都一定会击中光源(如果中间没有别的物体)，没有光线再会被浪费了。假设光源的面积为A，那么对光源进行采样的 (因为)，但原始的渲染方程： 很明显是对光线方向进行积分的，如果想要对光源进行采样的并依然使用蒙题卡洛的方法，那么一定要将其修改为对光源面积 dA的积分，换言之就是需要找到dA与d的关系即可。如下图所示： 关系式中的是为了计算出光源上微分面积元正对半球的面积，之后再按照立体角的定义，除以着色点x与光源采样点x’距离的平方即可。于是根据图中二者的关系可将渲染方程改写如下： 这样便成功从积分转到了对光源面积A的积分，就可以利用蒙特卡洛的方法对光源进行采样从而计算直接光照的积分值了，对于间接光照，依然采用先前的方法进行光线方向的均匀采样。最终伪代码如下，分直接光照和间接光照两部分计算： tips:计算直接光照的时候还需要判断光源与着色点之间是否有物体遮挡，该做法也很简单，只需从着色点x向光源采样点x’发出一条检测光线判断是否与光源之外的物体相交即可，如图所示: 最后以一张闫老师课程的path tracing作业的截图作为结束！ 遗留问题探索 怎样去在半球面上去采样呢？采样方法？ PDF函数的选取，目前用的最简单的均匀PDF，怎么选最合理的，重要性采样原理 随机数的生成 low discrepancy sequences 将半球采样和光源采样结合起来 multiple imp sampling 混合采样 像素平均加权问题 radiance和颜色的映射，gamma矫正 HDR 颜色空间 材质和外观Materials and Appearances 以前只有Blinn Phong的时候，通过非物理的方式模拟出各种材质。Material == BRDF 决定光如何被反射 漫反射、镜面反射、折射材质 Diffuse / Lambertian Material (BRDF) 漫反射材质 Glossy material (BRDF) 有一些镜面效果，但不是完全镜面的材质","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"渲染","slug":"图形学/渲染","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"}],"tags":[{"name":"Rasterizer","slug":"Rasterizer","permalink":"http://icecorn.github.io/tags/Rasterizer/"},{"name":"Games-101","slug":"Games-101","permalink":"http://icecorn.github.io/tags/Games-101/"}]},{"title":"Games-101|光栅化渲染部分","slug":"Games-101/Games101-光栅化部分","date":"2022-03-18T09:25:10.000Z","updated":"2022-06-29T14:59:15.932Z","comments":true,"path":"2022/03/18/Games-101/Games101-光栅化部分/","link":"","permalink":"http://icecorn.github.io/2022/03/18/Games-101/Games101-%E5%85%89%E6%A0%85%E5%8C%96%E9%83%A8%E5%88%86/","excerpt":"","text":"Game-101二 向量与线性代数向量vector表示的向量，包括向量的长度，方向，单位向量等。 向量加法（平行四边形，三角形法则），用笛卡尔坐标系直接坐标相加 向量点乘： a*b = |a||b|cosθ，得到的是一个数 作用： 算向量的夹角 算b向量在a向量上的投影 衡量两个方向是不是接近的 分解一个向量（到两个垂直方向上） 通过点成&gt;0或&lt;0判断方向性 向量叉乘： |axb| = |a||b|sinθ axb = -bxa 作用： 算法向量的方向 判断左右 判断内外（经典问题，判断点在三角形内外） 矩阵矩阵乘法是没有交换律的，AB！=BA 有结合律和分配律 矩阵求逆矩阵，求转置 向量的乘积写成矩阵形式： 三 变换（二维和三维）缩放变换 反转变换 切变换（Shear）找到对应关系，这里其实相当于在x方向上进行一个线性插值 旋转变换旋转方向默认逆时针 旋转-sinθ 线性变换 平移变换需要线性变化+常数项 平移变换不属于线性变换 将平移变换转变成矩阵乘法： 通过给二维点和向量增加一个维度从而实现（齐次坐标） 点+点表示的是这两个点的中点 仿射变换 总结：通过齐次坐标实现仿射变换，它们的任何变换操作都可以变成左乘一个变换矩阵来表示 逆变换 实现上就是左乘M矩阵的逆矩阵 变换的合成与分解通过左乘很多矩阵实现变换的合成，同时也可以左乘逆矩阵实现变换的分解 三维变换类比二维的，多加一为，用4x4的矩阵表示各种变换矩阵 对于三维的旋转有很多种方法： 比如欧拉角和四元数 四 变换（MVP变换，模型，视图，投影）以拍照来类比： Model：人拍pose View：确定相机的位置，和镜头朝向等等 Projection：按下快门，把三维场景投影到照片上 视图变换首先要固定相机在（0，0，0）的位置上，并且看下-Z方向，向上方向（想想摄像机上有一根草，相机歪着的话，草也是歪着的，这就是向上方向）为Y方向因为这样之后好处理。 那么在移动过程中，就是先移动相机的位置，然后所有的物体都做同样的变换，保持相对变换就可以了 先平移，在旋转 因为要把任意的（x,y,z）旋转到（1，0，0）不好写，所以可以先求逆变换，然后因为旋转矩阵是正交矩阵，它的转置就是它的逆，所以之后再转置就可以得到正常的旋转变化了。 这样的操作（平移+旋转）就叫视图变换 投影变换3D to 2D的变化方式，分为正交投影和透视投影 正交投影并不会近大远小 简单方法： 设置相机（0，0，0），-Z，向上Y 丢掉Z坐标 变换到【-1，1】的平方这块矩形上 常规方法（图形学上）： 先把物体中心平移到【-1，1】的立方这个小正方体上，在进行缩放变换 平移中心 缩放到单位正方体 写成数学形式： 透视投影会有近大远小的特性，符合人眼，用途广泛 实现方法： 分成两步： 将中间和远平面的所有点都“挤压”到单位平面上 再做正交投影 由相似三角形，可以得到被挤压后的位置应该在哪里 由此可以反推出来变换矩阵 根据近平面点和远平面中点的不变性，用待定系数法，推出M矩阵的第三行 五 光栅化（三角形的离散化）将【-1，1】的单位立方体，呈现到屏幕上，屏幕是由像素组成的比如1980*1080 视口变换： 先把中心平移到屏幕的中心 进行M变换 整个过程我们先不考虑Z轴的问题 三角网格的优势 怎样判断一个像素是在三角形内部还是外部？ 三个向量叉乘同号 采样光栅化（Sampling）采样其实就是把函数离散化的过程 例子： 首先写一个函数 inside（tri，x，y）；表示点是否在三角形内，然后遍历像素把每个像素的值写入结果image【x】【y】中 判断点是否在三角形内很重要，有时间写一下代码 优化： 为了避免每个三角形离散都要遍历所有像素，可以进行优化 包围盒，找到min_x,min_y,max_x,max_y这样就可以确定包围盒 一行一行遍历里边的像素（适合窄的三角形） 六 光栅化（深度测试与抗锯齿）反走样-MSAA（抗锯齿）需要先做模糊（卷积）再采样 具体的原因是根据信号与系统中时域和频域的知识，简单理解去掉高频信息可以使得采样更接近（想象一下颜色都相近情况下，采样的间隔当然可以变小，换句话说同样的采样间隔，颜色相近，频率更低的函数采样起来肯定更准确） 卷积通过一个卷积核对单位像素周围的一圈像素（一环领域）平均算值，从而实现模糊的效果 超采样MSAA将每个像素点分割成4个或16个或更多个小单元，判断一个像素中有几个单元在三角形内，然后计算比例，通过这种方式实现模糊操作 注意这里的采样方式不是规规整整的4个格子，是其他有效的采样方式，比如斐波那契采样之类的，而且有一些相邻的采样点还会被相邻像素复用 快速近似抗锯齿-FXAA得到有锯齿的图，找到锯齿的边界，换成没有锯齿的图 Temporal AA-TAA复用上一帧的抗锯齿效果，这一帧再进行处理 可见性（遮挡）要把很多物体放在屏幕上，如何呈现的问题 画家算法从远到近，一个一个画，后画的遮挡前边画的 深度缓存（Z-Buffer）从像素考虑，像素永远保存里屏幕最近的元素 同时要维护两张图，一张是最后的结果图，一张是深度图 对每一个三角形（物体），遍历它的采样（像素），如果它的深度比深度图中的小，那就要更新结果图和深度图，否则什么都不做 七-九 着色（光照与基本着色模型）布林-冯模型就是在一种光源下，一个着色点如何着色的问题 全反射（高光） 漫反射 环境光照（间接光照） 着色点，光源方向，观察方向等一些参数的设置 漫反射考虑光是离散的，根据光照射到着色点，着色点接收到光的能量来计算漫反射的实际光照 n点乘l，计算夹角的cos值 漫反射和观测角度没关系 高光镜面反射，和观测方向有关 环境光 着色频率按照粒度不同可分为，按照面着色（flat shading)，按照点着色(Gouraud shading)，按照像素着色(phong shading) Gouraud shading:渲染点，求出每个点法向，然后算出点的颜色，三角形内部点颜色插值得到 phong shading:像素渲染，每个像素插值法向，然后逐像素着色 算点的法向量：是点周围的面的法向量加权平均 实时渲染管线 顶点的投影 MVP变换 光栅化，包括Z-buffer操作 着色，可分为顶点着色，或者像素着色 Shader 程序 shader是在硬件中实现的，可以定义顶点着色或者像素着色 不用写for循环，一个shader写好可以应用在所有像素或者顶点上 纹理映射纹理贴图，uv映射 三角形内属性插值通过重心坐标实现插值 重点：重心坐标在投影下是会变的，也就是说，我们要插值三维属性（比如说深度，法向）就必须在世界空间（投影前的三维空间）下进行插值。 点在三角形要保证三个参数非负 纹理就是漫反射系数 纹理太小纹理太小，可以使用双线性插值，双三次插值等 纹理太大纹理太大会引起摩尔纹等走样问题 解决方法： Mipmap 三线性插值 mipmap做近似的正方形的范围查询 其实就是一张图生成一系列分辨率不同的图 这里有个问题是远处的点采样小分辨率的图，会覆盖很多像素，那么就会做模糊，可能会引起远处全糊的情况，可以使用各向异性过滤的方法解决 凹凸贴图通过凹凸贴图在切线空间重新计算扰动后的法向量，能够达到视觉上的trick 十 几何（基本表示方法）表示方法几何有很多表示方法，大体分为隐式表示和显示表示 隐式表示就是通过一系列的函数来描述几何体，比如一个球 水平集，分形等 优点：表示起来比较容易，一个公式描述一个形状，并且判断点在几何体内外很容易 缺点：难以描述复杂模型 曲线和曲面贝塞尔曲线 B样条，曲面表示等等 网格处理网格简化，网格正规化，网格细分 Loop 细分（加密）只能用在三角形网格 先递归分解，每个面片分成几个小面片 调整点的位置（光滑处理） Catmull-Clark 细分通过增加非四边形面的奇异点，来使网格都变成四边形面 然后再光滑处理 Shadow Mapping只能处理点光源 核心思想是一个点既能被相机看到也能被光源看到","categories":[{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"渲染","slug":"图形学/渲染","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"}],"tags":[{"name":"Rasterizer","slug":"Rasterizer","permalink":"http://icecorn.github.io/tags/Rasterizer/"},{"name":"Games-101","slug":"Games-101","permalink":"http://icecorn.github.io/tags/Games-101/"}]},{"title":"操作系统思维导图","slug":"操作系统/操作系统","date":"2022-03-16T11:37:26.000Z","updated":"2022-06-29T14:18:13.925Z","comments":true,"path":"2022/03/16/操作系统/操作系统/","link":"","permalink":"http://icecorn.github.io/2022/03/16/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"操作系统线程是什么？ 线程是os能调度的最小单位，它包含在进程中，是进程的实际运作单位，但是它不拥有资源（实际上就是为了将进程拥有资源和接受os调度这两个事分开才有的线程，同时一个进程可拥有多个线程，可以是进程并发的处理任务） 有什么？ 一个线程执行状态（运行，就绪等） 线程上下文，一个独立的程序计数器（记录下一条指令地址） 用于局部变量的一些静态存储空间（栈空间）要注意这个栈空间是私有的 与进程内其他线程共享的内存和资源的访问权限 好处？ 使cpu的调度时间片粒度更小，运行一个进程时，可以分成更小的时间片给进程的各个线程 线程间切换时间要小于进程间切换 提高了不同执行程序通信的效率，因为进程内的线程共享内存，直接改就行，而不用内核接入切换进程再通信来完成 两种线程 用户态线程 这种线程对os来说是未知的，切换线程不需要状态切换，但一个进程同时只能运行一个线程。一个线程阻塞，进程就阻塞。 内核态线程 这种线程实际上就是mini进程，线程切换和进程一样会触发中断进行状态切换。当然它们也就可以再多个处理器上真正的并行执行。 进程是什么？ 一个能分配给处理器执行的程序实体 有什么？ 1.程序代码 2.数据集（系统资源） 3.进程控制块 进程控制块（由os创建和管理） 标识符：进程唯一标识符 状态：执行状态 优先级：相对其他进程的优先顺序 程序计数器：程序中即将执行的下一条指令地址 内存指针：相关代码和数据集以及和其他进程共享内存块的指针 上下文：执行时处理器寄存器中的数据 IO信息：IO请求，使用的文件列表等 记账信息：包括处理器时间总和，时钟数总和等 进程状态 运行态：进程执行中，单核的话只有一个进程为运行态 就绪态：准备好了，有机会就执行 阻塞态：在某事发生前不能执行，如IO完成 新建态：刚创建的进程，通常进程控制块建好了，但没有加载到内存中 退出态：释放了的进程 挂起态：不属于上述5个标准的状态，挂起态是把阻塞长的进程换到磁盘中，把能直接执行的进程换到内存中，避免让cpu闲下来 进程切换 中断 时钟中断：就是时间片到点了 IO中断：要等打印机了== 内存失效：要使用到虚存了，要从磁盘里调 陷阱：处理一个错误或异常条件 系统调用：调用操作系统函数 以上三种发生了，处理器都会执行一次模式切换（用户态转到内核态），将控制权交给os例程，os处理完，可以恢复被中断的进程或切换到其他进程 如何控制资源？通过维护一些表。内存表 页表 段表 进程表 主进程表：包含每个进程的表项（至少包含一个指向进程映像的指针） 进程映像：包括程序，数据，栈，属性 进程可以一部分存在内存，一部分放在外存，这些信息都要存在进程表里。一切目的都是让cpu能够找到而已 IO表文件表并发性：互斥和同步互斥 通过编程语言来实现 信号量机制（实际的实现还是硬件或软件方法） 消息机制 管程 生产者/消费者问题 读/写者问题 硬件实现 中断禁用（临界区禁用中断） 专用的机器指令 软件实现 通过进程来实现 并发性：死锁和饥饿死锁是什么？ 产生死锁的3个必要非充分条件 互斥 占有且等待 不可抢占 充分条件：循环等待（是上边3个必要条件导致的结果） 资源分类 可重用资源（IO，内存等等） 可消耗资源（中断，IO缓冲区消息等） 解决死锁的方法 预防 一次性请求所有资源 缺点： 1.因阻塞导致占有这么多资源都不能用，别的进程也不能用2.事先不知道需要哪些资源 - 抢占 - 缺点： 1.要求两个进程优先级不同2.资源状态要容易保存和恢复 - 资源排序 - 缺点： 1.和一次性请求所有资源一样，会拒绝资源访问，浪费资源可使用的时间 避免 操作以便发现至少一条安全路径 1.若一个进程请求会导致死锁，则不启动该进程2.若一个进程增加资源请求会导致死锁，则不允许这一资源分配 - 资源分配拒绝策略 （银行家算法） - 优点： 无需死锁预防中的抢占和回滚进程 - 限制：1.必须事先声明每个进程请求的最大资源2.所讨论的进程必须是无关的，即它们的执行顺序没有任何同步要求的限制3.分配的资源数量必须是固定的4.在占有资源时，进程不能退出 检测 周期性检测死锁的存在 恢复 1.取消所有死锁进程（os最常用方法） 2.每个死锁进程回滚，并重启所有进程3.连续取消死锁进程直到不再存在死锁4.连续抢占资源直到不在存在死锁 哲学家就餐问题内存管理需求 重定位 保护 共享 逻辑组织 物理组织 内存分区 固定分区 动态分区 伙伴系统 分页 进程分成页内存分成页框（大小相等）每一页很小，windows是4kb进程可以拥有不连续的很多页，通过维护一个页表来找到它们 分段 进程和内存被分成很多段段的大小可以不相等 特点：可以由程序员控制，一般将每个段定义一组逻辑信息，然后映射到内存中去。而分页是定死的，程序员控制不了 分段和分页区别 1.页是信息的物理单位,分页是为了实现非连续分配,以便解决内存碎片问题,或者说分页是由于系统管理的需要.段是信息的逻辑单位,它含有一组意义相对完整的信息,分段的目的是为了更好地实现共享,满足用户的需要. 2.页的大小固定,由系统确定,将逻辑地址划分为页号和页内地址是由机器硬件实现的.而段的长度却不固定,决定于用户所编写的程序,通常由编译程序在对源程序进行编译时根据信息的性质来划分. 3.分页的作业地址空间是一维的.分段的地址空间是二维的. 意思是分页的话，给个虚拟地址就能找到物理地址（因为页是一样大的，可以算出来），而分段的话，需要给段号和虚拟地址才能算出来物理地址，因为段是不定长的嘛 段页式 首先将进程按逻辑分成段再将每段分成页查找需要段号，页号，偏移量 虚拟内存 好处： 1.可以使有限的内存存放更多进程2.可以使程序比整个内存都大，比如某些游戏3.不需要程序的所有页或段都在内存之中 操作系统处理 为了防止缺页中断太过频繁，os有很多算法来进行内存调度 读取策略：进程页可以在请求时读取，或预先分页，按簇一次读取多页 放置策略：对纯分段系统，读取的段必须匹配内存的空间 置换策略：内存装满后，必须决定置换哪些页 驻留集管理：换入特定进程时，os决定给他分配多少内存，既可以静态分配，也可以动态地变化 清除策略：修改过的进程页可在置换时写出，或使用预约式清楚策略，按簇一次写出多页 加载控制：主要关注任何给定时刻驻留在内存中的进程数量 调度单处理器调度 处理器调度类型 长程调度：决定哪些进程可以进入系统中处理（读入内存） 中程调度：是交换功能的一部分，就是决定进程的一部分读入内存或换出到磁盘 短程调度：真正决定当前cpu处理哪个进程（运行态）的调度 多处理器调度 粒度 进程调度 线程调度 负载分配 先来先服务 最少线程数优先 可抢占的最少线程数优先 组调度 专用处理器分配 动态调度 多核线程调度 实时调度调度算法 进程优先级 决策模式：抢占/非抢占 调度策略 先来先服务 轮转 最短进程优先 最短剩余时间 最高响应比优先 反馈法 公平共享调度（进程组）","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://icecorn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://icecorn.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"思维导图","slug":"思维导图","permalink":"http://icecorn.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"}]},{"title":"C++ Primer笔记|专题-四种类型转换的使用","slug":"C++ Primer/C++primer笔记-专题-四种类型转换","date":"2022-03-10T12:25:30.000Z","updated":"2022-06-29T13:24:31.104Z","comments":true,"path":"2022/03/10/C++ Primer/C++primer笔记-专题-四种类型转换/","link":"","permalink":"http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"专题 -四种类型转换的使用运行时类型识别（Run-Time Type Identification）运行时类型识别（RTTI）的功能由两个运算符实现： typeid运算符，用于返回表达式的类型。 dynamic_cast运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。 RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。 dynamic_cast运算符（The dynamic_cast Operator）dynamic_cast运算符的形式如下： 123dynamic_cast&lt;type*&gt;(e)dynamic_cast&lt;type&amp;&gt;(e)dynamic_cast&lt;type&amp;&amp;&gt;(e) 其中type是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个有效指针；在第二种形式中，e必须是一个左值；在第三种形式中，e不能是左值。在所有形式中，e的类型必须符合以下条件之一： e是type的公有派生类。 e是type的公有基类。 e和type类型相同。 如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果： 如果dynamic_cast语句的转换目标是指针类型，则结果为0。 12345678if (Derived *dp = dynamic_cast&lt;Derived*&gt;(bp))&#123; // use the Derived object to which dp points&#125;else&#123; // bp points at a Base object // use the Base object to which bp points&#125; 如果dynamic_cast语句的转换目标是引用类型，则抛出bad_cast异常（定义在头文件typeinfo中）。 123456789101112void f(const Base &amp;b)&#123; try &#123; const Derived &amp;d = dynamic_cast&lt;const Derived&amp;&gt;(b); // use the Derived object to which b referred &#125; catch (bad_cast) &#123; // handle the fact that the cast failed &#125;&#125; 在条件判断部分执行dynamic_cast可以确保类型转换和结果检查在同一条表达式中完成。 可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。 四种强制类型转换强制类型转换解决的问题： 强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成指针，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。 1) 没有从形式上体现转换功能和风险的不同。 例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。 2) 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。 3) 难以在程序中寻找到底什么地方进行了强制类型转换。 强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。 如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。 而用 C++ 的方式，则只需要查找**_cast**字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找reinterpret_cast字符串。 C++ 强制类型转换运算符的用法如下： *强制类型转换运算符 &lt;**要转换到的类型**&gt; (*待转换的表达式*)* 例如： double d = static_cast (35); //将 35 的值转换成实数 下面分别介绍四种强制类型转换运算符。 const_cast 常量转换const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。 将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。 123const string s = &quot;Inception&quot;;string&amp; p = const_cast &lt;string&amp;&gt; (s);string* ps = const_cast &lt;string*&gt; (&amp;s); // &amp;s 的类型是 const string* const int* p; //p可变,p指向的内容不可变int const* p; //p可变,p指向的内容不可变int* const p; //p不可变,p指向的内容可变 const修饰函数返回值表示返回值不可改变,多用于返回指针的情形volatile可理解为编译器警告指示字volatile用于告诉编译器必须每次去内存中取变量值volatile主要修饰可能被多个线程访问的变量volatile也可以修饰可能被未知因数更改的变量 1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；3、const_cast一般用于修改指针。如const char *p形式； 未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 c_val , use_val , ptr_val 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的c_val 会被改变.也有可能编译器对这类行为直接 error 或 warning. static_cast 静态类型转换1、static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。2、用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。3、用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。 4、static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除) 5、在c++ primer 中说道：c++ 的任何的隐式转换都是使用 static_cast 来实现。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class A&#123;public: operator int() &#123; return 1; &#125; operator char*() &#123; return NULL; &#125;&#125;;int main()&#123; A a; int n; char* p = &quot;New Dragon Inn&quot;; n = static_cast &lt;int&gt; (3.14); // n 的值变为 3 n = static_cast &lt;int&gt; (a); //调用 a.operator int，n 的值变为 1 p = static_cast &lt;char*&gt; (a); //调用 a.operator char*，p 的值变为 NULL n = static_cast &lt;int&gt; (p); //编译错误，static_cast不能将指针转换成整型 p = static_cast &lt;char*&gt; (n); //编译错误，static_cast 不能将整型转换成指针 return 0;&#125; dynamic_cast 动态类型转换用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。 dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base&#123; //有虚函数，因此是多态基类public: virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123; &#125;;int main()&#123; Base b; Derived d; Derived* pd; pd = reinterpret_cast &lt;Derived*&gt; (&amp;b); if (pd == NULL) //此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换 cout &lt;&lt; &quot;unsafe reinterpret_cast&quot; &lt;&lt; endl; //不会执行 pd = dynamic_cast &lt;Derived*&gt; (&amp;b); if (pd == NULL) //结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全 cout &lt;&lt; &quot;unsafe dynamic_cast1&quot; &lt;&lt; endl; //会执行 pd = dynamic_cast &lt;Derived*&gt; (&amp;d); //安全的转换 if (pd == NULL) //此处 pd 不会为 NULL cout &lt;&lt; &quot;unsafe dynamic_cast2&quot; &lt;&lt; endl; //不会执行 return 0;&#125; 程序的输出结果是：unsafe dynamic_cast1 第 20 行，通过判断 pd 的值是否为 NULL，就能知道第 19 行进行的转换是否是安全的。第 23 行同理。 如果上面的程序中出现了下面的语句： Derived &amp; r = dynamic_cast &lt;Derived &amp;&gt; (b); 那该如何判断该转换是否安全呢？不存在空引用，因此不能通过返回值来判断转换是否安全。C++ 的解决办法是：dynamic_cast 在进行引用的强制转换时，如果发现转换不安全，就会拋出一个异常，通过处理异常，就能发现不安全的转换。 dynamic_cast强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换. 对于从子类到基类的指针转换 ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果， 而从基类到子类的转换 , dynamic_cast 在转换时也没有报错,但是输出给 base2sub 是一个 nullptr ,说明dynami_cast 在程序运行时对类型转换对“运行期类型信息”（Runtime type information，RTTI）进行了检查. 这个检查主要来自虚函数(virtual function) 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。*因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数 reinterpret_cast 重新解释（类型的比特位）reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。 这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123;public: int i; int j; A(int n):i(n),j(n) &#123; &#125;&#125;;int main()&#123; A a(100); int &amp;r = reinterpret_cast&lt;int&amp;&gt;(a); //强行让 r 引用 a（即a的首地址） r = 200; //把 a.i 变成了 200 cout &lt;&lt; a.i &lt;&lt; &quot;,&quot; &lt;&lt; a.j &lt;&lt; endl; // 输出 200,100 int n = 300; A *pa = reinterpret_cast&lt;A*&gt; (&amp;n); //强行让 pa 指向 n pa-&gt;i = 400; // n 变成 400 pa-&gt;j = 500; //此条语句不安全，很可能导致程序崩溃 cout &lt;&lt; n &lt;&lt; endl; // 输出 400 long long la = 0x12345678abcdLL; pa = reinterpret_cast&lt;A*&gt;(la); //la太长，只取低32位0x5678abcd拷贝给pa unsigned int u = reinterpret_cast&lt;unsigned int&gt;(pa);//pa逐个比特拷贝到u cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl; //输出 5678abcd typedef void (* PF1) (int); typedef int (* PF2) (int,char *); PF1 pf1; PF2 pf2; pf2 = reinterpret_cast&lt;PF2&gt;(pf1); //两个不同类型的函数指针之间可以互相转换&#125; 程序的输出结果是：200, 1004005678abcd 第 19 行的代码不安全，因为在编译器看来，pa-&gt;j 的存放位置就是 n 后面的 4 个字节。 本条语句会向这 4 个字节中写入 500。**但这 4 个字节不知道是用来存放什么的（*因为i和j不一定连续存储*），贸然向其中写入可能会导致程序错误甚至崩溃。 上面程序中的各种转换都没有实际意义，只是为了演示 reinteipret_cast 的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。 reinterpret_cast体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。 提供下IBM C++ 对 reinterpret_cast 推荐使用的地方A pointer to any integral type large enough to hold it （指针转向足够大的整数类型）A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针）A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针）A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针）A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十五章-面向对象程序设计","slug":"C++ Primer/C++primer笔记-第十五章-面向对象程序设计","date":"2022-03-10T12:25:30.000Z","updated":"2022-06-29T13:21:19.003Z","comments":true,"path":"2022/03/10/C++ Primer/C++primer笔记-第十五章-面向对象程序设计/","link":"","permalink":"http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"第十五章 面向对象程序设计基类和派生类成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。 派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。 C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。 因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。 12345Quote item; // object of base typeBulk_quote bulk; // object of derived typeQuote *p = &amp;item; // p points to a Quote objectp = &amp;bulk; // p points to the Quote part of bulkQuote &amp;r = bulk; // r bound to the Quote part of bulk 每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。 123Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) &#123; &#125; 除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。 派生类可以访问基类的公有成员和受保护成员。 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。 已经完整定义的类才能被用作基类。 123class Base &#123; /* ... */ &#125; ;class D1: public Base &#123; /* ... */ &#125;;class D2: public D1 &#123; /* ... */ &#125;; Base是D1的直接基类（direct base），是D2的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。 C++11中，在类名后面添加final关键字可以禁止其他类继承它。 123456class NoDerived final &#123; /* */ &#125;; // NoDerived can&#x27;t be a base classclass Base &#123; /* */ &#125;;// Last is final; we cannot inherit from Lastclass Last final : Base &#123; /* */ &#125;; // Last can&#x27;t be a base classclass Bad : NoDerived &#123; /* */ &#125;; // error: NoDerived is finalclass Bad2 : Last &#123; /* */ &#125;; // error: Last is final 类型转换与继承和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。 表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。 不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。 123Quote base;Bulk_quote* bulkP = &amp;base; // error: can&#x27;t convert base to derivedBulk_quote&amp; bulkRef = base; // error: can&#x27;t convert base to derived 如果在基类中含有一个或多个虚函数，可以使用dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。 如果已知某个基类到派生类的转换是安全的，可以使用static_cast强制覆盖掉编译器的检查工作。 派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。 派生类到基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。 123Bulk_quote bulk; // object of derived typeQuote item(bulk); // uses the Quote::Quote(const Quote&amp;) constructoritem = bulk; // calls Quote::operator=(const Quote&amp;) 用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。 虚函数（Virtual Functions）当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。 在派生类中覆盖某个虚函数时，可以再次使用virtual关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。 在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。 派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。 C++11允许派生类使用override关键字显式地注明虚函数。如果override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。override位于函数参数列表之后。 1234567891011121314struct B&#123; virtual void f1(int) const; virtual void f2(); void f3();&#125;;struct D1 : B &#123; void f1(int) const override; // ok: f1 matches f1 in the base void f2(int) override; // error: B has no f2(int) function void f3() override; // error: f3 not virtual void f4() override; // error: B doesn&#x27;t have a function named f4&#125; 与禁止类继承类似，函数也可以通过添加final关键字来禁止覆盖操作。 12345struct D2 : B&#123; // inherits f2() and f3() from B and overrides f1(int) void f1(int) const final; // subsequent classes can&#x27;t override f1(int)&#125;; final和override关键字出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。 虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。 如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。 使用作用域运算符::可以强制执行虚函数的某个版本，不进行动态绑定。 12// calls the version from the base class regardless of the dynamic type of basePdouble undiscounted = baseP-&gt;Quote::net_price(42); 通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。 如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。 抽象基类（Abstract Base Classes）在类内部虚函数声明语句的分号前添加=0可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。 1double net_price(std::size_t) const = 0; 可以为纯虚函数提供定义，但函数体必须定义在类的外部。 含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。 不能创建抽象基类的对象。 派生类构造函数只初始化它的直接基类。 重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。 关于多继承和虚继承多继承很简单就是一个子类可以继承多个父类，且对于一个子类对象，它里面其实包含每个父类的对象各一个，那么怎么协调好变量和函数的继承关系，理解记忆就好了，关键是不产生冲突 虚继承是为了解决菱形继承出现的，因为如果不是菱形继承，一个子类对象就会有两个一样的爷爷类的对象，这是不对的，而有了虚继承，就是让一个子对象只拥有一个爷爷类对象，不会产生冲突。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十四章 重载运算与类型转换","slug":"C++ Primer/C++primer笔记-第十四章-重载运算与类型转换","date":"2022-03-08T12:25:30.000Z","updated":"2022-06-29T13:33:20.515Z","comments":true,"path":"2022/03/08/C++ Primer/C++primer笔记-第十四章-重载运算与类型转换/","link":"","permalink":"http://icecorn.github.io/2022/03/08/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"第14章 重载运算与类型转换基本概念（Basic Concepts）重载的运算符是具有特殊名字的函数，它们的名字由关键字operator和其后要定义的运算符号组成。 重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。 如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的this指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。 当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。 只能重载大多数已有的运算符，无权声明新的运算符号。 重载运算符的优先级和结合律与对应的内置运算符一致。 可以像调用普通函数一样直接调用运算符函数。 12345// equivalent calls to a nonmember operator functiondata1 + data2; // normal expressionoperator+(data1, data2); // equivalent function calldata1 += data2; // expression-based &#x27;&#x27;call&#x27;&#x27;data1.operator+=(data2); // equivalent call to a member operator function 通常情况下，不应该重载逗号,、取地址&amp;、逻辑与&amp;&amp;和逻辑或||运算符。 建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。 如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。 把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。 123string s = &quot;world&quot;;string t = s + &quot;!&quot;; // ok: we can add a const char* to a stringstring u = &quot;hi&quot; + s; // would be an error if + were a member of string 如何选择将运算符定义为成员函数还是普通函数： 赋值=、下标[]、调用()和成员访问箭头-&gt;运算符必须是成员函数。 复合赋值运算符一般是成员函数，但并非必须。 改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。 具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。 输入和输出运算符（Input and Output Operators）重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）通常情况下，输出运算符的第一个形参是ostream类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的ostream形参。 123456ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os;&#125; 输出运算符应该尽量减少格式化操作。 输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。 重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。 12345678910istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123; double price; // no need to initialize; we&#x27;ll read into price before we use it is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; if (is) // check that the inputs succeeded item.revenue = item.units_sold * price; else item = Sales_data(); // input failed: give the object the default state return is;&#125; 输入运算符必须处理输入失败的情况，而输出运算符不需要。 以下情况可能导致读取操作失败： 读取了错误类型的数据。 读取操作到达文件末尾。 遇到输入流的其他错误。 当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。 如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置failbit状态。eofbit、badbit等错误最好由IO标准库自己标示。 算术和关系运算符（Arithmetic and Relational Operators）通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。 算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的const类型）。 1234567// assumes that both objects refer to the same bookSales_data operator+(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; Sales_data sum = lhs; // copy data members from lhs into sum sum += rhs; // add rhs into sum return sum;&#125; 如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。 相等运算符（Equality Operators）相等运算符设计准则： 如果类在逻辑上有相等性的含义，则应该定义operator==而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。 通常情况下，operator==应该具有传递性。 如果类定义了operator==，则也应该定义operator!=。 operator==和operator!=中的一个应该把具体工作委托给另一个。 1234567891011bool operator==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.isbn() == rhs.isbn() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue;&#125;bool operator!=(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return !(lhs == rhs);&#125; 关系运算符（Relational Operators）定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较实用。 关系运算符设计准则： 定义顺序关系，令其与关联容器中对关键字的要求保持一致。 如果类定义了operator==，则关系运算符的定义应该与operator==保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。 只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义operator&lt;。 赋值运算符（Assignment Operators）赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。 12345678910111213141516171819StrVec &amp;StrVec::operator=(initializer_list&lt;string&gt; il)&#123; // alloc_n_copy allocates space and copies elements from the given range auto data = alloc_n_copy(il.begin(), il.end()); free(); // destroy the elements in this object and free the space elements = data.first; // update data members to point to the new space first_free = cap = data.second; return *this;&#125;// member binary operator: left-hand operand is bound to the implicit this pointer// assumes that both objects refer to the same bookSales_data&amp; Sales_data::operator+=(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;&#125; 下标运算符（Subscript Operator）下标运算符必须定义为成员函数。 类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。 1234567891011class StrVec&#123;public: std::string&amp; operator[](std::size_t n) &#123; return elements[n]; &#125; const std::string&amp; operator[](std::size_t n) const &#123; return elements[n]; &#125;private: std::string *elements; // pointer to the first element in the array&#125; 递增和递减运算符（Increment and Decrement Operators）定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。 为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。 123456// prefix: return a reference to the incremented/decremented objectStrBlobPtr&amp; StrBlobPtr::operator++()&#123; ++curr; // advance the current state return *this;&#125; 后置递增或递减运算符接受一个额外的（不被使用）int类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。 123456789class StrBlobPtr&#123;public: // increment and decrement StrBlobPtr&amp; operator++(); // prefix operators StrBlobPtr&amp; operator--(); StrBlobPtr operator++(int); // postfix operators StrBlobPtr operator--(int);&#125;; 为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的const类型）。 123456StrBlobPtr StrBlobPtr::operator++(int)&#123; StrBlobPtr ret = *this; // save the current value ++*this; // advance one element; prefix ++ checks the increment return ret; // return the saved state&#125; 如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。 123StrBlobPtr p(a1); // p points to the vector inside a1p.operator++(0); // call postfix operator++p.operator++(); // call prefix operator++ 成员访问运算符（Member Access Operators）箭头运算符必须定义为成员函数，解引用运算符通常也是如此。 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。 123456789101112class StrBlobPtr&#123;public: std::string&amp; operator*() const &#123; return (*p)[curr]; // (*p) is the vector to which this object points &#125; std::string* operator-&gt;() const &#123; // delegate the real work to the dereference operator return &amp; this-&gt;operator*(); &#125;&#125;; 对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;的类的对象。point类型不同，point-&gt;mem的含义也不同。 如果point是指针，则调用内置箭头运算符，表达式等价于(*point).mem。 如果point是重载了operator-&gt;的类的对象，则使用point.operator-&gt;()的结果来获取mem，表达式等价于(point.operator-&gt;())-&gt;mem。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。 函数调用运算符（Function-Call Operator）函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。 1234567891011121314151617class PrintString&#123;public: PrintString(ostream &amp;o = cout, char c = &#x27; &#x27;): os(o), sep(c) &#123; &#125; void operator()(const string &amp;s) const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;private: ostream &amp;os; // stream on which to write char sep; // character to print after each output&#125;;PrintString printer; // uses the defaults; prints to coutprinter(s); // prints s followed by a space on cout 如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。 1for_each(vs.begin(), vs.end(), PrintString(cerr, &#x27;\\n&#x27;)); lambda是函数对象（Lambdas Are Function Objects）编写一个lambda后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。 12345678910111213// sort words by size, but maintain alphabetical order for words of the same sizestable_sort(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size(); &#125;);// acts like an unnamed object of a class that would look something likeclass ShorterString&#123;public: bool operator()(const string &amp;s1, const string &amp;s2) const &#123; return s1.size() &lt; s2.size(); &#125;&#125;; lambda默认不能改变它捕获的变量。因此在默认情况下，由lambda产生的类中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不再是const函数了。 lambda通过引用捕获变量时，由程序负责确保lambda执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到lambda中，此时lambda产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。 123456789101112131415161718// get an iterator to the first element whose size() is &gt;= szauto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;);// would generate a class that looks something likeclass SizeComp&#123;public: SizeComp(size_t n): sz(n) &#123; &#125; // parameter for each captured variable // call operator with the same return type, parameters, and body as the lambda bool operator()(const string &amp;s) const &#123; return s.size() &gt;= sz; &#125;private: size_t sz; // a data member for each variable captured by value&#125;; lambda产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数则通常要视捕获的变量类型而定。 标准库定义的函数对象（Library-Defined Function Objects）标准库在头文件functional中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。 关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。 123456vector&lt;string *&gt; nameTable; // vector of pointers// error: the pointers in nameTable are unrelated, so &lt; is undefinedsort(nameTable.begin(), nameTable.end(), [](string *a, string *b) &#123; return a &lt; b; &#125;);// ok: library guarantees that less on pointer types is well definedsort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;()); 可调用对象与function（Callable Objects and function）调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。 标准库function类型是一个模板，定义在头文件functional中，用来表示对象的调用形式。 创建一个具体的function类型时必须提供其所表示的对象的调用形式。 123456789101112131415161718// ordinary functionint add(int i, int j) &#123; return i + j; &#125;// function-object classstruct div&#123; int operator()(int denominator, int divisor) &#123; return denominator / divisor; &#125;&#125;;function&lt;int(int, int)&gt; f1 = add; // function pointerfunction&lt;int(int, int)&gt; f2 = div(); // object of a function-object classfunction&lt;int(int, int)&gt; f3 = [](int i, int j) &#123; return i * j; &#125;; // lambda cout &lt;&lt; f1(4,2) &lt;&lt; endl; // prints 6cout &lt;&lt; f2(4,2) &lt;&lt; endl; // prints 2cout &lt;&lt; f3(4,2) &lt;&lt; endl; // prints 8 不能直接将重载函数的名字存入function类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用lambda或者存储函数指针而非函数名字。 C++11新标准库中的function类与旧版本中的unary_function和binary_function没有关系，后两个类已经被bind函数代替。 重载、类型转换与运算符（Overloading，Conversions，and Operators）转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。 类型转换运算符（Conversion Operators）类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下： 1operator type() const; 类型转换运算符可以面向除了void以外的任意类型（该类型要能作为函数的返回类型）进行定义。 12345678910111213class SmallInt&#123;public: SmallInt(int i = 0): val(i) &#123; if (i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; operator int() const &#123; return val; &#125; private: std::size_t val;&#125;; 隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。 1234// the double argument is converted to int using the built-in conversionSmallInt si = 3.14; // calls the SmallInt(int) constructor// the SmallInt conversion operator converts si to int;si + 3.14; // that int is converted to double using the built-in conversion 应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。 C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。 1234567891011class SmallInt&#123;public: // the compiler won&#x27;t automatically apply this conversion explicit operator int() const &#123; return val; &#125; // other members as before&#125;;SmallInt si = 3; // ok: the SmallInt constructor is not explicitsi + 3; // error: implicit is conversion required, but operator int is explicitstatic_cast&lt;int&gt;(si) + 3; // ok: explicitly request the conversion 如果表达式被用作条件，则编译器会隐式地执行显式类型转换。 if、while、do-while语句的条件部分。 for语句头的条件表达式。 条件运算符? :的条件表达式。 逻辑非运算符!、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象。 类类型向bool的类型转换通常用在条件部分，因此operator bool一般被定义为显式的。 避免有二义性的类型转换（Avoiding Ambiguous Conversions）在两种情况下可能产生多重转换路径： A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。 12345678910111213141516171819// usually a bad idea to have mutual conversions between two class typesstruct B;struct A&#123; A() = default; A(const B&amp;); // converts a B to an A // other members&#125;;struct B&#123; operator A() const; // also converts a B to an A // other members&#125;;A f(const A&amp;);B b;A a = f(b); // error ambiguous: f(B::operator A()) // or f(A::A(const B&amp;)) 类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。 123456789101112131415struct A&#123; A(int = 0); // usually a bad idea to have two A(double); // conversions from arithmetic types operator int() const; // usually a bad idea to have two operator double() const; // conversions to arithmetic types // other members&#125;;void f2(long double);A a;f2(a); // error ambiguous: f(A::operator int()) // or f(A::operator double())long lg;A a2(lg); // error ambiguous: A::A(int) or A::A(double) 可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。 12A a1 = f(b.operator A()); // ok: use B&#x27;s conversion operatorA a2 = f(A(b)); // ok: use A&#x27;s constructor 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。 使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。 如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。 调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。 12345678910111213141516struct C&#123; C(int); // other members&#125;;struct E&#123; E(double); // other members&#125;;void manip2(const C&amp;);void manip2(const E&amp;);// error ambiguous: two different user-defined conversions could be usedmanip2(10); // manip2(C(10) or manip2(E(double(10))) 函数匹配与重载运算符（Function Matching and Overloaded Operators）表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。 123456789101112131415class SmallInt&#123; friend SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;); public: SmallInt(int = 0); // conversion from int operator int() const &#123; return val; &#125; // conversion to int private: std::size_t val;&#125;;SmallInt s1, s2;SmallInt s3 = s1 + s2; // uses overloaded operator+int i = s3 + 0; // error: ambiguous 如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十三章-拷贝控制","slug":"C++ Primer/C++primer笔记-第十三章-拷贝控制","date":"2022-03-07T12:25:30.000Z","updated":"2022-06-29T13:17:34.702Z","comments":true,"path":"2022/03/07/C++ Primer/C++primer笔记-第十三章-拷贝控制/","link":"","permalink":"http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/","excerpt":"","text":"第十三章 拷贝控制主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。 关于拷贝不在赘述，主要要记得当一个类里有指针类型时，要注意深拷贝和浅拷贝的问题，比如Myclass b = a；就是如果是浅拷贝的话，b中拷贝过来的指针和a中原来的指针指向的是同一块位置，那么就要考虑要析构b的时候，a对象是否还再用，如果还在用就不能析构指针指向这块内存，防止出现a对象这个指针指向未定义的情况发生。如果是深拷贝的话，就是说a对象和b对象的指针指向的东西也不是在一块内存上，所以可以正常析构。具体要深拷贝还是浅拷贝还是要看业务类型来实现处理。 对象移动（Moving Objects）某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。 在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 右值引用（Rvalue Reference）为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过&amp;&amp;来获得右值引用。 123456int i = 42;int &amp;r = i; // ok: r refers to iint &amp;&amp;rr = i; // error: cannot bind an rvalue reference to anint &amp;r2 = i * 42; // error: i * 42 is an rvalueconst int &amp;r3 = i * 42; // ok: we can bind a reference to const to an rvalueint &amp;&amp;rr2 = i * 42; // ok: bind rr2 to the result of the multiplication 右值引用只能绑定到即将被销毁，并且没有其他用户的临时对象上。使用右值引用的代码可以自由地接管所引用对象的资源。 变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。 12int &amp;&amp;rr1 = 42; // ok: literals are rvaluesint &amp;&amp;rr2 = rr1; // error: the expression rr1 is an lvalue! 调用move函数可以获得绑定在左值上的右值引用，此函数定义在头文件utility中。 1int &amp;&amp;rr3 = std::move(rr1); 调用move函数的代码应该使用std::move而非move，这样做可以避免潜在的名字冲突。 移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。 除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。 在函数的形参列表后面添加关键字noexcept可以指明该函数不会抛出任何异常。 对于构造函数，noexcept位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定noexcept。 123456789class StrVec&#123;public: StrVec(StrVec&amp;&amp;) noexcept; // move constructor // other members as before&#125;;StrVec::StrVec(StrVec &amp;&amp;s) noexcept : /* member initializers */&#123; /* constructor body */ &#125; 标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。 在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。 1234567891011121314StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs) noexcept&#123; // direct test for self-assignment if (this != &amp;rhs) &#123; free(); // free existing elements elements = rhs.elements; // take over resources from rhs first_free = rhs.first_free; cap = rhs.cap; // leave rhs in a destructible state rhs.elements = rhs.first_free = rhs.cap = nullptr; &#125; return *this;&#125; 只有当一个类没有定义任何拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。 1234567891011121314// the compiler will synthesize the move operations for X and hasXstruct X&#123; int i; // built-in types can be moved std::string s; // string defines its own move operations&#125;;struct hasX&#123; X mem; // X has synthesized move operations&#125;;X x, x2 = std::move(x); // uses the synthesized move constructorhasX hx, hx2 = std::move(hx); // uses the synthesized move constructor 与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。 与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。 定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。 如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用move函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。 1234567891011class Foo&#123;public: Foo() = default; Foo(const Foo&amp;); // copy constructor // other members, but Foo does not define a move constructor&#125;;Foo x;Foo y(x); // copy constructor; x is an lvalueFoo z(std::move(x)); // copy constructor, because there is no move constructor 使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。 123456789// assignment operator is both the move- and copy-assignment operatorHasPtr&amp; operator=(HasPtr rhs)&#123; swap(*this, rhs); return *this;&#125;hp = hp2; // hp2 is an lvalue; copy constructor used to copy hp2hp = std::move(hp2); // move constructor moves hp2 建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。 移动赋值运算符可以直接检查自赋值情况。 C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。 调用make_move_iterator函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。 最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用move操作。 右值引用和成员函数（Rvalue References and Member Functions）区分移动和拷贝的重载函数通常有一个版本接受一个const T&amp;参数，另一个版本接受一个T&amp;&amp;参数（T为类型）。 12void push_back(const X&amp;); // copy: binds to any kind of Xvoid push_back(X&amp;&amp;); // move: binds only to modifiable rvalues of type X 有时可以对右值赋值： 12string s1, s2;s1 + s2 = &quot;wow!&quot;; 在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即this指向的对象）必须是一个左值。 在非static成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定this的左值/右值属性。引用限定符可以是&amp;或者&amp;&amp;，分别表示this可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。 123456789101112class Foo&#123;public: Foo &amp;operator=(const Foo&amp;) &amp;; // may assign only to modifiable lvalues // other members of Foo&#125;;Foo &amp;Foo::operator=(const Foo &amp;rhs) &amp;&#123; // do whatever is needed to assign rhs to this object return *this;&#125; 一个非static成员函数可以同时使用const和引用限定符，此时引用限定符跟在const限定符之后。 123456class Foo&#123;public: Foo someMem() &amp; const; // error: const qualifier must come first Foo anotherMem() const &amp;; // ok: const qualifier comes first&#125;; 引用限定符也可以区分成员函数的重载版本。 123456789class Foo&#123;public: Foo sorted() &amp;&amp;; // may run on modifiable rvalues Foo sorted() const &amp;; // may run on any kind of Foo&#125;;retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() &amp;&amp;retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &amp; 如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。 12345678910class Foo&#123;public: Foo sorted() &amp;&amp;; Foo sorted() const; // error: must have reference qualifier // Comp is type alias for the function type // that can be used to compare int values using Comp = bool(const int&amp;, const int&amp;); Foo sorted(Comp*); // ok: different parameter list&#125;; 理解move 这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。 注意：使用move不会释放源对象，所以一定要确保源对象不会再使用了，才能用move 详细帖子： https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c%2B%2B+%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十二章 动态内存","slug":"C++ Primer/C++primer笔记-第十二章-动态内存","date":"2022-03-05T12:25:30.000Z","updated":"2022-06-29T13:22:36.291Z","comments":true,"path":"2022/03/05/C++ Primer/C++primer笔记-第十二章-动态内存/","link":"","permalink":"http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","excerpt":"","text":"第十二章 动态内存程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。 动态内存与智能指针（Dynamic Memory and Smart Pointers）C++中的动态内存管理通过一对运算符完成：new在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；delete接受一个动态对象的指针，销毁该对象并释放与之关联的内存。 新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr独占所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在头文件memory中。 shared_ptr类（The shared_ptr Class）智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。 12shared_ptr&lt;string&gt; p1; // shared_ptr that can point at a stringshared_ptr&lt;list&lt;int&gt;&gt; p2; // shared_ptr that can point at a list of ints shared_ptr和unique_ptr都支持的操作： shared_ptr独有的操作： make_shared函数（定义在头文件memory中）在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。 123456// shared_ptr that points to an int with value 42shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);// p4 points to a string with value 9999999999shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, &#x27;9&#x27;);// p5 points to an int that is value initializedshared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;(); 进行拷贝或赋值操作时，每个shared_ptr会记录有多少个其他shared_ptr与其指向相同的对象。 123auto p = make_shared&lt;int&gt;(42); // object to which p points has one userauto q(p); // p and q point to the same object // object to which p and q point has two users 每个shared_ptr都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝shared_ptr时引用计数会递增。例如使用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给函数以及作为函数的返回值返回。给shared_ptr赋予新值或shared_ptr被销毁时引用计数会递减。例如一个局部shared_ptr离开其作用域。一旦一个shared_ptr的引用计数变为0，它就会自动释放其所管理的对象。 12345auto r = make_shared&lt;int&gt;(42); // int to which r points has one userr = q; // assign to r, making it point to a different address // increase the use count for the object to which q points // reduce the use count of the object to which r had pointed // the object r had pointed to has no users; that object is automatically freed shared_ptr的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，shared_ptr的析构函数会销毁对象并释放空间。 如果将shared_ptr存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用erase删除不再需要的元素。 程序使用动态内存通常出于以下三种原因之一： 不确定需要使用多少对象。 不确定所需对象的准确类型。 需要在多个对象间共享数据。 shared_ptr和new结合使用（Using shared_ptrs with new）可以用new返回的指针初始化智能指针。该构造函数是explicit的，因此必须使用直接初始化形式。 12shared_ptr&lt;int&gt; p1 = new int(1024); // error: must use direct initializationshared_ptr&lt;int&gt; p2(new int(1024)); // ok: uses direct initialization 默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用delete释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替delete。 不要混合使用内置指针和智能指针。当将shared_ptr绑定到内置指针后，资源管理就应该交由shared_ptr负责。不应该再使用内置指针访问shared_ptr指向的内存。 1234567891011121314// ptr is created and initialized when process is calledvoid process(shared_ptr&lt;int&gt; ptr)&#123; // use ptr&#125; // ptr goes out of scope and is destroyedint *x(new int(1024)); // dangerous: x is a plain pointer, not a smart pointerprocess(x); // error: cannot convert int* to shared_ptr&lt;int&gt;process(shared_ptr&lt;int&gt;(x)); // legal, but the memory will be deleted!int j = *x; // undefined: x is a dangling pointer!shared_ptr&lt;int&gt; p(new int(42)); // reference count is 1process(p); // copying p increments its count; in process the reference count is 2int i = *p; // ok: reference count is 1 智能指针的get函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用get返回指针的代码不能delete此指针。 不要使用get初始化另一个智能指针或为智能指针赋值。 1234567shared_ptr&lt;int&gt; p(new int(42)); // reference count is 1int *q = p.get(); // ok: but don&#x27;t use q in any way that might delete its pointer&#123; // new block // undefined: two independent shared_ptrs point to the same memory shared_ptr&lt;int&gt;(q);&#125; // block ends, q is destroyed, and the memory to which q points is freedint foo = *p; // undefined; the memory to which p points was freed 可以用reset函数将新的指针赋予shared_ptr。与赋值类似，reset会更新引用计数，如果需要的话，还会释放内存空间。reset经常与unique一起使用，来控制多个shared_ptr共享的对象。 123if (!p.unique()) p.reset(new string(*p)); // we aren&#x27;t alone; allocate a new copy*p += newVal; // now that we know we&#x27;re the only pointer, okay to change this object 智能指针和异常（Smart Pointers and Exceptions）如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。 123456789101112void f()&#123; int *ip = new int(42); // dynamically allocate a new object // code that throws an exception that is not caught inside f delete ip; // free the memory before exiting&#125;void f()&#123; shared_ptr&lt;int&gt; sp(new int(42)); // allocate a new object // code that throws an exception that is not caught inside f&#125; // shared_ptr freed automatically when the function ends 默认情况下shared_ptr假定其指向动态内存，使用delete释放对象。创建shared_ptr时可以传递一个（可选）指向删除函数的指针参数，用来代替delete。 12345678910111213141516struct destination; // represents what we are connecting tostruct connection; // information needed to use the connectionconnection connect(destination*); // open the connectionvoid disconnect(connection); // close the given connectionvoid end_connection(connection *p)&#123; disconnect(*p);&#125;void f(destination &amp;d /* other parameters */)&#123; connection c = connect(&amp;d); shared_ptr&lt;connection&gt; p(&amp;c, end_connection); // use the connection // when f exits, even if by an exception, the connection will be properly closed&#125; 智能指针规范： 不使用相同的内置指针值初始化或reset多个智能指针。 不释放get返回的指针。 不使用get初始化或reset另一个智能指针。 使用get返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。 使用shared_ptr管理并非new分配的资源时，应该传递删除函数。 深度理解智能指针1.智能指针的作用 ​ C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 理解智能指针需要从下面三个层次： 从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。 智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。 智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同，在Java里面下列代码： 12 Animal a = new Animal(); Animal b = a; 你当然知道，这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样， 12Animal a;Animal b = a; 这里却是就是生成了两个对象。 2.智能指针的实质 前面已经说过了，智能指针是一个类对象（类似迭代器，其实也是用类对象来模拟指针的作用），这样在被调函数执行完，程序过期时，对象将会被删除（对象的名字保存在栈变量中），这样不仅对象会被删除，它指向的内存也会被删除的。 智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、auto_ptr 建议： ​ 1-每种指针都有不同的使用范围，unique_ptr指针优于其它两种类型，除非对象需要共享时用shared_ptr。 ​ 2- 建议– 如果你没有打算在多个线程之间来共享资源的话，那么就请使用unique_ptr。 ​ 3 -建议- 使用make_shared而不是裸指针来初始化共享指针。 ​ 4 -建议 – 在设计类的时候，当不需要资源的所有权，而且你不想指定这个对象的生命周期时，可以考虑使用weak_ptr代替shared_ptr。 使用智能指针的时候，只需要将new出的地址值赋值给这种对象，也就是将new出的地址作为实参！ 总结：智能指针其实就是类对象，来模拟指针的效果，从而实现更安全的管理内存的操作，实现了自动释放内存等功能。智能指针分类，最简单实用的是unique_ptr,如果要多个指针指向同一个对象的话，要使用shared_ptr，同时因为多个指针操作一个对象，一定会带来多线程那种读写脏数据的问题，这时候就要加锁，而这里加锁的方式就是通过使用weak_ptr的lock()函数来进行的。而对于shared_ptr的数据结构，其实就是里边有一个count计数的类，并且重载了&gt;和*以及=等操作，并且根据实际需要实现维护count和释放内存的操作。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十一章-关联容器","slug":"C++ Primer/C++primer笔记-第十一章-关联容器","date":"2022-03-02T12:25:30.000Z","updated":"2022-06-29T13:11:59.278Z","comments":true,"path":"2022/03/02/C++ Primer/C++primer笔记-第十一章-关联容器/","link":"","permalink":"http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/","excerpt":"","text":"第11章 关联容器关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是map和set。 map中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。 set中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在set中。 标准库提供了8个关联容器，它们之间的不同体现在三个方面： 是map还是set类型。 是否允许保存重复的关键字。 是否按顺序保存元素。 允许重复保存关键字的容器名字都包含单词multi；无序保存元素的容器名字都以单词unordered开头。 map和multimap类型定义在头文件map中；set和multiset类型定义在头文件set中；无序容器定义在头文件unordered_map和unordered_set中。 使用关联容器（Using an Associative Container）map类型通常被称为关联数组（associative array）。 从map中提取一个元素时，会得到一个pair类型的对象。pair是一个模板类型，保存两个名为first和second的公有数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。 123456789// count the number of times each word occurs in the inputmap&lt;string, size_t&gt; word_count; // empty map from string to size_tstring word;while (cin &gt;&gt; word) ++word_count[word]; // fetch and increment the counter for wordfor (const auto &amp;w : word_count) // for each element in the map // print the results cout &lt;&lt; w.first &lt;&lt; &quot; occurs &quot; &lt;&lt; w.second &lt;&lt; ((w.second &gt; 1) ? &quot; times&quot; : &quot; time&quot;) &lt;&lt; endl; set类型的find成员返回一个迭代器。如果给定关键字在set中，则迭代器指向该关键字，否则返回的是尾后迭代器。 关联容器概述（Overview of the Associative Containers）定义关联容器（Defining an Associative Container）定义map时，必须指定关键字类型和值类型；定义set时，只需指定关键字类型。 初始化map时，提供的每个键值对用花括号&#123;&#125;包围。 12345678910map&lt;string, size_t&gt; word_count; // empty// list initializationset&lt;string&gt; exclude = &#123; &quot;the&quot;, &quot;but&quot;, &quot;and&quot; &#125;;// three elements; authors maps last name to firstmap&lt;string, string&gt; authors =&#123; &#123;&quot;Joyce&quot;, &quot;James&quot;&#125;, &#123;&quot;Austen&quot;, &quot;Jane&quot;&#125;, &#123;&quot;Dickens&quot;, &quot;Charles&quot;&#125;&#125;; map和set中的关键字必须唯一，multimap和multiset没有此限制。 关键字类型的要求（Requirements on Key Type）对于有序容器——map、multimap、set和multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来进行比较操作。 用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。 12345678bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.isbn() &lt; rhs.isbn();&#125;// bookstore can have several transactions with the same ISBN// elements in bookstore will be in ISBN ordermultiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn); pair类型（The pair Type）pair定义在头文件utility中。一个pair可以保存两个数据成员，分别命名为first和second。 123pair&lt;string, string&gt; anon; // holds two stringspair&lt;string, size_t&gt; word_count; // holds a string and an size_tpair&lt;string, vector&lt;int&gt;&gt; line; // holds string and vector&lt;int&gt; pair的默认构造函数对数据成员进行值初始化。 pair支持的操作： 在C++11中，如果函数需要返回pair，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。 12345678910pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v)&#123; // process v if (!v.empty()) // list initialize return &#123; v.back(), v.back().size() &#125;; else // explicitly constructed return value return pair&lt;string, int&gt;();&#125; 关联容器操作（Operations on Associative Containers）关联容器定义了类型别名来表示容器关键字和值的类型： 对于set类型，key_type和value_type是一样的。set中保存的值就是关键字。对于map类型，元素是关键字-值对。即每个元素是一个pair对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此pair的关键字部分是const的。另外，只有map类型（unordered_map、unordered_multimap、multimap、map）才定义了mapped_type。 12345set&lt;string&gt;::value_type v1; // v1 is a stringset&lt;string&gt;::key_type v2; // v2 is a stringmap&lt;string, int&gt;::value_type v3; // v3 is a pair&lt;const string, int&gt;map&lt;string, int&gt;::key_type v4; // v4 is a stringmap&lt;string, int&gt;::mapped_type v5; // v5 is an int 关联容器迭代器（Associative Container Iterators）解引用关联容器迭代器时，会得到一个类型为容器的value_type的引用。对map而言，value_type是pair类型，其first成员保存const的关键字，second成员保存值。 1234567// get an iterator to an element in word_countauto map_it = word_count.begin();// *map_it is a reference to a pair&lt;const string, size_t&gt; objectcout &lt;&lt; map_it-&gt;first; // prints the key for this elementcout &lt;&lt; &quot; &quot; &lt;&lt; map_it-&gt;second; // prints the value of the elementmap_it-&gt;first = &quot;new key&quot;; // error: key is const++map_it-&gt;second; // ok: we can change the value through an iterator 虽然set同时定义了iterator和const_iterator类型，但两种迭代器都只允许只读访问set中的元素。类似map，set中的关键字也是const的。 1234567set&lt;int&gt; iset = &#123;0,1,2,3,4,5,6,7,8,9&#125;;set&lt;int&gt;::iterator set_it = iset.begin();if (set_it != iset.end())&#123; *set_it = 42; // error: keys in a set are read-only cout &lt;&lt; *set_it &lt;&lt; endl; // ok: can read the key&#125; map和set都支持begin和end操作。使用迭代器遍历map、multimap、set或multiset时，迭代器按关键字升序遍历元素。 通常不对关联容器使用泛型算法。 添加元素（Adding Elements）使用insert成员可以向关联容器中添加元素。向map和set中添加已存在的元素对容器没有影响。 通常情况下，对于想要添加到map中的数据，并没有现成的pair对象。可以直接在insert的参数列表中创建pair。 12345// four ways to add word to word_countword_count.insert(&#123;word, 1&#125;);word_count.insert(make_pair(word, 1));word_count.insert(pair&lt;string, size_t&gt;(word, 1));word_count.insert(map&lt;string, size_t&gt;::value_type(word, 1)); 关联容器的insert操作： insert或emplace的返回值依赖于容器类型和参数： 对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，表示操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值。如果关键字已在容器中，则insert直接返回，bool值为false。如果关键字不存在，元素会被添加至容器中，bool值为true。 对于允许包含重复关键字的容器，添加单一元素的insert和emplace版本返回指向新元素的迭代器。 删除元素（Erasing Elements）关联容器的删除操作： 与顺序容器不同，关联容器提供了一个额外的erase操作。它接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，erase的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。 map的下标操作（Subscripting a map）map下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。 由于下标运算符可能向容器中添加元素，所以只能对非const的map使用下标操作。 对map进行下标操作时，返回的是mapped_type类型的对象；解引用map迭代器时，返回的是value_type类型的对象。 访问元素（Accessing Elements）关联容器的查找操作： 如果multimap或multiset中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。 12345678910111213141516multimap&lt;string, string&gt; authors;// adds the first element with the key Barth, Johnauthors.insert(&#123;&quot;Barth, John&quot;, &quot;Sot-Weed Factor&quot;&#125;);// ok: adds the second element with the key Barth, Johnauthors.insert(&#123;&quot;Barth, John&quot;, &quot;Lost in the Funhouse&quot;&#125;);string search_item(&quot;Alain de Botton&quot;); // author we&#x27;ll look forauto entries = authors.count(search_item); // number of elementsauto iter = authors.find(search_item); // first entry for this author// loop through the number of entries there are for this authorwhile(entries)&#123; cout &lt;&lt; iter-&gt;second &lt;&lt; endl; // print each title ++iter; // advance to the next title --entries; // keep track of how many we&#x27;ve printed&#125; lower_bound和upper_bound操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器会指向第一个匹配给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在multimap中，则lower_bound和upper_bound会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围，表示所有具有该关键字的元素范围。 123456// definitions of authors and search_item as above// beg and end denote the range of elements for this authorfor (auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg) cout &lt;&lt; beg-&gt;second &lt;&lt; endl; // print each title lower_bound和upper_bound有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lower_bound也返回尾后迭代器。 equal_range操作接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。 12345// definitions of authors and search_item as above// pos holds iterators that denote the range of elements for this keyfor (auto pos = authors.equal_range(search_item); pos.first != pos.second; ++pos.first) cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; // print each title 无序容器（The Unordered Containers）新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的==运算符组织元素。 无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。 无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。 无序容器管理操作： 默认情况下，无序容器使用关键字类型的==运算符比较元素，还使用一个hash&lt;key_type&gt;类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第九章-顺序容器","slug":"C++ Primer/C++primer笔记-第九章-顺序容器","date":"2022-02-28T12:25:30.000Z","updated":"2022-06-29T13:08:35.617Z","comments":true,"path":"2022/02/28/C++ Primer/C++primer笔记-第九章-顺序容器/","link":"","permalink":"http://icecorn.github.io/2022/02/28/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/","excerpt":"","text":"第9章 顺序容器顺序容器概述（Overview of the Sequential Containers）顺序容器类型： 类型 特性 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入/删除元素可能很慢 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问。在任何位置插入/删除速度都很快 forward_list 单向链表。只支持单向顺序访问。在任何位置插入/删除速度都很快 array 固定大小数组。支持快速随机访问。不能添加/删除元素 string 类似vector，但用于保存字符。支持快速随机访问。在尾部插入/删除速度很快 forward_list和array是C++11新增类型。与内置数组相比，array更安全易用。forward_list没有size操作。 容器选择原则： 除非有合适的理由选择其他容器，否则应该使用vector。 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。 如果程序要求随机访问容器元素，则应该使用vector或deque。 如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用deque。 如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则： 先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向vector追加数据，再调用标准库的sort函数重排元素，从而避免在中间位置添加元素。 如果必须在中间位置插入元素，可以在输入阶段使用list。输入完成后将list中的内容拷贝到vector中。 不确定应该使用哪种容器时，可以先只使用vector和list的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择vector或list都很方便。 容器库概览（Container Library Overview）每个容器都定义在一个头文件中，文件名与类型名相同。容器均为模板类型。 迭代器（Iterators）forward_list类型不支持递减运算符--。 一个迭代器范围（iterator range）由一对迭代器表示。这两个迭代器通常被称为begin和end，分别指向同一个容器中的元素或尾后地址。end迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为[begin，end）。迭代器begin和end必须指向相同的容器，end可以与begin指向相同的位置，但不能指向begin之前的位置（由程序员确保）。 假定begin和end构成一个合法的迭代器范围，则： 如果begin等于end，则范围为空。 如果begin不等于end，则范围内至少包含一个元素，且begin指向该范围内的第一个元素。 可以递增begin若干次，令begin等于end。 12345while (begin != end)&#123; *begin = val; // ok: range isn&#x27;t empty so begin denotes an element ++begin; // advance the iterator to get the next element&#125; 容器类型成员（Container Type Members）通过类型别名，可以在不了解容器元素类型的情况下使用元素。如果需要元素类型，可以使用容器的value_type。如果需要元素类型的引用，可以使用reference或const_reference。 begin和end成员（begin and end Members）begin和end操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。 begin和end操作有多个版本：带r的版本返回反向迭代器。以c开头的版本（C++11新增）返回const迭代器。不以c开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对const对象调用时，返回const迭代器。 12345list&lt;string&gt; a = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;auto it1 = a.begin(); // list&lt;string&gt;::iteratorauto it2 = a.rbegin(); // list&lt;string&gt;::reverse_iteratorauto it3 = a.cbegin(); // list&lt;string&gt;::const_iteratorauto it4 = a.crbegin(); // list&lt;string&gt;::const_reverse_iterator 当auto与begin或end结合使用时，返回的迭代器类型依赖于容器类型。但调用以c开头的版本仍然可以获得const迭代器，与容器是否是常量无关。 当程序不需要写操作时，应该使用cbegin和cend。 容器定义和初始化（Defining and Initializing a Container）容器定义和初始化方式： 将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。 传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换。 12345678// each container has three elements, initialized from the given initializerslist&lt;string&gt; authors = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;vector&lt;const char*&gt; articles = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;list&lt;string&gt; list2(authors); // ok: types matchdeque&lt;string&gt; authList(authors); // error: container types don&#x27;t matchvector&lt;string&gt; words(articles); // error: element types must match// ok: converts const char* elements to stringforward_list&lt;string&gt; words(articles.begin(), articles.end()); C++11允许对容器进行列表初始化。 123// each container has three elements, initialized from the given initializerslist&lt;string&gt; authors = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;vector&lt;const char*&gt; articles = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; 定义和使用array类型时，需要同时指定元素类型和容器大小。 1234array&lt;int, 42&gt; // type is: array that holds 42 intsarray&lt;string, 10&gt; // type is: array that holds 10 stringsarray&lt;int, 10&gt;::size_type i; // array type includes element type and sizearray&lt;int&gt;::size_type j; // error: array&lt;int&gt; is not a type 对array进行列表初始化时，初始值的数量不能大于array的大小。如果初始值的数量小于array的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。 可以对array进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。 赋值和swap（Assignment and swap）容器赋值操作： 赋值运算符两侧的运算对象必须类型相同。assign允许用不同但相容的类型赋值，或者用容器的子序列赋值。 12345list&lt;string&gt; names;vector&lt;const char*&gt; oldstyle;names = oldstyle; // error: container types don&#x27;t match// ok: can convert from const char*to stringnames.assign(oldstyle.cbegin(), oldstyle.cend()); 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器本身。 swap交换两个相同类型容器的内容。除array外，swap不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此可以保证快速完成。 123vector&lt;string&gt; svec1(10); // vector with ten elementsvector&lt;string&gt; svec2(24); // vector with 24 elementsswap(svec1, svec2); 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作交换容器内容，不会导致迭代器、引用和指针失效（array和string除外）。 对于array，swap会真正交换它们的元素。因此在swap操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。 12345678910array&lt;int, 3&gt; a = &#123; 1, 2, 3 &#125;;array&lt;int, 3&gt; b = &#123; 4, 5, 6 &#125;;auto p = a.cbegin(), q = a.cend();a.swap(b);// 输出交换后的值，即4、5、6while (p != q)&#123; cout &lt;&lt; *p &lt;&lt; endl; ++p;&#125; 对于其他容器类型（除string），指针、引用和迭代器在swap操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。 12345678910vector&lt;int&gt; a = &#123; 1, 2, 3 &#125;;vector&lt;int&gt; b = &#123; 4, 5, 6 &#125;;auto p = a.cbegin(), q = a.cend();a.swap(b);// 输出交换前的值，即1、2、3while (p != q)&#123; cout &lt;&lt; *p &lt;&lt; endl; ++p;&#125; array不支持assign，也不允许用花括号列表进行赋值。 1234array&lt;int, 10&gt; a1 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;array&lt;int, 10&gt; a2 = &#123;0&#125;; // elements all have value 0a1 = a2; // replaces elements in a1a2 = &#123;0&#125;; // error: cannot assign to an array from a braced list 新标准库同时提供了成员和非成员函数版本的swap。非成员版本的swap在泛型编程中非常重要，建议统一使用非成员版本的swap。 容器大小操作（Container Size Operations）size成员返回容器中元素的数量；empty当size为0时返回true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数量的值。forward_list支持max_size和empty，但不支持size。 关系运算符（Relational Operators）每个容器类型都支持相等运算符（==、!=）。除无序关联容器外，其他容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符两侧的容器类型和保存元素类型都必须相同。 两个容器的比较实际上是元素的逐对比较，其工作方式与string的关系运算符类似： 如果两个容器大小相同且所有元素对应相等，则这两个容器相等。 如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。 如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。 12345678vector&lt;int&gt; v1 = &#123; 1, 3, 5, 7, 9, 12 &#125;;vector&lt;int&gt; v2 = &#123; 1, 3, 9 &#125;;vector&lt;int&gt; v3 = &#123; 1, 3, 5, 7 &#125;;vector&lt;int&gt; v4 = &#123; 1, 3, 5, 7, 9, 12 &#125;;v1 &lt; v2 // true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]v1 &lt; v3 // false; all elements are equal, but v3 has fewer of them;v1 == v4 // true; each element is equal and v1 and v4 have the same size()v1 == v2 // false; v2 has fewer elements than v1 容器的相等运算符实际上是使用元素的==运算符实现的，而其他关系运算符则是使用元素的&lt;运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。 顺序容器操作（Sequential Container Operations）向顺序容器添加元素（Adding Elements to a Sequential Container）除array外，所有标准库容器都提供灵活的内存管理，在运行时可以动态添加或删除元素。 push_back将一个元素追加到容器尾部，push_front将元素插入容器头部。 1234// read from standard input, putting each word onto the end of containerstring word;while (cin &gt;&gt; word) container.push_back(word); insert将元素插入到迭代器指定的位置之前。一些不支持push_front的容器可以使用insert将元素插入开始位置。 1234567vector&lt;string&gt; svec;list&lt;string&gt; slist;// equivalent to calling slist.push_front(&quot;Hello!&quot;);slist.insert(slist.begin(), &quot;Hello!&quot;);// no push_front on vector but we can insert before begin()// warning: inserting anywhere but at the end of a vector might be slowsvec.insert(svec.begin(), &quot;Hello!&quot;); 将元素插入到vector、deque或string的任何位置都是合法的，但可能会很耗时。 在新标准库中，接受元素个数或范围的insert版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回void。如果范围为空，不插入任何元素，insert会返回第一个参数。 1234list&lt;string&gt; 1st;auto iter = 1st.begin();while (cin &gt;&gt; word) iter = 1st.insert(iter, word); // same as calling push_front 新标准库增加了三个直接构造而不是拷贝元素的操作：emplace_front、emplace_back和emplace，其分别对应push_front、push_back和insert。当调用push或insert时，元素对象被拷贝到容器中。而调用emplace时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。 1234567// construct a Sales_data object at the end of c// uses the three-argument Sales_data constructorc.emplace_back(&quot;978-0590353403&quot;, 25, 15.99);// error: there is no version of push_back that takes three argumentsc.push_back(&quot;978-0590353403&quot;, 25, 15.99);// ok: we create a temporary Sales_data object to pass to push_backc.push_back(Sales_data(&quot;978-0590353403&quot;, 25, 15.99)); 传递给emplace的参数必须与元素类型的构造函数相匹配。 forward_list有特殊版本的insert和emplace操作，且不支持push_back和emplace_back。vector和string不支持push_front和emplace_front。 访问元素（Accessing Elements）每个顺序容器都有一个front成员函数，而除了forward_list之外的顺序容器还有一个back成员函数。这两个操作分别返回首元素和尾元素的引用。 在调用front和back之前，要确保容器非空。 顺序容器的元素访问操作： 在容器中访问元素的成员函数都返回引用类型。如果容器是const对象，则返回const引用，否则返回普通引用。 可以快速随机访问的容器（string、vector、deque和array）都提供下标运算符。保证下标有效是程序员的责任。如果希望确保下标合法，可以使用at成员函数。at类似下标运算，但如果下标越界，at会抛出out_of_range异常。 123vector&lt;string&gt; svec; // empty vectorcout &lt;&lt; svec[0]; // run-time error: there are no elements in svec!cout &lt;&lt; svec.at(0); // throws an out_of_range exception 删除元素（Erasing Elements）顺序容器的元素删除操作： 删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除vector或string的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。 删除元素前，程序员必须确保目标元素存在。 pop_front和pop_back函数分别删除首元素和尾元素。vector和string类型不支持pop_front，forward_list类型不支持pop_back。 erase函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的erase都返回指向删除元素（最后一个）之后位置的迭代器。 123// delete the range of elements between two iterators// returns an iterator to the element just after the last removed elementelem1 = slist.erase(elem1, elem2); // after the call elem1 == elem2 clear函数删除容器内的所有元素。 特殊的forward_list操作（Specialized forward_list Operations）在forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。 forward_list的插入和删除操作： 改变容器大小（Resizing a Container）顺序容器的大小操作： resize函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且resize向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。 容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。 向容器中添加元素后： 如果容器是vector或string类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。 如果容器是deque类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。 如果容器是list或forward_list类型，指向容器的迭代器、指针和引用仍然有效。 从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效： 如果容器是list或forward_list类型，指向容器其他位置的迭代器、指针和引用仍然有效。 如果容器是deque类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。 如果容器是vector或string类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。 必须保证在每次改变容器后都正确地重新定位迭代器。 不要保存end函数返回的迭代器。 12345678// safer: recalculate end on each trip whenever the loop adds/erases elementswhile (begin != v.end())&#123; // do some processing ++begin; // advance begin because we want to insert after this element begin = v.insert(begin, 42); // insert the new value ++begin; // advance begin past the element we just added&#125; vector对象是如何增长的（How a vector Grows）vector和string的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多新元素。 容器大小管理操作： capacity函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。reserve函数告知容器应该准备保存多少元素，它并不改变容器中元素的数量，仅影响容器预先分配的内存空间大小。 只有当需要的内存空间超过当前容量时，reserve才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，reserve并不会退回内存空间。因此在调用reserve之后，capacity会大于或等于传递给reserve的参数。 在C++11中可以使用shrink_to_fit函数来要求deque、vector和string退回不需要的内存空间（并不保证退回）。 额外的string操作（Additional string Operations）构造string的其他方法（Other Ways to Construct strings）构造string的其他方法： 从另一个string对象拷贝字符构造string时，如果提供的拷贝开始位置（可选）大于给定string的大小，则构造函数会抛出out_of_range异常。 子字符串操作： 如果传递给substr函数的开始位置超过string的大小，则函数会抛出out_of_range异常。 改变string的其他方法（Other Ways to Change a string）修改string的操作： append函数是在string末尾进行插入操作的简写形式。 123string s(&quot;C++ Primer&quot;), s2 = s; // initialize s and s2 to &quot;C++ Primer&quot;s.insert(s.size(), &quot; 4th Ed.&quot;); // s == &quot;C++ Primer 4th Ed.&quot;s2.append(&quot; 4th Ed.&quot;); // equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2 replace函数是调用erase和insert函数的简写形式。 12345// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;s.erase(11, 3); // s == &quot;C++ Primer Ed.&quot;s.insert(11, &quot;5th&quot;); // s == &quot;C++ Primer 5th Ed.&quot;// starting at position 11, erase three characters and then insert &quot;5th&quot;s2.replace(11, 3, &quot;5th&quot;); // equivalent: s == s2 string搜索操作（string Search Operations）string的每个搜索操作都返回一个string::size_type值，表示匹配位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为const string::size_type类型，并初始化为-1。 不建议用int或其他带符号类型来保存string搜索函数的返回值。 string搜索操作： compare函数（The compare Functions）string类型提供了一组compare函数进行字符串比较操作，类似C标准库的strcmp函数。 compare函数的几种参数形式： 数值转换（Numeric Conversions）C++11增加了string和数值之间的转换函数： 进行数值转换时，string参数的第一个非空白字符必须是符号（+或-）或数字。它可以以0x或0X开头来表示十六进制数。对于转换目标是浮点值的函数，string参数也可以以小数点开头，并可以包含e或E来表示指数部分。 如果给定的string不能转换为一个数值，则转换函数会抛出invalid_argument异常。如果转换得到的数值无法用任何类型表示，则抛出out_of_range异常。 容器适配器（Container Adaptors）标准库定义了stack、queue和priority_queue三种容器适配器。容器适配器可以改变已有容器的工作机制。 所有容器适配器都支持的操作和类型： 默认情况下，stack和queue是基于deque实现的，priority_queue是基于vector实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。 1234// empty stack implemented on top of vectorstack&lt;string, vector&lt;string&gt;&gt; str_stk;// str_stk2 is implemented on top of vector and initially holds a copy of svecstack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec); 所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在array上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用forward_list构造适配器。 栈适配器stack定义在头文件stack中，其支持的操作如下： 队列适配器queue和priority_queue定义在头文件queue中，其支持的操作如下： queue使用先进先出（first-in，first-out，FIFO）的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第八章-IO库","slug":"C++ Primer/C++primer笔记-第八章-IO库","date":"2022-02-26T12:25:30.000Z","updated":"2022-06-29T13:04:00.943Z","comments":true,"path":"2022/02/26/C++ Primer/C++primer笔记-第八章-IO库/","link":"","permalink":"http://icecorn.github.io/2022/02/26/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-IO%E5%BA%93/","excerpt":"","text":"第8章 IO库部分IO库设施： istream：输入流类型，提供输入操作。 ostream：输出流类型，提供输出操作。 cin：istream对象，从标准输入读取数据。 cout：ostream对象，向标准输出写入数据。 cerr：ostream对象，向标准错误写入数据。 &gt;&gt;运算符：从istream对象读取输入数据。 &lt;&lt;运算符：向ostream对象写入输出数据。 getline函数：从istream对象读取一行数据，写入string对象。 IO类（The IO Classes）头文件iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存中string对象的类型。 宽字符版本的IO类型和函数的名字以w开始，如wcin、wcout和wcerr分别对应cin、cout和cerr。它们与其对应的普通char版本都定义在同一个头文件中，如头文件fstream定义了ifstream和wifstream类型。 可以将派生类的对象当作其基类的对象使用。 IO象无拷贝或赋值（No Copy or Assign for IO Objects）不能拷贝或对IO对象赋值。 1234ofstream out1, out2;out1 = out2; // error: cannot assign stream objectsofstream print(ofstream); // error: can&#x27;t initialize the ofstream parameterout2 = print(out2); // error: cannot copy stream objects 由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 条件状态（Condition States）IO库条件状态： badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法继续使用了。在发生可恢复错误后，failbit会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，eofbit和failbit都会被置位。如果流未发生错误，则goodbit的值为0。如果badbit、failbit和eofbit任何一个被置位，检测流状态的条件都会失败。 12while (cin &gt;&gt; word) // ok: read operation successful... good函数在所有错误均未置位时返回true。而bad、fail和eof函数在对应错误位被置位时返回true。此外，在badbit被置位时，fail函数也会返回true。因此应该使用good或fail函数确定流的总体状态，eof和bad只能检测特定错误。 流对象的rdstate成员返回一个iostate值，表示流的当前状态。setstate成员用于将指定条件置位（叠加原始流状态）。clear成员的无参版本清除所有错误标志；含参版本接受一个iostate值，用于设置流的新状态（覆盖原始流状态）。 12345// remember the current state of cinauto old_state = cin.rdstate(); // remember the current state of cincin.clear(); // make cin validprocess_input(cin); // use cincin.setstate(old_state); // now reset cin to its old state 管理输出缓冲（Managing the Output Buffer）每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多： 程序正常结束。 缓冲区已满。 使用操纵符（如endl）显式刷新缓冲区。 在每个输出操作之后，可以用unitbuf操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，cin和cerr都关联到cout，因此，读cin或写cerr都会刷新cout的缓冲区。 flush操纵符刷新缓冲区，但不输出任何额外字符。ends向缓冲区插入一个空字符，然后刷新缓冲区。 123cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; // writes hi and a newline, then flushes the buffercout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // writes hi, then flushes the buffer; adds no datacout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends; // writes hi and a null, then flushes the buffer 如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操纵符。它令流在接下来的每次写操作后都进行一次flush操作。而nounitbuf操纵符则使流恢复使用正常的缓冲区刷新机制。 123cout &lt;&lt; unitbuf; // all writes will be flushed immediately// any output is flushed immediately, no bufferingcout &lt;&lt; nounitbuf; // returns to normal buffering 如果程序异常终止，输出缓冲区不会被刷新。 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起，因此下面的语句会导致cout的缓冲区被刷新： 1cin &gt;&gt; ival; 交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。 使用tie函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。tie的第二个版本接受一个指向ostream的指针，将本对象关联到此ostream。 123456cin.tie(&amp;cout); // illustration only: the library ties cin and cout for us// old_tie points to the stream (if any) currently tied to cinostream *old_tie = cin.tie(nullptr); // cin is no longer tied// ties cin and cerr; not a good idea because cin should be tied to coutcin.tie(&amp;cerr); // reading cin flushes cerr, not coutcin.tie(old_tie); // reestablish normal tie between cin and cout 每个流同时最多关联一个流，但多个流可以同时关联同一个ostream。向tie传递空指针可以解开流的关联。 文件输入输出（File Input and Output）头文件fstream定义了三个类型来支持文件IO：ifstream从给定文件读取数据，ofstream向指定文件写入数据，fstream可以同时读写指定文件。 使用文件流对象（Using File Stream Objects）每个文件流类型都定义了open函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。 创建文件流对象时，如果提供了文件名（可选），open会被自动调用。 12ifstream in(ifile); // construct an ifstream and open the given fileofstream out; // output file stream that is not associated with any file 在C++11中，文件流对象的文件名可以是string对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。 在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受iostream类型引用或指针参数的函数，可以用对应的fstream类型来调用。 可以先定义空文件流对象，再调用open函数将其与指定文件关联。如果open调用失败，failbit会被置位。 对一个已经打开的文件流调用open会失败，并导致failbit被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用close关闭当前文件，再调用clear重置流的条件状态（close不会重置流的条件状态）。 当fstream对象被销毁时，close会自动被调用。 文件模式（File Modes）每个流都有一个关联的文件模式，用来指出如何使用文件。 只能对ofstream或fstream对象设定out模式。 只能对ifstream或fstream对象设定in模式。 只有当out被设定时才能设定trunc模式。 只要trunc没被设定，就能设定app模式。在app模式下，即使没有设定out模式，文件也是以输出方式打开。 默认情况下，即使没有设定trunc，以out模式打开的文件也会被截断。如果想保留以out模式打开的文件内容，就必须同时设定app模式，这会将数据追加写到文件末尾；或者同时设定in模式，即同时进行读写操作。 ate和binary模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。 与ifstream对象关联的文件默认以in模式打开，与ofstream对象关联的文件默认以out模式打开，与fstream对象关联的文件默认以in和out模式打开。 默认情况下，打开ofstream对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定app或in模式。 流对象每次打开文件时都可以改变其文件模式。 12345ofstream out; // no file mode is setout.open(&quot;scratchpad&quot;); // mode implicitly out and truncout.close(); // close out so we can use it for a different fileout.open(&quot;precious&quot;, ofstream::app); // mode is out and appout.close(); string流（string Streams）头文件sstream定义了三个类型来支持内存IO：istringstream从string读取数据，ostringstream向string写入数据，stringstream可以同时读写string的数据。 使用istringstream（Using an istringstream）12345678910111213141516171819// members are public by defaultstruct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125;;string line, word; // will hold a line and word from input, respectivelyvector&lt;PersonInfo&gt; people; // will hold all the records from the input// read the input a line at a time until cin hits end-of-file (or another error)while (getline(cin, line))&#123; PersonInfo info; // create an object to hold this record&#x27;s data istringstream record(line); // bind record to the line we just read record &gt;&gt; info.name; // read the name while (record &gt;&gt; word) // read the phone numbers info.phones.push_back(word); // and store them people.push_back(info); // append this record to people&#125; 使用ostringstream（Using ostringstreams）123456789101112131415161718192021for (const auto &amp;entry : people)&#123; // for each entry in people ostringstream formatted, badNums; // objects created on each loop for (const auto &amp;nums : entry.phones) &#123; // for each number if (!valid(nums)) &#123; badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; // string in badNums &#125; else // &#x27;&#x27;writes&#x27;&#x27; to formatted&#x27;s string formatted &lt;&lt; &quot; &quot; &lt;&lt; format(nums); &#125; if (badNums.str().empty()) // there were no bad numbers os &lt;&lt; entry.name &lt;&lt; &quot; &quot; // print the name &lt;&lt; formatted.str() &lt;&lt; endl; // and reformatted numbers else // otherwise, print the name and bad numbers cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid number(s) &quot; &lt;&lt; badNums.str() &lt;&lt; endl;&#125;","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第七章-类","slug":"C++ Primer/C++primer笔记-第七章-类","date":"2022-02-24T12:25:30.000Z","updated":"2022-06-29T12:58:17.632Z","comments":true,"path":"2022/02/24/C++ Primer/C++primer笔记-第七章-类/","link":"","permalink":"http://icecorn.github.io/2022/02/24/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/","excerpt":"","text":"第七章 类成员函数成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。 123456789101112struct Sales_data&#123; // new members: operations on Sales_data objects std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; // data members std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; 成员函数通过一个名为this的隐式额外参数来访问调用它的对象。this参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用this指针。 默认情况下，this的类型是指向类类型非常量版本的常量指针。this也遵循初始化规则，所以默认不能把this绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。 C++允许在成员函数的参数列表后面添加关键字const，表示this是一个指向常量的指针。使用关键字const的成员函数被称作常量成员函数（const member function）。 下边这种就是错误的：因为上边声明了isbn（）是一个const的成员函数。 1234567// pseudo-code illustration of how the implicit this pointer is used// this code is illegal: we may not explicitly define the this pointer ourselves// note that this is a pointer to const because isbn is a const memberstd::string Sales_data::isbn(const Sales_data *const this)&#123; return this-&gt;isbn;&#125; 常量对象和指向常量对象的引用或指针都只能调用常量成员函数。 总结：因为this默认指向非常量的成员函数，所以常量对象不能调用非常量的函数，常量对象只能调用常量的成员函数（后边加const的，这时用this的话，this是一个常量指针）。另外const成员函数的声明和定义后边必须都有const 防止隐式构造函数转换在要求隐式转换的程序上下文中，可以通过将构造函数声明为explicit的加以阻止。 12345678910class Sales_data&#123;public: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123; &#125; explicit Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125; explicit Sales_data(std::istream&amp;); // remaining members as before&#125;; explicit关键字只对接受一个实参的构造函数有效。 只能在类内声明构造函数时使用explicit关键字，在类外定义时不能重复。 执行拷贝初始化时（使用=）会发生隐式转换，所以explicit构造函数只能用于直接初始化。 123Sales_data item1 (null_book); // ok: direct initialization// error: cannot use the copy form of initialization with an explicit constructorSales_data item2 = null_book; 可以使用explicit构造函数显式地强制转换类型。 1234// ok: the argument is an explicitly constructed Sales_data objectitem.combine(Sales_data(null_book));// ok: static_cast can use an explicit constructoritem.combine(static_cast&lt;Sales_data&gt;(cin)); 类的静态成员使用关键字static可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。 12345678910111213class Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const的，也不能在静态成员函数内使用this指针。 用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。 1234567891011121314151617double r;r = Account::rate(); // access a static member using the scope operatorAccount ac1;Account *ac2 = &amp;ac1;// equivalent ways to call the static member rate functionr = ac1.rate(); // through an Account object or referencer = ac2-&gt;rate(); // through a pointer to an Account objectclass Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125;private: static double interestRate; // remaining members as before&#125;; 在类外部定义静态成员时，不能重复static关键字，其只能用于类内部的声明语句。 由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。 12// define and initialize a static class memberdouble Account::interestRate = initRate(); 建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。 尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式。 123456789class Account&#123;public: static double rate() &#123; return interestRate; &#125; static void rate(double);private: static constexpr int period = 30; // period is a constant double daily_tbl[period];&#125;; 静态数据成员的类型可以是它所属的类类型。 123456class Bar&#123; static Bar mem1; // ok: static member can have incomplete type Bar *mem2; // ok: pointer member can have incomplete type Bar mem3; // error: data members must have complete type&#125; 可以使用静态成员作为函数的默认实参。 static关键字详解从程序的存储上来看： 正文段CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是经常环境指针环境表环境字符串执行的程序(如文本编辑程序、C编译程序、s h e l l等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令。 初始化数据段通常将此段称为数据段，它包含了程序中需赋初值的变量。初始化的全局变量和静态变量存放在这里。例如，C程序中任何函数之外的说明：int maxcount = 99; 使此变量以初值存放在初始化数据段中。a.初始化的全局变量b.初始化的静态变量 非初始化数据段通常将此段称为bss段，这一名称来源于早期汇编程序的一个操作符，意思是“block started by symbol（由符号开始的块）”，未初始化的全局变量和静态变量存放在这里。在程序开始执行之前，内核将此段初始化为0。函数外的说明：long sum[1000] ; 使此变量存放在非初始化数据段中。a.未初始化的全局变量b.未初始化的静态变量 堆需要由程序员分配释放管理，若程序员不释放，程序结束时可能由OS回收。通常在堆中进行动态存储分配。如程序中的malloc, calloc, realloc等函数都从这里面分配。堆是从下向上分配的。 栈由编译器自动分配释放管理。局部变量及每次函数调用时返回地址、以及调用者的环境信息（例如某些机器寄存器）都存放在栈中。新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C函数可以递归调用。递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响另一个函数调用实例中的变量。a.局部变量b.函数调用时返回地址c.调用者的环境信息（例如某些机器寄存器） c++中static用法：1、static 数据成员 在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream.h&gt;class Myclass&#123;public: Myclass(int a,int b,int c); void GetSum();private: int a,b,c; static int Sum; //声明静态数据成员&#125;;int Myclass::Sum=0; //定义并初始化静态数据成员//static int Myclass::Sum = 0; //注意加static， 是错误的Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c;&#125;void Myclass::GetSum()&#123; cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl;&#125;void main()&#123; Myclass M(1,2,3); M.GetSum(); // cout 6 Myclass N(4,5,6); N.GetSum(); // cout 21 M.GetSum(); // cout 21&#125; 可以看出，static数据成员有以下特点：(1). 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。 (2). 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。 在上例中，语句 int Myclass::Sum = 0; 是定义静态数据成员； (3). 静态数据成员和普通数据成员一样遵从public, protected, private 访问规则；除了定义，定义不要管访问规则。 (4). 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； (5). 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： 12//＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞int Myclass::Sum=0; (6). 类的静态数据成员有两种 访问形式： 12345//＜类对象名＞.＜静态数据成员名＞M.Sum = 0//＜类类型名＞::＜静态数据成员名＞Myclass::Sum = 0 但是上面这个例子是不行的，因为他是private的变量，如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ； (7). 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了； (8). 同全局变量相比，使用静态数据成员有两个优势：a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能； 2、static 成员函数 static 成员函数，它为类的全部对象服务而不是为某一个类的具体对象服务。普通的成员函数一般都隐含了一个this指针，但静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的no-static数据成员，也无法访问no-static成员函数，它只能调用其余的静态成员函数。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream.h&gt;class Myclass&#123;public: Myclass(int a,int b,int c); static void GetSum(); /声明静态成员函数private: int a,b,c; static int Sum; //声明静态数据成员&#125;;int Myclass::Sum = 0;//定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c; //非静态成员函数可以访问静态数据成员&#125;//static void Myclass::GetSum()&#123;...&#125; //加上static是错误的void Myclass::GetSum() //静态成员函数的实现&#123; //cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员 cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl; //静态函数是能访问静态数据成员&#125; void main()&#123; Myclass M(1,2,3); M.GetSum(); Myclass N(4,5,6); N.GetSum(); Myclass::GetSum();&#125; 关于静态成员函数，可以总结为以下几点： (1). 在类体外，静态函数的定义前不能加关键字static； (2). static成员之间可以相互访问，包括static成员函数访问static数据成员和访问static成员函数； (3). 非静态成员函数可以任意地访问静态成员函数和静态数据成员； (4). 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的； (5). 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； (6). 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)或直接用类名调用静态成员函数 M.GetSum();Myclass::GetSum();调用类的静态成员函数。但是，一样 要遵从 public，protected，private 访问规则 。 堆和栈的区别1.栈简介栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。参考如下代码： 123456int main() &#123; int b; //栈 char s[] = &quot;abc&quot;; //栈 char *p2; //栈&#125; 其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如上面代码中变量 s 的地址小于变量 b 的地址，p2 地址小于 s 的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。 2. 堆简介堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。参考如下代码： 1234567891011121314151617int main() &#123; // C 中用 malloc() 函数申请 char* p1 = (char *)malloc(10); cout&lt;&lt;(int*)p1&lt;&lt;endl; //输出：00000000003BA0C0 // 用 free() 函数释放 free(p1); // C++ 中用 new 运算符申请 char* p2 = new char[10]; cout &lt;&lt; (int*)p2 &lt;&lt; endl; //输出：00000000003BA0C0 // 用 delete 运算符释放 delete[] p2;&#125; 其中 p1 所指的 10 字节的内存空间与 p2 所指的 10 字节内存空间都是存在于堆。堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。 关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。**另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。(这就是为什么stl中pool_allocator更好的原因，可以节省一些存放分配大小的首地址的开销)**由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。 1.3 堆与栈区别堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏； （2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB； （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。 （4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloc()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。 （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。 （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。 从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。 无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第六章-函数","slug":"C++ Primer/C++primer笔记-第六章-函数","date":"2022-02-23T12:25:30.000Z","updated":"2022-06-29T12:56:42.477Z","comments":true,"path":"2022/02/23/C++ Primer/C++primer笔记-第六章-函数/","link":"","permalink":"http://icecorn.github.io/2022/02/23/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/","excerpt":"","text":"第六章 函数传引用参数使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。 除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。 如果函数无须改变引用形参的值，最好将其声明为常量引用。 一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。 const形参和实参当形参有顶层const时，传递给它常量对象或非常量对象都是可以的。 可以使用非常量对象初始化一个底层const形参，但是反过来不行。 把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。 所以，“不变”的参数一定要记得加上const 数组形参因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。 1234// each function has a single parameter of type const int*void print(const int*);void print(const int[]); // shows the intent that the function takes an arrayvoid print(const int[10]); // dimension for documentation purposes (at best) 因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。 以数组作为形参的函数必须确保使用数组时不会越界。 如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。 形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。 将多维数组传递给函数时，数组第二维（以及后面所有维度）的大小是数组类型的一部分，不能省略。 12f(int &amp;arr[10]) // error: declares arr as an array of referencesf(int (&amp;arr)[10]) // ok: arr is a reference to an array of ten ints 关于函数返回引用调用一个返回引用的函数会得到左值，其他返回类型得到右值。 如果返回的是引用的话，是可以当作左值来使用的 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int value[10];int error=-1;int &amp;func(int n)&#123; if(n&gt;=0&amp;&amp;n&lt;=9) return value[n];//返回的引用所绑定的变量一定是全局变量，不能是函数中定义的局部变量 else return error;&#125; int main()&#123; func(0)=10; func(4)=12; cout&lt;&lt;value[0]&lt;&lt;endl; cout&lt;&lt;value[4]&lt;&lt;endl; return 0; &#125; C++函数返回的步骤是：1、一般情况下计算结果保存在某个局部变量内，上面的程序，结果保存在变量 result 内。2、return result 的时候，result 的值会“复制” 到一个临时变量中，假设变量名为 temp，即执行 temp = result，然后，函数生命周期结束。3、最后， 主程序把 temp 变量的值“复制”到目标变量中，例如：x4 = temp。 这里面有两次“复制”过程，因此需要构造temp和目标变量。有些编译器会自动优化，甚至只需要构造一次 result 就解决问题了。这样虽然效率提高了很多，但是这样的源代码却不合适，因为换成其他的编译器可能效率就低下来了。 引用作为函数的返回值 引用作为函数的返回值时，必须在定义函数时在函数名前将&amp; 用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本 123456789101112131415161718192021222324//代码来源：RUNOOB#include&lt;iostream&gt;using namespace std;float temp;float fn1(float r)&#123; temp=r*r*3.14; return temp;&#125; float &amp;fn2(float r)&#123; //&amp;说明返回的是temp的引用，换句话说就是返回temp本身 temp=r*r*3.14; return temp;&#125;int main()&#123; float a=fn1(5.0); //case 1：返回值 //float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type &#x27;float&amp;&#x27; from an rvalue of type &#x27;float&#x27; //（有些编译器可以成功编译该语句，但会给出一个warning） float c=fn2(5.0);//case 3：返回引用 float &amp;d=fn2(5.0);//case 4：用函数返回的引用作为新引用的初始化值 cout&lt;&lt;a&lt;&lt;endl;//78.5 //cout&lt;&lt;b&lt;&lt;endl;//78.5 cout&lt;&lt;c&lt;&lt;endl;//78.5 cout&lt;&lt;d&lt;&lt;endl;//78.5 return 0;&#125; case 1：用返回值方式调用函数（如下图，图片来源：伯乐在线）： 返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a case 2：用函数的返回值初始化引用的方式调用函数 这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &amp;b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。 如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用： 12int x=fn1(5.0);int &amp;b=x; case 3:用返回引用的方式调用函数 这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。 case 4:用函数返回的引用作为新引用的初始化值的方式来调用函数 这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。（注意看上边的代码，在最上边声明了全局变量temp，所以是ok的，但是如果temp是函数里的局部变量的话，它就会在函数结束时被析构掉，这时候d就变成了未定义的引用了，危险！） 不能返回局部变量的引用。如上面的例子，如果temp是局部变量，那么它会在函数返回后被销毁，此时对temp的引用就会成为“无所指”的引用，程序会进入未知状态。 不能返回函数内部通过new分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生 当返回类成员的引用时，最好是const引用。这样可以避免在无意的情况下破坏该类的成员。 到这里的，用引用做返回值的情况就比较清晰了，接下来要弄清楚上边的各种变量是存在哪里的（堆还是栈），还有关于右值引用和move方法。 用引用实现多态在C++中，引用是除了指针外另一个可以产生多态效果的手段。也就是说一个基类的引用可以用来绑定其派生类的实例 1234class Father;//基类（父类）class Son：public Father&#123;.....&#125;//Son是Father的派生类Son son;//son是类Son的一个实例Father &amp;ptr=son;//用派生类的对象初始化基类对象的使用 特别注意： ptr只能用来访问派生类对象中从基类继承下来的成员。如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。 这里就和java是一样的，通过父类引用指向子类对象来实现多态 函数重载如果形参是某种类型的指针或引用，则通过区分其指向的对象是常量还是非常量可以实现函数重载，此时的const是底层的。当我们传递给重载函数一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。 123456// functions taking const and nonconst references or pointers have different parameters// declarations for four independent, overloaded functionsRecord lookup(Account&amp;); // function that takes a reference to AccountRecord lookup(const Account&amp;); // new function that takes a const referenceRecord lookup(Account*); // new function, takes a pointer to AccountRecord lookup(const Account*); // new function, takes a pointer to const const_cast可以用于函数的重载。当函数的实参不是常量时，将得到普通引用。 123456789101112// return a reference to the shorter of two stringsconst string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125;string &amp;shorterString(string &amp;s1, string &amp;s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;(r);&#125; 函数匹配（function matching）也叫做重载确定（overload resolution），是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。 调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。 编译器找不到任何一个函数与实参匹配，发出无匹配（no match）的错误信息。 有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用（ambiguous call）的错误信息。 特殊用途语言特性默认实参 默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 12typedef string::size_type sz;string screen(sz ht = 24, sz wid = 80, char backgrnd = &#x27; &#x27;); 调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。 如果想使用默认实参，只要在调用函数的时候省略该实参即可。 虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 1234// no default for the height or width parametersstring screen(sz, sz, char = &#x27; &#x27;);string screen(sz, sz, char = &#x27;*&#x27;); // error: redeclarationstring screen(sz = 24, sz = 80, char); // ok: adds default 默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。 12345678910111213// 函数声明void fun(int n);int main()&#123; // Error: 编译器向前查找函数声明 // fun调用形式与声明不符 fun(); return EXIT_SUCCESS;&#125;// 函数定义void fun(int n = 0) &#123; /*...*/ &#125; 局部变量不能作为函数的默认实参。 用作默认实参的名字在函数声明所在的作用域内解析，但名字的求值过程发生在函数调用时。 1234567891011121314// the declarations of wd, def, and ht must appear outside a functionsz wd = 80;char def = &#x27; &#x27;;sz ht();string screen(sz = ht(), sz = wd, char = def);string window = screen(); // calls screen(ht(), 80, &#x27; &#x27;)void f2()&#123; def = &#x27;*&#x27;; // changes the value of a default argument sz wd = 100; // hides the outer definition of wd but does not change the default window = screen(); // calls screen(ht(), 80, &#x27;*&#x27;)&#125; 内联函数和constexpr函数内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字inline。 12345// inline version: find the shorter of two stringsinline const string &amp;horterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; 在函数声明和定义中都能使用关键字inline，但是建议只在函数定义时使用。 一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和switch语句，否则函数会被编译为普通函数。 为什么要有内联函数，内联函数有什么用？ 因为，在大多数机器上，调用函数都要做很多的工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新的位置来执行。而内联函数的目的就是提高函数的执行效率，用关键字 inline 放在函数定义的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开。假设我们将 max 定义为内联函数： 1234567inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;则调用： cout&lt;&lt;max(a, b)&lt;&lt;endl;在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;从而消除了把max写成函数的额外开销。 定义在类声明之中的成员函数将自动的成为内联函数 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。 Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. constexpr函数是指能用于常量表达式的函数。constexpr函数的返回类型及所有形参的类型都得是字面值类型。另外C++11标准要求constexpr函数体中必须有且只有一条return语句，但是此限制在C++14标准中被删除。 123456constexpr int new_sz()&#123; return 42;&#125;constexpr int foo = new_sz(); // ok: foo is a constant expression constexpr函数的返回值可以不是一个常量。 123456789// scale(arg) is a constant expression if arg is a constant expressionconstexpr size_t scale(size_t cnt)&#123; return new_sz() * cnt;&#125;int arr[scale(2)]; // ok: scale(2) is a constant expressionint i = 2; // i is not a constant expressionint a2[scale(i)]; // error: scale(i) is not a constant expression constexpr函数被隐式地指定为内联函数。 和其他函数不同，内联函数和constexpr函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或constexpr函数，它的多个定义必须完全一致。因此内联函数和constexpr函数通常定义在头文件中。 调试帮助 变量名称 内容 __func__ 当前函数名称 __FILE__ 当前文件名称 __LINE__ 当前行号 __TIME__ 文件编译时间 __DATE__ 文件编译日期 函数指针要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。 1234// compares lengths of two stringsbool lengthCompare(const string &amp;, const string &amp;);// pf points to a function returning bool that takes two const string referencesbool (*pf)(const string &amp;, const string &amp;); // uninitialized 可以直接使用指向函数的指针来调用函数，无须提前解引用指针。 123456pf = lengthCompare; // pf now points to the function named lengthComparepf = &amp;lengthCompare; // equivalent assignment: address-of operator is optionalbool b1 = pf(&quot;hello&quot;, &quot;goodbye&quot;); // calls lengthComparebool b2 = (*pf)(&quot;hello&quot;, &quot;goodbye&quot;); // equivalent callbool b3 = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;); // equivalent call 对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。 123void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; // pf1 points to ff(unsigned) 可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。 1234567// third parameter is a function type and is automatically treated as a pointer to functionvoid useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));// equivalent declaration: explicitly define the parameter as a pointer to functionvoid useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;));// automatically converts the function lengthCompare to a pointer to functionuseBigger(s1, s2, lengthCompare); 关键字decltype作用于函数时，返回的是函数类型，而不是函数指针类型。 函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第四章-表达式","slug":"C++ Primer/C++primer笔记-第四章-表达式","date":"2022-02-21T12:25:30.000Z","updated":"2022-06-29T12:53:37.524Z","comments":true,"path":"2022/02/21/C++ Primer/C++primer笔记-第四章-表达式/","link":"","permalink":"http://icecorn.github.io/2022/02/21/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"第四章 表达式运算符重载C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。 左值和右值C++的表达式分为右值（rvalue）和左值（lvalue）。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址。需要右值的地方可以用左值代替，反之则不行。 赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。 取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符都返回左值。 内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。 如果decltype作用于一个求值结果是左值的表达式，会得到引用类型。 深度理解左值和右值 ​ 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。 右值、将亡值 在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。 ​ C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。 ​ 将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。 左值引用、右值引用 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。 ​ 右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。 ​ 左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。 123456int &amp;a = 2; # 左值引用绑定到右值，编译失败int b = 2; # 非常量左值const int &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过const int d = 2; # 常量左值const int &amp;e = c; # 常量左值引用绑定到常量左值，编译通过const int &amp;b =2; # 常量左值引用绑定到右值，编程通过 ​ 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如： 1234int a;int &amp;&amp;r1 = c; # 编译失败int &amp;&amp;r2 = std::move(a); # 编译通过下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。 关于运算符逻辑运算符注意事项 逻辑与（logical AND）运算符&amp;&amp;和逻辑或（logical OR）运算符||都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。 递增和递减运算符 递增和递减运算符分为前置版本和后置版本： 前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。 后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。 123int i = 0, j;j = ++i; // j = 1, i = 1: prefix yields the incremented valuej = i++; // j = 1, i = 2: postfix yields the unincremented value 除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。 在某些语句中混用解引用和递增运算符可以使程序更简洁。 1cout &lt;&lt; *iter++ &lt;&lt; endl; 因为后置++返回的是值而非引用，所以 ++++i可以，而i++++不可以。 sizeof运算符sizeof运算符返回一个表达式或一个类型名字所占的字节数，返回值是size_t类型。 在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。 sizeof运算符的结果部分依赖于其作用的类型： 对char或者类型为char的表达式执行sizeof运算，返回值为1。 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 对指针执行sizeof运算得到指针本身所占空间的大小。 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。 对数组执行sizeof运算得到整个数组所占空间的大小。 对string或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。 就是说对于sizeof(vector)应该等于24，因为vector内有3个指针 类型转换无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。 算术转换 把一种算术类型转换成另一种算术类型叫做算术转换。 整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。 其他隐式类型转换 在大多数表达式中，数组名字自动转换成指向数组首元素的指针。 常量整数值0或字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*。 任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是false，否则是true。 指向非常量类型的指针能转换成指向相应的常量类型的指针。 显式转换 显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。 命名的强制类型转换（named cast）形式如下： 1cast-name&lt;type&gt;(expression); 其中type是转换的目标类型，expression是要转换的值。如果type是引用类型，则转换结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种，用来指定转换的方式。 dynamic_cast支持运行时类型识别。 任何具有明确定义的类型转换，只要不包含底层const（数据是常量，比如const int），都能使用static_cast。 const_cast只能改变运算对象的底层const，不能改变表达式的类型。同时也只有const_cast能改变表达式的常量属性。const_cast常常用于函数重载。 reinterpret_cast通常为运算对象的位模式提供底层上的重新解释。 早期版本的C++语言中，显式类型转换包含两种形式： 12type (expression); // function-style cast notation(type) expression; // C-language-style cast notation","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第三章-字符串，向量和数组","slug":"C++ Primer/C++primer笔记-第三章-字符串，向量和数组","date":"2022-02-20T12:25:30.000Z","updated":"2022-06-29T12:52:21.527Z","comments":true,"path":"2022/02/20/C++ Primer/C++primer笔记-第三章-字符串，向量和数组/","link":"","permalink":"http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"第三章 字符串,向量和数组关于string的注意点： size函数返回string对象的长度，返回值是string::size_type类型，这是一种无符号类型。要使用size_type，必须先指定它是由哪种类型定义的。 当把string对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是string。 123string s4 = s1 + &quot;, &quot;; // ok: adding a string and a literalstring s5 = &quot;hello&quot; + &quot;, &quot;; // error: no string operandstring s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand 其实是变量生命周期的问题，在这里记录一下： 123456789string s1 = string(&quot;string1&quot;); string s2 = string(&quot;string2&quot;); const char* p1 = s1.substr(1).data(); // substr(1)的意思是取[字符串]从下标1到结尾的部分 const char* p2 = s2.substr(1).data();cout &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; endl; 这里输出应该是tring1tring2，却输出了tring2tring2。这是因为s1.substr(1)创建了一个临时对象来存储s1的字串，然后data()获取这个子串内存的指针赋值给p1。但是到下一行，编译器发现刚才的临时对象没用了，就把它析构掉了（注意，析构表明cpu重新获得这块内存的分配权，但是里边的信息01状态不会改变），然后p2进行一样的操作，刚好s2.substr()又分配到了这块内存空间，这就导致最后的结果是p1p2都指向这块内存，而这块内存是tring2！ 所以，在使用接口函数时一定要注意返回值是什么，而且编程时要注意对象的生命周期！ vector使用注意：vector和string对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。 123456vector&lt;int&gt; ivec; // empty vectorfor (decltype(ivec.size()) ix = 0; ix != 10; ++ix)&#123; ivec[ix] = ix; // disaster: ivec has no elements ivec.push_back(ix); // ok: adds a new element with value ix&#125; vector原理见stl笔记 数组（Arrays）数组类似vector，但数组的大小确定不变，不能随意向数组中添加元素。 如果不清楚元素的确切个数，应该使用vector。 定义和初始化内置数组（Defining and Initializing Built-in Arrays）数组是一种复合类型，声明形式为a[d]，其中a是数组名称，d是数组维度（dimension）。维度必须是一个常量表达式。 默认情况下，数组的元素被默认初始化。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值列表推断类型。 如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但如果显式指明了维度，那么初始值的数量不能超过指定的大小。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。 123456const unsigned sz = 3;int ia1[sz] = &#123;0,1,2&#125;; // array of three ints with values 0, 1, 2int a2[] = &#123;0, 1, 2&#125;; // an array of dimension 3int a3[5] = &#123;0, 1, 2&#125;; // equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; // same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;int a5[2] = &#123;0,1,2&#125;; // error: too many initializers 可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。 1234char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;; // list initialization, no nullchar a2[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;, &#x27;\\0&#x27;&#125;; // list initialization, explicit nullchar a3[] = &quot;C++&quot;; // null terminator added automaticallyconst char a4[6] = &quot;Daniel&quot;; // error: no space for the null! 不能用一个数组初始化或直接赋值给另一个数组。 从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。 1234int *ptrs[10]; // ptrs is an array of ten pointers to intint &amp;refs[10] = /* ? */; // error: no arrays of referencesint (*Parray)[10] = &amp;arr; // Parray points to an array of ten intsint (&amp;arrRef)[10] = arr; // arrRef refers to an array of ten ints 访问数组元素（Accessing the Elements of an Array）数组下标通常被定义成size_t类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。size_t定义在头文件cstddef中。 大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。 指针和数组（Pointers and Arrays）在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。 123string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; // array of stringsstring *p = &amp;nums[0]; // p points to the first element in numsstring *p2 = nums; // equivalent to p2 = &amp;nums[0] 这里刚好可以说明一下指针和引用的区别，为什么要有引用这个东西。比如有一个长度为10的数组arr，要改变第五个元素，arr[4] = 0；就可以直接改，这里的arr[4]就是引用，表述起来比较方便，想一下如果要用指针表述的话，就是(&amp;arr[4]) = 0;更复杂的情况会更繁琐，这可能是引用出现的一个因素吧* 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。但decltype关键字不会发生这种转换，直接返回数组类型。 12345678int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsauto ia2(ia); // ia2 is an int* that points to the first element in iaia2 = 42; // error: ia2 is a pointer, and we can&#x27;t assign an int to a pointerauto ia2(&amp;ia[0]); // now it&#x27;s clear that ia2 has type int*// ia3 is an array of ten intsdecltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;ia3 = p; // error: can&#x27;t assign an int* to an arrayia3[4] = i; // ok: assigns the value of i to an element in ia3 C++11在头文件iterator中定义了两个名为begin和end的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。 123int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsint *beg = begin(ia); // pointer to the first element in iaint *last = end(ia); // pointer one past the last element in ia 两个指针相减的结果类型是ptrdiff_t，这是一种定义在头文件cstddef中的带符号类型。 标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。 C风格字符串C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。 C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库string要比使用C风格字符串更加安全和高效。 C风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组。 与旧代码的接口（Interfacing to Older Code）任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替： 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。 在string对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。 不能用string对象直接初始化指向字符的指针。为了实现该功能，string提供了一个名为c_str的成员函数，返回const char*类型的指针，指向一个以空字符结束的字符数组，数组的数据和string对象一样。 123string s(&quot;Hello World&quot;); // s holds Hello Worldchar *str = s; // error: can&#x27;t initialize a char* from a stringconst char *str = s.c_str(); // ok 针对string对象的后续操作有可能会让c_str函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 可以使用数组来初始化vector对象，但是需要指明要拷贝区域的首元素地址和尾后地址。 123int int_arr[] = &#123;0, 1, 2, 3, 4, 5&#125;;// ivec has six elements; each is a copy of the corresponding element in int_arrvector&lt;int&gt; ivec(begin(int_arr), end(int_arr)); 在新版本的C++程序中应该尽量使用vector、string和迭代器，避免使用内置数组、C风格字符串和指针。 多维数组（Multidimensional Arrays）C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。 多维数组初始化的几种方式： 123456789101112int ia[3][4] =&#123; // three elements; each element is an array of size 4 &#123;0, 1, 2, 3&#125;, // initializers for the row indexed by 0 &#123;4, 5, 6, 7&#125;, // initializers for the row indexed by 1 &#123;8, 9, 10, 11&#125; // initializers for the row indexed by 2&#125;;// equivalent initialization without the optional nested braces for each rowint ib[3][4] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;// explicitly initialize only element 0 in each rowint ic[3][4] = &#123;&#123; 0 &#125;, &#123; 4 &#125;, &#123; 8 &#125;&#125;;// explicitly initialize row 0; the remaining elements are value initializedint id[3][4] = &#123;0, 3, 6, 9&#125;; 可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。 123// assigns the first element of arr to the last element in the last row of iaia[2][3] = arr[0][0][0];int (&amp;row)[4] = ia[1]; // binds row to the second four-element array in ia 使用范围for语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。 123for (const auto &amp;row : ia) // for every element in the outer array for (auto col : row) // for every element in the inner array cout &lt;&lt; col &lt;&lt; endl; 如果row不是引用类型，编译器初始化row时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的row就是int*类型，而之后的内层循环则试图在一个int*内遍历，程序将无法通过编译。 12for (auto row : ia) for (auto col : row) 使用范围for语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。 因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。 123int ia[3][4]; // array of size 3; each element is an array of ints of size 4int (*p)[4] = ia; // p points to an array of four intsp = &amp;ia[2]; // p now points to the last element in ia 声明指向数组类型的指针时，必须带有圆括号。 12int *ip[4]; // array of pointers to intint (*ip)[4]; // pointer to an array of four ints 使用auto和decltype能省略复杂的指针定义。 123456789// print the value of each element in ia, with each inner array on its own line// p points to an array of four intsfor (auto p = ia; p != ia + 3; ++p)&#123; // q points to the first element of an array of four ints; that is, q points to an int for (auto q = *p; q != *p + 4; ++q) cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;&#125;","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第二章-变量和基本类型","slug":"C++ Primer/C++primer笔记-第二章-变量和基本类型","date":"2022-02-20T12:25:30.000Z","updated":"2022-06-29T11:37:00.955Z","comments":true,"path":"2022/02/20/C++ Primer/C++primer笔记-第二章-变量和基本类型/","link":"","permalink":"http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"第二章 变量和基本类型变量初始化如果定义变量时未指定初值，则变量被默认初始化（default initialized）。 对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。 所以类里边的成员变量一定要初始化，不然会有未定义的结果 变量声明和定义的关系声明（declaration）使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。(不分配内存) 定义（definition）负责创建与名字相关联的实体。（分配内存，不一定初始化） 如果想声明一个变量而不定义它，就在变量名前添加关键字extern，并且不要显式地初始化变量。 总结：除了用extern修饰变量，其他的声明都是定义。 12extern int i; // declares but does not define iint j; // declares and defines j extern语句如果包含了初始值就不再是声明了，而变成了定义。 变量能且只能被定义一次，但是可以被声明多次。 如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。 extern用法详解 extern修饰变量的声明： 主要使用的情况是，不同的文件中都需要用到这个变量X（大多数情况是全局变量），而且，extern声明的变量可以在文件中的任何地方声明。 总结：其实就是类似一个引用的手法，在一个项目中只在某一个地方int x = 1;声明加定义（开辟一块内存），这样在其他地方用到这个变量，只需要extern int x；就相当于获得了这个变量的引用，接下来的程序就可以用了。 extern修饰函数声明： 本质的看，变量和函数没有区别，函数名是指向函数二进制块开头处的指针。也就是说extern在这里，也是一样的，如果A文件中有一个函数int fun(),那么想在B文件里用它，就可以extern int fun()就可以用了。 使用extern和包含头文件引用函数有什么区别呢？ 用extern更简洁，想用哪个函数就extern哪个，而不用整体include，另外的还可以加速程序的编译，因为不需要编译不要用到的函数了嘛！ extern还可用于指示C或者C++的调用规范： 比如在C++中调用C的函数，就需要在C++代码中用extern声明要引入的C库函数。这是给链接器看的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。 用C语言编写程序的时候，我们经常会遇到这样一种情况：希望在头文件中定义一个全局变量，然后包含到两个不同的c文件中，希望这个全局变量能在两个文件中共用。 举例说明：项目文件夹project下有main.c、common.c和common.h三个文件，其中common.h文件分别#include在main.c和common.c文件中。现在希望声明一个字符型变量key，在main.c和common.c中公用。如下图所示：有人想，既然是想两个文件都用，那就在common.h中声明一个unsigned char key，然后由于包含关系，在main.c和common.c中都是可见的，所以就能共用了。这种想法其实是很多初学者都会想到的，想起来确实有道理，但是实际写出来，我们发现编译的时候编译器提示出错，一般提示大概都类似于：Error: L6200E: Symbol key multiply defined (by common.o and main.o). 也就是说编译器认为我们重复定义了key这个变量。这是因为#include命令就是原封不同的把头文件中的内容搬到#include的位置，所以相当于main.c和common.c中都执行了一次unsigned char key，而C语言中全局变量是项目内（或者叫工程内）可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义。正确的解决办法：使用extern关键字来声明变量为外部变量。具体说就是在其中一个c文件中定义一个全局变量key，然后在另一个要使用key这个变量的c文件中使用extern关键字声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：定义和声明。例如在main.c文件中定义变量key，在common.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了。 标识符和名字的作用域标识符： C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。 名字的作用域 定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。 最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。 作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。 可以用作用域操作符::来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。 12345678910111213141516#include &lt;iostream&gt;// Program for illustration purposes only: It is bad style for a function// to use a global variable and also define a local variable with the same nameint reused = 42; // reused has global scopeint main()&#123; int unique = 0; // unique has block scope // output #1: uses global reused; prints 42 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; int reused = 0; // new, local object named reused hides global reused // output #2: uses local reused; prints 0 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; // output #3: explicitly requests the global reused; prints 42 0 std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; return 0;&#125; 如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。 总结：内部作用域可以用外部的变量，反之不行，内部作用域会覆盖同名外部作用域。可以用：：选择作用域中的变量。 复合类型引用（References）引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是变量名称。 123int ival = 1024;int &amp;refVal = ival; // refVal refers to (is another name for) ivalint &amp;refVal2; // error: a reference must be initialized 定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。 引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。 声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。 引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。 指针（Pointer）与引用类似，指针也实现了对其他对象的间接访问。 指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 通过将声明符写成*d的形式来定义指针类型，其中d是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号*。 12int *ip1, *ip2; // both ip1 and ip2 are pointers to intdouble dp, *dp2; // dp2 is a pointer to double; dp is a double 指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符&amp;。 12int ival = 42;int *p = &amp;ival; // p holds the address of ival; p is a pointer to ival 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。 指针的值（即地址）应属于下列状态之一： 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针，即指针没有指向任何对象。 无效指针，即上述情况之外的其他值。 试图拷贝或以其他方式访问无效指针的值都会引发错误。 如果指针指向一个对象，可以使用解引用（dereference）符*来访问该对象。 123int ival = 42;int *p = &amp;ival; // p holds the address of ival; p is a pointer to ivalcout &lt;&lt; *p; // * yields the object to which p points; prints 42 给解引用的结果赋值就是给指针所指向的对象赋值。 解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值nullptr来初始化指针。 旧版本程序通常使用NULL（预处理变量，定义于头文件cstdlib中，值为0）给指针赋值，但在C++11中，最好使用nullptr初始化空指针。 1234int *p1 = nullptr; // equivalent to int *p1 = 0;int *p2 = 0; // directly initializes p2 from the literal constant 0// must #include cstdlibint *p3 = NULL; // equivalent to int *p3 = 0; 建议初始化所有指针。 void*是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作void*指针所指的对象。 理解复合类型的声明指向指针的指针（Pointers to Pointers）： 123int ival = 1024;int *pi = &amp;ival; // pi points to an intint **ppi = &amp;pi; // ppi points to a pointer to an int 指向指针的引用（References to Pointers）： 12345int i = 42;int *p; // p is a pointer to intint *&amp;r = p; // r is a reference to the pointer pr = &amp;i; // r refers to a pointer; assigning &amp;i to r makes p point to i*r = 0; // dereferencing r yields i, the object to which p points; changes i to 0 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。 const限定符在变量类型前添加关键字const可以创建值不能被改变的对象。**const变量必须被初始化。** 12const int bufSize = 512; // input buffer sizebufSize = 512; // error: attempt to write to const object 默认情况下，const对象被设定成仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。 如果想在多个文件间共享const对象： 若const对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。 若const对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时const变量的声明和定义前都应该添加extern关键字。 1234// file_1.cc defines and initializes a const that is accessible to other filesextern const int bufSize = fcn();// file_1.hextern const int bufSize; // same bufSize as defined in file_1.cc const的引用把引用绑定在const对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。这里其实就是因为不能用引用来修改原来是const的变量的值，所以不能有非const的引用，我一个本尊都不能修改，能让你一个假身（引用）修改嘛？ 1234const int ci = 1024;const int &amp;r1 = ci; // ok: both reference and underlying object are constr1 = 42; // error: r1 is a reference to constint &amp;r2 = ci; // error: non const reference to a const object 大部分情况下，引用的类型要和与之绑定的对象严格匹配。但是有两个例外： 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。 12345int i = 42;const int &amp;r1 = i; // we can bind a const int&amp; to a plain int objectconst int &amp;r2 = 42; // ok: r1 is a reference to constconst int &amp;r3 = r1 * 2; // ok: r3 is a reference to constint &amp;r4 = r * 2; // error: r4 is a plain, non const reference 允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。 12double dval = 3.14;const int &amp;ri = dval; 指针和const（Pointers and const）指向常量的指针（pointer to const）不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。 123456const double pi = 3.14; // pi is const; its value may not be changeddouble *ptr = &amp;pi; // error: ptr is a plain pointerconst double *cptr = &amp;pi; // ok: cptr may point to a double that is const*cptr = 42; // error: cannot assign to *cptrdouble dval = 3.14; // dval is a double; its value can be changedcptr = &amp;dval; // ok: but can&#x27;t change dval through cptr 定义语句中把*放在const之前用来说明指针本身是一个常量，常量指针（const pointer）必须初始化。 1234int errNumb = 0;int *const curErr = &amp;errNumb; // curErr will always point to errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; // pip is a const pointer to a const object 指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。 顶层const（Top-Level const）顶层const表示指针本身是个常量，底层const（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层const也可以是底层const。 123456int i = 0;int *const p1 = &amp;i; // we can&#x27;t change the value of p1; const is top-levelconst int ci = 42; // we cannot change ci; const is top-levelconst int *p2 = &amp;ci; // we can change p2; const is low-levelconst int *const p3 = p2; // right-most const is top-level, left-most is notconst int &amp;r = ci; // const in reference types is always low-level 当执行拷贝操作时，常量是顶层const还是底层const区别明显： 顶层const没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。 12i = ci; // ok: copying the value of ci; top-level const in ci is ignoredp2 = p3; // ok: pointed-to type matches; top-level const in p3 is ignored 拷入和拷出的对象必须具有相同的底层const资格。或者两个对象的数据类型可以相互转换。一般来说，非常量可以转换成常量，反之则不行。 这种就想，如果能把常量转换成非常量的话，这就代表你这个新的指针可以随便改这个值，那原来的变量又怎么能叫做常量呢？ 12345int *p = p3; // error: p3 has a low-level const but p doesn&#x27;tp2 = p3; // ok: p2 has the same low-level const qualification as p3p2 = &amp;i; // ok: we can convert int* to const int*int &amp;r = ci; // error: can&#x27;t bind an ordinary int&amp; to a const int objectconst int &amp;r2 = i; // ok: can bind const int&amp; to plain int constexpr和常量表达式（constexpr and Constant Expressions）常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。 一个对象是否为常量表达式由它的数据类型和初始值共同决定。 1234const int max_files = 20; // max_files is a constant expressionconst int limit = max_files + 1; // limit is a constant expressionint staff_size = 27; // staff_size is not a constant expressionconst int sz = get_size(); // sz is not a constant expression C++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 123constexpr int mf = 20; // 20 is a constant expressionconstexpr int limit = mf + 1; // mf + 1 is a constant expressionconstexpr int sz = size(); // ok only if size is a constexpr function 指针和引用都能定义成constexpr，但是初始值受到严格限制。constexpr指针的初始值必须是0、nullptr或者是存储在某个固定地址中的对象。 函数体内定义的普通变量一般并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化constexpr指针。 在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针本身有效，与指针所指的对象无关。constexpr把它所定义的对象置为了顶层const。 123constexpr int *p = nullptr; // p是指向int的const指针constexpr int i = 0;constexpr const int *cp = &amp;i; // cp是指向const int的const指针 const和constexpr限定的值都是常量。但constexpr对象的值必须在编译期间确定，而const对象的值可以延迟到运行期间确定。 建议使用constexpr修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。 处理类型（Dealing with Types）类型别名（Type Aliases）类型别名是某种类型的同义词，传统方法是使用关键字typedef定义类型别名。 12typedef double wages; // wages is a synonym for doubletypedef wages base, *p; // base is a synonym for double, p for double* C++11使用关键字using进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。 1using SI = Sales_item; // SI is a synonym for Sales_item auto类型说明符（The auto Type Specifier）C++11新增auto类型说明符，能让编译器自动分析表达式所属的类型。auto定义的变量必须有初始值。 12// the type of item is deduced from the type of the result of adding val1 and val2auto item = val1 + val2; // item initialized to the result of val1 + val2 编译器推断出来的auto类型有时和初始值的类型并不完全一样。 当引用被用作初始值时，编译器以引用对象的类型作为auto的类型。 12int i = 0, &amp;r = i;auto a = r; // a is an int (r is an alias for i, which has type int) auto一般会忽略顶层const。因为是赋值出来的另一个变量，独立的内存 12345const int ci = i, &amp;cr = ci;auto b = ci; // b is an int (top-level const in ci is dropped)auto c = cr; // c is an int (cr is an alias for ci whose const is top-level)auto d = &amp;i; // d is an int*(&amp; of an int object is int*)auto e = &amp;ci; // e is const int*(&amp; of a const object is low-level const) 如果希望推断出的auto类型是一个顶层const，需要显式指定const auto。 1const auto f = ci; // deduced type of ci is int; f has type const int 设置类型为auto的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。 123auto &amp;g = ci; // g is a const int&amp; that is bound to ciauto &amp;h = 42; // error: we can&#x27;t bind a plain reference to a literalconst auto &amp;j = 42; // ok: we can bind a const reference to a literal decltype类型指示符（The decltype Type Specifier）C++11新增decltype类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。 1decltype(f()) sum = x; // sum has whatever type f returns decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）。 1234const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x has type const intdecltype(cj) y = x; // y has type const int&amp; and is bound to xdecltype(cj) z; // error: z is a reference and must be initialized 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则decltype会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。 decltype((var))的结果永远是引用，而decltype(var)的结果只有当var本身是一个引用时才会是引用。 自定义数据结构（Defining Our Own Data Structures）C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。 类内初始值不能使用圆括号。 类定义的最后应该加上分号。 头文件（header file）通常包含那些只能被定义一次的实体，如类、const和constexpr变量。 头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。 头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量。#ifdef指令当且仅当变量已定义时为真，#ifndef指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。 12345678910#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string&gt;struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;#endif 在高级版本的IDE环境中，可以直接使用#pragma once命令来防止头文件的重复包含。 预处理变量无视C++语言中关于作用域的规则。 整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。 头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"计算机网络--应用层","slug":"计算机网络/计算机网络--应用层","date":"2022-02-16T11:25:30.000Z","updated":"2022-06-29T10:21:15.875Z","comments":true,"path":"2022/02/16/计算机网络/计算机网络--应用层/","link":"","permalink":"http://icecorn.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"计算机网络–应用层本章主要掌握各种应用层协议的使用方法和实现方法 常见的基于UDP和TCP的应用 1 域名系统DNS我们打开一个网页比如百度通常是使用www.baidu.com而不是它的ip地址加端口号，这就是靠域名服务器进行域名解析实现的。主机发送DNS请求报文（使用UDP）给**域名服务器**，收到响应中的ip地址后可与目的主机进行通信。 全球只用一个域名服务器显然是不现实的，所以域名服务器实际上是一个分布式系统，并且按如下划分了域名空间 权限域名服务器：负责一个区的域名服务器，一般是一个公司内部的，比如可以划分abc.com和y.abc.com 本地域名服务器：又叫做默认域名服务器，一般是离主机最近的服务器 主机向本地域名服务器的查询一般采用递归查询 本地服务器向根服务器的查询一般采用迭代查询，当然也可以用递归查询 递归查询就是自己只发送一次查询报文然后剩下的一层层处理最后拿个结果就好了（小弟派小弟层层转包） 迭代查询是自己发送查询接收响应反复操作最后得到结果（事必躬亲） 2 文件传送协议FTP基于TCP，TFTP基于UDP 2.1 FTP协议FTP使用客户服务器方式，FTP服务器由一个主进程和若干个从属进程组成，这是因为FTP服务器要接收好多个客户的请求，每次和一个客户连接后马上给这个客户分配几个从属进程，快点把主进程空出来给别的客户访问 对于一个主机来说，与服务器一般建立两个TCP连接，一个控制进程，一个数据传送进程，通信中控制进程一直连接着吗，因此FTP控制信息是带外的 TCP只能整体传送文件，这就有了网络文件系统NFS，它可以允许应用程序只读取并修改指定位置的信息，减少了通信量 2.2 TFTP协议基于UDP的超级简单的协议，只支持传输不支持交互 优点： 多个主机同时从服务器下载东西（因为UDP可以一对多嘛，可以理解类似于多播） 开销小，占内存小，这就适合很多不需要太多功能的开源硬件 另外虽然UDP是不可靠传输，但TFTP类似与停止等待协议，这就是靠应用层实现传输控制来保证的 2.3 远程终端协议TELNET用来远程控制桌面的东东，只需要知道怎么用以及它是基于TCP的就ok 3 万维网协议就是我们熟悉的www啦，了解万维网，主要了解一下几个问题： 怎样标志分布在整个互联网上的各种万维网文档？ URL 用什么协议实现万维网的连接？ HTTP 不同风格的文档在不同主机怎么显示？ HTML 怎样查找需要的信息？ 搜索引擎 3.1 统一资源定位符URL相当于互联网上任一文件的指针，一般形式为： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议常见的有http，ftp等，端口和路径可以省略 3.2 超文本传输协议HTTPHTTP是面向事务的应用层协议，基于TCP 特点： 无连接的：意思就是http不用先建立连接再通信，因为是基于TCP的，由TCP来保证可靠传输 无状态的： 意思是同一个客户再来访问结果还是一样，服务器不会记得 面向文本： 意思是http报文中的每一个字段都是一些ASCII码，长度是由用户输入决定的 http首先要与服务器建立TCP连接，这就需要3次握手，由传输层的知识我们知道这样就会导致客户实际收到消息时需要2RTT的时间间隔，而http1.0协议使用非持续传输，意思就是访问这个网页（服务器不同路径）上的任何一个元素都需要重新建立TCP连接，这就会浪费好多个2RTT时间 所以http1.1采用了持续连接，意思就是访问同一个服务器上东西的时候TCP连接不用断开，就用着一个就完事了，省下来很多握手时间，具体方式还分为流水线和非流水线方式，不赘述了 代理服务器，又叫做万维网高速缓存 这玩意就是保存了一个局域网内最近主机的请求和响应信息，当又有主机访问相同的资源的时候就不用再去远端查找了。这就减少了链路的通信量。 HTTP的报文结构 主要就是请求报文和响应报文 3.3 万维网文档超文本标记语言HTML：用于在浏览器上显示数据 可扩展标记语言XML： 用于传输数据 可扩展超文本标记语言XHTML： 更严格的html版本 层叠样式表CSS： 用于定义html文档布局 动态文档 上述都是静态文档，而动态文档只是文档的生成方法不同，静态文档只要放在服务器上就ok了，动态文档允许客户和服务器进行交互，也就是说服务器获取到客户的信息后进行一系列处理之后生成文档 这就需要在服务器中新增加一个应用程序叫做CGI程序，也叫作CGI脚本。 活动文档 它是用来满足更复杂的需求比如动画交互之类的，如果一直让服务器来传送的话太浪费资源，所以活动文档相当于是在服务器上的一个静态文档，类似一个浏览器可执行的小应用程序，现在常用的JS脚本 3.4 万维网的信息检索系统分为两种： 全文检索搜索： 比如谷歌百度这种，本质是使用爬虫在数据库里搜索相关信息 分类目录搜索： 比如门户网站这些，已经给你分配好了的专栏 4 电子邮件主要涉及简单邮件传送协议SMTP，互联网邮件扩充MIME，邮局协议POP3，网际报文存取协议IMAP 要注意的是这些都是基于TCP的 上图基本给出了用户代理，发送方和接收方邮件服务器的作用 由于SMTP有以下缺点： 不能传送可执行文件和其他的二进制对象 只能传送7位的ASCII码，导致其他国家文字不能传输 SMTP服务器会拒绝超出一定长度的邮件 将制表符tab转换为若干个空格 由此提出了互联网扩充协议MIME 具体看书吧，记住有了MIME实现了上述这些功能就行了 两种接收协议的特点： POP3： 优点：简单 缺点：邮件读了后就自动删除了 IMAP： 优点：可以在不同主机上随时处理邮件服务器的邮件，支持阅读部分邮件 缺点：必须上网连接IMAP服务器才能阅读邮件 互联网邮箱： 现在多数都是这些，记住浏览器和互联网上的邮件服务器通信使用的是HTTP协议，而邮件服务器之间通信使用SMTP即可 5 动态主机配置协议DHCPDCHP使用UDP进行传输。就是动态的分配IP地址，子网掩码，默认路由地址，域名服务器地址（就是我们常用的自动配置IP） 一个新的主机第一次连接到一个网络，按照以下步骤： 主机发送广播（目的地址全1）给网络中的DCHP中继代理（一般是一个路由器） 路由器发送单播告诉DCHP服务器 DCHP发送响应给主机A 注意两点： 主机在一个网络中连了一次网，分配的IP就记录在DCHP服务器中了，下次联网还是这个IP地址 给了IP地址后，不是一直可以使用的，有一个租用期，长短有DCHP服务器控制，过半后主机发送续租报文，服务器同意就续上，不同意就不能用这个IP了 6 P2P应用6.1 集中服务器的P2P工作方式在集中式目录服务器中建立一个数据库保存哪个资源都哪些主机有，这是要想下载一个东西就先去集中服务器查找，返回一串主机，在选一个主机进行下载 6.2 全分布式结构P2P共享程序使用洪泛法，在网络内进行有限范围的洪泛查询，具有代表性的就是BT种子了（某播：技术是无罪的==） P2P的本质就是惠人惠己，比如我们要下载一部小电影，实际上在p2p网络中这个小电影是由好多个文件块组成的，有好多主机上边都有这些文件块，可能这个给你一块那个给你一块那么我们就能很快把这个小电影下载完，当然之后我们电脑上有这个文件了（即使一些文件块）也要给别人下载，不能太自私啦。这些和我们互相交互下载文件块的主机叫做对等方。 同时在发送过程中有两个规则： 最稀有优先：意思就是小电影中哪个文件块在现在网上拥有的数目最少就要先下载哪个，不然那些主机都下线最后少了这个文件块导致看不了小电影就很难受QAQ 优先发送对等方选择：前面说我们也要给别人下载，那么怎么确定优先给谁发呢？当然要优先发给给我们发送文件块的对等方了（按速率排序，互惠互利）。一般保持4个最高速的对等方，这些对等方叫已疏通的或无障碍的对等方 还有一个问题就是分布式结构到底怎么确定小电影在哪些主机上有呢？ 洪泛法的效率太低且浪费资源，所以最好还是建立一个分布式数据库，又不能像集中式服务器那样，所以现在有个算法是分布式散列表，具体内容再看吧QAQ 7 应用进程和系统调用我们知道程序员的业务逻辑代码基本都是在应用层，对运输层的控制很少（只能设置最大数据长度MSS等），那么进行网络编程时实际上都是使用API（也可以说套接字）来对接操作系统从而实现网络通信 进行TCP的基本API调用流程如下，细节的话联系操作系统","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--运输层","slug":"计算机网络/计算机网络--运输层","date":"2022-02-14T06:16:07.000Z","updated":"2022-06-29T10:20:45.416Z","comments":true,"path":"2022/02/14/计算机网络/计算机网络--运输层/","link":"","permalink":"http://icecorn.github.io/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/","excerpt":"","text":"计算机网络–运输层1. 运输层基本概念运输层向应用层提供通信服务，在运输层中，通信的真正端点不是主机而是主机中的进程 网络层为主机之间提供逻辑通信，运输层为应用进程提供端到端的逻辑通信 运输层连个主要协议： 用户数据报协议UDP（不用连接） 传输控制协议TCP（面向连接） 运输层支持复用和分用，方法是使用协议端口号（端口） 这里的端口号是指软件端口，分为两大类： 服务器端使用的端口号 1.熟知端口号（系统端口号）： 0~1023 比如FTP是21 2.登记算口号： 1024~49151 其他应用使用的 客户端使用的端口号 数值49152~65535 在客户进程运行时才动态选择，又叫短暂端口号 ，在不同主机可以随意分配 2 用户数据报协议UDPUDP在IP数据报服务上增加了复用分用功能和差错检测功能 主要特点： 是无连接的 尽最大努力交付： 即不保证可靠交付 是面向报文的： 意思是UDP接收到应用层报文不做任何操作仅仅加上UDP首部就构成了UDP报文，这就要求应用层控制报文大小（太大会导致IP报文需要分片，太小导致传输效率太低） 没有拥塞控制 支持1对1,1对多，多对1，多对多的交互通信 首部开销小： 只有8字节 UDP 首部格式 首部共8字节，四个字段，分别是源端口 目的端口 长度（UDP报文总长度，最小为8只有首部） 检验和 每个字段2字节 伪首部只在计算检验和时被用于计算，检验方法类似IP数据报首部校验方法，区别是UDP的校验是把首部和数据部分一起都检验 3 传输控制协议TCPTCP具有可靠传输，流量控制，拥塞控制等等功能 主要特点： 面向连接：通信前必须建立TCP连接 点对点：每一条TCP连接只能有两个端点，即只能1对1传输 提供可靠交付： 无差错，不丢失，不重复，按序到达 全双工通信：TCP连接两端设有发送缓存和接收缓存 面向字节流：对TCP来说应用程序发送的数据仅仅看成一连串无结构的字节流，TCP不理解这些玩意代表啥意思，只是必须把这些字节流按照顺序完整的传达到终点，它的任务就完成了。解析的活就交给终端处理就好 这里有一个UDP与TCP的差别就是，UDP发送的报文长度是应用进程给出的，而TCP是根据对方的窗口值和网络拥塞之类的自己判断（如果应用数据太长就分几段，太短就攒几个一起发） TCP连接的端点叫套接字socket，将端口号拼接到IP地址就是套接字 比如 192.3.4.5:80 TCP把连接作为最基本的抽象，每条TCP连接唯一的被通信两端的套接字确定 TCP连接::={socket1,socket2}={(IP1:port1),(IP2,port2)} 4 TCP报文段首部格式TCP首部前20字节是固定的，后边可根据需要增加4n字节 源端口和目的端口：各占2字节，目的是实现分用 序号：4字节，TCP是面向字节流的，所以该字段是指本报文段所发送的第一个字节的序号 确认号：4字节，是期望收到对方下一个报文段的第一个数据字节序号 数据偏移：4位，和IP数据报中的首部长度类似，表示的是TCP首部的实际长度（最大二进制15,4字节为单位，所以TCP首部最大也是60字节） 保留：目前没用，置0 紧急URG：1位，置1时代表高优先级优先发送 确认ACK：1位，置1时才有效，TCP连接建立后所有报文ACK都为1 推送PSH：1位，表示接收端收到就上交给应用层（不用少量信息攒一波），很少用 复位RST：1位，TCP连接出现严重差错，该字段置1重建连接 同步SYN：1位，建立连接时用来同步序号，置1表示这是一个连接请求或连接接受报文 终止FIN：1位，用来释放一个连接，置1表示发送方数据发送完毕，请求释放运输连接 窗口：2字节，是指发送本报文段的一方的接收窗口 检验和：2字节，检验首部和数据两部分，和UDP一样计算时也加伪首部 紧急指针：2字节，仅在URG置1时有意义，指出紧急数据在的末尾在此报文段中的位置 选项：长度可变，最多40字节 5 可靠传输的原理和实现TCP是面向连接且可靠的传输协议，理想的传输协议需要具备以下两点： 传输信道不产生差错 不管发送方以多快的速度发送分组，接收端总能正确接收并处理 5.1 停止等待协议停止等待是最简单的可靠传输，A发生完一个分组就停止发送等待对方的确认 超时重传：当发送方发送的分组出现差错没有送达接收方，就会启动超时重传机制，A每发送一个分组立刻设置一个超时计时器。这里有三点需要注意： A发送一个分组后，必须暂时保留该分组副本，收到确认后才删除 分组和确认分组都要进行编号，对于停止等待来说 0和1两个编号循环使用就行 超时重传时间应该设置的比数据传输的平均往返时间长一些 确认丢失时B忽略第二次收到的重复分组并发送确认给A 确认迟到B同样忽略第二次收到的重复分组，A忽略重复确认 这样我们就在不可靠的传输网络上实现了可靠通信，这种可靠传输协议叫做自动重传请求ARQ 5.2 流水线传输停止等待协议的优点是简单，但缺点是信道利用率太低，所以出现了流水线传输。流水线传输需要用到连续ARQ协议，回退N帧（gobackN）协议，滑动窗口协议等等 连续ARQ协议： 发送方根据接收方的窗口参数和自身的发送缓存决定窗口大小，窗口内的分组都是可以发送的，每收到一个确认窗口就向前移动一个分组 累计确认：接收方不用每收到一个分组就发送一条确认，而是攒几个发送一个确认（按序到达的最后一个分组编号）即可。 累计确认的优点是容易实现，减少了通信量，即使确认丢失也不用重传。 累计确认的缺点是不能向发送方反应已经正确收到的所有分组信息 比如发送了前5个分组，接收方收到了1 2 4 5，那么接收方直接发送收到了2，这样发送方就必须重新发送3 4 5，哪怕4 5 已经收到了，这就叫做回退N帧协议（Go-back-N） 5.3 滑动窗口协议滑动窗口协议其实就是以字节为单位的连续ARQ协议，但是研究的时候通常也可以以分组为单位研究 这里要注意以下几点： A根据B可接收的窗口大小和A的发送缓存大小（取较小值）来确定A的发送窗口，当然有时还可以根据拥塞状况适当减小。 发送窗口中已发送数据在没收到确认之前不能删除 接收方一定要支持累计确认功能，减小传输开销 TCP是全双工通信，通信双方都有发送窗口和接收窗口 5.4 超时重传时间的选择重传时间的选择是TCP中最复杂的问题，TCP采用一种自适应的算法线算出报文段的往返时间RTT，再计算一个加权平均往返时间RTTS。 不想写了，用到的话看书吧QAQ 5.5 选择确认SACK若接收方收到的分组无差错，只是没按序号，或者只有中间的几个分组丢失了，能不能告诉发送方只发送这几个分组？ 没错，这玩意就是解决这个问题的，要在TCP建立连接时在扩展首部里加上“允许SACK”选项 具体内容不写了，QAQ 6 TCP流量控制6.1 利用滑动窗口实现流量控制流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收 TCP是面向字节流的，seq代表发送字节的序号，ACK是确认位，ack是确认编号，rwnd是接收端允许发送端发送的数据窗口大小 图中最后rwnd置0，说明此时A不能再发送字节了，要是之后B发送重置rwnd时确认丢失，就会产生死锁，解决方案就是TCP的每条连接都有一个持续计时器，在发送端收到rwnd置0消息时开启，超时后发送端发送一个1字节的零窗口探测报文段，这样接收端就知道响应报文丢失了。 6.2 TCP的传输效率对于UDP来说，什么时候发送报文是应用程序决定的，UDP只需要原封不动的转发就行。但是对于TCP，应用进程把数据传送到TCP的发送缓存后就不管了，所以TCP是什么时候发送报文就是一个很重要的问题，有下面几种机制来发送： TCP维持一个最大报文段长度MSS变量，只要缓存中数据达到MSS字节就发送 发送方的应用进程指明要求发送报文段，即TCP支持推送操作 用一个计时器规定时间，到点发送 Nagle算法：发送方先发送第一个数据字节，将后续应用程序输入的字节保存在发送缓存，收到接收方的确认后，将攒了一波的数据发送出去（当然不能超过MSS），同时继续保存发送缓存。在收到接收方确认，再发送数据报。另外，当发送缓存中数据已经到达窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。 糊涂窗口综合症： 这个玩意是指TCP接收方的缓存已经满了，并且接受方的应用程序比较懒，一次处理一个字节，那么接收缓存每次仅仅空出一个字节还每次都发送确认（并把rwnd设置为1，导致发送方每次有效传输只有1字节），发送1字节还要加上TCP首部20字节，IP首部20字节，这样效率实在太低 解决方案可以让接收方等一会，等接收缓存空出来一个最大报文段或者等到接收缓存有一半以上空地方 总结： 发送效率主要就是要减少40字节的首部的占比，所以记住发送方别发送太短的报文，接收方也别没事就发信号让发送方发报文就完事了。 6.3 吞吐量吞吐量是指一个传输周期内传输的字节速率，注意单位是bit/s，经常会有和发送窗口相关的计算题 一个TCP连接下面使用256Kb/s的链路，其端到端时延为128ms。经测试，发现吞吐量只有120kb/s，则发送窗口大约是 A．3614字节B．7228字节C．57826字节D．120k比特 本题目主要考查的是“TCP流量控制”。为了提高报文段的传输效率，TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位为字节。发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。发送端利用发送窗口调节向网络注入分组的速率不仅是为了使接收端来得及接收，而且还是为了对网络进行拥塞控制。在每一个运输连接上报文段是断续发送的，这样就有了两种速率。一种是链路层的数据率，另一种是从运输层看到的数据注入速率。题目中给出端到端时延为128ms，则在一个传输周期里，从发送第一个报文段到收到所有确认时间为：W/R+2T，其中w为发送窗口的大小，R为链路速率，T为端到端时延。因此吞吐量TP=W/(W/R+2T)，将题目中的具体数据代入，即可求得W=7228字节。 7 TCP的拥塞控制7.1 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不会过载 拥塞控制和流量控制的区别是：拥塞控制涉及到是整条通信线路上所有的资源（主机，路由器，链路等等），所以需要控制调整的措施也比较复杂。而流量控制是端到端的交流，就是接收端告诉发送端你慢点，我吃不消了QAQ 拥塞控制主要分为两种方法： 开环控制：在设计网络时将会导致拥塞的因素都考虑到，运行时就基本不能改了 闭环控制：基于反馈环路，几种措施 ​ 1.监测网络拥塞发生在何处 ​ 2.把拥塞信息传达到可以采取行动的地方 ​ 3.调整网络系统的运行解决问题 7.2 TCP的拥塞控制方法TCP进行拥塞控制的算法有四种：慢开始 拥塞避免 快重传 快恢复 首先，发送当要维持一个拥塞窗口cnwd变量，发送方让自己的发送窗口等于拥塞窗口，cnwd的单位是发送方的最大报文段SMSS，一般初始设置为1。 慢开始：意思就是初始cnwd设置为1，然后以指数方式增长 拥塞避免：当cnwd超过预设门限值ssthresh时，改为线性增大，尽量避免拥塞发生 快重传： 为了避免发送方一检测到超时就进行慢开始（有时候超时不意味着拥塞），快重传就是说发送方收到连续3次确认（因为中间一个数据报丢了，后边的收到了累计确认），这时发送方直接重传丢失数据报 快恢复： 3ACK后不进行慢开始，而是直接把cnwd置为一半 这就是所谓的加法增大，乘法减小 另外发送窗口大小还取决于接收方的通知窗口，所以发送窗口取值=MIN[rnwd,cnwd] 主动队列管理AQM 在通信链路中的路由器中，路由器缓存队列一般都是先进先出，而一旦发生拥塞后来的分组就会被路由器丢弃，那么发送方就会进行慢开始，而由于TCP的复用特性（路由器接到的都是IP数据报，同一个IP地址可能包装了不同的端口号），这就会导致一时间整个网络很多的TCP连接都慢开始了，这种现象叫全局同步，严重影响了传送效率 而AQM就是解决这个问题的，AQM其中一种方法叫随机早期检测RED，其实就是给路由器的缓存设置一个门限值，不让它到满了的时候再丢弃，用一个随机算法在它超过门限时就随机丢弃，这就保证了不是所有TCP都会同时慢开始了。 8.TCP的运输连接管理TCP连接三个阶段：连接建立，数据传送，连接释放 TCP连接建立采用客户服务器方式 8.1 连接建立就是著名的三次握手啦 SYN报文不允许携带数据，但是消耗一个序号 ACK报文携带数据的话消耗序号，不携带的话不消耗序号 为什么最后A一定要在发送一次确认给B呢？ 这是因为假设A发送请求滞留在路由器里导致超时了，这是A以为报文丢了就重发了一个请求与B建立了连接通信后又断开连接。然后这是A的第一个请求报文到达了B，B就会发送确认给A，此时A知道已经连接完了不搭理B，但B还会傻傻的等着A给他发消息，这就浪费了很多资源。 8.2 连接释放四次挥手 FIN不携带数据，但是消耗序号 ACK不携带数据不消耗序号，携带消耗 MSL叫做最长报文段寿命，为什么time-wait状态后要有2MSL等待时间呢？ 1.因为B再发送完FIN-ACK确认报文后还在等着A发送确认，而A的最后一个确认报文可能会丢失，丢失了B收不到确认就会发送重传，此时如果没有2MSL时间A直接结束了连接，B就会一直发确认，资源浪费 2.就是上边提到的A重复发送连接请求，第一个请求延迟到达了的情况，有了2MSL就能使本连接持续时间内产生的所有报文段都从网络中消失 保活计时器：有时候建立连接后客户端突然挂掉，这是服务器就会一直等着，所以要有这个保活计时器，服务器没收到一次数据就重置保活计时器，时间大约2小时，2小时没有新的数据，服务器就发送一个探测报文段，每75s发送一次，连续10次无反应服务器就关闭连接 8.3 TCP状态机","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--网络层","slug":"计算机网络/计算机网络--网络层","date":"2022-02-13T08:53:09.000Z","updated":"2022-06-29T10:20:16.253Z","comments":true,"path":"2022/02/13/计算机网络/计算机网络--网络层/","link":"","permalink":"http://icecorn.github.io/2022/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"计算机网络–网络层1 网络层的两种服务形式一种是虚电路服务，另一种是数据报服务，虚电路面向连接的通信方式，在分组交换中建立一条虚电路来预留通信双方所需的一切网络资源，这样在网络层实现可靠传输。数据报服务是采用分组传输方式，网络层向上只提供简单的，无连接的，尽最大努力的不可靠传输。 本质是是否要在网络层实现可靠传输的问题，由于现在的终端相比于过去的电话设备具有更强的处理能力，所以现在数据报服务成为主流，将可靠传输的实现上移到传输层和用户主机由TCP处理。 对比 虚电路 数据报 思路 可靠通信由网络层保证 可靠通信由用户主机保证 连接建立 必须有 不需要 终点地址 仅在建立连接时使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组转发 同一条虚电路分组由同一路由器转发 每个分组独立选择路由器转发 结点故障 所有通过故障结点的虚电路均不能工作 出故障结点可能会丢失分组，但可以选择其他路由器发送分组 分组的顺序 总是按发送顺序到达终点 到达终点不一定按先后顺序 端到端差错处理及流量控制 可以由网络负责也可以由用户主机负责 由用户主机负责 2 网际协议IPIP协议是很重要的协议，它也是一族协议 除了IP协议外还有与之配套的 地址解析协议 ARP 网际控制报文协议 ICMP 网际组管理协议 IGMP 要把世界上数以万计的网络连接起来是非常复杂的，并且没有一种网络能够满足所有用户的需求。所以，在网络层使用IP协议构成一个虚拟互连网络，也就是说对于ip协议的网络层，下边的数据链路层和物理层是透明的。 2.1 分类的IP地址IP地址就是给互联网上每一台主机或路由器分配一个全世界范围内唯一的32位的标识符，这里只研究IPv4。 IP地址的编码方式经历了三个阶段： 分类的IP地址 划分子网 构成超网 本节研究分类的IP地址，就是将IP地址划分为若干个固定类，每一类地址由两个固定长度字段组成，第一个字段是网络号，第二个阻断是主机号，全网唯一 分为以下几类： 其中A B C类都是单播地址（1对1） A B C类地址网络号分别为1,2,3字节，且网络号前边类别位分别为0,10,110 D类地址是多播地址，类别位1110 E类地址目前不使用 采用点分十进制来记录IP，如128.0.0.1 常见的三类IP地址 对于A B C类IP地址来说，都有几个不能指派的网络号和主机号 对A类地址，网络号全0不能指派，用来表示“此网络”，全1也不能指派，用来表示“环回测试”；主机号全0表示“本主机”，全1表示“所有主机” 对B类和C类地址，因为网络号有类别码10和110故不存在全0全1，但去除掉类别码后的网络号也不能设置为全0，表示的意义和A类一样；主机号也不能全0全1 IP地址特点： 由网络号+主机号组成，分配时只分配网络号，主机号由单位自行分配。另一个好处是路由器转发时可以根据网络号转发分组，减少路由表存储空间 实际上IP地址标志一台主机和一条链路的接口，这意味着路由器两端连接两个网络就必然拥有两个IP地址，而连接两个网络的主机叫做多归属主机 一个网络通常是指网络号相同的网络，所以用转发器和网桥连接起来的局域网通常认为是一个网络 IP地址中，所有分配到网络号的网络都是平等的 2.2 IP地址和硬件地址IP地址是逻辑地址，封装在IP数据报首部 硬件地址是物理地址，存放在适配器ROM中，封装在MAC帧首部 这里只要记住通信时网络层，数据链路层同一层级的传输都是透明的，即不需要考虑封装帧，解析帧之类的。可以理解为网络层直接传送IP数据报，数据链路层只传送MAC帧。 那么有一个问题是路由器转发IP数据报需要包装成MAC帧格式在数据链路层传输，怎么才能知道要添加的MAC地址是多少呢？换句话说怎样通过目的IP得到目的MAC地址？这就需要使用ARP地址解析协议了。 2.3 地址解析协议ARP主要作用就是根据目的IP地址找出目的MAC地址，实现方法是在每一个主机都设有一个ARP高速缓存，里边保存本局域网上各主机和路由器的IP地址到MAC地址映射表。主机A要向B发送IP数据报时，先去高速缓存查找B的映射，如果有直接就找到了，没有的话就要运行ARP根据以下步骤找到B的MAC地址。 ARP进程在本局域网上广播一个ARP请求分组，主要内容是“我的IP地址是xxx。MAC地址是xxx，我想知道IP地址是XXX的主机的硬件地址” 本局域网上所有主机的ARP进程都收到消息 主机B发现A要找的人是自己，，向A发送一个响应分组（注意这里是单播） 内容是“我的IP地址是XXX，我的MAC地址是XXX”，同时把A的映射记录在自己的高速缓存中（这一步是为了以后B向A发消息方便），非B的其他主机当然对A发送的请求分组不理睬 A收到B的响应，将B的映射记录在高速缓存中 总结就是一个喊话（广播）找人的过程，且找人必须要先自报家门让别人可以响应，喊道谁的名字谁就答应（单播），并且互相都把对方的映射记录了下来，这就方便了之后再进行通信，否则每次都要广播喊话再响应浪费资源。 另外，ARP高速缓存每一份映射都要设置生存时间（如10~20分钟），这是因为适配器可能会故障，比如B的适配器坏了，MAC地址失效了，A用失效的MAC地址也找不到B，留着没用还浪费资源，所以定期删除重新广播建立联系，确保不会有“死掉”的映射浪费资源 这里有一个最重要的点就是ARP协议是运行在同一个局域网上的，如果如下图H1要向不在同一个局域网的H4发送消息，那么首先ARP协议会找到路由器R1的MAC地址，A将MAC帧封装的IP数据报发给R1，接下来交给R1来找下一跳的路由器R2，再次运次ARP协议找到和R1同属一个网络的路由器R2的MAC地址，如此反复进行ARP解析。 那么有一个问题是既然最后在链路上传送的帧最终都是要用MAC地址送出，为什么还要用抽象的IP地址而不直接用MAC地址呢？ 这是因为全世界有各种不同的网络和设备，就有不同的硬件地址，要使这些异构网络通信就必须进行复杂的硬件地址转接工作，而使用IP地址将这些差异屏蔽掉，给用户就带来了极大的方便，对于用户来说只要关注IP地址就好了，反正ARP是自动运行的，对于用户是透明的。 2.4 IP数据报格式这里介绍IPv4，在TCP/IP中，各种数据报格式常常以32位（4字节）为单位来描述。 IP数据报由首部+数据部分组成，首部前一部分固定长度20字节，后边还有一些可选字段（一般不用，用了必须是4字节的倍数） 版本 占4位，是指IPv4或IPv6 首部长度 4位，这里必须要注意的是首部长度表示数的单位是32位（4字节，意思是首部长度是数字1实际上代表4字节），最小必须要20字节（也就是十进制5，二进制0101），最大为60字节（因为只占4位，二进制最大1111，相当于十进制15） 区分服务 8位，一般不用这个字段 总长度 16位，单位为字节。最大长度是2的16次幂-1 = 65535字节，实际一般不会这么长。这个总长度指的是首部+数据部分。这是因为总程度不能大于数据链路层的最大传送单元MTU，一般MTU = 1500，超过就要进行分片处理。分片后总长度指的是每一片的首部+数据部分 另外，大部分路由器必须能够接受长度不超过576的IP数据报，至于支不支持1500的根据路由器而定 标识 16位，这个字段是每产生一个数据报，计数器+1，将这个数写入标识符。主要作用是分片后的每一片都是这个标识，接受端根据这个标识把每一片拼在一起 标志 3位 只有前两位有意义，最低位MF（1代表后边还有分片，0标识没了）；中间位DF（1代表不允许分片，0才允许分片） 片偏移 13位 分片后每一片在原数据中的位置，意思是代表这片是从原数据何处开始的。片偏移以8个字节为偏移单位，每个分片长度一定是8的整数倍，具体结合问题去看 生存时间 8位 TTL 现在一般代表跳数，最大值为255，意味着跳了255次路由器就会把它扔掉 协议 8位 指出数据报携带的数据使用哪种协议，上交给谁。常见的有TCP UDP ICMP IGMP IP等等 首部校验和 16位 只检验首部，不包括数据部分 。这是因为每经过一个路由器可能分片信息之类的会发生变化，需要校验。不用复杂的CRC算法，使用16位反码相加的方法，具体参考书本 源地址 32位 目的地址 32位 首部可变部分：这里可以添加很多字段支持排错，安全等但是一般不用，只要记住如果使用必须要填充字节变成4的倍数 2.5 IP层分组转发流程在IP层进行分组转发，主要是根据路由器中的转发表来进行转发，本节不介绍路由器中的转发表是怎么生成和更新的，放在后边处理。 这里要注意的是每个路由器连接几个子网，并且每个子网都有若干台主机，都记录路由转发表的话数据量过多，所以路由器转发是根据网段（网络号）来转发的，并且从源地址到目的地址不是一蹴而就的（不能从开始就知道整条路径），而是进行若干个下一跳达到终点。 每条路由最主要的两个信息（目的网络地址，下一跳地址） 特定路由： 目的网络地址可以设置一个特定的路由器，直接转发到该路由器即可 默认路由： 是指路由表中没有指定跳到哪个路由器时直接转发给默认路由器进行处理（路由表中记为0.0.0.0） 分组转发算法： 从数据报首部提取目的主机的IP地址D，得出网络地址N 若N是与此路由器直连的某个地址，则直接交付 ，不需要经过别的路由器（当然这里必须使用ARP协议解析出目的主机MAC地址，封装后传输，但是研究网络层时看成透明的即可）；否则进行间接交付 ，执行3 若路由表中有目的地址为D的特定路由，则跳到特定路由 若路由表中有到网络N的路由，进行下一跳即可 若都没有，而路由表中有一个默认路由，则跳到默认路由，都没有执行6 报告分组转发出错 3 划分子网和构成超网3.1 划分子网本质是拥有许多物理网络的单位，将所属的物理网络划分为若干个子网，但是对外表现仍然是一个网络。 IP地址 = 网络号 + 子网号 + 主机号 外部路由器还是按网络号145.13.0.0找到R1，R1对内分为145.13.3.0,145.13.7.-，145.13.21.0三个子网进行转发 划分子网知识把IP地址主机号这部分再划分一下 子网掩码：由连续的1和连续的0构成的32位数据 因为IP首部没有标识子网信息的位置，所以使用子网掩码来解决，每一个路由器的路由表中都要配置一项子网掩码。使用时将目的IP地址和子网掩码按位与运算得到子网的网络号，再进行传输。 要注意的是即使没有划分子网，单使用A B C类划分地址也要有默认的子网掩码 路由器在交换路由表时，要把自己所连接的子网和对应的子网掩码同时发送交换 划分子网的目的是增加灵活性，看需求分配主机数不同的子网掩码 划分子网后路由表必须有三项内容： 目的网络地址，子网掩码，下一跳地址 分组转发比不划分子网的情况多了用子网掩码按位与操作 3.2 构成超网（无分类编址CIDR）为了应对B类地址即将用完，互联网路由表项目急速增长，IPv4地址空间将要耗尽等问题，提出了无分类域间路由选择CIDR 取消了分类地址和划分子网，采用网络前缀和主机号两级编址方式 IP地址 = 网络前缀+主机号 记为形如10.0.0.0/10 或者 00001010 00*（ *后边是主机号） 代表前10位是网络前缀，后22位是主机号 CIDR的好处主要有两个： 增加了IP地址的数量 形成地址聚合，从而减少路由表中的条目 最长前缀匹配： 使用CIDR，路由表的每个项目由网络前缀和下一跳地址来组成，而由于地址聚合的性质，同一个目的IP地址在路由表中匹配不同的CIDR可能都符合，这时就要选择匹配成功中的最长前缀的下一跳地址来转发（因为短的包含长的，换句换说长的CIDR是短的精细再分配后的） 二叉线索查找： 由于采用最长前缀匹配，那么最长采用的方法就是遍历路由表来找到最长前缀匹配，但过于浪费时间和资源，所以诞生了二叉线索查找的方法更快的找出目的前缀，具体算法参考教材 4 网际控制报文协议ICMPICMP协议是IP协议族中的，不是高层协议，因为ICMP的报文是装在IP数据报中的，作为数据部分。 类型字段代表协议类型，代码字段细分类型中的具体情况，校验和保证ICMP报文（即IP数据报数据部分）正确，还记得IP报文首部校验和只计算IP首部不计算IP数据部分吧 4.1 ICMP报文种类种类有两种： ICMP差错报告报文 ICMP询问报文 ICMP差错报告报文主要有四种： 终点不可达 时间超过：还记得IP首部生存时间字段吧，TTL为0时丢弃该IP数据报并向源点发送此条ICMP报文 参数问题：收到的数据报首部有字段值不正确发送 改变路由（重定向）：主要是默认路由器找到更优秀的线路时发送 ICMP差错报文格式如下，将要发送差错的IP数据报的首部和紧跟着的8字节（这里是端口号，为上层TCP UDP服务的）拼上ICMP前8字节（差错类型）组成ICMP差错报文发送 不该发送ICMP差错报文情况： 对ICMP差错报文，不再发送ICMP差错报文 对第一个分片数据报的后续分片不发送 对多播的数据报不发送 对特殊地址127.0.0.0/0.0.0.0（环回测试）不发送 ICMP询问报文： 回送请求和回答：测试目的站状态 时间戳请求和回答：用于时钟同步和时间测量 4.2 ICMP应用举例分组网间探测PING，测试主机间连通性，PING使用了ICMP询问报文中的回送请求和回答。注意PING应用是应用层直接使用网络层ICMP协议的一个典型例子，没有通过运输层的TCP或UDP traceroute应用，用来跟踪一个分组从源点到终点的路径 原理是源主机向终点发送一串IP数据报，数据报中封装的是无法交付的UDP用户数据报。第一个数据报的TTL设为1，第二个设为2等等。这样第一个数据报到达路径上第一个路由器R1，TTL变成0，于是R1将第一个数据报丢弃同时向源站发送ICMP时间超过报文。同理我们得到第二个路由器R2发回来的ICMP时间超时报文等等。当有一个数据报成功到达终点时，又因为UDP用户数据报无法被接受，于是终点会向源点发送ICMP终点不可达报文，这样就得到了源点到终点的整条路径。 5 互联网路由选择协议5.1 基本概念路由选择协议就是讨论路由表中的路由是怎样得出的 理想的路由算法： 算法必须是正确的和完整的 算法在计算上应简单 算法应能适应通信量和网络拓扑变化（自适应性，更新路由表） 稳定性（一段时间内端到端基本保持一条路径） 公平性（照顾到所有用户） 能够找出最佳的路径 从能否适应通信量和网络拓扑变化来划分为两大类： 静态路由选择策略（非自适应） 动态路由选择策略 互联网采用的都是动态的，分布式的路由选择协议 可以将整个互联网划分成若干个自治系统AS，比如一个大ISP，在这个基础上分为两大类： 内部网关协议IGP： 研究的是在一个AS中用的什么路由选择协议，主要有RIP和OSPF协议。这种路由选择也叫域内路由选择 外部网关协议EPG： 研究的是不同AS间主机通信的路由选择，主要用BGP-4协议。这种路由选择也叫域间路由选择 每个AS内自主决定用什么IGP，而在每个AS的边界都要有一个或者几个路由器不仅运行IGP还要运行EPG实现系统外通信 5.2 内部网关协议RIPRIP是一种基于距离向量的路由选择协议，优点是简单 可以把使用RIP协议的所有路由器想象成一张图，那么距离就是图中顶点到顶点的距离，并且RIP实际上最求的就是最短距离参考，实际上路由表中维护的就是图中每个顶点到其他顶点的最短路径 RIP将直连的两个路由器距离向量记为1（当然也可以记作0），同时RIP允许一条路径上最多包含15个路由器，因此距离16相当于不可达，这代表RIP只适用于小型互联网 不管是RIP还是OSPF都是动态分布式协议，我们要注意三个问题，和那些路由器交换信息？ 交换什么信息？ 什么时候交换信息？ RIP协议特点： 只和相邻路由器交换信息 交换全部的信息，即整个路由表 按固定时间间隔交换（30s）或者网络拓扑发生变化 距离向量算法：用相邻路由发来的信息更新自己的路由表，做个例题很容易理解 RIP报文格式： 主要掌握RIP协议使用UDP用户数据报进行传送 RIP有一个特点是好消息传播的快，坏消息传播的慢 这个主要是指R1连接的网1故障了，却收到R2之前记录的信息，从而在R1R2之间反复横跳，直到都变成16不可达，具体查看教材 5.3 内部网关协议OSPFOSPF（开放最短路径优先，因为使用了dijkstra算法）是使用分布式的链路状态协议 特点： 向AS中所有路由器发送信息，采用洪泛法 发送的信息是与本路由器相邻的所有路由器的链路状态以及代价（带宽，时延之类的） 只有链路状态发生变化时，才发送信息 通过这种方式最终所有路由器都能建立一个链路状态数据库，实际上就是全网的拓扑结构图，在全网是一致的。这样每个路由器根据这个数据库生成自己的路由表 OSPF可以支持很多的路由器接入，为了方便管理将AS划分成一些小的区域，每个区域内路由器数目最好小于200个 OSPF直接用IP数据报传送 其他优点： 建立路径时允许计算代价而不是单单看最短路径 负载平衡（几条相同代价的线路平均分配通信量） OSPF有五种分组类型： 问候分组，数据库描述分组，链路请求分组，链路状态更新，链路状态确认 OSPF规定每隔10s相邻站点发送问候分组确定有没有站点挂掉，超过40s没有回应，则用剩下4种分组进行更新操作，更新时采用可靠的洪泛法 5.4 外部网关协议BGP解决不同AS之间的路由选择问题 BGP采用路径向量路由选择协议，每个AS至少选择一个BGP发言人，一般是边界路由器，但也可以不是 需要知道的是BGP发言人之间通过建立TCP连接来交换信息，在主干网上发出生命，例如BGP1：“到达N1可以经过AS1” 6 IPv6相比IPv4主要变化： 更大的地址空间：128位 首部固定为40字节 扩展的地址层次结构：空间大，可划分层次多 灵活的首部格式：IPv6精简了首部字段，并且在数据部分支持各种扩展首部 改进的选项：允许在数据部分增加控制信息 允许协议继续扩充 支持即插即用（自动配置）：IPv6不需要DHCP 支持资源预分配 首部改为8字节对齐，IPv4是4字节对齐 版本： 4位，指明IPv6 通信量类： 8位，为了区分不同的IPv6数据报的类别或优先级 流标号： 20位，主要视为流媒体进行资源预分配 有效载荷长度： 16位，指明数据报除了基本首部的字节数，最大值65535字节 下一个首部： 8位，可选字段，标识下一个扩展首部的类型 跳数限制： 8位，就是TTL改个名 源地址： 128位 目的地址： 128位 数据报途中经过的路由器都不处理扩展首部，大大提高了路由器处理效率 IPv6数据报的目的地址可以是三种类型： 单播 同ipv4 多播 同ipv4，ipv6认为广播时特殊的多播 任播 终点是一组计算机，但只交付其中的一个，通常是最近的 IPv6使用冒号十六进制记法 68E6:8C33:FFFF:FFFF:0:DF34:2376:FFFF 中间的0可以压缩： FF05::B3 还可以结合点分十进制法表示之前的ipv4地址： ::128.0.0.1 CIDR也可以使用： 12AB:0:0:CD30::/60 IPv4向IPv6过渡 两种方法，双协议栈 隧道技术 双协议栈：将一部分的主机/路由器同时支持两种协议，不支持的网络通过转换首部来实现通信，当然不可避免会丢失一些字段 隧道技术：原理是在经过ipv4网络时，将ipv6数据报文整个封装进ipv4数据报里，出了ipv4网络再去掉。 ICMPv6是IPv6支持的控制协议，比ipv4的ICMP更加复杂，并且ICMPv6将ARP和IGMP等协议都合并到一起了 7 IP多播多播就是一对多进行传播，需要支持多播的路由器实现。多播的标识符就是IP地址中的D类地址，用一个D类地址标识一个多播组，是尽最大努力交付的（即不保证多播组中每个主机都收到消息），使用的是IGMP协议，故不产生ICMP差错报文 分为硬件多播和互联网多播 需要使用IGMP协议（使用IP数据报传送报文，即IGMP报文构成IP数据报的数据部分）和多播路由选择协议，具体查看教材 8 虚拟专用网VPN实际上一个部门内不是所有的主机都要接入互联网，给这些主机分配全球唯一IP是一种浪费，这时只给这些主机分配本地地址就可以 所以规定了一些专用地址（可重用地址），这些地址只能作为本地地址不能作为全球地址 由这些专用地址组成的网络叫做专用网，假定一个部门在两地拥有两个专用A和B，AB通信的话就要使用公用的互联网作为专用网间的通信载体，这种专用网叫做虚拟专用网VPN 9 网络地址转换NAT如果专用网内的主机已经分配了本地IP地址，但是又想和互联网连接，这时就要用到网络地址转换NAT了 方法是将专用网连接到互联网的路由器装上NAT插件，这样的路由器叫NAT路由器，它必须有至少一个全球IP地址 主机A发送数据报时，NAT路由器将数据报中的本地IP地址转换成全球IP地址用于通信，接收到目的服务器响应后将收到数据报中的全球IP地址转换成主机A的本地IP地址 同一时刻有几个全球IP地址就可以有几个专用网主机与外界通信 也可以加上端口号，这样就可以实现不同端口访问不同的外界服务器。这时一个全球IP地址就可以分配不同的端口给不同专用网内主机使用了。这样的NAT较做网络地址与端口号转换NAPT 10 多协议标记交换MPLS一种新的面向连接的协议，看书吧QAQ 特点： 支持面向连接的服务质量 支持流量工程，平衡网络负载 有效地支持虚拟专用网VPN","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--数据链路层","slug":"计算机网络/计算机网络--数据链路层","date":"2022-02-11T09:25:10.000Z","updated":"2022-06-29T10:19:25.655Z","comments":true,"path":"2022/02/11/计算机网络/计算机网络--数据链路层/","link":"","permalink":"http://icecorn.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"计算机网络–数据链路层数据链路层主要研究的是同一个局域网中，数据分组怎样从一台主机传送到另一台主机，不经过路由器的转发。局域网虽然是网络但不放在网络层来研究，因为网络层主要是研究多个网络之间的互连。 数据链路层使用的信道有两种类型： 点对点信道 广播信道 1 点对点信道的数据链路层1.1 数据链路和帧链路： 链路是从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有其他的交换节点。（物理链路） 数据链路： 传送数据时，还需要必要的通信协议来控制数据的传输，吧实现这些协议的硬件和软件加到链路上就构成了数据链路。（逻辑链路） 帧： 数据链路层的协议数据单元 PDU 主机A将IP数据报封装成帧→A发送帧给B→B去掉帧头帧尾取出IP数据报 另外，对于数据链路层，不需要考虑物理层，即物理层是透明的。 1.2 三个基本问题对于数据链路层有不同种协议，但都要实现三个基本的问题。分别是封装成帧，透明传输，差错检测。 封装成帧 将IP数据报加上帧头和帧尾构成帧，首部和尾部的重要作用是帧定界。 为了提高传输效率，帧的数据部分应尽可能大于首部和尾部。 帧的数据部分长度上限——最大传送单元MTU 帧定界使用特殊的帧定符： 帧开始符SOH（start of head） 十六进制编码01（二进制00000001） 帧结束符EOT（end of transmission） 十六进制编码04（二进制00000100） 透明传输 主要目的是防止传输的文件中含有和控制字符SOH或EOT相同的二进制bit导致接收方解析帧错误。 解决方案是在传输数据中出现的SOH或EOT前面加上一个转义字符ESC（十六进制编码1B，二进制00011011）。如果转义字符也出现在数据当中，那么就在ESC前再加一个ESC，接收端解析时会自动去掉前边一个，这种方法叫做字节填充或字符填充。 差错检验 通信链路会因干扰导致比特差错，即0变成1之类。为了保证传输可靠性，我们使用循环冗余检验CRC。 具体的CRC方法参考课本例题，需要知道的是CRC差错检验仅仅保证无比特差错，但这并不代表实现了可靠传输。因为还有另一类传输差错比如帧丢失，帧重复和帧失序等，由于成本原因这类问题不放在数据链路层解决，而由传输层的TCP协议来解决。即不要求数据链路层向上提供可靠的传输服务。这样可以提高通信效率。 2 点对点ppp协议ppp协议用于用户和ISP进行通信时使用的数据链路协议 2.1 ppp协议要求 简单： 意味着不可靠，只需要进行CRC校验 封装成帧： 使用帧定界符 透明性： 字节填充ESC 多种网络层协议： 要在同一条物理链路上支持多种网络层协议（如IP和IPX），连接的局域网或路由器同理 多种类型链路： 电的，光的，交换的或非交换的链路。以太网PPPOE 差错检测： CRC 检测连接状态： 及时检测链路故障的功能 最大传送单元： MTU，如果超过最大长度，ppp就将帧丢弃 网络层地址协商： 提供一种机制使通信的两个网络层实体能够知道彼此的网络层地址，IP地址 数据压缩协商： 提供一种方法来协商使用数据压缩算法 PPP协议只支持全双工链路 2.2 ppp帧格式 字段意义 首尾各一个字节标志字段F（flag，0x7E，01111110），表示帧开始和结束，连续两帧间只需要一个。连续两个标志字段代表空帧，丢弃。 首部地址字段A规定为FF，控制字段C规定为03，不能改。 首部协议字段2字节，为0x0021时表示IP数据报，0xC021表示ppp链路控制协议LCP数据，0x8021表示网络层的控制数据。 尾部FCS是CRC的帧检验序列、 信息部分最大1500字节 字节填充 和上文中字节填充一样，ppp选用转义字符为0x7D(01111101) 信息字段出现 0x7E 变成 0x7D 0x5E 信息字段出现 0x7D变成 0x7D 0x5D 信息字段出现ASCII码的控制字符（即数值小于0x20的字符）如0x23变成 0x7D 0x23 零比特填充 另一种实现透明传输的方法，适用于同步传输（一连串的比特连续发送） 具体方法是发现有5个连续的1，立刻填入一个0，因此可以保证信息字段不会出现连续的6个1（因为7E的二进制01111110），接收端发现连续的5个1时把后边的0去掉即可实现透明传输 2.3 ppp协议的工作状态简单的说就是用户点击拨号上网，此时调制解调器发出载波信号被路由器监听到，建立了一条物理连接。然后用户电脑向ISP发送链路控制协议LCP分组（封装成多个ppp帧），配置了一些参数建立LCP连接。之后进行网络层配置，网络控制协议给用户电脑分配一个临时的IP地址，实现通信。通信结束后，NCP释放网络层连接，收回IP地址，LCP释放数据链路层连接，最后释放物理层连接。 几个状态： 链路静止： 这是用户电脑和ISP路由器间无物理连接 链路建立： 拨号后，建立物理连接后进入该状态，目的建立LCP连接 鉴别： 建立LCP连接后进入该状态，发送鉴别协议分组等待鉴别 网络层协议： ppp协议两端的网络层协商所使用的网络层配置 链路打开： 此时可以正常通信 链路终止：出现故障或鉴定错误等问题时跳变的状态 3 广播信道的数据链路层3.1 局域网的数据链路层局域网优点： 具有广播功能，局域网内主机共享各种硬件软件资源 便于系统的扩展和逐渐演变，设备位置灵活调整改变 提高系统的可靠性，可用性，生存性 按网络拓扑分类： 星型网，环型网，总线网 为保证众多用户共享媒体资源，采用两种技术方法 静态划分信道： 频分，时分，波分，码分复用等等，代价高，不适合局域网使用 动态媒体接入控制：随机接入（重点），受控接入 两种以太网标准： DIX Ethernet V2标准和IEEE 802.3标准，802.3比较繁琐，所以目前主要使用的还是V2版本 适配器的作用： 适配器，即是网络接口卡（NIC 网卡），其与局域网通信是通过双绞线或无线连接等传输媒体（串行传输），与计算机通信则是通过主板上的I/O总线（并行传输）。 所以网卡中须有缓存的存储芯片来协调接受或发送网络通信内容传达给CPU进行处理。且我们说的MAC地址就在适配器的ROM之中。 3.2 CSMA/CD协议以太网采用随机接入，而一条总线网络同一时间只能传送一条信息，这就会导致会有信息的碰撞，CSMA/CD协议就是为了解决这个问题诞生的。 协议要点： 多点接入： 说明是总线型网络，多台主机接入 载波监听： 检测信道，总线上每个站时刻不停的检测信道 碰撞检测： 边发送边监听，发送时判断有没有其他站也在发送信息，发生碰撞立刻停止发送 CSMA/CD协议中的每个站不可能同时发送和接收，故只能半双工通信 把总线上单程端到端的传播时延记为T，每个站发出一个帧后最长需要经过2T时间可以知道是否发生了碰撞，故2T叫做争用期（碰撞窗口）。对于10Mbit/s的以太网，争用期时间为51.2微秒，征用期内可发送512bit，即64字节。也可以说争用期是512bit时间，用bit作为争用期的单位。 发生碰撞后以太网使用截断二进制指数退避选择重传的时机，从离散集合【0,1，…,2的k次幂-1】随机取出一个数r，等待r倍的争用期再进行重传。重传16次仍不成功，丢弃该帧，向上级反映。 重点：一种特殊情况是某个站发出了一个很短的帧，在发送完毕前没有检测到碰撞，而实际上该帧发生了碰撞并被丢弃，但发送站不知道碰撞从而不会进行重发。 为了避免这种状况，以太网规定一个最短帧长64字节，即512bit（争用期时间），不满64字节的帧要补充到64字节，所以如果收到小于64字节的帧即为错误帧，舍弃。 强化碰撞：发送站发现碰撞，立刻停止发送，并且发送32bit或48bit的人为干扰信号，此举是为了让所有的站都知道现在发生了碰撞。 帧间最小间隔： 以太网规定最小间隔为96bit时间。 3.3 以太网信道利用率因为会发生碰撞，所以以太网信道利用率不会是100%，T是bit端到端单程的时间，T1是帧的发送时间 a = T/T1 a越小信道利用率越高，故可采用的办法有两个，限制以太网连线的长度，适当增大以太网帧的长度 信道的利用率S = T/T+T1 = 1/1+a 3.4 以太网MAC层MAC地址又叫硬件地址或物理地址，是在适配器ROM中存在的具有唯一性的标识。MAC地址格式为6字节（48bit）由IEEE分配的全球唯一标识。 主机通信时，适配器使用过滤功能，主要有三种情况 单播帧（一对一）： 收到帧的MAC地址与自己的相同 广播帧（一对全体）： 发送给本局域网多有站点的帧（全1地址） 多播帧（一对多）： 发送给局域网上一部分站点，需要多播协议设置，有的适配器不支持 MAC帧的格式： 只介绍V2的帧格式： 很简单前边两个字段是目的地址和源地址，类型字段用来标志数据使用的是什么协议，0x0800代表IP数据报。数据是46~1500，46是因为最小长度64-首尾18=46。尾部FCS用于CRC校验。 另外，帧的前边有8字节的前同步码，是因为MAC帧是异步传输，需要与适配器进行时钟同步，最后一个字节是帧定界符，最后的11告诉适配器接下来的就是有用的MAC帧消息了。还有个问题是，MAC帧没有长度字段怎么确定数据部分是从哪到哪呢？ 这是因为以太网采用了曼彻斯特编码，具有自同步功能，当接受完全部的帧信息后，从后往前数4个字节就可以得到IP数据报的结束位置了，这也是MAC帧不需要结尾帧定界的原因。 3.5 以太网的扩展 物理层 物理层的以太网使用多个集线器，连接成很大范围内的以太网 好处： 可以使远端计算机互相连接 扩大了以太网范围，因为集线器最大距离只有100m 坏处： 1.碰撞域也增大了，大的以太网上同一时间也只能传送一个帧 不同速率的适配器不能连接在一起 数据链路层 网桥：可以对收到的MAC帧进行转发和过滤，根据网桥中的地址表选择转发和丢弃 交换机：实质上是一个多接口的网桥，可以使多对主机同时通信，其内部的地址表不用像网桥一样配置而是通过自学习算法自主建立的。最大的优点是每个用户可以使用独自的带宽 交换机的自学习功能： A向B发送帧，把自己的MAC地址和接口1写入地址表，然后去地址表查有没有B的地址，有就转发，没有就向除了自己的接口1之外的其他接口广播这个帧，这是B发现和自己的MAC地址一样就接受了，C D扔掉。 中心思想就是谁发帧谁登记，这样慢慢的所有主机都记录在地址表上了 另外两个交互接空闲接口多的时候广播时容易发生兜圈子现象，这是就要使用生成树协议STP从逻辑上切断某些链路 总结： 集线器工作在物理层，用它连接后的网络依然还是一个网，需要使用CSMA/CD协议，且集线器只是转发电信号而已。网桥有一定的转发过滤功能，只有两个接口，网桥两边的网络可以理解为分开的网络，是全双工的不会发生碰撞。交换机是加强版的网桥，有很多接口，全双工不会发生碰撞，并且有强大的自学习算法不需要人工配置地址表。换句话说集线器连接的网络整个都是冲突域，网桥是端口两端分别为冲突域，而交换机每个端口是一个冲突域。 3.6 虚拟局域网利用交换机实现的一种逻辑上的局域网 支持虚拟局域网的以太网帧扩展：最大长度从1518字节增加到1522字节 3.7 使用以太网进行宽带接入因为以太网帧格式中没有标识用户名字段的位置，所以采用pppoe（ppp over ethernet）的方法连接互联网。现在的光纤入户宽带接入都是采用这种方式。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--物理层","slug":"计算机网络/计算机网络--物理层","date":"2022-02-10T06:35:54.000Z","updated":"2022-06-29T09:48:26.452Z","comments":true,"path":"2022/02/10/计算机网络/计算机网络--物理层/","link":"","permalink":"http://icecorn.github.io/2022/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"计算机网络–物理层1. 物理层的基本概念物理层的主要任务是尽可能的屏蔽掉不同传输媒体和通信手段的差异，使物理层之上的数据链路层使用起来是透明的。物理层的协议又叫做规程。 物理层的主要任务描述为确定与传输媒体的接口有关的一些特性： 机械特性： 指明接口所用的接线器的形状，尺寸，引脚数目和排列，固定等。平时常见的各种规格的接插件都有严格的标准化规定。 电气特性： 指明在接口电缆的各条线上出现的电压的范围。 功能特性： 指明某条线上出现的某一电平的电压的意义。 过程特性： 指明对于不同功能的各种可能事件的的出现顺序。 物理层协议：点对点，多点连接，广播连接 传输媒体： 导引型传输媒体：架空明线，双绞线，同轴电缆，光缆 非导引型传输媒体： 各种波段的无线信道，微波，卫星通信 2. 数据通信的基础知识2.1 通信系统三部分： 源系统： 源点： 产生要传输数据的设备 如计算机产生数字比特流，又叫源站，信源 发送器： 比特流要经过发送器编码才能传输，典型发送器就是调制器，计算机使用内置的调制解调器 目的系统： 接收器：接受传输系统发出的信号，并转换为终端设备可处理的信号，典型接收器就是解调器，将模拟信号解调还原发送端产生的数字比特流。 终点： 从接收器获取数字比特流，显示在输出设备上，如屏幕 传输系统： 可以使简单的传输线，也可以是复杂的网络系统 消息： 话音，文字，图像，视频 数据： 运送消息的实体 信号： 是数据的电气或者电磁表现 分为模拟信号（连续信号）和数字信号（离散信号）两种 2.2 信道的概念及极限容量信道一般表示向某一个方向传送信息的媒体，一条通信电路包括一条发送信道和一条接收信道。 通信方式 信道 举例 单工通信 一条 无线广播 半双工通信 一条（正向或反向） 对讲机 全双工通信 两条（正反各一条） 手机 文字图像等信源输出的信号属于基带信号，传输不便，故需要进行调制。 调制方法： 基带调制： 将数字信号转换为另一种数字信号，变换后仍为基带信号，故称编码。 载波调制： 将基带信号频率调到较高的频段，转换为模拟信号，能更好的在模拟信道中传输，调制后的信号成为带通信号（仅在一段频率范围内能够通过信道），故也称为带通调制。 常见编码方式： 曼彻斯特编码是看周期中心的跳变是正还是负（上下），差分曼彻斯特编码是看位开始边界是否有跳变。曼彻斯特编码有自同步能力，不归零则没有。 要注意的是以上每种编码的0/1都是人为规定的，所以是可以互换的。 基本带通调制： 另外还有QAM16为代表的正交振幅调制，利用编码让每一个码元携带更多比特的信息量。 奈氏准则： 在任何信道中，码元传输的速率是有上限的，传输速率超过上限，就会出现码间串扰，影响接收端的识别。 信噪比： 信号的平均功率和噪声的平均功率之比。记作S/N，度量单位为分贝db 信噪比（db） = 10 log10（S/N）（db） 香农公式： 信道的极限信息传输速率C C = W * log2（1+S/N）(bit/s) 其中W为信道带宽（单位HZ），S为信道内信号的平均功率，N为信道内高斯噪声功率。 香农公式表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 2.3 信道复用技术 频分复用 FDM： 所有用户在同一时间内占用不同的带宽资源（频带宽度HZ）。即频带分片 时分复用 TDM： 所有用户在不同时间占用同样的频带宽度。即时间分片 统计时分复用 STDM： 一种改进的时分复用，明显提高信道的利用率，又叫异步时分复用。 波分复用 WDM： 光的频分复用。分光器 码分复用 CDM： 码分多址CDMA，抗干扰能力强，广泛应用与民用的移动通信中，特别是无线局域网。 在CDMA中，每一个比特时间再划分为m个短的时间间隔，称为码片，m通常为64或128，实际就是发送64个比特来表示一个逻辑比特0或1，虽然降低了发送效率，但是完成了加密更安全。 一个站要发送比特1，则发送自己的m bit码片序列，发送0则发送码片序列的二进制补码。CDMA系统给每一个站分配的码片序列不仅必须各不相同而且必须互相正交。这样可以保证每一个码片都与其他站的码片的內积为0。另外码片自身的內积为1，自身与自身补码的內积为-1（-1代表二进制0）。 现假定一个站X要接受站S发送的数据，则X需要知道S的码片序列，在同一时刻会有很多不同的站发来数据，而此时X使用S的码片序列与接收到的比特流进行內积操作，这样X收到其他非S站的数据內积均是0，只有收到S的比特流內积可以得出1或者-1，即可获得S站发出的逻辑比特流。 2.4 宽带接入技术 ADSL 技术： 非对称数字用户线ADSL技术是用数字技术对现有的模拟电话用户线进行改造。ADSL将0~4khz的低端频谱保留给传统电话使用，4khz以上的高频谱分为上行带宽和下行带宽。 光纤同轴混合网： 即HFC网，是一种基于有线电视网的居民宽带。 FTTx技术：及光纤入户，光纤入楼。使用分光器使几十户人家共用一根光纤干线。 使用光线路终端OLT把收到的下行数据发往无源的1：N光分路器，然后用广播方式向所有用户端的光网络单元ONU发送。ONU在用户家中即是光纤入户，从ONU到个人电脑一般用以太网连接，使用5类线作为传输媒体。 3. 常见问题3.1 传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？不是，传输媒体在物理层下面。由于物理层是体系结构第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号是什么意思，即不知道传输的信号什么时候代表1，什么时候代表0。但物理层由于规定了电气特性，所以能够识别比特流。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Markdown常用语法","slug":"Markdown基础语法","date":"2022-02-09T11:37:26.000Z","updated":"2022-06-29T11:19:33.075Z","comments":true,"path":"2022/02/09/Markdown基础语法/","link":"","permalink":"http://icecorn.github.io/2022/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdown语法1.Markdown 的基础语法本文介绍markdown的基本语法，很容易掌握，一看就会。 1.1标题 这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。Markdown 支持 6 种级别的标题，对应 HTML 标签 h1 ~ h6。l例如： 123456# h1## h2### h3#### h4##### h5###### h6 注意： ```123456789101112131415161718 和标题之间建议保留一个字符的空格，这是最标准的 Markdown 写法。以上标记效果如下： ![ ](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/h1.png)- 除此之外，Markdown 还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制```bash这是一级标题===这是二级标题--- 以上标记效果如下： 这种处理方式在 Github 的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。 1.2段落及区块引用 需要记住的是，Markdown 其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为 HTML 标签，因此使用 Markdown 分段非常简单，将你要分段的部分前后至少保留一个空行即可。 而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown 提供了一个特殊符号 &gt; 用于段首进行强调，被强调的文字部分将会高亮显示。例如： 1|&gt; 如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。 其显示结果如下： 如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。 注意： 聪明的你可能已经发现了，上面显示的引用效果和文章开头引用百度百科的效果是一样的。没错，本站所有文章均采用 Markdown 语法写作，而且大家在评论时也可以采用 Markdown 语法进行评论。这也是为什么第二篇文章写 Markdown 的原因之一了。至于我渲染出来的结果为什么跟你不一样，这是因为我们采用了不同的 CSS 进行调节，这一内容会在后面的教程进行讲解。 引用完后，一定记得空出一行再写其他东西，不然，你接下来写作的内容也都在引用内容里。 &gt;与你要引用的文字之间一定有一个空格，不然会被认为是普通的文本。&gt;前面不能有文字，必须单独一行才能引用。 1.3目录 Markdown引入目录非常简单，只需要在你想加入目录的地方输入[TOC]就可以了。 1.4首行缩进方法 在用中文写文章时，我们通常习惯段首缩进两个字，但是使用 Markdown 编辑时我们手打空格缩进是不起作用的，因此我们需要通过使用 HTML 中的空格实体来帮助我们实现缩进效果。 为了让本文不那么难以理解，这一部分我只打算讲一个，也是我比较推荐的一个，&amp;emsp;。一个汉字占两个空格大小，所以使用四个空格就可以达到首行缩进两个汉字的效果。而一个 &amp;emsp; 代表两个空格，所以用两个 &amp;emsp; 就代表两个汉字、四个空格了。 1.5分割线 分割线可以由 * 、 - 、 _（星号，减号，底线）这 3 个符号的至少 3 个符号表示，注意至少要 3 个，且不需要连续，有空格也可以。例如： 12345***---___* * ***** 其显示结果如下： 1.6粗体和斜体 Markdown 的粗体和斜体也非常简单，用**或者__包含一段文本就是粗体的语法，用*或者_包含一段文本就是斜体的语法。例如： 1234*始于颜值、陷于才华、忠于人品*_始于颜值、陷于才华、忠于人品_**始于颜值、陷于才华、忠于人品**__始于颜值、陷于才华、忠于人品__ 其显示结果如下： 始于颜值、陷于才华、忠于人品始于颜值、陷于才华、忠于人品始于颜值、陷于才华、忠于人品始于颜值、陷于才华、忠于人品 1.7删除线 用 ~~ 包含一段文本就是删除线了。例如： 1~~请删除我~~ 其显示结果如下：请删除我 1.8列表 Markdown 支持有序列表和无序列表两种形式：无序列表使用*或+或- 标识；有序列表使用数字加 . 标识。例如： 1234567891011121314151617181920212223* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子4. 黄瓜5. 玉米6. 茄子7. 黄瓜8. 玉米9. 茄子 其显示结果如下： 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 注意： 有序表不用 1. 2. 3. 这样排下去，可以直接 1. 1. 1. 这样，如果以 3. 开头，如 3. 2. 1. 这样，那么结果是 3. 4. 5.。即以什么数字开头，结果就以什么数字开头，后面的数字可以随便写。如果中间要再插入一项，就不用修改整个列表的序号了。 如果需要写多级列表，这可以用缩进的办法实现，例如： 1234567891. 动物 1. 哺乳动物 2. 爬行动物 3. 鸟类 4. 其他2. 植物 5. 被子植物 6. 裸子植物 7. 其他 其显示结果如下： 动物 哺乳动物 爬行动物 鸟类 其他 植物 被子植物 裸子植物 其他 1.9代办清单 To-do List 你可以在 Markdown 中编写代办清单，相关代码如下： 12345- [x] 已完成项目1 - [x] 已完成事项 - [ ] 代办事项- [ ] 代办项目2- [ ] 代办项目3 其显示结果如下： 已完成项目1 已完成事项 代办事项 代办项目2 代办项目3 1.10插入链接 Markdown 针对链接的处理比较简单，可以使用下面的语法进行标记： 1[点击跳转至百度](http://www.baidu.com) 其显示结果如下：点击跳转至百度 2.Markdown 的高级语法 通过上一节的讲解，我们现在已经可以进行简单的纯文字写作了。你可能想问，Markdown 只能处理纯文本吗，那如果我想插入表格，图片，公式等等该怎么办。不要急，Markdown 虽然语法简单，但是功能很强大的，上面的这些需求完全可以满足。 2.1插入图片2.1.1基本用法1![当链接内容不存在时显示的内容](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya2.jpg) 其显示结果如下： 当链接内容不存在时显示的内容 2.1.2加入图名和居中对齐 Markdown 图片默认左对齐，如果需要居中对齐，就需要采用 HTML 的语法了（注：博主采用了样式表，使图片默认居中，显示图名）。语法如下： 1&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot;&gt;&lt;/br&gt;小雅&lt;/div&gt; 小雅 2.1.3控制图片大小1&lt;img src = &quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot; width = 50%/&gt; 其显示结果如下： 2.1.4其他 主要采用的是HTML标记语言和CSS样式表来控制图片格式的。本系列教程不涉及这些，如果你有需要，可以点击HTML图片|菜鸟教程和CSS图片|菜鸟教程 进行学习。 2.1.5图床图床请参考我的Github+Hexo博客搭建小白教程 里面详细的介绍了七牛云图床的使用方法 2.2表格 表格是 Markdown 语法中比较复杂的一个，也是我们平常常用的样式之一，但也不是无迹可寻。 2.2.1基本用法 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界。 在表头下方的分隔线标记中加入:，即可标记下方单元格内容的对齐方式。 :— 代表左对齐:–: 代表居中对齐—: 代表右对齐 例如： 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 其显示结果如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 例如： 12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz 其显示结果如下： dog bird cat foo foo foo bar bar bar baz baz baz 注意： | 、 - 、: 之间的多余空格会被忽略，不影响布局。 默认标题栏居中对齐，内容居左对齐。 -: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。 内容和 | 之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个。 2.2.2加入表头 Markdown 默认语法里面没有关于表头的，但如果我们需要有表头，那该怎么办呢。通过图片章节的学习，我想你应该知道解决办法了。对，没错，就是 HTML + CSS。点击 HTML 表格 | 菜鸟教程 进行学习。 2.3插入代码块 Markdown 在 IT 圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码，其实我在前面已经多次向大家展示了代码块的最终效果。代码块的语法特别简单，只要把你想要展示的代码片段用 包裹就可以了。行内代码用一个 包裹，如 var y=x^3+2 如果要插入一整段代码，就需要至少三个` 进行包裹，如： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-num=[];i=2for i in range(2,100): j=2 for j in range(2,i): if(i%j==0): break else: num.append(i)print(num) 上面的例子就是输出100以内的素数的Python代码。 注意： 在代码前面，三个反引号后面填写你插入代码的类型，如 Markdown、Python，这样就可以高亮你的代码块了。 很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧 esc 键下面的第一个键点击即可。 2.4数学公式 Markdown 可以插入 LaTex 数学公式，这一点我非常的喜欢，因为我是先学习了 LaTex，然后再接触到 Markdown 的，Markdown 几乎支持 LaTex 的所有数学公式语法。至于 LaTex 是什么，我会在后面的文章进行介绍，现在你只要知道 Markdown 适合记一些笔记，写一些文字，但它并不适合写论文，而 LaTex 就是为排版而生的。 下面引用百度百科的介绍： LaTeX（LATEX，音译 “拉泰赫”）是一种基于 ΤΕΧ 的排版系统，由美国计算机学家莱斯利・兰伯特（Leslie Lamport）在 20 世纪 80 年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由 TeX 所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 从百度百科的介绍中我们可以知道，LaTex 非常适合生成复杂的数学公式，理工科的同学看到这点是不是很激动啊。在 Word 里面输入公式，我们一般会用到 Mathtype 这个插件，但每次都需要点很多次才能输入我们想要的公式，这严重影响到了我们的思绪。而 LaTex 只需要记住少量的代码，就可以非常流畅且快速的书写数学公式了。我曾在知乎上面看到过这样的介绍，「1700 页数学笔记火了！全程敲代码，速度飞快易搜索，硬核小哥教你上手 LaTeX+Vim」，虽然有 Vim 这样的编辑器之神（此处多说几句，自从用上Vim后，对其他编辑器的操作方式再也没正眼瞧过，看我文章的应该没有Emacs党吧）加持，但依然从侧面说明了 LaTex 在书写数学公式方面的强大和易用。 由于数学公式语法较多，后面我会在 LaTex 系列专门写一篇文章进行介绍，这里就展示几个例子。 行内公式：将公式插入到本行内，用一个美元符号包裹公式。 独行公式：将公式插入到新的一行内，并且居中，用两个美元符号包裹公式。 123456%欧拉公式$$e^&#123;i\\pi&#125;+1=0$$%薛定谔方程$$i \\hbar \\frac&#123;\\partial&#125;&#123;\\partial t&#125; \\Psi(\\boldsymbol&#123;r&#125;, t)=-\\frac&#123;\\hbar^&#123;2&#125;&#125;&#123;2 m&#125; \\nabla^&#123;2&#125; \\Psi(\\boldsymbol&#123;r&#125;, t)+V(\\boldsymbol&#123;r&#125;, t) \\Psi(\\boldsymbol&#123;r&#125;, t)$$ 2.5特殊符号处理 Markdown 使用反斜杠 \\ 插入语法中用到的特殊符号。在 Markdown 中，主要有以下几种特殊符号需要处理： 1234567891011121.\\ 反斜线2.` 反引号3.* 星号4._ 底线5.&#123;&#125; 花括号6.[] 方括号7.括弧8.# 井字号9.+ 加号10.- 减号11.. 英文句点12.! 惊叹号 1.\\ 反斜线2.` 反引号3.* 星号4._ 底线5.{} 花括号6.[] 方括号7.括弧8.# 井字号9.+ 加号10.- 减号11.. 英文句点12.! 惊叹号 3.Markdown 软件推荐 对于初学者，我推荐你使用Typora，Typora 的优点太多了：简洁美观、实时预览、扩展语法、跨平台、免费。","categories":[{"name":"工具","slug":"工具","permalink":"http://icecorn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://icecorn.github.io/tags/Markdown/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"http://icecorn.github.io/categories/C/"},{"name":"设计模式","slug":"C/设计模式","permalink":"http://icecorn.github.io/categories/C/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://icecorn.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"图形学","slug":"图形学","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"渲染","slug":"图形学/渲染","permalink":"http://icecorn.github.io/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E6%B8%B2%E6%9F%93/"},{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"Linux","slug":"ReadingNotes/Linux","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/"},{"name":"系统编程","slug":"ReadingNotes/Linux/系统编程","permalink":"http://icecorn.github.io/categories/ReadingNotes/Linux/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"},{"name":"操作系统","slug":"操作系统","permalink":"http://icecorn.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","permalink":"http://icecorn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"单例模式","slug":"单例模式","permalink":"http://icecorn.github.io/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"name":"算法","slug":"算法","permalink":"http://icecorn.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","permalink":"http://icecorn.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"divide&conquer","slug":"divide-conquer","permalink":"http://icecorn.github.io/tags/divide-conquer/"},{"name":"动态规划","slug":"动态规划","permalink":"http://icecorn.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"Games-104","slug":"Games-104","permalink":"http://icecorn.github.io/tags/Games-104/"},{"name":"游戏引擎","slug":"游戏引擎","permalink":"http://icecorn.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{"name":"shader","slug":"shader","permalink":"http://icecorn.github.io/tags/shader/"},{"name":"openGL","slug":"openGL","permalink":"http://icecorn.github.io/tags/openGL/"},{"name":"Linux高性能服务器","slug":"Linux高性能服务器","permalink":"http://icecorn.github.io/tags/Linux%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"多线程","slug":"多线程","permalink":"http://icecorn.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"多进程","slug":"多进程","permalink":"http://icecorn.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"socket编程","slug":"socket编程","permalink":"http://icecorn.github.io/tags/socket%E7%BC%96%E7%A8%8B/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C++内存管理机制","slug":"C-内存管理机制","permalink":"http://icecorn.github.io/tags/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"},{"name":"内存池","slug":"内存池","permalink":"http://icecorn.github.io/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"},{"name":"Rasterizer","slug":"Rasterizer","permalink":"http://icecorn.github.io/tags/Rasterizer/"},{"name":"Games-101","slug":"Games-101","permalink":"http://icecorn.github.io/tags/Games-101/"},{"name":"操作系统","slug":"操作系统","permalink":"http://icecorn.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"思维导图","slug":"思维导图","permalink":"http://icecorn.github.io/tags/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"},{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"},{"name":"Markdown","slug":"Markdown","permalink":"http://icecorn.github.io/tags/Markdown/"}]}