{"meta":{"title":"Blog of Icecorn","subtitle":"","description":"","author":"Icecorn","url":"http://Icecorn.github.io","root":"/"},"pages":[{"title":"about","date":"2022-02-10T10:57:28.000Z","updated":"2022-06-29T10:57:55.898Z","comments":true,"path":"about/index.html","permalink":"http://icecorn.github.io/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-02-09T10:56:06.000Z","updated":"2022-06-29T10:56:40.411Z","comments":true,"path":"categories/index.html","permalink":"http://icecorn.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-02-09T10:53:15.000Z","updated":"2022-06-29T10:53:59.303Z","comments":true,"path":"tags/index.html","permalink":"http://icecorn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++ Primer笔记|专题-四种类型转换的使用","slug":"C++ Primer/C++primer笔记-专题-四种类型转换","date":"2022-03-10T12:25:30.000Z","updated":"2022-06-29T13:24:31.104Z","comments":true,"path":"2022/03/10/C++ Primer/C++primer笔记-专题-四种类型转换/","link":"","permalink":"http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E4%B8%93%E9%A2%98-%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"专题 -四种类型转换的使用运行时类型识别（Run-Time Type Identification）运行时类型识别（RTTI）的功能由两个运算符实现： typeid运算符，用于返回表达式的类型。 dynamic_cast运算符，用于将基类的指针或引用安全地转换为派生类的指针或引用。 RTTI运算符适用于以下情况：想通过基类对象的指针或引用执行某个派生类操作，并且该操作不是虚函数。 dynamic_cast运算符（The dynamic_cast Operator）dynamic_cast运算符的形式如下： 123dynamic_cast&lt;type*&gt;(e)dynamic_cast&lt;type&amp;&gt;(e)dynamic_cast&lt;type&amp;&amp;&gt;(e) 其中type是一个类类型，并且通常情况下该类型应该含有虚函数。在第一种形式中，e必须是一个有效指针；在第二种形式中，e必须是一个左值；在第三种形式中，e不能是左值。在所有形式中，e的类型必须符合以下条件之一： e是type的公有派生类。 e是type的公有基类。 e和type类型相同。 如果条件符合，则类型转换成功，否则转换失败。转换失败可能有两种结果： 如果dynamic_cast语句的转换目标是指针类型，则结果为0。 12345678if (Derived *dp = dynamic_cast&lt;Derived*&gt;(bp))&#123; // use the Derived object to which dp points&#125;else&#123; // bp points at a Base object // use the Base object to which bp points&#125; 如果dynamic_cast语句的转换目标是引用类型，则抛出bad_cast异常（定义在头文件typeinfo中）。 123456789101112void f(const Base &amp;b)&#123; try &#123; const Derived &amp;d = dynamic_cast&lt;const Derived&amp;&gt;(b); // use the Derived object to which b referred &#125; catch (bad_cast) &#123; // handle the fact that the cast failed &#125;&#125; 在条件判断部分执行dynamic_cast可以确保类型转换和结果检查在同一条表达式中完成。 可以对一个空指针执行dynamic_cast，结果是所需类型的空指针。 四种强制类型转换强制类型转换解决的问题： 强制类型转换是有一定风险的，有的转换并不一定安全，如把整型数值转换成指针，把基类指针转换成派生类指针，把一种函数指针转换成另一种函数指针，把常量指针转换成非常量指针等。C++ 引入新的强制类型转换机制，主要是为了克服C语言强制类型转换的以下三个缺点。 1) 没有从形式上体现转换功能和风险的不同。 例如，将 int 强制转换成 double 是没有风险的，而将常量指针转换成非常量指针，将基类指针转换成派生类指针都是高风险的，而且后两者带来的风险不同（即可能引发不同种类的错误），C语言的强制类型转换形式对这些不同并不加以区分。 2) 将多态基类指针转换成派生类指针时不检查安全性，即无法判断转换后的指针是否确实指向一个派生类对象。 3) 难以在程序中寻找到底什么地方进行了强制类型转换。 强制类型转换是引发程序运行时错误的一个原因，因此在程序出错时，可能就会想到是不是有哪些强制类型转换出了问题。 如果采用C语言的老式做法，要在程序中找出所有进行了强制类型转换的地方，显然是很麻烦的，因为这些转换没有统一的格式。 而用 C++ 的方式，则只需要查找**_cast**字符串就可以了。甚至可以根据错误的类型，有针对性地专门查找某一种强制类型转换。例如，怀疑一个错误可能是由于使用了 reinterpret_cast 导致的，就可以只查找reinterpret_cast字符串。 C++ 强制类型转换运算符的用法如下： *强制类型转换运算符 &lt;**要转换到的类型**&gt; (*待转换的表达式*)* 例如： double d = static_cast (35); //将 35 的值转换成实数 下面分别介绍四种强制类型转换运算符。 const_cast 常量转换const_cast 运算符仅用于进行去除 const 属性的转换，它也是四个强制类型转换运算符中唯一能够去除 const 属性的运算符。 将 const 引用转换为同类型的非 const 引用，将 const 指针转换为同类型的非 const 指针时可以使用 const_cast 运算符。 123const string s = &quot;Inception&quot;;string&amp; p = const_cast &lt;string&amp;&gt; (s);string* ps = const_cast &lt;string*&gt; (&amp;s); // &amp;s 的类型是 const string* const int* p; //p可变,p指向的内容不可变int const* p; //p可变,p指向的内容不可变int* const p; //p不可变,p指向的内容可变 const修饰函数返回值表示返回值不可改变,多用于返回指针的情形volatile可理解为编译器警告指示字volatile用于告诉编译器必须每次去内存中取变量值volatile主要修饰可能被多个线程访问的变量volatile也可以修饰可能被未知因数更改的变量 1、常量指针被转化成非常量的指针，并且仍然指向原来的对象；2、常量引用被转换成非常量的引用，并且仍然指向原来的对象；3、const_cast一般用于修改指针。如const char *p形式； 未定义行为:C++标准对此类行为没有做出明确规定.同一份代码在使用不同的编译器会有不同的效果.在 vs2017 下, 虽然代码中 c_val , use_val , ptr_val 看到的地址是一样的.但是c_val的值并没有改变.有可能在某种编译器实现后,这一份代码的c_val 会被改变.也有可能编译器对这类行为直接 error 或 warning. static_cast 静态类型转换1、static_cast 作用和C语言风格强制转换的效果基本一样，由于没有运行时类型检查来保证转换的安全性，所以这类型的强制转换和C语言风格的强制转换都有安全隐患。2、用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。注意：进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。3、用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。这种转换的安全性需要开发者来维护。 4、static_cast不能转换掉原有类型的const、volatile、或者 __unaligned属性。(前两种可以使用const_cast 来去除) 5、在c++ primer 中说道：c++ 的任何的隐式转换都是使用 static_cast 来实现。 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;class A&#123;public: operator int() &#123; return 1; &#125; operator char*() &#123; return NULL; &#125;&#125;;int main()&#123; A a; int n; char* p = &quot;New Dragon Inn&quot;; n = static_cast &lt;int&gt; (3.14); // n 的值变为 3 n = static_cast &lt;int&gt; (a); //调用 a.operator int，n 的值变为 1 p = static_cast &lt;char*&gt; (a); //调用 a.operator char*，p 的值变为 NULL n = static_cast &lt;int&gt; (p); //编译错误，static_cast不能将指针转换成整型 p = static_cast &lt;char*&gt; (n); //编译错误，static_cast 不能将整型转换成指针 return 0;&#125; dynamic_cast 动态类型转换用 reinterpret_cast 可以将多态基类（包含虚函数的基类）的指针强制转换为派生类的指针，但是这种转换不检查安全性，即不检查转换后的指针是否确实指向一个派生类对象。dynamic_cast专门用于将多态基类的指针或引用强制转换为派生类的指针或引用，而且能够检查转换的安全性。对于不安全的指针转换，转换结果返回 NULL 指针。 dynamic_cast 是通过“运行时类型检查”来保证安全性的。dynamic_cast 不能用于将非多态基类的指针或引用强制转换为派生类的指针或引用——这种转换没法保证安全性，只好用 reinterpret_cast 来完成。 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Base&#123; //有虚函数，因此是多态基类public: virtual ~Base() &#123;&#125;&#125;;class Derived : public Base &#123; &#125;;int main()&#123; Base b; Derived d; Derived* pd; pd = reinterpret_cast &lt;Derived*&gt; (&amp;b); if (pd == NULL) //此处pd不会为 NULL。reinterpret_cast不检查安全性，总是进行转换 cout &lt;&lt; &quot;unsafe reinterpret_cast&quot; &lt;&lt; endl; //不会执行 pd = dynamic_cast &lt;Derived*&gt; (&amp;b); if (pd == NULL) //结果会是NULL，因为 &amp;b 不指向派生类对象，此转换不安全 cout &lt;&lt; &quot;unsafe dynamic_cast1&quot; &lt;&lt; endl; //会执行 pd = dynamic_cast &lt;Derived*&gt; (&amp;d); //安全的转换 if (pd == NULL) //此处 pd 不会为 NULL cout &lt;&lt; &quot;unsafe dynamic_cast2&quot; &lt;&lt; endl; //不会执行 return 0;&#125; 程序的输出结果是：unsafe dynamic_cast1 第 20 行，通过判断 pd 的值是否为 NULL，就能知道第 19 行进行的转换是否是安全的。第 23 行同理。 如果上面的程序中出现了下面的语句： Derived &amp; r = dynamic_cast &lt;Derived &amp;&gt; (b); 那该如何判断该转换是否安全呢？不存在空引用，因此不能通过返回值来判断转换是否安全。C++ 的解决办法是：dynamic_cast 在进行引用的强制转换时，如果发现转换不安全，就会拋出一个异常，通过处理异常，就能发现不安全的转换。 dynamic_cast强制转换,应该是这四种中最特殊的一个,因为他涉及到面向对象的多态性和程序运行时的状态,也与编译器的属性设置有关.所以不能完全使用C语言的强制转换替代,它也是最常有用的,最不可缺少的一种强制转换. 对于从子类到基类的指针转换 ,dynamic_cast 成功转换,没有什么运行异常,且达到预期结果， 而从基类到子类的转换 , dynamic_cast 在转换时也没有报错,但是输出给 base2sub 是一个 nullptr ,说明dynami_cast 在程序运行时对类型转换对“运行期类型信息”（Runtime type information，RTTI）进行了检查. 这个检查主要来自虚函数(virtual function) 在C++的面对对象思想中，虚函数起到了很关键的作用，当一个类中拥有至少一个虚函数，那么编译器就会构建出一个虚函数表(virtual method table)来指示这些函数的地址，假如继承该类的子类定义并实现了一个同名并具有同样函数签名（function siguature）的方法重写了基类中的方法，那么虚函数表会将该函数指向新的地址。此时多态性就体现出来了：当我们将基类的指针或引用指向子类的对象的时候，调用方法时，就会顺着虚函数表找到对应子类的方法而非基类的方法。*因此注意下代码中 Base 和 Sub 都有声明定义的一个虚函数 ” i_am_virtual_foo” ,我这份代码的 Base 和 Sub 使用 dynami_cast 转换时检查的运行期类型信息,可以说就是这个虚函数 reinterpret_cast 重新解释（类型的比特位）reinterpret_cast 用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个比特复制的操作。 这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个 int* 指针、函数指针或其他类型的指针转换成 string* 类型的指针也是可以的，至于以后用转换后的指针调用 string 类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作：（C++ 标准不允许将函数指针转换成对象指针，但有些编译器，如 Visual Studio 2010，则支持这种转换）。 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;class A&#123;public: int i; int j; A(int n):i(n),j(n) &#123; &#125;&#125;;int main()&#123; A a(100); int &amp;r = reinterpret_cast&lt;int&amp;&gt;(a); //强行让 r 引用 a（即a的首地址） r = 200; //把 a.i 变成了 200 cout &lt;&lt; a.i &lt;&lt; &quot;,&quot; &lt;&lt; a.j &lt;&lt; endl; // 输出 200,100 int n = 300; A *pa = reinterpret_cast&lt;A*&gt; (&amp;n); //强行让 pa 指向 n pa-&gt;i = 400; // n 变成 400 pa-&gt;j = 500; //此条语句不安全，很可能导致程序崩溃 cout &lt;&lt; n &lt;&lt; endl; // 输出 400 long long la = 0x12345678abcdLL; pa = reinterpret_cast&lt;A*&gt;(la); //la太长，只取低32位0x5678abcd拷贝给pa unsigned int u = reinterpret_cast&lt;unsigned int&gt;(pa);//pa逐个比特拷贝到u cout &lt;&lt; hex &lt;&lt; u &lt;&lt; endl; //输出 5678abcd typedef void (* PF1) (int); typedef int (* PF2) (int,char *); PF1 pf1; PF2 pf2; pf2 = reinterpret_cast&lt;PF2&gt;(pf1); //两个不同类型的函数指针之间可以互相转换&#125; 程序的输出结果是：200, 1004005678abcd 第 19 行的代码不安全，因为在编译器看来，pa-&gt;j 的存放位置就是 n 后面的 4 个字节。 本条语句会向这 4 个字节中写入 500。**但这 4 个字节不知道是用来存放什么的（*因为i和j不一定连续存储*），贸然向其中写入可能会导致程序错误甚至崩溃。 上面程序中的各种转换都没有实际意义，只是为了演示 reinteipret_cast 的用法而已。在编写黑客程序、病毒或反病毒程序时，也许会用到这样怪异的转换。 reinterpret_cast体现了 C++ 语言的设计思想：用户可以做任何操作，但要为自己的行为负责。 提供下IBM C++ 对 reinterpret_cast 推荐使用的地方A pointer to any integral type large enough to hold it （指针转向足够大的整数类型）A value of integral or enumeration type to a pointer （从整形或者enum枚举类型转换为指针）A pointer to a function to a pointer to a function of a different type （从指向函数的指针转向另一个不同类型的指向函数的指针）A pointer to an object to a pointer to an object of a different type （从一个指向对象的指针转向另一个不同类型的指向对象的指针）A pointer to a member to a pointer to a member of a different class or type, if the types of the members are both function types or object types （从一个指向成员的指针转向另一个指向类成员的指针！或者是类型，如果类型的成员和函数都是函数类型或者对象类型）","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十五章-面向对象程序设计","slug":"C++ Primer/C++primer笔记-第十五章-面向对象程序设计","date":"2022-03-10T12:25:30.000Z","updated":"2022-06-29T13:21:19.003Z","comments":true,"path":"2022/03/10/C++ Primer/C++primer笔记-第十五章-面向对象程序设计/","link":"","permalink":"http://icecorn.github.io/2022/03/10/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"第十五章 面向对象程序设计基类和派生类成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段。 派生类能访问基类的公有成员，不能访问私有成员。如果基类希望定义外部代码无法访问，但是派生类对象可以访问的成员，可以使用受保护的（protected）访问运算符进行说明。 C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的。 因为在派生类对象中含有与其基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类的指针或引用绑定到派生类对象中的基类部分上。这种转换通常称为派生类到基类的（derived-to-base）类型转换，编译器会隐式执行。 12345Quote item; // object of base typeBulk_quote bulk; // object of derived typeQuote *p = &amp;item; // p points to a Quote objectp = &amp;bulk; // p points to the Quote part of bulkQuote &amp;r = bulk; // r bound to the Quote part of bulk 每个类控制它自己的成员初始化过程，派生类必须使用基类的构造函数来初始化它的基类部分。派生类的构造函数通过构造函数初始化列表来将实参传递给基类构造函数。 123Bulk_quote(const std::string&amp; book, double p, std::size_t qty, double disc) : Quote(book, p), min_qty(qty), discount(disc) &#123; &#125; 除非特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。 派生类初始化时首先初始化基类部分，然后按照声明的顺序依次初始化派生类成员。 派生类可以访问基类的公有成员和受保护成员。 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。如果某静态成员是可访问的，则既能通过基类也能通过派生类使用它。 已经完整定义的类才能被用作基类。 123class Base &#123; /* ... */ &#125; ;class D1: public Base &#123; /* ... */ &#125;;class D2: public D1 &#123; /* ... */ &#125;; Base是D1的直接基类（direct base），是D2的间接基类（indirect base）。最终的派生类将包含它直接基类的子对象以及每个间接基类的子对象。 C++11中，在类名后面添加final关键字可以禁止其他类继承它。 123456class NoDerived final &#123; /* */ &#125;; // NoDerived can&#x27;t be a base classclass Base &#123; /* */ &#125;;// Last is final; we cannot inherit from Lastclass Last final : Base &#123; /* */ &#125;; // Last can&#x27;t be a base classclass Bad : NoDerived &#123; /* */ &#125;; // error: NoDerived is finalclass Bad2 : Last &#123; /* */ &#125;; // error: Last is final 类型转换与继承和内置指针一样，智能指针类也支持派生类到基类的类型转换，所以可以将一个派生类对象的指针存储在一个基类的智能指针内。 表达式的静态类型（static type）在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型（dynamic type）则是变量或表达式表示的内存中对象的类型，只有运行时才可知。 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。 不存在从基类到派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上也不行，因为编译器只能通过检查指针或引用的静态类型来判断转换是否合法。 123Quote base;Bulk_quote* bulkP = &amp;base; // error: can&#x27;t convert base to derivedBulk_quote&amp; bulkRef = base; // error: can&#x27;t convert base to derived 如果在基类中含有一个或多个虚函数，可以使用dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用，该转换的安全检查将在运行期间执行。 如果已知某个基类到派生类的转换是安全的，可以使用static_cast强制覆盖掉编译器的检查工作。 派生类到基类的自动类型转换只对指针或引用有效，在派生类类型和基类类型之间不存在这种转换。 派生类到基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象，这些操作是基类定义的，只会处理基类自己的成员，派生类的部分被切掉（sliced down）了。 123Bulk_quote bulk; // object of derived typeQuote item(bulk); // uses the Quote::Quote(const Quote&amp;) constructoritem = bulk; // calls Quote::operator=(const Quote&amp;) 用一个派生类对象为一个基类对象初始化或赋值时，只有该对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。 虚函数（Virtual Functions）当且仅当通过指针或引用调用虚函数时，才会在运行过程解析该调用，也只有在这种情况下对象的动态类型有可能与静态类型不同。 在派生类中覆盖某个虚函数时，可以再次使用virtual关键字说明函数性质，但这并非强制要求。因为一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。 在派生类中覆盖某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。 派生类可以定义一个与基类中的虚函数名字相同但形参列表不同的函数，但编译器会认为该函数与基类中原有的函数是相互独立的，此时派生类的函数并没有覆盖掉基类中的版本。 C++11允许派生类使用override关键字显式地注明虚函数。如果override标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报告错误。override位于函数参数列表之后。 1234567891011121314struct B&#123; virtual void f1(int) const; virtual void f2(); void f3();&#125;;struct D1 : B &#123; void f1(int) const override; // ok: f1 matches f1 in the base void f2(int) override; // error: B has no f2(int) function void f3() override; // error: f3 not virtual void f4() override; // error: B doesn&#x27;t have a function named f4&#125; 与禁止类继承类似，函数也可以通过添加final关键字来禁止覆盖操作。 12345struct D2 : B&#123; // inherits f2() and f3() from B and overrides f1(int) void f1(int) const final; // subsequent classes can&#x27;t override f1(int)&#125;; final和override关键字出现在形参列表（包括任何const或引用修饰符）以及尾置返回类型之后。 虚函数也可以有默认实参，每次函数调用的默认实参值由本次调用的静态类型决定。如果通过基类的指针或引用调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此。 如果虚函数使用默认实参，则基类和派生类中定义的默认实参值最好一致。 使用作用域运算符::可以强制执行虚函数的某个版本，不进行动态绑定。 12// calls the version from the base class regardless of the dynamic type of basePdouble undiscounted = baseP-&gt;Quote::net_price(42); 通常情况下，只有成员函数或友元中的代码才需要使用作用域运算符来回避虚函数的动态绑定机制。 如果一个派生类虚函数需要调用它的基类版本，但没有使用作用域运算符，则在运行时该调用会被解析为对派生类版本自身的调用，从而导致无限递归。 抽象基类（Abstract Base Classes）在类内部虚函数声明语句的分号前添加=0可以将一个虚函数声明为纯虚（pure virtual）函数。一个纯虚函数无须定义。 1double net_price(std::size_t) const = 0; 可以为纯虚函数提供定义，但函数体必须定义在类的外部。 含有（或未经覆盖直接继承）纯虚函数的类是抽象基类。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。 不能创建抽象基类的对象。 派生类构造函数只初始化它的直接基类。 重构（refactoring）负责重新设计类的体系以便将操作或数据从一个类移动到另一个类中。 关于多继承和虚继承多继承很简单就是一个子类可以继承多个父类，且对于一个子类对象，它里面其实包含每个父类的对象各一个，那么怎么协调好变量和函数的继承关系，理解记忆就好了，关键是不产生冲突 虚继承是为了解决菱形继承出现的，因为如果不是菱形继承，一个子类对象就会有两个一样的爷爷类的对象，这是不对的，而有了虚继承，就是让一个子对象只拥有一个爷爷类对象，不会产生冲突。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十三章-拷贝控制","slug":"C++ Primer/C++primer笔记-第十三章-拷贝控制","date":"2022-03-07T12:25:30.000Z","updated":"2022-06-29T13:17:34.702Z","comments":true,"path":"2022/03/07/C++ Primer/C++primer笔记-第十三章-拷贝控制/","link":"","permalink":"http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/","excerpt":"","text":"第十三章 拷贝控制主要是关于拷贝构造，拷贝赋值，移动构造，移动赋值，析构函数的说明。 关于拷贝不在赘述，主要要记得当一个类里有指针类型时，要注意深拷贝和浅拷贝的问题，比如Myclass b = a；就是如果是浅拷贝的话，b中拷贝过来的指针和a中原来的指针指向的是同一块位置，那么就要考虑要析构b的时候，a对象是否还再用，如果还在用就不能析构指针指向这块内存，防止出现a对象这个指针指向未定义的情况发生。如果是深拷贝的话，就是说a对象和b对象的指针指向的东西也不是在一块内存上，所以可以正常析构。具体要深拷贝还是浅拷贝还是要看业务类型来实现处理。 对象移动（Moving Objects）某些情况下，一个对象拷贝后就立即被销毁了，此时移动而非拷贝对象会大幅度提高性能。 在旧版本的标准库中，容器所能保存的类型必须是可拷贝的。但在新标准中，可以用容器保存不可拷贝，但可移动的类型。 标准库容器、string和shared_ptr类既支持移动也支持拷贝。IO类和unique_ptr类可以移动但不能拷贝。 右值引用（Rvalue Reference）为了支持移动操作，C++11引入了右值引用类型。右值引用就是必须绑定到右值的引用。可以通过&amp;&amp;来获得右值引用。 123456int i = 42;int &amp;r = i; // ok: r refers to iint &amp;&amp;rr = i; // error: cannot bind an rvalue reference to anint &amp;r2 = i * 42; // error: i * 42 is an rvalueconst int &amp;r3 = i * 42; // ok: we can bind a reference to const to an rvalueint &amp;&amp;rr2 = i * 42; // ok: bind rr2 to the result of the multiplication 右值引用只能绑定到即将被销毁，并且没有其他用户的临时对象上。使用右值引用的代码可以自由地接管所引用对象的资源。 变量表达式都是左值，所以不能将一个右值引用直接绑定到一个变量上，即使这个变量的类型是右值引用也不行。 12int &amp;&amp;rr1 = 42; // ok: literals are rvaluesint &amp;&amp;rr2 = rr1; // error: the expression rr1 is an lvalue! 调用move函数可以获得绑定在左值上的右值引用，此函数定义在头文件utility中。 1int &amp;&amp;rr3 = std::move(rr1); 调用move函数的代码应该使用std::move而非move，这样做可以避免潜在的名字冲突。 移动构造函数和移动赋值运算符（Move Constructor and Move Assignment）移动构造函数的第一个参数是该类类型的右值引用，其他任何额外参数都必须有默认值。 除了完成资源移动，移动构造函数还必须确保移后源对象是可以安全销毁的。 在函数的形参列表后面添加关键字noexcept可以指明该函数不会抛出任何异常。 对于构造函数，noexcept位于形参列表和初始化列表开头的冒号之间。在类的头文件声明和定义中（如果定义在类外）都应该指定noexcept。 123456789class StrVec&#123;public: StrVec(StrVec&amp;&amp;) noexcept; // move constructor // other members as before&#125;;StrVec::StrVec(StrVec &amp;&amp;s) noexcept : /* member initializers */&#123; /* constructor body */ &#125; 标准库容器能对异常发生时其自身的行为提供保障。虽然移动操作通常不抛出异常，但抛出异常也是允许的。为了安全起见，除非容器确定元素类型的移动操作不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝而非移动操作。 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。 在移动操作之后，移后源对象必须保持有效的、可销毁的状态，但是用户不能使用它的值。 1234567891011121314StrVec &amp;StrVec::operator=(StrVec &amp;&amp;rhs) noexcept&#123; // direct test for self-assignment if (this != &amp;rhs) &#123; free(); // free existing elements elements = rhs.elements; // take over resources from rhs first_free = rhs.first_free; cap = rhs.cap; // leave rhs in a destructible state rhs.elements = rhs.first_free = rhs.cap = nullptr; &#125; return *this;&#125; 只有当一个类没有定义任何拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为类合成移动构造函数和移动赋值运算符。编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，则编译器也能移动该成员。 1234567891011121314// the compiler will synthesize the move operations for X and hasXstruct X&#123; int i; // built-in types can be moved std::string s; // string defines its own move operations&#125;;struct hasX&#123; X mem; // X has synthesized move operations&#125;;X x, x2 = std::move(x); // uses the synthesized move constructorhasX hx, hx2 = std::move(hx); // uses the synthesized move constructor 与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。 与拷贝操作不同，移动操作永远不会被隐式定义为删除的函数。但如果显式地要求编译器生成=default的移动操作，且编译器不能移动全部成员，则移动操作会被定义为删除的函数。 定义了移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认地定义为删除的函数。 如果一个类有可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的，即使调用move函数时也是如此。拷贝赋值运算符和移动赋值运算符的情况类似。 1234567891011class Foo&#123;public: Foo() = default; Foo(const Foo&amp;); // copy constructor // other members, but Foo does not define a move constructor&#125;;Foo x;Foo y(x); // copy constructor; x is an lvalueFoo z(std::move(x)); // copy constructor, because there is no move constructor 使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能。依赖于实参的类型，左值被拷贝，右值被移动。 123456789// assignment operator is both the move- and copy-assignment operatorHasPtr&amp; operator=(HasPtr rhs)&#123; swap(*this, rhs); return *this;&#125;hp = hp2; // hp2 is an lvalue; copy constructor used to copy hp2hp = std::move(hp2); // move constructor moves hp2 建议将五个拷贝控制成员当成一个整体来对待。如果一个类需要任何一个拷贝操作，它就应该定义所有五个操作。 移动赋值运算符可以直接检查自赋值情况。 C++11标准库定义了移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。移动迭代器的解引用运算符返回一个右值引用。 调用make_move_iterator函数能将一个普通迭代器转换成移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。 最好不要在移动构造函数和移动赋值运算符这些类实现代码之外的地方随意使用move操作。 右值引用和成员函数（Rvalue References and Member Functions）区分移动和拷贝的重载函数通常有一个版本接受一个const T&amp;参数，另一个版本接受一个T&amp;&amp;参数（T为类型）。 12void push_back(const X&amp;); // copy: binds to any kind of Xvoid push_back(X&amp;&amp;); // move: binds only to modifiable rvalues of type X 有时可以对右值赋值： 12string s1, s2;s1 + s2 = &quot;wow!&quot;; 在旧标准中，没有办法阻止这种使用方式。为了维持向下兼容性，新标准库仍然允许向右值赋值。但是可以在自己的类中阻止这种行为，规定左侧运算对象（即this指向的对象）必须是一个左值。 在非static成员函数的形参列表后面添加引用限定符（reference qualifier）可以指定this的左值/右值属性。引用限定符可以是&amp;或者&amp;&amp;，分别表示this可以指向一个左值或右值对象。引用限定符必须同时出现在函数的声明和定义中。 123456789101112class Foo&#123;public: Foo &amp;operator=(const Foo&amp;) &amp;; // may assign only to modifiable lvalues // other members of Foo&#125;;Foo &amp;Foo::operator=(const Foo &amp;rhs) &amp;&#123; // do whatever is needed to assign rhs to this object return *this;&#125; 一个非static成员函数可以同时使用const和引用限定符，此时引用限定符跟在const限定符之后。 123456class Foo&#123;public: Foo someMem() &amp; const; // error: const qualifier must come first Foo anotherMem() const &amp;; // ok: const qualifier comes first&#125;; 引用限定符也可以区分成员函数的重载版本。 123456789class Foo&#123;public: Foo sorted() &amp;&amp;; // may run on modifiable rvalues Foo sorted() const &amp;; // may run on any kind of Foo&#125;;retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() &amp;&amp;retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &amp; 如果一个成员函数有引用限定符，则具有相同参数列表的所有重载版本都必须有引用限定符。 12345678910class Foo&#123;public: Foo sorted() &amp;&amp;; Foo sorted() const; // error: must have reference qualifier // Comp is type alias for the function type // that can be used to compare int values using Comp = bool(const int&amp;, const int&amp;); Foo sorted(Comp*); // ok: different parameter list&#125;; 理解move 这里也要注意对move语义的误解，move实际上它并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用。如果是一些基本类型比如int和char[10]定长数组等类型，使用move的话仍然会发生拷贝（因为没有对应的移动构造函数）。所以，move对于含资源（堆内存或句柄）的对象来说更有意义。 注意：使用move不会释放源对象，所以一定要确保源对象不会再使用了，才能用move 详细帖子： https://blog.csdn.net/weixin_34268579/article/details/85696355?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163921024016780357225243%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=163921024016780357225243&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-85696355.first_rank_v2_pc_rank_v29&amp;utm_term=c%2B%2B+%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8&amp;spm=1018.2226.3001.4187","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十四章 重载运算与类型转换","slug":"C++ Primer/C++primer笔记-第十四章-重载运算与类型转换","date":"2022-03-07T12:25:30.000Z","updated":"2022-06-29T13:19:46.434Z","comments":true,"path":"2022/03/07/C++ Primer/C++primer笔记-第十四章-重载运算与类型转换/","link":"","permalink":"http://icecorn.github.io/2022/03/07/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"第14章 重载运算与类型转换基本概念（Basic Concepts）重载的运算符是具有特殊名字的函数，它们的名字由关键字operator和其后要定义的运算符号组成。 重载运算符函数的参数数量和该运算符作用的运算对象数量一样多。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。除了重载的函数调用运算符operator()之外，其他重载运算符不能含有默认实参。 如果一个运算符函数是类的成员函数，则它的第一个运算对象会绑定到隐式的this指针上。因此成员运算符函数的显式参数数量比运算对象的数量少一个。 当运算符作用于内置类型的运算对象时，无法改变该运算符的含义。 只能重载大多数已有的运算符，无权声明新的运算符号。 重载运算符的优先级和结合律与对应的内置运算符一致。 可以像调用普通函数一样直接调用运算符函数。 12345// equivalent calls to a nonmember operator functiondata1 + data2; // normal expressionoperator+(data1, data2); // equivalent function calldata1 += data2; // expression-based &#x27;&#x27;call&#x27;&#x27;data1.operator+=(data2); // equivalent call to a member operator function 通常情况下，不应该重载逗号,、取地址&amp;、逻辑与&amp;&amp;和逻辑或||运算符。 建议只有当操作的含义对于用户来说清晰明了时才使用重载运算符，重载运算符的返回类型也应该与其内置版本的返回类型兼容。 如果类中含有算术运算符或位运算符，则最好也提供对应的复合赋值运算符。 把运算符定义为成员函数时，它的左侧运算对象必须是运算符所属类型的对象。 123string s = &quot;world&quot;;string t = s + &quot;!&quot;; // ok: we can add a const char* to a stringstring u = &quot;hi&quot; + s; // would be an error if + were a member of string 如何选择将运算符定义为成员函数还是普通函数： 赋值=、下标[]、调用()和成员访问箭头-&gt;运算符必须是成员函数。 复合赋值运算符一般是成员函数，但并非必须。 改变对象状态或者与给定类型密切相关的运算符，如递增、递减、解引用运算符，通常是成员函数。 具有对称性的运算符可能转换任意一端的运算对象，如算术、相等性、关系和位运算符，通常是普通函数。 输入和输出运算符（Input and Output Operators）重载输出运算符&lt;&lt;（Overloading the Output Operator &lt;&lt;）通常情况下，输出运算符的第一个形参是ostream类型的普通引用，第二个形参是要打印类型的常量引用，返回值是它的ostream形参。 123456ostream &amp;operator&lt;&lt;(ostream &amp;os, const Sales_data &amp;item)&#123; os &lt;&lt; item.isbn() &lt;&lt; &quot; &quot; &lt;&lt; item.units_sold &lt;&lt; &quot; &quot; &lt;&lt; item.revenue &lt;&lt; &quot; &quot; &lt;&lt; item.avg_price(); return os;&#125; 输出运算符应该尽量减少格式化操作。 输入输出运算符必须是非成员函数。而由于IO操作通常需要读写类的非公有数据，所以输入输出运算符一般被声明为友元。 重载输入运算符&gt;&gt;（Overloading the Input Operator &gt;&gt;）通常情况下，输入运算符的第一个形参是要读取的流的普通引用，第二个形参是要读入的目的对象的普通引用，返回值是它的第一个形参。 12345678910istream &amp;operator&gt;&gt;(istream &amp;is, Sales_data &amp;item)&#123; double price; // no need to initialize; we&#x27;ll read into price before we use it is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &gt;&gt; price; if (is) // check that the inputs succeeded item.revenue = item.units_sold * price; else item = Sales_data(); // input failed: give the object the default state return is;&#125; 输入运算符必须处理输入失败的情况，而输出运算符不需要。 以下情况可能导致读取操作失败： 读取了错误类型的数据。 读取操作到达文件末尾。 遇到输入流的其他错误。 当读取操作发生错误时，输入操作符应该负责从错误状态中恢复。 如果输入的数据不符合规定的格式，即使从技术上看IO操作是成功的，输入运算符也应该设置流的条件状态以标示出失败信息。通常情况下，输入运算符只设置failbit状态。eofbit、badbit等错误最好由IO标准库自己标示。 算术和关系运算符（Arithmetic and Relational Operators）通常情况下，算术和关系运算符应该定义为非成员函数，以便两侧的运算对象进行转换。其次，由于这些运算符一般不会改变运算对象的状态，所以形参都是常量引用。 算术运算符通常会计算它的两个运算对象并得到一个新值，这个值通常存储在一个局部变量内，操作完成后返回该局部变量的副本作为结果（返回类型建议设置为原对象的const类型）。 1234567// assumes that both objects refer to the same bookSales_data operator+(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; Sales_data sum = lhs; // copy data members from lhs into sum sum += rhs; // add rhs into sum return sum;&#125; 如果类定义了算术运算符，则通常也会定义对应的复合赋值运算符，此时最有效的方式是使用复合赋值来实现算术运算符。 相等运算符（Equality Operators）相等运算符设计准则： 如果类在逻辑上有相等性的含义，则应该定义operator==而非一个普通的命名函数。这样做便于使用标准库容器和算法，也更容易记忆。 通常情况下，operator==应该具有传递性。 如果类定义了operator==，则也应该定义operator!=。 operator==和operator!=中的一个应该把具体工作委托给另一个。 1234567891011bool operator==(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.isbn() == rhs.isbn() &amp;&amp; lhs.units_sold == rhs.units_sold &amp;&amp; lhs.revenue == rhs.revenue;&#125;bool operator!=(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return !(lhs == rhs);&#125; 关系运算符（Relational Operators）定义了相等运算符的类通常也会定义关系运算符。因为关联容器和一些算法要用到小于运算符，所以定义operator&lt;会比较实用。 关系运算符设计准则： 定义顺序关系，令其与关联容器中对关键字的要求保持一致。 如果类定义了operator==，则关系运算符的定义应该与operator==保持一致。特别是，如果两个对象是不相等的，那么其中一个对象应该小于另一个对象。 只有存在唯一一种逻辑可靠的小于关系时，才应该考虑为类定义operator&lt;。 赋值运算符（Assignment Operators）赋值运算符必须定义为成员函数，复合赋值运算符通常也是如此。这两类运算符都应该返回其左侧运算对象的引用。 12345678910111213141516171819StrVec &amp;StrVec::operator=(initializer_list&lt;string&gt; il)&#123; // alloc_n_copy allocates space and copies elements from the given range auto data = alloc_n_copy(il.begin(), il.end()); free(); // destroy the elements in this object and free the space elements = data.first; // update data members to point to the new space first_free = cap = data.second; return *this;&#125;// member binary operator: left-hand operand is bound to the implicit this pointer// assumes that both objects refer to the same bookSales_data&amp; Sales_data::operator+=(const Sales_data &amp;rhs)&#123; units_sold += rhs.units_sold; revenue += rhs.revenue; return *this;&#125; 下标运算符（Subscript Operator）下标运算符必须定义为成员函数。 类通常会定义两个版本的下标运算符：一个返回普通引用，另一个是类的常量成员并返回常量引用。 1234567891011class StrVec&#123;public: std::string&amp; operator[](std::size_t n) &#123; return elements[n]; &#125; const std::string&amp; operator[](std::size_t n) const &#123; return elements[n]; &#125;private: std::string *elements; // pointer to the first element in the array&#125; 递增和递减运算符（Increment and Decrement Operators）定义递增和递减运算符的类应该同时定义前置和后置版本，这些运算符通常定义为成员函数。 为了与内置操作保持一致，前置递增或递减运算符应该返回运算后对象的引用。 123456// prefix: return a reference to the incremented/decremented objectStrBlobPtr&amp; StrBlobPtr::operator++()&#123; ++curr; // advance the current state return *this;&#125; 后置递增或递减运算符接受一个额外的（不被使用）int类型形参，该形参的唯一作用就是区分运算符的前置和后置版本。 123456789class StrBlobPtr&#123;public: // increment and decrement StrBlobPtr&amp; operator++(); // prefix operators StrBlobPtr&amp; operator--(); StrBlobPtr operator++(int); // postfix operators StrBlobPtr operator--(int);&#125;; 为了与内置操作保持一致，后置递增或递减运算符应该返回运算前对象的原值（返回类型建议设置为原对象的const类型）。 123456StrBlobPtr StrBlobPtr::operator++(int)&#123; StrBlobPtr ret = *this; // save the current value ++*this; // advance one element; prefix ++ checks the increment return ret; // return the saved state&#125; 如果想通过函数调用的方式使用后置递增或递减运算符，则必须为它的整型参数传递一个值。 123StrBlobPtr p(a1); // p points to the vector inside a1p.operator++(0); // call postfix operator++p.operator++(); // call prefix operator++ 成员访问运算符（Member Access Operators）箭头运算符必须定义为成员函数，解引用运算符通常也是如此。 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的类的对象。 123456789101112class StrBlobPtr&#123;public: std::string&amp; operator*() const &#123; return (*p)[curr]; // (*p) is the vector to which this object points &#125; std::string* operator-&gt;() const &#123; // delegate the real work to the dereference operator return &amp; this-&gt;operator*(); &#125;&#125;; 对于形如point-&gt;mem的表达式来说，point必须是指向类对象的指针或者是一个重载了operator-&gt;的类的对象。point类型不同，point-&gt;mem的含义也不同。 如果point是指针，则调用内置箭头运算符，表达式等价于(*point).mem。 如果point是重载了operator-&gt;的类的对象，则使用point.operator-&gt;()的结果来获取mem，表达式等价于(point.operator-&gt;())-&gt;mem。其中，如果该结果是一个指针，则执行内置操作，否则重复调用当前操作。 函数调用运算符（Function-Call Operator）函数调用运算符必须定义为成员函数。一个类可以定义多个不同版本的调用运算符，相互之间必须在参数数量或类型上有所区别。 1234567891011121314151617class PrintString&#123;public: PrintString(ostream &amp;o = cout, char c = &#x27; &#x27;): os(o), sep(c) &#123; &#125; void operator()(const string &amp;s) const &#123; os &lt;&lt; s &lt;&lt; sep; &#125;private: ostream &amp;os; // stream on which to write char sep; // character to print after each output&#125;;PrintString printer; // uses the defaults; prints to coutprinter(s); // prints s followed by a space on cout 如果类定义了调用运算符，则该类的对象被称作函数对象（function object），函数对象常常作为泛型算法的实参。 1for_each(vs.begin(), vs.end(), PrintString(cerr, &#x27;\\n&#x27;)); lambda是函数对象（Lambdas Are Function Objects）编写一个lambda后，编译器会将该表达式转换成一个未命名类的未命名对象，类中含有一个重载的函数调用运算符。 12345678910111213// sort words by size, but maintain alphabetical order for words of the same sizestable_sort(words.begin(), words.end(), [](const string &amp;a, const string &amp;b) &#123; return a.size() &lt; b.size(); &#125;);// acts like an unnamed object of a class that would look something likeclass ShorterString&#123;public: bool operator()(const string &amp;s1, const string &amp;s2) const &#123; return s1.size() &lt; s2.size(); &#125;&#125;; lambda默认不能改变它捕获的变量。因此在默认情况下，由lambda产生的类中的函数调用运算符是一个const成员函数。如果lambda被声明为可变的，则调用运算符就不再是const函数了。 lambda通过引用捕获变量时，由程序负责确保lambda执行时该引用所绑定的对象确实存在。因此编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员。相反，通过值捕获的变量被拷贝到lambda中，此时lambda产生的类必须为每个值捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化数据成员。 123456789101112131415161718// get an iterator to the first element whose size() is &gt;= szauto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;);// would generate a class that looks something likeclass SizeComp&#123;public: SizeComp(size_t n): sz(n) &#123; &#125; // parameter for each captured variable // call operator with the same return type, parameters, and body as the lambda bool operator()(const string &amp;s) const &#123; return s.size() &gt;= sz; &#125;private: size_t sz; // a data member for each variable captured by value&#125;; lambda产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数则通常要视捕获的变量类型而定。 标准库定义的函数对象（Library-Defined Function Objects）标准库在头文件functional中定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。这些类都被定义为模板的形式，可以为其指定具体的应用类型（即调用运算符的形参类型）。 关系运算符的函数对象类通常被用来替换算法中的默认运算符，这些类对于指针同样适用。 123456vector&lt;string *&gt; nameTable; // vector of pointers// error: the pointers in nameTable are unrelated, so &lt; is undefinedsort(nameTable.begin(), nameTable.end(), [](string *a, string *b) &#123; return a &lt; b; &#125;);// ok: library guarantees that less on pointer types is well definedsort(nameTable.begin(), nameTable.end(), less&lt;string*&gt;()); 可调用对象与function（Callable Objects and function）调用形式指明了调用返回的类型以及传递给调用的实参类型。不同的可调用对象可能具有相同的调用形式。 标准库function类型是一个模板，定义在头文件functional中，用来表示对象的调用形式。 创建一个具体的function类型时必须提供其所表示的对象的调用形式。 123456789101112131415161718// ordinary functionint add(int i, int j) &#123; return i + j; &#125;// function-object classstruct div&#123; int operator()(int denominator, int divisor) &#123; return denominator / divisor; &#125;&#125;;function&lt;int(int, int)&gt; f1 = add; // function pointerfunction&lt;int(int, int)&gt; f2 = div(); // object of a function-object classfunction&lt;int(int, int)&gt; f3 = [](int i, int j) &#123; return i * j; &#125;; // lambda cout &lt;&lt; f1(4,2) &lt;&lt; endl; // prints 6cout &lt;&lt; f2(4,2) &lt;&lt; endl; // prints 2cout &lt;&lt; f3(4,2) &lt;&lt; endl; // prints 8 不能直接将重载函数的名字存入function类型的对象中，这样做会产生二义性错误。消除二义性的方法是使用lambda或者存储函数指针而非函数名字。 C++11新标准库中的function类与旧版本中的unary_function和binary_function没有关系，后两个类已经被bind函数代替。 重载、类型转换与运算符（Overloading，Conversions，and Operators）转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversion）。 类型转换运算符（Conversion Operators）类型转换运算符是类的一种特殊成员函数，负责将一个类类型的值转换成其他类型。它不能声明返回类型，形参列表也必须为空，一般形式如下： 1operator type() const; 类型转换运算符可以面向除了void以外的任意类型（该类型要能作为函数的返回类型）进行定义。 12345678910111213class SmallInt&#123;public: SmallInt(int i = 0): val(i) &#123; if (i &lt; 0 || i &gt; 255) throw std::out_of_range(&quot;Bad SmallInt value&quot;); &#125; operator int() const &#123; return val; &#125; private: std::size_t val;&#125;; 隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。 1234// the double argument is converted to int using the built-in conversionSmallInt si = 3.14; // calls the SmallInt(int) constructor// the SmallInt conversion operator converts si to int;si + 3.14; // that int is converted to double using the built-in conversion 应该避免过度使用类型转换函数。如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。 C++11引入了显示的类型转换运算符（explicit conversion operator）。和显式构造函数一样，编译器通常不会将显式类型转换运算符用于隐式类型转换。 1234567891011class SmallInt&#123;public: // the compiler won&#x27;t automatically apply this conversion explicit operator int() const &#123; return val; &#125; // other members as before&#125;;SmallInt si = 3; // ok: the SmallInt constructor is not explicitsi + 3; // error: implicit is conversion required, but operator int is explicitstatic_cast&lt;int&gt;(si) + 3; // ok: explicitly request the conversion 如果表达式被用作条件，则编译器会隐式地执行显式类型转换。 if、while、do-while语句的条件部分。 for语句头的条件表达式。 条件运算符? :的条件表达式。 逻辑非运算符!、逻辑或运算符||、逻辑与运算符&amp;&amp;的运算对象。 类类型向bool的类型转换通常用在条件部分，因此operator bool一般被定义为显式的。 避免有二义性的类型转换（Avoiding Ambiguous Conversions）在两种情况下可能产生多重转换路径： A类定义了一个接受B类对象的转换构造函数，同时B类定义了一个转换目标是A类的类型转换运算符。 12345678910111213141516171819// usually a bad idea to have mutual conversions between two class typesstruct B;struct A&#123; A() = default; A(const B&amp;); // converts a B to an A // other members&#125;;struct B&#123; operator A() const; // also converts a B to an A // other members&#125;;A f(const A&amp;);B b;A a = f(b); // error ambiguous: f(B::operator A()) // or f(A::A(const B&amp;)) 类定义了多个类型转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。 123456789101112131415struct A&#123; A(int = 0); // usually a bad idea to have two A(double); // conversions from arithmetic types operator int() const; // usually a bad idea to have two operator double() const; // conversions to arithmetic types // other members&#125;;void f2(long double);A a;f2(a); // error ambiguous: f(A::operator int()) // or f(A::operator double())long lg;A a2(lg); // error ambiguous: A::A(int) or A::A(double) 可以通过显式调用类型转换运算符或转换构造函数解决二义性问题，但不能使用强制类型转换，因为强制类型转换本身也存在二义性。 12A a1 = f(b.operator A()); // ok: use B&#x27;s conversion operatorA a2 = f(A(b)); // ok: use A&#x27;s constructor 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标都是算术类型的转换。 使用两个用户定义的类型转换时，如果转换前后存在标准类型转换，则由标准类型转换决定最佳匹配。 如果在调用重载函数时需要使用构造函数或者强制类型转换来改变实参的类型，通常意味着程序设计存在不足。 调用重载函数时，如果需要额外的标准类型转换，则该转换只有在所有可行函数都请求同一个用户定义类型转换时才有用。如果所需的用户定义类型转换不止一个，即使其中一个调用能精确匹配而另一个调用需要额外的标准类型转换，也会产生二义性错误。 12345678910111213141516struct C&#123; C(int); // other members&#125;;struct E&#123; E(double); // other members&#125;;void manip2(const C&amp;);void manip2(const E&amp;);// error ambiguous: two different user-defined conversions could be usedmanip2(10); // manip2(C(10) or manip2(E(double(10))) 函数匹配与重载运算符（Function Matching and Overloaded Operators）表达式中运算符的候选函数集既包括成员函数，也包括非成员函数。 123456789101112131415class SmallInt&#123; friend SmallInt operator+(const SmallInt&amp;, const SmallInt&amp;); public: SmallInt(int = 0); // conversion from int operator int() const &#123; return val; &#125; // conversion to int private: std::size_t val;&#125;;SmallInt s1, s2;SmallInt s3 = s1 + s2; // uses overloaded operator+int i = s3 + 0; // error: ambiguous 如果类既定义了转换目标是算术类型的类型转换，也定义了重载的运算符，则会遇到重载运算符与内置运算符的二义性问题。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十二章 动态内存","slug":"C++ Primer/C++primer笔记-第十二章-动态内存","date":"2022-03-05T12:25:30.000Z","updated":"2022-06-29T13:22:36.291Z","comments":true,"path":"2022/03/05/C++ Primer/C++primer笔记-第十二章-动态内存/","link":"","permalink":"http://icecorn.github.io/2022/03/05/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/","excerpt":"","text":"第十二章 动态内存程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。 动态内存与智能指针（Dynamic Memory and Smart Pointers）C++中的动态内存管理通过一对运算符完成：new在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；delete接受一个动态对象的指针，销毁该对象并释放与之关联的内存。 新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：shared_ptr允许多个指针指向同一个对象；unique_ptr独占所指向的对象。标准库还定义了一个名为weak_ptr的伴随类，它是一种弱引用，指向shared_ptr所管理的对象。这三种类型都定义在头文件memory中。 shared_ptr类（The shared_ptr Class）智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。 12shared_ptr&lt;string&gt; p1; // shared_ptr that can point at a stringshared_ptr&lt;list&lt;int&gt;&gt; p2; // shared_ptr that can point at a list of ints shared_ptr和unique_ptr都支持的操作： shared_ptr独有的操作： make_shared函数（定义在头文件memory中）在动态内存中分配一个对象并初始化它，返回指向此对象的shared_ptr。 123456// shared_ptr that points to an int with value 42shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);// p4 points to a string with value 9999999999shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, &#x27;9&#x27;);// p5 points to an int that is value initializedshared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;(); 进行拷贝或赋值操作时，每个shared_ptr会记录有多少个其他shared_ptr与其指向相同的对象。 123auto p = make_shared&lt;int&gt;(42); // object to which p points has one userauto q(p); // p and q point to the same object // object to which p and q point has two users 每个shared_ptr都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝shared_ptr时引用计数会递增。例如使用一个shared_ptr初始化另一个shared_ptr，或将它作为参数传递给函数以及作为函数的返回值返回。给shared_ptr赋予新值或shared_ptr被销毁时引用计数会递减。例如一个局部shared_ptr离开其作用域。一旦一个shared_ptr的引用计数变为0，它就会自动释放其所管理的对象。 12345auto r = make_shared&lt;int&gt;(42); // int to which r points has one userr = q; // assign to r, making it point to a different address // increase the use count for the object to which q points // reduce the use count of the object to which r had pointed // the object r had pointed to has no users; that object is automatically freed shared_ptr的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，shared_ptr的析构函数会销毁对象并释放空间。 如果将shared_ptr存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用erase删除不再需要的元素。 程序使用动态内存通常出于以下三种原因之一： 不确定需要使用多少对象。 不确定所需对象的准确类型。 需要在多个对象间共享数据。 shared_ptr和new结合使用（Using shared_ptrs with new）可以用new返回的指针初始化智能指针。该构造函数是explicit的，因此必须使用直接初始化形式。 12shared_ptr&lt;int&gt; p1 = new int(1024); // error: must use direct initializationshared_ptr&lt;int&gt; p2(new int(1024)); // ok: uses direct initialization 默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用delete释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替delete。 不要混合使用内置指针和智能指针。当将shared_ptr绑定到内置指针后，资源管理就应该交由shared_ptr负责。不应该再使用内置指针访问shared_ptr指向的内存。 1234567891011121314// ptr is created and initialized when process is calledvoid process(shared_ptr&lt;int&gt; ptr)&#123; // use ptr&#125; // ptr goes out of scope and is destroyedint *x(new int(1024)); // dangerous: x is a plain pointer, not a smart pointerprocess(x); // error: cannot convert int* to shared_ptr&lt;int&gt;process(shared_ptr&lt;int&gt;(x)); // legal, but the memory will be deleted!int j = *x; // undefined: x is a dangling pointer!shared_ptr&lt;int&gt; p(new int(42)); // reference count is 1process(p); // copying p increments its count; in process the reference count is 2int i = *p; // ok: reference count is 1 智能指针的get函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用get返回指针的代码不能delete此指针。 不要使用get初始化另一个智能指针或为智能指针赋值。 1234567shared_ptr&lt;int&gt; p(new int(42)); // reference count is 1int *q = p.get(); // ok: but don&#x27;t use q in any way that might delete its pointer&#123; // new block // undefined: two independent shared_ptrs point to the same memory shared_ptr&lt;int&gt;(q);&#125; // block ends, q is destroyed, and the memory to which q points is freedint foo = *p; // undefined; the memory to which p points was freed 可以用reset函数将新的指针赋予shared_ptr。与赋值类似，reset会更新引用计数，如果需要的话，还会释放内存空间。reset经常与unique一起使用，来控制多个shared_ptr共享的对象。 123if (!p.unique()) p.reset(new string(*p)); // we aren&#x27;t alone; allocate a new copy*p += newVal; // now that we know we&#x27;re the only pointer, okay to change this object 智能指针和异常（Smart Pointers and Exceptions）如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。 123456789101112void f()&#123; int *ip = new int(42); // dynamically allocate a new object // code that throws an exception that is not caught inside f delete ip; // free the memory before exiting&#125;void f()&#123; shared_ptr&lt;int&gt; sp(new int(42)); // allocate a new object // code that throws an exception that is not caught inside f&#125; // shared_ptr freed automatically when the function ends 默认情况下shared_ptr假定其指向动态内存，使用delete释放对象。创建shared_ptr时可以传递一个（可选）指向删除函数的指针参数，用来代替delete。 12345678910111213141516struct destination; // represents what we are connecting tostruct connection; // information needed to use the connectionconnection connect(destination*); // open the connectionvoid disconnect(connection); // close the given connectionvoid end_connection(connection *p)&#123; disconnect(*p);&#125;void f(destination &amp;d /* other parameters */)&#123; connection c = connect(&amp;d); shared_ptr&lt;connection&gt; p(&amp;c, end_connection); // use the connection // when f exits, even if by an exception, the connection will be properly closed&#125; 智能指针规范： 不使用相同的内置指针值初始化或reset多个智能指针。 不释放get返回的指针。 不使用get初始化或reset另一个智能指针。 使用get返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。 使用shared_ptr管理并非new分配的资源时，应该传递删除函数。 深度理解智能指针1.智能指针的作用 ​ C++程序设计中使用堆内存是非常频繁的操作，堆内存的申请和释放都由程序员自己管理。程序员自己管理堆内存可以提高了程序的效率，但是整体来说堆内存的管理是麻烦的，C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。 理解智能指针需要从下面三个层次： 从较浅的层面看，智能指针是利用了一种叫做RAII（资源获取即初始化）的技术对普通的指针进行封装，这使得智能指针实质是一个对象，行为表现的却像一个指针。 智能指针的作用是防止忘记调用delete释放内存和程序异常的进入catch块忘记释放内存。另外指针的释放时机也是非常有考究的，多次释放同一个指针会造成程序崩溃，这些都可以通过智能指针来解决。 智能指针还有一个作用是把值语义转换成引用语义。C++和Java有一处最大的区别在于语义不同，在Java里面下列代码： 12 Animal a = new Animal(); Animal b = a; 你当然知道，这里其实只生成了一个对象，a和b仅仅是把持对象的引用而已。但在C++中不是这样， 12Animal a;Animal b = a; 这里却是就是生成了两个对象。 2.智能指针的实质 前面已经说过了，智能指针是一个类对象（类似迭代器，其实也是用类对象来模拟指针的作用），这样在被调函数执行完，程序过期时，对象将会被删除（对象的名字保存在栈变量中），这样不仅对象会被删除，它指向的内存也会被删除的。 智能指针在C++11版本之后提供，包含在头文件中，shared_ptr、unique_ptr、auto_ptr 建议： ​ 1-每种指针都有不同的使用范围，unique_ptr指针优于其它两种类型，除非对象需要共享时用shared_ptr。 ​ 2- 建议– 如果你没有打算在多个线程之间来共享资源的话，那么就请使用unique_ptr。 ​ 3 -建议- 使用make_shared而不是裸指针来初始化共享指针。 ​ 4 -建议 – 在设计类的时候，当不需要资源的所有权，而且你不想指定这个对象的生命周期时，可以考虑使用weak_ptr代替shared_ptr。 使用智能指针的时候，只需要将new出的地址值赋值给这种对象，也就是将new出的地址作为实参！ 总结：智能指针其实就是类对象，来模拟指针的效果，从而实现更安全的管理内存的操作，实现了自动释放内存等功能。智能指针分类，最简单实用的是unique_ptr,如果要多个指针指向同一个对象的话，要使用shared_ptr，同时因为多个指针操作一个对象，一定会带来多线程那种读写脏数据的问题，这时候就要加锁，而这里加锁的方式就是通过使用weak_ptr的lock()函数来进行的。而对于shared_ptr的数据结构，其实就是里边有一个count计数的类，并且重载了&gt;和*以及=等操作，并且根据实际需要实现维护count和释放内存的操作。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第十一章-关联容器","slug":"C++ Primer/C++primer笔记-第十一章-关联容器","date":"2022-03-02T12:25:30.000Z","updated":"2022-06-29T13:11:59.278Z","comments":true,"path":"2022/03/02/C++ Primer/C++primer笔记-第十一章-关联容器/","link":"","permalink":"http://icecorn.github.io/2022/03/02/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/","excerpt":"","text":"第11章 关联容器关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是map和set。 map中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。 set中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在set中。 标准库提供了8个关联容器，它们之间的不同体现在三个方面： 是map还是set类型。 是否允许保存重复的关键字。 是否按顺序保存元素。 允许重复保存关键字的容器名字都包含单词multi；无序保存元素的容器名字都以单词unordered开头。 map和multimap类型定义在头文件map中；set和multiset类型定义在头文件set中；无序容器定义在头文件unordered_map和unordered_set中。 使用关联容器（Using an Associative Container）map类型通常被称为关联数组（associative array）。 从map中提取一个元素时，会得到一个pair类型的对象。pair是一个模板类型，保存两个名为first和second的公有数据成员。map所使用的pair用first成员保存关键字，用second成员保存对应的值。 123456789// count the number of times each word occurs in the inputmap&lt;string, size_t&gt; word_count; // empty map from string to size_tstring word;while (cin &gt;&gt; word) ++word_count[word]; // fetch and increment the counter for wordfor (const auto &amp;w : word_count) // for each element in the map // print the results cout &lt;&lt; w.first &lt;&lt; &quot; occurs &quot; &lt;&lt; w.second &lt;&lt; ((w.second &gt; 1) ? &quot; times&quot; : &quot; time&quot;) &lt;&lt; endl; set类型的find成员返回一个迭代器。如果给定关键字在set中，则迭代器指向该关键字，否则返回的是尾后迭代器。 关联容器概述（Overview of the Associative Containers）定义关联容器（Defining an Associative Container）定义map时，必须指定关键字类型和值类型；定义set时，只需指定关键字类型。 初始化map时，提供的每个键值对用花括号&#123;&#125;包围。 12345678910map&lt;string, size_t&gt; word_count; // empty// list initializationset&lt;string&gt; exclude = &#123; &quot;the&quot;, &quot;but&quot;, &quot;and&quot; &#125;;// three elements; authors maps last name to firstmap&lt;string, string&gt; authors =&#123; &#123;&quot;Joyce&quot;, &quot;James&quot;&#125;, &#123;&quot;Austen&quot;, &quot;Jane&quot;&#125;, &#123;&quot;Dickens&quot;, &quot;Charles&quot;&#125;&#125;; map和set中的关键字必须唯一，multimap和multiset没有此限制。 关键字类型的要求（Requirements on Key Type）对于有序容器——map、multimap、set和multiset，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的&lt;运算符来进行比较操作。 用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。 12345678bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs)&#123; return lhs.isbn() &lt; rhs.isbn();&#125;// bookstore can have several transactions with the same ISBN// elements in bookstore will be in ISBN ordermultiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn); pair类型（The pair Type）pair定义在头文件utility中。一个pair可以保存两个数据成员，分别命名为first和second。 123pair&lt;string, string&gt; anon; // holds two stringspair&lt;string, size_t&gt; word_count; // holds a string and an size_tpair&lt;string, vector&lt;int&gt;&gt; line; // holds string and vector&lt;int&gt; pair的默认构造函数对数据成员进行值初始化。 pair支持的操作： 在C++11中，如果函数需要返回pair，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。 12345678910pair&lt;string, int&gt; process(vector&lt;string&gt; &amp;v)&#123; // process v if (!v.empty()) // list initialize return &#123; v.back(), v.back().size() &#125;; else // explicitly constructed return value return pair&lt;string, int&gt;();&#125; 关联容器操作（Operations on Associative Containers）关联容器定义了类型别名来表示容器关键字和值的类型： 对于set类型，key_type和value_type是一样的。set中保存的值就是关键字。对于map类型，元素是关键字-值对。即每个元素是一个pair对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此pair的关键字部分是const的。另外，只有map类型（unordered_map、unordered_multimap、multimap、map）才定义了mapped_type。 12345set&lt;string&gt;::value_type v1; // v1 is a stringset&lt;string&gt;::key_type v2; // v2 is a stringmap&lt;string, int&gt;::value_type v3; // v3 is a pair&lt;const string, int&gt;map&lt;string, int&gt;::key_type v4; // v4 is a stringmap&lt;string, int&gt;::mapped_type v5; // v5 is an int 关联容器迭代器（Associative Container Iterators）解引用关联容器迭代器时，会得到一个类型为容器的value_type的引用。对map而言，value_type是pair类型，其first成员保存const的关键字，second成员保存值。 1234567// get an iterator to an element in word_countauto map_it = word_count.begin();// *map_it is a reference to a pair&lt;const string, size_t&gt; objectcout &lt;&lt; map_it-&gt;first; // prints the key for this elementcout &lt;&lt; &quot; &quot; &lt;&lt; map_it-&gt;second; // prints the value of the elementmap_it-&gt;first = &quot;new key&quot;; // error: key is const++map_it-&gt;second; // ok: we can change the value through an iterator 虽然set同时定义了iterator和const_iterator类型，但两种迭代器都只允许只读访问set中的元素。类似map，set中的关键字也是const的。 1234567set&lt;int&gt; iset = &#123;0,1,2,3,4,5,6,7,8,9&#125;;set&lt;int&gt;::iterator set_it = iset.begin();if (set_it != iset.end())&#123; *set_it = 42; // error: keys in a set are read-only cout &lt;&lt; *set_it &lt;&lt; endl; // ok: can read the key&#125; map和set都支持begin和end操作。使用迭代器遍历map、multimap、set或multiset时，迭代器按关键字升序遍历元素。 通常不对关联容器使用泛型算法。 添加元素（Adding Elements）使用insert成员可以向关联容器中添加元素。向map和set中添加已存在的元素对容器没有影响。 通常情况下，对于想要添加到map中的数据，并没有现成的pair对象。可以直接在insert的参数列表中创建pair。 12345// four ways to add word to word_countword_count.insert(&#123;word, 1&#125;);word_count.insert(make_pair(word, 1));word_count.insert(pair&lt;string, size_t&gt;(word, 1));word_count.insert(map&lt;string, size_t&gt;::value_type(word, 1)); 关联容器的insert操作： insert或emplace的返回值依赖于容器类型和参数： 对于不包含重复关键字的容器，添加单一元素的insert和emplace版本返回一个pair，表示操作是否成功。pair的first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值。如果关键字已在容器中，则insert直接返回，bool值为false。如果关键字不存在，元素会被添加至容器中，bool值为true。 对于允许包含重复关键字的容器，添加单一元素的insert和emplace版本返回指向新元素的迭代器。 删除元素（Erasing Elements）关联容器的删除操作： 与顺序容器不同，关联容器提供了一个额外的erase操作。它接受一个key_type参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，erase的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。 map的下标操作（Subscripting a map）map下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。 由于下标运算符可能向容器中添加元素，所以只能对非const的map使用下标操作。 对map进行下标操作时，返回的是mapped_type类型的对象；解引用map迭代器时，返回的是value_type类型的对象。 访问元素（Accessing Elements）关联容器的查找操作： 如果multimap或multiset中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。 12345678910111213141516multimap&lt;string, string&gt; authors;// adds the first element with the key Barth, Johnauthors.insert(&#123;&quot;Barth, John&quot;, &quot;Sot-Weed Factor&quot;&#125;);// ok: adds the second element with the key Barth, Johnauthors.insert(&#123;&quot;Barth, John&quot;, &quot;Lost in the Funhouse&quot;&#125;);string search_item(&quot;Alain de Botton&quot;); // author we&#x27;ll look forauto entries = authors.count(search_item); // number of elementsauto iter = authors.find(search_item); // first entry for this author// loop through the number of entries there are for this authorwhile(entries)&#123; cout &lt;&lt; iter-&gt;second &lt;&lt; endl; // print each title ++iter; // advance to the next title --entries; // keep track of how many we&#x27;ve printed&#125; lower_bound和upper_bound操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，lower_bound返回的迭代器会指向第一个匹配给定关键字的元素，而upper_bound返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在multimap中，则lower_bound和upper_bound会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用lower_bound和upper_bound会得到一个迭代器范围，表示所有具有该关键字的元素范围。 123456// definitions of authors and search_item as above// beg and end denote the range of elements for this authorfor (auto beg = authors.lower_bound(search_item), end = authors.upper_bound(search_item); beg != end; ++beg) cout &lt;&lt; beg-&gt;second &lt;&lt; endl; // print each title lower_bound和upper_bound有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则upper_bound返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则lower_bound也返回尾后迭代器。 equal_range操作接受一个关键字，返回一个迭代器pair。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。 12345// definitions of authors and search_item as above// pos holds iterators that denote the range of elements for this keyfor (auto pos = authors.equal_range(search_item); pos.first != pos.second; ++pos.first) cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl; // print each title 无序容器（The Unordered Containers）新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的==运算符组织元素。 无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。 无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。 无序容器管理操作： 默认情况下，无序容器使用关键字类型的==运算符比较元素，还使用一个hash&lt;key_type&gt;类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第九章-顺序容器","slug":"C++ Primer/C++primer笔记-第九章-顺序容器","date":"2022-02-28T12:25:30.000Z","updated":"2022-06-29T13:08:35.617Z","comments":true,"path":"2022/02/28/C++ Primer/C++primer笔记-第九章-顺序容器/","link":"","permalink":"http://icecorn.github.io/2022/02/28/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/","excerpt":"","text":"第9章 顺序容器顺序容器概述（Overview of the Sequential Containers）顺序容器类型： 类型 特性 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入/删除元素可能很慢 deque 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快 list 双向链表。只支持双向顺序访问。在任何位置插入/删除速度都很快 forward_list 单向链表。只支持单向顺序访问。在任何位置插入/删除速度都很快 array 固定大小数组。支持快速随机访问。不能添加/删除元素 string 类似vector，但用于保存字符。支持快速随机访问。在尾部插入/删除速度很快 forward_list和array是C++11新增类型。与内置数组相比，array更安全易用。forward_list没有size操作。 容器选择原则： 除非有合适的理由选择其他容器，否则应该使用vector。 如果程序有很多小的元素，且空间的额外开销很重要，则不要使用list或forward_list。 如果程序要求随机访问容器元素，则应该使用vector或deque。 如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用deque。 如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则： 先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向vector追加数据，再调用标准库的sort函数重排元素，从而避免在中间位置添加元素。 如果必须在中间位置插入元素，可以在输入阶段使用list。输入完成后将list中的内容拷贝到vector中。 不确定应该使用哪种容器时，可以先只使用vector和list的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择vector或list都很方便。 容器库概览（Container Library Overview）每个容器都定义在一个头文件中，文件名与类型名相同。容器均为模板类型。 迭代器（Iterators）forward_list类型不支持递减运算符--。 一个迭代器范围（iterator range）由一对迭代器表示。这两个迭代器通常被称为begin和end，分别指向同一个容器中的元素或尾后地址。end迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为[begin，end）。迭代器begin和end必须指向相同的容器，end可以与begin指向相同的位置，但不能指向begin之前的位置（由程序员确保）。 假定begin和end构成一个合法的迭代器范围，则： 如果begin等于end，则范围为空。 如果begin不等于end，则范围内至少包含一个元素，且begin指向该范围内的第一个元素。 可以递增begin若干次，令begin等于end。 12345while (begin != end)&#123; *begin = val; // ok: range isn&#x27;t empty so begin denotes an element ++begin; // advance the iterator to get the next element&#125; 容器类型成员（Container Type Members）通过类型别名，可以在不了解容器元素类型的情况下使用元素。如果需要元素类型，可以使用容器的value_type。如果需要元素类型的引用，可以使用reference或const_reference。 begin和end成员（begin and end Members）begin和end操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。 begin和end操作有多个版本：带r的版本返回反向迭代器。以c开头的版本（C++11新增）返回const迭代器。不以c开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对const对象调用时，返回const迭代器。 12345list&lt;string&gt; a = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;auto it1 = a.begin(); // list&lt;string&gt;::iteratorauto it2 = a.rbegin(); // list&lt;string&gt;::reverse_iteratorauto it3 = a.cbegin(); // list&lt;string&gt;::const_iteratorauto it4 = a.crbegin(); // list&lt;string&gt;::const_reverse_iterator 当auto与begin或end结合使用时，返回的迭代器类型依赖于容器类型。但调用以c开头的版本仍然可以获得const迭代器，与容器是否是常量无关。 当程序不需要写操作时，应该使用cbegin和cend。 容器定义和初始化（Defining and Initializing a Container）容器定义和初始化方式： 将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。 传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换。 12345678// each container has three elements, initialized from the given initializerslist&lt;string&gt; authors = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;vector&lt;const char*&gt; articles = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;;list&lt;string&gt; list2(authors); // ok: types matchdeque&lt;string&gt; authList(authors); // error: container types don&#x27;t matchvector&lt;string&gt; words(articles); // error: element types must match// ok: converts const char* elements to stringforward_list&lt;string&gt; words(articles.begin(), articles.end()); C++11允许对容器进行列表初始化。 123// each container has three elements, initialized from the given initializerslist&lt;string&gt; authors = &#123;&quot;Milton&quot;, &quot;Shakespeare&quot;, &quot;Austen&quot;&#125;;vector&lt;const char*&gt; articles = &#123;&quot;a&quot;, &quot;an&quot;, &quot;the&quot;&#125;; 定义和使用array类型时，需要同时指定元素类型和容器大小。 1234array&lt;int, 42&gt; // type is: array that holds 42 intsarray&lt;string, 10&gt; // type is: array that holds 10 stringsarray&lt;int, 10&gt;::size_type i; // array type includes element type and sizearray&lt;int&gt;::size_type j; // error: array&lt;int&gt; is not a type 对array进行列表初始化时，初始值的数量不能大于array的大小。如果初始值的数量小于array的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。 可以对array进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。 赋值和swap（Assignment and swap）容器赋值操作： 赋值运算符两侧的运算对象必须类型相同。assign允许用不同但相容的类型赋值，或者用容器的子序列赋值。 12345list&lt;string&gt; names;vector&lt;const char*&gt; oldstyle;names = oldstyle; // error: container types don&#x27;t match// ok: can convert from const char*to stringnames.assign(oldstyle.cbegin(), oldstyle.cend()); 由于其旧元素被替换，因此传递给assign的迭代器不能指向调用assign的容器本身。 swap交换两个相同类型容器的内容。除array外，swap不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此可以保证快速完成。 123vector&lt;string&gt; svec1(10); // vector with ten elementsvector&lt;string&gt; svec2(24); // vector with 24 elementsswap(svec1, svec2); 赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而swap操作交换容器内容，不会导致迭代器、引用和指针失效（array和string除外）。 对于array，swap会真正交换它们的元素。因此在swap操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。 12345678910array&lt;int, 3&gt; a = &#123; 1, 2, 3 &#125;;array&lt;int, 3&gt; b = &#123; 4, 5, 6 &#125;;auto p = a.cbegin(), q = a.cend();a.swap(b);// 输出交换后的值，即4、5、6while (p != q)&#123; cout &lt;&lt; *p &lt;&lt; endl; ++p;&#125; 对于其他容器类型（除string），指针、引用和迭代器在swap操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。 12345678910vector&lt;int&gt; a = &#123; 1, 2, 3 &#125;;vector&lt;int&gt; b = &#123; 4, 5, 6 &#125;;auto p = a.cbegin(), q = a.cend();a.swap(b);// 输出交换前的值，即1、2、3while (p != q)&#123; cout &lt;&lt; *p &lt;&lt; endl; ++p;&#125; array不支持assign，也不允许用花括号列表进行赋值。 1234array&lt;int, 10&gt; a1 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;array&lt;int, 10&gt; a2 = &#123;0&#125;; // elements all have value 0a1 = a2; // replaces elements in a1a2 = &#123;0&#125;; // error: cannot assign to an array from a braced list 新标准库同时提供了成员和非成员函数版本的swap。非成员版本的swap在泛型编程中非常重要，建议统一使用非成员版本的swap。 容器大小操作（Container Size Operations）size成员返回容器中元素的数量；empty当size为0时返回true，否则返回false；max_size返回一个大于或等于该类型容器所能容纳的最大元素数量的值。forward_list支持max_size和empty，但不支持size。 关系运算符（Relational Operators）每个容器类型都支持相等运算符（==、!=）。除无序关联容器外，其他容器都支持关系运算符（&gt;、&gt;=、&lt;、&lt;=）。关系运算符两侧的容器类型和保存元素类型都必须相同。 两个容器的比较实际上是元素的逐对比较，其工作方式与string的关系运算符类似： 如果两个容器大小相同且所有元素对应相等，则这两个容器相等。 如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。 如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。 12345678vector&lt;int&gt; v1 = &#123; 1, 3, 5, 7, 9, 12 &#125;;vector&lt;int&gt; v2 = &#123; 1, 3, 9 &#125;;vector&lt;int&gt; v3 = &#123; 1, 3, 5, 7 &#125;;vector&lt;int&gt; v4 = &#123; 1, 3, 5, 7, 9, 12 &#125;;v1 &lt; v2 // true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]v1 &lt; v3 // false; all elements are equal, but v3 has fewer of them;v1 == v4 // true; each element is equal and v1 and v4 have the same size()v1 == v2 // false; v2 has fewer elements than v1 容器的相等运算符实际上是使用元素的==运算符实现的，而其他关系运算符则是使用元素的&lt;运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。 顺序容器操作（Sequential Container Operations）向顺序容器添加元素（Adding Elements to a Sequential Container）除array外，所有标准库容器都提供灵活的内存管理，在运行时可以动态添加或删除元素。 push_back将一个元素追加到容器尾部，push_front将元素插入容器头部。 1234// read from standard input, putting each word onto the end of containerstring word;while (cin &gt;&gt; word) container.push_back(word); insert将元素插入到迭代器指定的位置之前。一些不支持push_front的容器可以使用insert将元素插入开始位置。 1234567vector&lt;string&gt; svec;list&lt;string&gt; slist;// equivalent to calling slist.push_front(&quot;Hello!&quot;);slist.insert(slist.begin(), &quot;Hello!&quot;);// no push_front on vector but we can insert before begin()// warning: inserting anywhere but at the end of a vector might be slowsvec.insert(svec.begin(), &quot;Hello!&quot;); 将元素插入到vector、deque或string的任何位置都是合法的，但可能会很耗时。 在新标准库中，接受元素个数或范围的insert版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回void。如果范围为空，不插入任何元素，insert会返回第一个参数。 1234list&lt;string&gt; 1st;auto iter = 1st.begin();while (cin &gt;&gt; word) iter = 1st.insert(iter, word); // same as calling push_front 新标准库增加了三个直接构造而不是拷贝元素的操作：emplace_front、emplace_back和emplace，其分别对应push_front、push_back和insert。当调用push或insert时，元素对象被拷贝到容器中。而调用emplace时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。 1234567// construct a Sales_data object at the end of c// uses the three-argument Sales_data constructorc.emplace_back(&quot;978-0590353403&quot;, 25, 15.99);// error: there is no version of push_back that takes three argumentsc.push_back(&quot;978-0590353403&quot;, 25, 15.99);// ok: we create a temporary Sales_data object to pass to push_backc.push_back(Sales_data(&quot;978-0590353403&quot;, 25, 15.99)); 传递给emplace的参数必须与元素类型的构造函数相匹配。 forward_list有特殊版本的insert和emplace操作，且不支持push_back和emplace_back。vector和string不支持push_front和emplace_front。 访问元素（Accessing Elements）每个顺序容器都有一个front成员函数，而除了forward_list之外的顺序容器还有一个back成员函数。这两个操作分别返回首元素和尾元素的引用。 在调用front和back之前，要确保容器非空。 顺序容器的元素访问操作： 在容器中访问元素的成员函数都返回引用类型。如果容器是const对象，则返回const引用，否则返回普通引用。 可以快速随机访问的容器（string、vector、deque和array）都提供下标运算符。保证下标有效是程序员的责任。如果希望确保下标合法，可以使用at成员函数。at类似下标运算，但如果下标越界，at会抛出out_of_range异常。 123vector&lt;string&gt; svec; // empty vectorcout &lt;&lt; svec[0]; // run-time error: there are no elements in svec!cout &lt;&lt; svec.at(0); // throws an out_of_range exception 删除元素（Erasing Elements）顺序容器的元素删除操作： 删除deque中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除vector或string的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。 删除元素前，程序员必须确保目标元素存在。 pop_front和pop_back函数分别删除首元素和尾元素。vector和string类型不支持pop_front，forward_list类型不支持pop_back。 erase函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的erase都返回指向删除元素（最后一个）之后位置的迭代器。 123// delete the range of elements between two iterators// returns an iterator to the element just after the last removed elementelem1 = slist.erase(elem1, elem2); // after the call elem1 == elem2 clear函数删除容器内的所有元素。 特殊的forward_list操作（Specialized forward_list Operations）在forward_list中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。 forward_list的插入和删除操作： 改变容器大小（Resizing a Container）顺序容器的大小操作： resize函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且resize向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。 容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。 向容器中添加元素后： 如果容器是vector或string类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。 如果容器是deque类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。 如果容器是list或forward_list类型，指向容器的迭代器、指针和引用仍然有效。 从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效： 如果容器是list或forward_list类型，指向容器其他位置的迭代器、指针和引用仍然有效。 如果容器是deque类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。 如果容器是vector或string类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。 必须保证在每次改变容器后都正确地重新定位迭代器。 不要保存end函数返回的迭代器。 12345678// safer: recalculate end on each trip whenever the loop adds/erases elementswhile (begin != v.end())&#123; // do some processing ++begin; // advance begin because we want to insert after this element begin = v.insert(begin, 42); // insert the new value ++begin; // advance begin past the element we just added&#125; vector对象是如何增长的（How a vector Grows）vector和string的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多新元素。 容器大小管理操作： capacity函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。reserve函数告知容器应该准备保存多少元素，它并不改变容器中元素的数量，仅影响容器预先分配的内存空间大小。 只有当需要的内存空间超过当前容量时，reserve才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，reserve并不会退回内存空间。因此在调用reserve之后，capacity会大于或等于传递给reserve的参数。 在C++11中可以使用shrink_to_fit函数来要求deque、vector和string退回不需要的内存空间（并不保证退回）。 额外的string操作（Additional string Operations）构造string的其他方法（Other Ways to Construct strings）构造string的其他方法： 从另一个string对象拷贝字符构造string时，如果提供的拷贝开始位置（可选）大于给定string的大小，则构造函数会抛出out_of_range异常。 子字符串操作： 如果传递给substr函数的开始位置超过string的大小，则函数会抛出out_of_range异常。 改变string的其他方法（Other Ways to Change a string）修改string的操作： append函数是在string末尾进行插入操作的简写形式。 123string s(&quot;C++ Primer&quot;), s2 = s; // initialize s and s2 to &quot;C++ Primer&quot;s.insert(s.size(), &quot; 4th Ed.&quot;); // s == &quot;C++ Primer 4th Ed.&quot;s2.append(&quot; 4th Ed.&quot;); // equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2 replace函数是调用erase和insert函数的简写形式。 12345// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;s.erase(11, 3); // s == &quot;C++ Primer Ed.&quot;s.insert(11, &quot;5th&quot;); // s == &quot;C++ Primer 5th Ed.&quot;// starting at position 11, erase three characters and then insert &quot;5th&quot;s2.replace(11, 3, &quot;5th&quot;); // equivalent: s == s2 string搜索操作（string Search Operations）string的每个搜索操作都返回一个string::size_type值，表示匹配位置的下标。如果搜索失败，则返回一个名为string::npos的static成员。标准库将npos定义为const string::size_type类型，并初始化为-1。 不建议用int或其他带符号类型来保存string搜索函数的返回值。 string搜索操作： compare函数（The compare Functions）string类型提供了一组compare函数进行字符串比较操作，类似C标准库的strcmp函数。 compare函数的几种参数形式： 数值转换（Numeric Conversions）C++11增加了string和数值之间的转换函数： 进行数值转换时，string参数的第一个非空白字符必须是符号（+或-）或数字。它可以以0x或0X开头来表示十六进制数。对于转换目标是浮点值的函数，string参数也可以以小数点开头，并可以包含e或E来表示指数部分。 如果给定的string不能转换为一个数值，则转换函数会抛出invalid_argument异常。如果转换得到的数值无法用任何类型表示，则抛出out_of_range异常。 容器适配器（Container Adaptors）标准库定义了stack、queue和priority_queue三种容器适配器。容器适配器可以改变已有容器的工作机制。 所有容器适配器都支持的操作和类型： 默认情况下，stack和queue是基于deque实现的，priority_queue是基于vector实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。 1234// empty stack implemented on top of vectorstack&lt;string, vector&lt;string&gt;&gt; str_stk;// str_stk2 is implemented on top of vector and initially holds a copy of svecstack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec); 所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在array上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用forward_list构造适配器。 栈适配器stack定义在头文件stack中，其支持的操作如下： 队列适配器queue和priority_queue定义在头文件queue中，其支持的操作如下： queue使用先进先出（first-in，first-out，FIFO）的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第八章-IO库","slug":"C++ Primer/C++primer笔记-第八章-IO库","date":"2022-02-26T12:25:30.000Z","updated":"2022-06-29T13:04:00.943Z","comments":true,"path":"2022/02/26/C++ Primer/C++primer笔记-第八章-IO库/","link":"","permalink":"http://icecorn.github.io/2022/02/26/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AB%E7%AB%A0-IO%E5%BA%93/","excerpt":"","text":"第8章 IO库部分IO库设施： istream：输入流类型，提供输入操作。 ostream：输出流类型，提供输出操作。 cin：istream对象，从标准输入读取数据。 cout：ostream对象，向标准输出写入数据。 cerr：ostream对象，向标准错误写入数据。 &gt;&gt;运算符：从istream对象读取输入数据。 &lt;&lt;运算符：向ostream对象写入输出数据。 getline函数：从istream对象读取一行数据，写入string对象。 IO类（The IO Classes）头文件iostream定义了用于读写流的基本类型，fstream定义了读写命名文件的类型，sstream定义了读写内存中string对象的类型。 宽字符版本的IO类型和函数的名字以w开始，如wcin、wcout和wcerr分别对应cin、cout和cerr。它们与其对应的普通char版本都定义在同一个头文件中，如头文件fstream定义了ifstream和wifstream类型。 可以将派生类的对象当作其基类的对象使用。 IO象无拷贝或赋值（No Copy or Assign for IO Objects）不能拷贝或对IO对象赋值。 1234ofstream out1, out2;out1 = out2; // error: cannot assign stream objectsofstream print(ofstream); // error: can&#x27;t initialize the ofstream parameterout2 = print(out2); // error: cannot copy stream objects 由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以引用方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的。 条件状态（Condition States）IO库条件状态： badbit表示系统级错误，如不可恢复的读写错误。通常情况下，一旦badbit被置位，流就无法继续使用了。在发生可恢复错误后，failbit会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，eofbit和failbit都会被置位。如果流未发生错误，则goodbit的值为0。如果badbit、failbit和eofbit任何一个被置位，检测流状态的条件都会失败。 12while (cin &gt;&gt; word) // ok: read operation successful... good函数在所有错误均未置位时返回true。而bad、fail和eof函数在对应错误位被置位时返回true。此外，在badbit被置位时，fail函数也会返回true。因此应该使用good或fail函数确定流的总体状态，eof和bad只能检测特定错误。 流对象的rdstate成员返回一个iostate值，表示流的当前状态。setstate成员用于将指定条件置位（叠加原始流状态）。clear成员的无参版本清除所有错误标志；含参版本接受一个iostate值，用于设置流的新状态（覆盖原始流状态）。 12345// remember the current state of cinauto old_state = cin.rdstate(); // remember the current state of cincin.clear(); // make cin validprocess_input(cin); // use cincin.setstate(old_state); // now reset cin to its old state 管理输出缓冲（Managing the Output Buffer）每个输出流都管理一个缓冲区，用于保存程序读写的数据。导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多： 程序正常结束。 缓冲区已满。 使用操纵符（如endl）显式刷新缓冲区。 在每个输出操作之后，可以用unitbuf操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的。 一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，cin和cerr都关联到cout，因此，读cin或写cerr都会刷新cout的缓冲区。 flush操纵符刷新缓冲区，但不输出任何额外字符。ends向缓冲区插入一个空字符，然后刷新缓冲区。 123cout &lt;&lt; &quot;hi!&quot; &lt;&lt; endl; // writes hi and a newline, then flushes the buffercout &lt;&lt; &quot;hi!&quot; &lt;&lt; flush; // writes hi, then flushes the buffer; adds no datacout &lt;&lt; &quot;hi!&quot; &lt;&lt; ends; // writes hi and a null, then flushes the buffer 如果想在每次输出操作后都刷新缓冲区，可以使用unitbuf操纵符。它令流在接下来的每次写操作后都进行一次flush操作。而nounitbuf操纵符则使流恢复使用正常的缓冲区刷新机制。 123cout &lt;&lt; unitbuf; // all writes will be flushed immediately// any output is flushed immediately, no bufferingcout &lt;&lt; nounitbuf; // returns to normal buffering 如果程序异常终止，输出缓冲区不会被刷新。 当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将cout和cin关联在一起，因此下面的语句会导致cout的缓冲区被刷新： 1cin &gt;&gt; ival; 交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。 使用tie函数可以关联两个流。它有两个重载版本：无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。tie的第二个版本接受一个指向ostream的指针，将本对象关联到此ostream。 123456cin.tie(&amp;cout); // illustration only: the library ties cin and cout for us// old_tie points to the stream (if any) currently tied to cinostream *old_tie = cin.tie(nullptr); // cin is no longer tied// ties cin and cerr; not a good idea because cin should be tied to coutcin.tie(&amp;cerr); // reading cin flushes cerr, not coutcin.tie(old_tie); // reestablish normal tie between cin and cout 每个流同时最多关联一个流，但多个流可以同时关联同一个ostream。向tie传递空指针可以解开流的关联。 文件输入输出（File Input and Output）头文件fstream定义了三个类型来支持文件IO：ifstream从给定文件读取数据，ofstream向指定文件写入数据，fstream可以同时读写指定文件。 使用文件流对象（Using File Stream Objects）每个文件流类型都定义了open函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。 创建文件流对象时，如果提供了文件名（可选），open会被自动调用。 12ifstream in(ifile); // construct an ifstream and open the given fileofstream out; // output file stream that is not associated with any file 在C++11中，文件流对象的文件名可以是string对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。 在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受iostream类型引用或指针参数的函数，可以用对应的fstream类型来调用。 可以先定义空文件流对象，再调用open函数将其与指定文件关联。如果open调用失败，failbit会被置位。 对一个已经打开的文件流调用open会失败，并导致failbit被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用close关闭当前文件，再调用clear重置流的条件状态（close不会重置流的条件状态）。 当fstream对象被销毁时，close会自动被调用。 文件模式（File Modes）每个流都有一个关联的文件模式，用来指出如何使用文件。 只能对ofstream或fstream对象设定out模式。 只能对ifstream或fstream对象设定in模式。 只有当out被设定时才能设定trunc模式。 只要trunc没被设定，就能设定app模式。在app模式下，即使没有设定out模式，文件也是以输出方式打开。 默认情况下，即使没有设定trunc，以out模式打开的文件也会被截断。如果想保留以out模式打开的文件内容，就必须同时设定app模式，这会将数据追加写到文件末尾；或者同时设定in模式，即同时进行读写操作。 ate和binary模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。 与ifstream对象关联的文件默认以in模式打开，与ofstream对象关联的文件默认以out模式打开，与fstream对象关联的文件默认以in和out模式打开。 默认情况下，打开ofstream对象时，文件内容会被丢弃，阻止文件清空的方法是同时指定app或in模式。 流对象每次打开文件时都可以改变其文件模式。 12345ofstream out; // no file mode is setout.open(&quot;scratchpad&quot;); // mode implicitly out and truncout.close(); // close out so we can use it for a different fileout.open(&quot;precious&quot;, ofstream::app); // mode is out and appout.close(); string流（string Streams）头文件sstream定义了三个类型来支持内存IO：istringstream从string读取数据，ostringstream向string写入数据，stringstream可以同时读写string的数据。 使用istringstream（Using an istringstream）12345678910111213141516171819// members are public by defaultstruct PersonInfo&#123; string name; vector&lt;string&gt; phones;&#125;;string line, word; // will hold a line and word from input, respectivelyvector&lt;PersonInfo&gt; people; // will hold all the records from the input// read the input a line at a time until cin hits end-of-file (or another error)while (getline(cin, line))&#123; PersonInfo info; // create an object to hold this record&#x27;s data istringstream record(line); // bind record to the line we just read record &gt;&gt; info.name; // read the name while (record &gt;&gt; word) // read the phone numbers info.phones.push_back(word); // and store them people.push_back(info); // append this record to people&#125; 使用ostringstream（Using ostringstreams）123456789101112131415161718192021for (const auto &amp;entry : people)&#123; // for each entry in people ostringstream formatted, badNums; // objects created on each loop for (const auto &amp;nums : entry.phones) &#123; // for each number if (!valid(nums)) &#123; badNums &lt;&lt; &quot; &quot; &lt;&lt; nums; // string in badNums &#125; else // &#x27;&#x27;writes&#x27;&#x27; to formatted&#x27;s string formatted &lt;&lt; &quot; &quot; &lt;&lt; format(nums); &#125; if (badNums.str().empty()) // there were no bad numbers os &lt;&lt; entry.name &lt;&lt; &quot; &quot; // print the name &lt;&lt; formatted.str() &lt;&lt; endl; // and reformatted numbers else // otherwise, print the name and bad numbers cerr &lt;&lt; &quot;input error: &quot; &lt;&lt; entry.name &lt;&lt; &quot; invalid number(s) &quot; &lt;&lt; badNums.str() &lt;&lt; endl;&#125;","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第七章-类","slug":"C++ Primer/C++primer笔记-第七章-类","date":"2022-02-24T12:25:30.000Z","updated":"2022-06-29T12:58:17.632Z","comments":true,"path":"2022/02/24/C++ Primer/C++primer笔记-第七章-类/","link":"","permalink":"http://icecorn.github.io/2022/02/24/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E7%B1%BB/","excerpt":"","text":"第七章 类成员函数成员函数（member function）的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。定义在类内部的函数是隐式的内联函数。 123456789101112struct Sales_data&#123; // new members: operations on Sales_data objects std::string isbn() const &#123; return bookNo; &#125; Sales_data&amp; combine(const Sales_data&amp;); double avg_price() const; // data members std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;; 成员函数通过一个名为this的隐式额外参数来访问调用它的对象。this参数是一个常量指针，被初始化为调用该函数的对象地址。在函数体内可以显式使用this指针。 默认情况下，this的类型是指向类类型非常量版本的常量指针。this也遵循初始化规则，所以默认不能把this绑定到一个常量对象上，即不能在常量对象上调用普通的成员函数。 C++允许在成员函数的参数列表后面添加关键字const，表示this是一个指向常量的指针。使用关键字const的成员函数被称作常量成员函数（const member function）。 下边这种就是错误的：因为上边声明了isbn（）是一个const的成员函数。 1234567// pseudo-code illustration of how the implicit this pointer is used// this code is illegal: we may not explicitly define the this pointer ourselves// note that this is a pointer to const because isbn is a const memberstd::string Sales_data::isbn(const Sales_data *const this)&#123; return this-&gt;isbn;&#125; 常量对象和指向常量对象的引用或指针都只能调用常量成员函数。 总结：因为this默认指向非常量的成员函数，所以常量对象不能调用非常量的函数，常量对象只能调用常量的成员函数（后边加const的，这时用this的话，this是一个常量指针）。另外const成员函数的声明和定义后边必须都有const 防止隐式构造函数转换在要求隐式转换的程序上下文中，可以通过将构造函数声明为explicit的加以阻止。 12345678910class Sales_data&#123;public: Sales_data() = default; Sales_data(const std::string &amp;s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) &#123; &#125; explicit Sales_data(const std::string &amp;s): bookNo(s) &#123; &#125; explicit Sales_data(std::istream&amp;); // remaining members as before&#125;; explicit关键字只对接受一个实参的构造函数有效。 只能在类内声明构造函数时使用explicit关键字，在类外定义时不能重复。 执行拷贝初始化时（使用=）会发生隐式转换，所以explicit构造函数只能用于直接初始化。 123Sales_data item1 (null_book); // ok: direct initialization// error: cannot use the copy form of initialization with an explicit constructorSales_data item2 = null_book; 可以使用explicit构造函数显式地强制转换类型。 1234// ok: the argument is an explicitly constructed Sales_data objectitem.combine(Sales_data(null_book));// ok: static_cast can use an explicit constructoritem.combine(static_cast&lt;Sales_data&gt;(cin)); 类的静态成员使用关键字static可以声明类的静态成员。静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。 12345678910111213class Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125; static double rate() &#123; return interestRate; &#125; static void rate(double);private: std::string owner; double amount; static double interestRate; static double initRate();&#125;; 由于静态成员不与任何对象绑定，因此静态成员函数不能声明为const的，也不能在静态成员函数内使用this指针。 用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。 1234567891011121314151617double r;r = Account::rate(); // access a static member using the scope operatorAccount ac1;Account *ac2 = &amp;ac1;// equivalent ways to call the static member rate functionr = ac1.rate(); // through an Account object or referencer = ac2-&gt;rate(); // through a pointer to an Account objectclass Account&#123;public: void calculate() &#123; amount += amount * interestRate; &#125;private: static double interestRate; // remaining members as before&#125;; 在类外部定义静态成员时，不能重复static关键字，其只能用于类内部的声明语句。 由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。而必须在类外部定义并初始化每个静态成员。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。 12// define and initialize a static class memberdouble Account::interestRate = initRate(); 建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。 尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供const整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。初始值必须是常量表达式。 123456789class Account&#123;public: static double rate() &#123; return interestRate; &#125; static void rate(double);private: static constexpr int period = 30; // period is a constant double daily_tbl[period];&#125;; 静态数据成员的类型可以是它所属的类类型。 123456class Bar&#123; static Bar mem1; // ok: static member can have incomplete type Bar *mem2; // ok: pointer member can have incomplete type Bar mem3; // error: data members must have complete type&#125; 可以使用静态成员作为函数的默认实参。 static关键字详解从程序的存储上来看： 正文段CPU执行的机器指令部分。通常，正文段是可共享的，所以即使是经常环境指针环境表环境字符串执行的程序(如文本编辑程序、C编译程序、s h e l l等)在存储器中也只需有一个副本，另外，正文段常常是只读的，以防止程序由于意外事故而修改其自身的指令。 初始化数据段通常将此段称为数据段，它包含了程序中需赋初值的变量。初始化的全局变量和静态变量存放在这里。例如，C程序中任何函数之外的说明：int maxcount = 99; 使此变量以初值存放在初始化数据段中。a.初始化的全局变量b.初始化的静态变量 非初始化数据段通常将此段称为bss段，这一名称来源于早期汇编程序的一个操作符，意思是“block started by symbol（由符号开始的块）”，未初始化的全局变量和静态变量存放在这里。在程序开始执行之前，内核将此段初始化为0。函数外的说明：long sum[1000] ; 使此变量存放在非初始化数据段中。a.未初始化的全局变量b.未初始化的静态变量 堆需要由程序员分配释放管理，若程序员不释放，程序结束时可能由OS回收。通常在堆中进行动态存储分配。如程序中的malloc, calloc, realloc等函数都从这里面分配。堆是从下向上分配的。 栈由编译器自动分配释放管理。局部变量及每次函数调用时返回地址、以及调用者的环境信息（例如某些机器寄存器）都存放在栈中。新被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C函数可以递归调用。递归函数每次调用自身时，就使用一个新的栈帧，因此一个函数调用实例中的变量集不会影响另一个函数调用实例中的变量。a.局部变量b.函数调用时返回地址c.调用者的环境信息（例如某些机器寄存器） c++中static用法：1、static 数据成员 在类内数据成员的声明前加上关键字static，该数据成员就是类内的静态数据成员。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream.h&gt;class Myclass&#123;public: Myclass(int a,int b,int c); void GetSum();private: int a,b,c; static int Sum; //声明静态数据成员&#125;;int Myclass::Sum=0; //定义并初始化静态数据成员//static int Myclass::Sum = 0; //注意加static， 是错误的Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c;&#125;void Myclass::GetSum()&#123; cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl;&#125;void main()&#123; Myclass M(1,2,3); M.GetSum(); // cout 6 Myclass N(4,5,6); N.GetSum(); // cout 21 M.GetSum(); // cout 21&#125; 可以看出，static数据成员有以下特点：(1). 对于非static数据成员，每个类对象都有自己的拷贝。而static数据成员被当作是类的成员。无论这个类的对象被定义了多少个，静态数据成员在程序中也只有一份拷贝，由该类型的所有对象共享访问。 (2). 静态数据成员存储在全局数据区。静态数据成员定义时才分配空间，所以不能在类声明中定义。 在上例中，语句 int Myclass::Sum = 0; 是定义静态数据成员； (3). 静态数据成员和普通数据成员一样遵从public, protected, private 访问规则；除了定义，定义不要管访问规则。 (4). 因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以，它不属于特定的类对象，在没有产生类对象时其作用域就可见，即在没有产生类的实例时，我们就可以操作它； (5). 静态数据成员初始化与一般数据成员初始化不同。静态数据成员初始化的格式为： 12//＜数据类型＞＜类名＞::＜静态数据成员名＞=＜值＞int Myclass::Sum=0; (6). 类的静态数据成员有两种 访问形式： 12345//＜类对象名＞.＜静态数据成员名＞M.Sum = 0//＜类类型名＞::＜静态数据成员名＞Myclass::Sum = 0 但是上面这个例子是不行的，因为他是private的变量，如果静态数据成员的访问权限允许的话（即public的成员），可在程序中，按上述格式来引用静态数据成员 ； (7). 静态数据成员主要用在各个对象都有相同的某项属性的时候。比如对于一个存款类，每个实例的利息都是相同的。所以，应该把利息设为存款类的静态数据成员。这有两个好处，第一，不管定义多少个存款类对象，利息数据成员都共享分配在全局数据区的内存，所以节省存储空间。第二，一旦利息需要改变时，只要改变一次，则所有存款类对象的利息全改变过来了； (8). 同全局变量相比，使用静态数据成员有两个优势：a. 静态数据成员没有进入程序的全局名字空间，因此不存在与程序中其它全局名字冲突的可能性；b. 可以实现信息隐藏。静态数据成员可以是private成员，而全局变量不能； 2、static 成员函数 static 成员函数，它为类的全部对象服务而不是为某一个类的具体对象服务。普通的成员函数一般都隐含了一个this指针，但静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个意义上讲，它无法访问属于类对象的no-static数据成员，也无法访问no-static成员函数，它只能调用其余的静态成员函数。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream.h&gt;class Myclass&#123;public: Myclass(int a,int b,int c); static void GetSum(); /声明静态成员函数private: int a,b,c; static int Sum; //声明静态数据成员&#125;;int Myclass::Sum = 0;//定义并初始化静态数据成员Myclass::Myclass(int a,int b,int c)&#123; this-&gt;a=a; this-&gt;b=b; this-&gt;c=c; Sum+=a+b+c; //非静态成员函数可以访问静态数据成员&#125;//static void Myclass::GetSum()&#123;...&#125; //加上static是错误的void Myclass::GetSum() //静态成员函数的实现&#123; //cout&lt;&lt;a&lt;&lt;endl; //错误代码，a是非静态数据成员 cout&lt;&lt;&quot;Sum=&quot;&lt;&lt;Sum&lt;&lt;endl; //静态函数是能访问静态数据成员&#125; void main()&#123; Myclass M(1,2,3); M.GetSum(); Myclass N(4,5,6); N.GetSum(); Myclass::GetSum();&#125; 关于静态成员函数，可以总结为以下几点： (1). 在类体外，静态函数的定义前不能加关键字static； (2). static成员之间可以相互访问，包括static成员函数访问static数据成员和访问static成员函数； (3). 非静态成员函数可以任意地访问静态成员函数和静态数据成员； (4). 静态成员函数不能访问非静态成员函数和非静态数据成员，只能访问静态的； (5). 由于没有this指针的额外开销，因此静态成员函数与类的全局函数相比速度上会有少许的增长； (6). 调用静态成员函数，可以用成员访问操作符(.)和(-&gt;)或直接用类名调用静态成员函数 M.GetSum();Myclass::GetSum();调用类的静态成员函数。但是，一样 要遵从 public，protected，private 访问规则 。 堆和栈的区别1.栈简介栈由操作系统自动分配释放 ，用于存放函数的参数值、局部变量等，其操作方式类似于数据结构中的栈。参考如下代码： 123456int main() &#123; int b; //栈 char s[] = &quot;abc&quot;; //栈 char *p2; //栈&#125; 其中函数中定义的局部变量按照先后定义的顺序依次压入栈中，也就是说相邻变量的地址之间不会存在其它变量。栈的内存地址生长方向与堆相反，由高到底，所以后定义的变量地址低于先定义的变量，比如上面代码中变量 s 的地址小于变量 b 的地址，p2 地址小于 s 的地址。栈中存储的数据的生命周期随着函数的执行完成而结束。 2. 堆简介堆由开发人员分配和释放， 若开发人员不释放，程序结束时由 OS 回收，分配方式类似于链表。参考如下代码： 1234567891011121314151617int main() &#123; // C 中用 malloc() 函数申请 char* p1 = (char *)malloc(10); cout&lt;&lt;(int*)p1&lt;&lt;endl; //输出：00000000003BA0C0 // 用 free() 函数释放 free(p1); // C++ 中用 new 运算符申请 char* p2 = new char[10]; cout &lt;&lt; (int*)p2 &lt;&lt; endl; //输出：00000000003BA0C0 // 用 delete 运算符释放 delete[] p2;&#125; 其中 p1 所指的 10 字节的内存空间与 p2 所指的 10 字节内存空间都是存在于堆。堆的内存地址生长方向与栈相反，由低到高，但需要注意的是，后申请的内存空间并不一定在先申请的内存空间的后面，即 p2 指向的地址并不一定大于 p1 所指向的内存地址，原因是先申请的内存空间一旦被释放，后申请的内存空间则会利用先前被释放的内存，从而导致先后分配的内存空间在地址上不存在先后关系。堆中存储的数据若未释放，则其生命周期等同于程序的生命周期。 关于堆上内存空间的分配过程，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。**另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确地释放本内存空间。(这就是为什么stl中pool_allocator更好的原因，可以节省一些存放分配大小的首地址的开销)**由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动地将多余的那部分重新放入空闲链表。 1.3 堆与栈区别堆与栈实际上是操作系统对进程占用的内存空间的两种管理方式，主要有如下几种区别：（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏； （2）空间大小不同。每个进程拥有的栈大小要远远小于堆大小。理论上，进程可申请的堆大小为虚拟内存大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB； （3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。 （4）分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有 2 种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloc()函数分配，但是栈的动态分配和堆是不同的，它的动态分配是由操作系统进行释放，无需我们手工实现。 （5）分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。 （6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。当主函数调用另外一个函数的时候，要对当前函数执行断点进行保存，需要使用栈来实现，首先入栈的是主函数下一条语句的地址，即扩展指针寄存器的内容（EIP），然后是当前栈帧的底部地址，即扩展基址指针寄存器内容（EBP），再然后是被调函数的实参等，一般情况下是按照从右向左的顺序入栈，之后是被调函数的局部变量，注意静态变量是存放在数据段或者BSS段，是不入栈的。出栈的顺序正好相反，最终栈顶指向主函数下一条语句的地址，主程序又从该地址开始执行。堆，一般情况堆顶使用一个字节的空间来存放堆的大小，而堆中具体存放内容是由程序员来填充的。 从以上可以看到，堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。 无论是堆还是栈，在内存使用时都要防止非法越界，越界导致的非法内存访问可能会摧毁程序的堆、栈数据，轻则导致程序运行处于不确定状态，获取不到预期结果，重则导致程序异常崩溃，这些都是我们编程时与内存打交道时应该注意的问题。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第六章-函数","slug":"C++ Primer/C++primer笔记-第六章-函数","date":"2022-02-23T12:25:30.000Z","updated":"2022-06-29T12:56:42.477Z","comments":true,"path":"2022/02/23/C++ Primer/C++primer笔记-第六章-函数/","link":"","permalink":"http://icecorn.github.io/2022/02/23/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%87%BD%E6%95%B0/","excerpt":"","text":"第六章 函数传引用参数使用引用形参可以避免拷贝操作，拷贝大的类类型对象或容器对象比较低效。另外有的类类型（如IO类型）根本就不支持拷贝操作，这时只能通过引用形参访问该类型的对象。 除了内置类型、函数对象和标准库迭代器外，其他类型的参数建议以引用方式传递。 如果函数无须改变引用形参的值，最好将其声明为常量引用。 一个函数只能返回一个值，但利用引用形参可以使函数返回额外信息。 const形参和实参当形参有顶层const时，传递给它常量对象或非常量对象都是可以的。 可以使用非常量对象初始化一个底层const形参，但是反过来不行。 把函数不会改变的形参定义成普通引用会极大地限制函数所能接受的实参类型，同时也会给别人一种误导，即函数可以修改实参的值。 所以，“不变”的参数一定要记得加上const 数组形参因为不能拷贝数组，所以无法以值传递的方式使用数组参数，但是可以把形参写成类似数组的形式。 1234// each function has a single parameter of type const int*void print(const int*);void print(const int[]); // shows the intent that the function takes an arrayvoid print(const int[10]); // dimension for documentation purposes (at best) 因为数组会被转换成指针，所以当我们传递给函数一个数组时，实际上传递的是指向数组首元素的指针。 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外信息。 以数组作为形参的函数必须确保使用数组时不会越界。 如果函数不需要对数组元素执行写操作，应该把数组形参定义成指向常量的指针。 形参可以是数组的引用，但此时维度是形参类型的一部分，函数只能作用于指定大小的数组。 将多维数组传递给函数时，数组第二维（以及后面所有维度）的大小是数组类型的一部分，不能省略。 12f(int &amp;arr[10]) // error: declares arr as an array of referencesf(int (&amp;arr)[10]) // ok: arr is a reference to an array of ten ints 关于函数返回引用调用一个返回引用的函数会得到左值，其他返回类型得到右值。 如果返回的是引用的话，是可以当作左值来使用的 123456789101112131415161718#include&lt;iostream&gt;using namespace std;int value[10];int error=-1;int &amp;func(int n)&#123; if(n&gt;=0&amp;&amp;n&lt;=9) return value[n];//返回的引用所绑定的变量一定是全局变量，不能是函数中定义的局部变量 else return error;&#125; int main()&#123; func(0)=10; func(4)=12; cout&lt;&lt;value[0]&lt;&lt;endl; cout&lt;&lt;value[4]&lt;&lt;endl; return 0; &#125; C++函数返回的步骤是：1、一般情况下计算结果保存在某个局部变量内，上面的程序，结果保存在变量 result 内。2、return result 的时候，result 的值会“复制” 到一个临时变量中，假设变量名为 temp，即执行 temp = result，然后，函数生命周期结束。3、最后， 主程序把 temp 变量的值“复制”到目标变量中，例如：x4 = temp。 这里面有两次“复制”过程，因此需要构造temp和目标变量。有些编译器会自动优化，甚至只需要构造一次 result 就解决问题了。这样虽然效率提高了很多，但是这样的源代码却不合适，因为换成其他的编译器可能效率就低下来了。 引用作为函数的返回值 引用作为函数的返回值时，必须在定义函数时在函数名前将&amp; 用引用作函数的返回值的最大的好处是在内存中不产生返回值的副本 123456789101112131415161718192021222324//代码来源：RUNOOB#include&lt;iostream&gt;using namespace std;float temp;float fn1(float r)&#123; temp=r*r*3.14; return temp;&#125; float &amp;fn2(float r)&#123; //&amp;说明返回的是temp的引用，换句话说就是返回temp本身 temp=r*r*3.14; return temp;&#125;int main()&#123; float a=fn1(5.0); //case 1：返回值 //float &amp;b=fn1(5.0); //case 2:用函数的返回值作为引用的初始化值 [Error] invalid initialization of non-const reference of type &#x27;float&amp;&#x27; from an rvalue of type &#x27;float&#x27; //（有些编译器可以成功编译该语句，但会给出一个warning） float c=fn2(5.0);//case 3：返回引用 float &amp;d=fn2(5.0);//case 4：用函数返回的引用作为新引用的初始化值 cout&lt;&lt;a&lt;&lt;endl;//78.5 //cout&lt;&lt;b&lt;&lt;endl;//78.5 cout&lt;&lt;c&lt;&lt;endl;//78.5 cout&lt;&lt;d&lt;&lt;endl;//78.5 return 0;&#125; case 1：用返回值方式调用函数（如下图，图片来源：伯乐在线）： 返回全局变量temp的值时，C++会在内存中创建临时变量并将temp的值拷贝给该临时变量。当返回到主函数main后，赋值语句a=fn1(5.0)会把临时变量的值再拷贝给变量a case 2：用函数的返回值初始化引用的方式调用函数 这种情况下，函数fn1()是以值方式返回到，返回时，首先拷贝temp的值给临时变量。返回到主函数后，用临时变量来初始化引用变量b，使得b成为该临时变量到的别名。由于临时变量的作用域短暂（在C++标准中，临时变量或对象的生命周期在一个完整的语句表达式结束后便宣告结束，也就是在语句float &amp;b=fn1(5.0);之后） ，所以b面临无效的危险，很有可能以后的值是个无法确定的值。 如果真的希望用函数的返回值来初始化一个引用，应当先创建一个变量，将函数的返回值赋给这个变量，然后再用该变量来初始化引用： 12int x=fn1(5.0);int &amp;b=x; case 3:用返回引用的方式调用函数 这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数，即主函数的赋值语句中的左值是直接从变量temp中拷贝而来（也就是说c只是变量temp的一个拷贝而非别名） ，这样就避免了临时变量的产生。尤其当变量temp是一个用户自定义的类的对象时，这样还避免了调用类中的拷贝构造函数在内存中创建临时对象的过程，提高了程序的时间和空间的使用效率。 case 4:用函数返回的引用作为新引用的初始化值的方式来调用函数 这种情况下，函数fn2()的返回值不产生副本，而是直接将变量temp返回给主函数。在主函数中，一个引用声明d用该返回值初始化，也就是说此时d成为变量temp的别名。由于temp是全局变量，所以在d的有效期内temp始终保持有效，故这种做法是安全的。（注意看上边的代码，在最上边声明了全局变量temp，所以是ok的，但是如果temp是函数里的局部变量的话，它就会在函数结束时被析构掉，这时候d就变成了未定义的引用了，危险！） 不能返回局部变量的引用。如上面的例子，如果temp是局部变量，那么它会在函数返回后被销毁，此时对temp的引用就会成为“无所指”的引用，程序会进入未知状态。 不能返回函数内部通过new分配的内存的引用。虽然不存在局部变量的被动销毁问题，但如果被返回的函数的引用只是作为一个临时变量出现，而没有将其赋值给一个实际的变量，那么就可能造成这个引用所指向的空间（有new分配）无法释放的情况（由于没有具体的变量名，故无法用delete手动释放该内存），从而造成内存泄漏。因此应当避免这种情况的发生 当返回类成员的引用时，最好是const引用。这样可以避免在无意的情况下破坏该类的成员。 到这里的，用引用做返回值的情况就比较清晰了，接下来要弄清楚上边的各种变量是存在哪里的（堆还是栈），还有关于右值引用和move方法。 用引用实现多态在C++中，引用是除了指针外另一个可以产生多态效果的手段。也就是说一个基类的引用可以用来绑定其派生类的实例 1234class Father;//基类（父类）class Son：public Father&#123;.....&#125;//Son是Father的派生类Son son;//son是类Son的一个实例Father &amp;ptr=son;//用派生类的对象初始化基类对象的使用 特别注意： ptr只能用来访问派生类对象中从基类继承下来的成员。如果基类（类Father）中定义的有虚函数，那么就可以通过在派生类（类Son）中重写这个虚函数来实现类的多态。 这里就和java是一样的，通过父类引用指向子类对象来实现多态 函数重载如果形参是某种类型的指针或引用，则通过区分其指向的对象是常量还是非常量可以实现函数重载，此时的const是底层的。当我们传递给重载函数一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。 123456// functions taking const and nonconst references or pointers have different parameters// declarations for four independent, overloaded functionsRecord lookup(Account&amp;); // function that takes a reference to AccountRecord lookup(const Account&amp;); // new function that takes a const referenceRecord lookup(Account*); // new function, takes a pointer to AccountRecord lookup(const Account*); // new function, takes a pointer to const const_cast可以用于函数的重载。当函数的实参不是常量时，将得到普通引用。 123456789101112// return a reference to the shorter of two stringsconst string &amp;shorterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125;string &amp;shorterString(string &amp;s1, string &amp;s2)&#123; auto &amp;r = shorterString(const_cast&lt;const string&amp;&gt;(s1), const_cast&lt;const string&amp;&gt;(s2)); return const_cast&lt;string&amp;&gt;(r);&#125; 函数匹配（function matching）也叫做重载确定（overload resolution），是指编译器将函数调用与一组重载函数中的某一个进行关联的过程。 调用重载函数时有三种可能的结果： 编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。 编译器找不到任何一个函数与实参匹配，发出无匹配（no match）的错误信息。 有一个以上的函数与实参匹配，但每一个都不是明显的最佳选择，此时编译器发出二义性调用（ambiguous call）的错误信息。 特殊用途语言特性默认实参 默认实参作为形参的初始值出现在形参列表中。可以为一个或多个形参定义默认值，不过一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。 12typedef string::size_type sz;string screen(sz ht = 24, sz wid = 80, char backgrnd = &#x27; &#x27;); 调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。 如果想使用默认实参，只要在调用函数的时候省略该实参即可。 虽然多次声明同一个函数是合法的，但是在给定的作用域中一个形参只能被赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值。 1234// no default for the height or width parametersstring screen(sz, sz, char = &#x27; &#x27;);string screen(sz, sz, char = &#x27;*&#x27;); // error: redeclarationstring screen(sz = 24, sz = 80, char); // ok: adds default 默认实参只能出现在函数声明和定义其中一处。通常应该在函数声明中指定默认实参，并将声明放在合适的头文件中。 12345678910111213// 函数声明void fun(int n);int main()&#123; // Error: 编译器向前查找函数声明 // fun调用形式与声明不符 fun(); return EXIT_SUCCESS;&#125;// 函数定义void fun(int n = 0) &#123; /*...*/ &#125; 局部变量不能作为函数的默认实参。 用作默认实参的名字在函数声明所在的作用域内解析，但名字的求值过程发生在函数调用时。 1234567891011121314// the declarations of wd, def, and ht must appear outside a functionsz wd = 80;char def = &#x27; &#x27;;sz ht();string screen(sz = ht(), sz = wd, char = def);string window = screen(); // calls screen(ht(), 80, &#x27; &#x27;)void f2()&#123; def = &#x27;*&#x27;; // changes the value of a default argument sz wd = 100; // hides the outer definition of wd but does not change the default window = screen(); // calls screen(ht(), 80, &#x27;*&#x27;)&#125; 内联函数和constexpr函数内联函数会在每个调用点上“内联地”展开，省去函数调用所需的一系列工作。定义内联函数时需要在函数的返回类型前添加关键字inline。 12345// inline version: find the shorter of two stringsinline const string &amp;horterString(const string &amp;s1, const string &amp;s2)&#123; return s1.size() &lt;= s2.size() ? s1 : s2;&#125; 在函数声明和定义中都能使用关键字inline，但是建议只在函数定义时使用。 一般来说，内联机制适用于优化规模较小、流程直接、调用频繁的函数。内联函数中不允许有循环语句和switch语句，否则函数会被编译为普通函数。 为什么要有内联函数，内联函数有什么用？ 因为，在大多数机器上，调用函数都要做很多的工作：调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新的位置来执行。而内联函数的目的就是提高函数的执行效率，用关键字 inline 放在函数定义的前面即可将函数指定为内联函数，内联函数通常就是将它在程序中的每个调用点上“内联地”展开。假设我们将 max 定义为内联函数： 1234567inline int max(int a, int b)&#123; return a &gt; b ? a : b;&#125;则调用： cout&lt;&lt;max(a, b)&lt;&lt;endl;在编译时展开为： cout&lt;&lt;(a &gt; b ? a : b)&lt;&lt;endl;从而消除了把max写成函数的额外开销。 定义在类声明之中的成员函数将自动的成为内联函数 内联函数应该在头文件中定义，这一点不同于其他函数。编译器在调用点内联展开函数的代码时，必须能够找到 inline 函数的定义才能将调用函数替换为函数代码，而对于在头文件中仅有函数声明是不够的。 当然内联函数定义也可以放在源文件中，但此时只有定义的那个源文件可以用它，而且必须为每个源文件拷贝一份定义(即每个源文件里的定义必须是完全相同的)，当然即使是放在头文件中，也是对每个定义做一份拷贝，只不过是编译器替你完成这种拷贝罢了。但相比于放在源文件中，放在头文件中既能够确保调用函数是定义是相同的，又能够保证在调用点能够找到函数定义从而完成内联(替换)。 Tip： 只有当函数只有 10 行甚至更少时才将其定义为内联函数. 定义: 当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用.优点: 当函数体比较小的时候, 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短, 性能关键的函数, 鼓励使用内联.缺点: 滥用内联将导致程序变慢. 内联可能使目标代码量或增或减, 这取决于内联函数的大小. 内联非常短小的存取函数通常会减少代码大小, 但内联一个相当大的函数将戏剧性的增加代码大小. 现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。结论: 一个较为合理的经验准则是, 不要内联超过 10 行的函数. 谨慎对待析构函数, 析构函数往往比其表面看起来要更长, 因为有隐含的成员和基类析构函数被调用!另一个实用的经验准则: 内联那些包含循环或 switch 语句的函数常常是得不偿失 (除非在大多数情况下, 这些循环或 switch 语句从不被执行).有些函数即使声明为内联的也不一定会被编译器内联, 这点很重要; 比如虚函数和递归函数就不会被正常内联. 通常, 递归函数不应该声明成内联函数.(递归调用堆栈的展开并不像循环那么简单, 比如递归层数在编译时可能是未知的, 大多数编译器都不支持内联递归函数). 虚函数内联的主要原因则是想把它的函数体放在类定义内, 为了图个方便, 抑或是当作文档描述其行为, 比如精短的存取函数. constexpr函数是指能用于常量表达式的函数。constexpr函数的返回类型及所有形参的类型都得是字面值类型。另外C++11标准要求constexpr函数体中必须有且只有一条return语句，但是此限制在C++14标准中被删除。 123456constexpr int new_sz()&#123; return 42;&#125;constexpr int foo = new_sz(); // ok: foo is a constant expression constexpr函数的返回值可以不是一个常量。 123456789// scale(arg) is a constant expression if arg is a constant expressionconstexpr size_t scale(size_t cnt)&#123; return new_sz() * cnt;&#125;int arr[scale(2)]; // ok: scale(2) is a constant expressionint i = 2; // i is not a constant expressionint a2[scale(i)]; // error: scale(i) is not a constant expression constexpr函数被隐式地指定为内联函数。 和其他函数不同，内联函数和constexpr函数可以在程序中多次定义。因为在编译过程中，编译器需要函数的定义来随时展开函数。对于某个给定的内联函数或constexpr函数，它的多个定义必须完全一致。因此内联函数和constexpr函数通常定义在头文件中。 调试帮助 变量名称 内容 __func__ 当前函数名称 __FILE__ 当前文件名称 __LINE__ 当前行号 __TIME__ 文件编译时间 __DATE__ 文件编译日期 函数指针要想声明一个可以指向某种函数的指针，只需要用指针替换函数名称即可。 1234// compares lengths of two stringsbool lengthCompare(const string &amp;, const string &amp;);// pf points to a function returning bool that takes two const string referencesbool (*pf)(const string &amp;, const string &amp;); // uninitialized 可以直接使用指向函数的指针来调用函数，无须提前解引用指针。 123456pf = lengthCompare; // pf now points to the function named lengthComparepf = &amp;lengthCompare; // equivalent assignment: address-of operator is optionalbool b1 = pf(&quot;hello&quot;, &quot;goodbye&quot;); // calls lengthComparebool b2 = (*pf)(&quot;hello&quot;, &quot;goodbye&quot;); // equivalent callbool b3 = lengthCompare(&quot;hello&quot;, &quot;goodbye&quot;); // equivalent call 对于重载函数，编译器通过指针类型决定函数版本，指针类型必须与重载函数中的某一个精确匹配。 123void ff(int*);void ff(unsigned int);void (*pf1)(unsigned int) = ff; // pf1 points to ff(unsigned) 可以把函数的形参定义成指向函数的指针。调用时允许直接把函数名当作实参使用，它会自动转换成指针。 1234567// third parameter is a function type and is automatically treated as a pointer to functionvoid useBigger(const string &amp;s1, const string &amp;s2, bool pf(const string &amp;, const string &amp;));// equivalent declaration: explicitly define the parameter as a pointer to functionvoid useBigger(const string &amp;s1, const string &amp;s2, bool (*pf)(const string &amp;, const string &amp;));// automatically converts the function lengthCompare to a pointer to functionuseBigger(s1, s2, lengthCompare); 关键字decltype作用于函数时，返回的是函数类型，而不是函数指针类型。 函数可以返回指向函数的指针。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第四章-表达式","slug":"C++ Primer/C++primer笔记-第四章-表达式","date":"2022-02-21T12:25:30.000Z","updated":"2022-06-29T12:53:37.524Z","comments":true,"path":"2022/02/21/C++ Primer/C++primer笔记-第四章-表达式/","link":"","permalink":"http://icecorn.github.io/2022/02/21/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"第四章 表达式运算符重载C++定义了运算符作用于内置类型和复合类型的运算对象时所执行的操作。当运算符作用于类类型的运算对象时，用户可以自定义其含义，这被称作运算符重载（overloaded operator）。 左值和右值C++的表达式分为右值（rvalue）和左值（lvalue）。当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值时，用的是对象的地址。需要右值的地方可以用左值代替，反之则不行。 赋值运算符需要一个非常量左值作为其左侧运算对象，返回结果也是一个左值。 取地址符作用于左值运算对象，返回指向该运算对象的指针，该指针是一个右值。 内置解引用运算符、下标运算符、迭代器解引用运算符、string和vector的下标运算符都返回左值。 内置类型和迭代器的递增递减运算符作用于左值运算对象。前置版本返回左值，后置版本返回右值。 如果decltype作用于一个求值结果是左值的表达式，会得到引用类型。 深度理解左值和右值 ​ 在C++11中所有的值必属于左值、右值两者之一，右值又可以细分为纯右值、将亡值。在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值（将亡值或纯右值）。举个例子，int a = b+c, a 就是左值，其有变量名为a，通过&amp;a可以获取该变量的地址；表达式b+c、函数int func()的返回值是右值，在其被赋值给某一变量前，我们不能通过变量名找到它，＆(b+c)这样的操作则不会通过编译。 右值、将亡值 在理解C++11的右值前，先看看C++98中右值的概念：C++98中右值是纯右值，纯右值指的是临时变量值、不跟对象关联的字面量值。临时变量指的是非引用返回的函数返回值、表达式等，例如函数int func()的返回值，表达式a+b；不跟对象关联的字面量值，例如true，2，”C”等。 ​ C++11对C++98中的右值进行了扩充。在C++11中右值又分为纯右值（prvalue，Pure Rvalue）和将亡值（xvalue，eXpiring Value）。其中纯右值的概念等同于我们在C++98标准中右值的概念，指的是临时变量和不跟对象关联的字面量值；将亡值则是C++11新增的跟右值引用相关的表达式，这样表达式通常是将要被移动的对象（移为他用），比如返回右值引用T&amp;&amp;的函数返回值、std::move的返回值，或者转换为T&amp;&amp;的类型转换函数的返回值。 ​ 将亡值可以理解为通过“盗取”其他变量内存空间的方式获取到的值。在确保其他变量不再被使用、或即将被销毁时，通过“盗取”的方式可以避免内存空间的释放和分配，能够延长变量值的生命期。 左值引用、右值引用 左值引用就是对一个左值进行引用的类型。右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。 ​ 右值引用和左值引用都是属于引用类型。无论是声明一个左值引用还是右值引用，都必须立即进行初始化。而其原因可以理解为是引用类型本身自己并不拥有所绑定对象的内存，只是该对象的一个别名。左值引用是具名变量值的别名，而右值引用则是不具名（匿名）变量的别名。 ​ 左值引用通常也不能绑定到右值，但常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。不过常量左值所引用的右值在它的“余生”中只能是只读的。相对地，非常量左值只能接受非常量左值对其进行初始化。 123456int &amp;a = 2; # 左值引用绑定到右值，编译失败int b = 2; # 非常量左值const int &amp;c = b; # 常量左值引用绑定到非常量左值，编译通过const int d = 2; # 常量左值const int &amp;e = c; # 常量左值引用绑定到常量左值，编译通过const int &amp;b =2; # 常量左值引用绑定到右值，编程通过 ​ 右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值，例如： 1234int a;int &amp;&amp;r1 = c; # 编译失败int &amp;&amp;r2 = std::move(a); # 编译通过下表列出了在C++11中各种引用类型可以引用的值的类型。值得注意的是，只要能够绑定右值的引用类型，都能够延长右值的生命期。 关于运算符逻辑运算符注意事项 逻辑与（logical AND）运算符&amp;&amp;和逻辑或（logical OR）运算符||都是先计算左侧运算对象的值再计算右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会去计算右侧运算对象的值。这种策略称为短路求值（short-circuit evaluation）。 对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。 对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。 进行比较运算时，除非比较的对象是布尔类型，否则不要使用布尔字面值true和false作为运算对象。 递增和递减运算符 递增和递减运算符分为前置版本和后置版本： 前置版本首先将运算对象加1（或减1），然后将改变后的对象作为求值结果。 后置版本也会将运算对象加1（或减1），但求值结果是运算对象改变前的值的副本。 123int i = 0, j;j = ++i; // j = 1, i = 1: prefix yields the incremented valuej = i++; // j = 1, i = 2: postfix yields the unincremented value 除非必须，否则不应该使用递增或递减运算符的后置版本。后置版本需要将原始值存储下来以便于返回修改前的内容，如果我们不需要这个值，那么后置版本的操作就是一种浪费。 在某些语句中混用解引用和递增运算符可以使程序更简洁。 1cout &lt;&lt; *iter++ &lt;&lt; endl; 因为后置++返回的是值而非引用，所以 ++++i可以，而i++++不可以。 sizeof运算符sizeof运算符返回一个表达式或一个类型名字所占的字节数，返回值是size_t类型。 在sizeof的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。 sizeof运算符的结果部分依赖于其作用的类型： 对char或者类型为char的表达式执行sizeof运算，返回值为1。 对引用类型执行sizeof运算得到被引用对象所占空间的大小。 对指针执行sizeof运算得到指针本身所占空间的大小。 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。 对数组执行sizeof运算得到整个数组所占空间的大小。 对string或vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。 就是说对于sizeof(vector)应该等于24，因为vector内有3个指针 类型转换无须程序员介入，会自动执行的类型转换叫做隐式转换（implicit conversions）。 算术转换 把一种算术类型转换成另一种算术类型叫做算术转换。 整型提升（integral promotions）负责把小整数类型转换成较大的整数类型。 其他隐式类型转换 在大多数表达式中，数组名字自动转换成指向数组首元素的指针。 常量整数值0或字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*。 任意一种算术类型或指针类型都能转换成布尔类型。如果指针或算术类型的值为0，转换结果是false，否则是true。 指向非常量类型的指针能转换成指向相应的常量类型的指针。 显式转换 显式类型转换也叫做强制类型转换（cast）。虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。建议尽量避免强制类型转换。 命名的强制类型转换（named cast）形式如下： 1cast-name&lt;type&gt;(expression); 其中type是转换的目标类型，expression是要转换的值。如果type是引用类型，则转换结果是左值。cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种，用来指定转换的方式。 dynamic_cast支持运行时类型识别。 任何具有明确定义的类型转换，只要不包含底层const（数据是常量，比如const int），都能使用static_cast。 const_cast只能改变运算对象的底层const，不能改变表达式的类型。同时也只有const_cast能改变表达式的常量属性。const_cast常常用于函数重载。 reinterpret_cast通常为运算对象的位模式提供底层上的重新解释。 早期版本的C++语言中，显式类型转换包含两种形式： 12type (expression); // function-style cast notation(type) expression; // C-language-style cast notation","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第三章-字符串，向量和数组","slug":"C++ Primer/C++primer笔记-第三章-字符串，向量和数组","date":"2022-02-20T12:25:30.000Z","updated":"2022-06-29T12:52:21.527Z","comments":true,"path":"2022/02/20/C++ Primer/C++primer笔记-第三章-字符串，向量和数组/","link":"","permalink":"http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/","excerpt":"","text":"第三章 字符串,向量和数组关于string的注意点： size函数返回string对象的长度，返回值是string::size_type类型，这是一种无符号类型。要使用size_type，必须先指定它是由哪种类型定义的。 当把string对象和字符字面值及字符串字面值混合在一条语句中使用时，必须确保每个加法运算符两侧的运算对象中至少有一个是string。 123string s4 = s1 + &quot;, &quot;; // ok: adding a string and a literalstring s5 = &quot;hello&quot; + &quot;, &quot;; // error: no string operandstring s6 = s1 + &quot;, &quot; + &quot;world&quot;; // ok: each + has a string operand 其实是变量生命周期的问题，在这里记录一下： 123456789string s1 = string(&quot;string1&quot;); string s2 = string(&quot;string2&quot;); const char* p1 = s1.substr(1).data(); // substr(1)的意思是取[字符串]从下标1到结尾的部分 const char* p2 = s2.substr(1).data();cout &lt;&lt; p1 &lt;&lt; p2 &lt;&lt; endl; 这里输出应该是tring1tring2，却输出了tring2tring2。这是因为s1.substr(1)创建了一个临时对象来存储s1的字串，然后data()获取这个子串内存的指针赋值给p1。但是到下一行，编译器发现刚才的临时对象没用了，就把它析构掉了（注意，析构表明cpu重新获得这块内存的分配权，但是里边的信息01状态不会改变），然后p2进行一样的操作，刚好s2.substr()又分配到了这块内存空间，这就导致最后的结果是p1p2都指向这块内存，而这块内存是tring2！ 所以，在使用接口函数时一定要注意返回值是什么，而且编程时要注意对象的生命周期！ vector使用注意：vector和string对象的下标运算符只能用来访问已经存在的元素，而不能用来添加元素。 123456vector&lt;int&gt; ivec; // empty vectorfor (decltype(ivec.size()) ix = 0; ix != 10; ++ix)&#123; ivec[ix] = ix; // disaster: ivec has no elements ivec.push_back(ix); // ok: adds a new element with value ix&#125; vector原理见stl笔记 数组（Arrays）数组类似vector，但数组的大小确定不变，不能随意向数组中添加元素。 如果不清楚元素的确切个数，应该使用vector。 定义和初始化内置数组（Defining and Initializing Built-in Arrays）数组是一种复合类型，声明形式为a[d]，其中a是数组名称，d是数组维度（dimension）。维度必须是一个常量表达式。 默认情况下，数组的元素被默认初始化。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值列表推断类型。 如果定义数组时提供了元素的初始化列表，则允许省略数组维度，编译器会根据初始值的数量计算维度。但如果显式指明了维度，那么初始值的数量不能超过指定的大小。如果维度比初始值的数量大，则用提供的值初始化数组中靠前的元素，剩下的元素被默认初始化。 123456const unsigned sz = 3;int ia1[sz] = &#123;0,1,2&#125;; // array of three ints with values 0, 1, 2int a2[] = &#123;0, 1, 2&#125;; // an array of dimension 3int a3[5] = &#123;0, 1, 2&#125;; // equivalent to a3[] = &#123;0, 1, 2, 0, 0&#125;string a4[3] = &#123;&quot;hi&quot;, &quot;bye&quot;&#125;; // same as a4[] = &#123;&quot;hi&quot;, &quot;bye&quot;, &quot;&quot;&#125;int a5[2] = &#123;0,1,2&#125;; // error: too many initializers 可以用字符串字面值初始化字符数组，但字符串字面值结尾处的空字符也会一起被拷贝到字符数组中。 1234char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;; // list initialization, no nullchar a2[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;, &#x27;\\0&#x27;&#125;; // list initialization, explicit nullchar a3[] = &quot;C++&quot;; // null terminator added automaticallyconst char a4[6] = &quot;Daniel&quot;; // error: no space for the null! 不能用一个数组初始化或直接赋值给另一个数组。 从数组的名字开始由内向外阅读有助于理解复杂数组声明的含义。 1234int *ptrs[10]; // ptrs is an array of ten pointers to intint &amp;refs[10] = /* ? */; // error: no arrays of referencesint (*Parray)[10] = &amp;arr; // Parray points to an array of ten intsint (&amp;arrRef)[10] = arr; // arrRef refers to an array of ten ints 访问数组元素（Accessing the Elements of an Array）数组下标通常被定义成size_t类型，这是一种机器相关的无符号类型，可以表示内存中任意对象的大小。size_t定义在头文件cstddef中。 大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。 指针和数组（Pointers and Arrays）在大多数表达式中，使用数组类型的对象其实是在使用一个指向该数组首元素的指针。 123string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;; // array of stringsstring *p = &amp;nums[0]; // p points to the first element in numsstring *p2 = nums; // equivalent to p2 = &amp;nums[0] 这里刚好可以说明一下指针和引用的区别，为什么要有引用这个东西。比如有一个长度为10的数组arr，要改变第五个元素，arr[4] = 0；就可以直接改，这里的arr[4]就是引用，表述起来比较方便，想一下如果要用指针表述的话，就是(&amp;arr[4]) = 0;更复杂的情况会更繁琐，这可能是引用出现的一个因素吧* 当使用数组作为一个auto变量的初始值时，推断得到的类型是指针而非数组。但decltype关键字不会发生这种转换，直接返回数组类型。 12345678int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsauto ia2(ia); // ia2 is an int* that points to the first element in iaia2 = 42; // error: ia2 is a pointer, and we can&#x27;t assign an int to a pointerauto ia2(&amp;ia[0]); // now it&#x27;s clear that ia2 has type int*// ia3 is an array of ten intsdecltype(ia) ia3 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;ia3 = p; // error: can&#x27;t assign an int* to an arrayia3[4] = i; // ok: assigns the value of i to an element in ia3 C++11在头文件iterator中定义了两个名为begin和end的函数，功能与容器中的两个同名成员函数类似，参数是一个数组。 123int ia[] = &#123;0,1,2,3,4,5,6,7,8,9&#125;; // ia is an array of ten intsint *beg = begin(ia); // pointer to the first element in iaint *last = end(ia); // pointer one past the last element in ia 两个指针相减的结果类型是ptrdiff_t，这是一种定义在头文件cstddef中的带符号类型。 标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求。 C风格字符串C风格字符串是将字符串存放在字符数组中，并以空字符结束（null terminated）。这不是一种类型，而是一种为了表达和使用字符串而形成的书写方法。 C++标准支持C风格字符串，但是最好不要在C++程序中使用它们。对大多数程序来说，使用标准库string要比使用C风格字符串更加安全和高效。 C风格字符串函数不负责验证其参数的正确性，传入此类函数的指针必须指向以空字符作为结尾的数组。 与旧代码的接口（Interfacing to Older Code）任何出现字符串字面值的地方都可以用以空字符结束的字符数组来代替： 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。 在string对象的加法运算中，允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）。 在string对象的复合赋值运算中，允许使用以空字符结束的字符数组作为右侧运算对象。 不能用string对象直接初始化指向字符的指针。为了实现该功能，string提供了一个名为c_str的成员函数，返回const char*类型的指针，指向一个以空字符结束的字符数组，数组的数据和string对象一样。 123string s(&quot;Hello World&quot;); // s holds Hello Worldchar *str = s; // error: can&#x27;t initialize a char* from a stringconst char *str = s.c_str(); // ok 针对string对象的后续操作有可能会让c_str函数之前返回的数组失去作用，如果程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。 可以使用数组来初始化vector对象，但是需要指明要拷贝区域的首元素地址和尾后地址。 123int int_arr[] = &#123;0, 1, 2, 3, 4, 5&#125;;// ivec has six elements; each is a copy of the corresponding element in int_arrvector&lt;int&gt; ivec(begin(int_arr), end(int_arr)); 在新版本的C++程序中应该尽量使用vector、string和迭代器，避免使用内置数组、C风格字符串和指针。 多维数组（Multidimensional Arrays）C++中的多维数组其实就是数组的数组。当一个数组的元素仍然是数组时，通常需要用两个维度定义它：一个维度表示数组本身的大小，另一个维度表示其元素（也是数组）的大小。通常把二维数组的第一个维度称作行，第二个维度称作列。 多维数组初始化的几种方式： 123456789101112int ia[3][4] =&#123; // three elements; each element is an array of size 4 &#123;0, 1, 2, 3&#125;, // initializers for the row indexed by 0 &#123;4, 5, 6, 7&#125;, // initializers for the row indexed by 1 &#123;8, 9, 10, 11&#125; // initializers for the row indexed by 2&#125;;// equivalent initialization without the optional nested braces for each rowint ib[3][4] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11&#125;;// explicitly initialize only element 0 in each rowint ic[3][4] = &#123;&#123; 0 &#125;, &#123; 4 &#125;, &#123; 8 &#125;&#125;;// explicitly initialize row 0; the remaining elements are value initializedint id[3][4] = &#123;0, 3, 6, 9&#125;; 可以使用下标访问多维数组的元素，数组的每个维度对应一个下标运算符。如果表达式中下标运算符的数量和数组维度一样多，则表达式的结果是给定类型的元素。如果下标运算符数量比数组维度小，则表达式的结果是给定索引处的一个内层数组。 123// assigns the first element of arr to the last element in the last row of iaia[2][3] = arr[0][0][0];int (&amp;row)[4] = ia[1]; // binds row to the second four-element array in ia 使用范围for语句处理多维数组时，为了避免数组被自动转换成指针，语句中的外层循环控制变量必须声明成引用类型。 123for (const auto &amp;row : ia) // for every element in the outer array for (auto col : row) // for every element in the inner array cout &lt;&lt; col &lt;&lt; endl; 如果row不是引用类型，编译器初始化row时会自动将数组形式的元素转换成指向该数组内首元素的指针，这样得到的row就是int*类型，而之后的内层循环则试图在一个int*内遍历，程序将无法通过编译。 12for (auto row : ia) for (auto col : row) 使用范围for语句处理多维数组时，除了最内层的循环，其他所有外层循环的控制变量都应该定义成引用类型。 因为多维数组实际上是数组的数组，所以由多维数组名称转换得到的指针指向第一个内层数组。 123int ia[3][4]; // array of size 3; each element is an array of ints of size 4int (*p)[4] = ia; // p points to an array of four intsp = &amp;ia[2]; // p now points to the last element in ia 声明指向数组类型的指针时，必须带有圆括号。 12int *ip[4]; // array of pointers to intint (*ip)[4]; // pointer to an array of four ints 使用auto和decltype能省略复杂的指针定义。 123456789// print the value of each element in ia, with each inner array on its own line// p points to an array of four intsfor (auto p = ia; p != ia + 3; ++p)&#123; // q points to the first element of an array of four ints; that is, q points to an int for (auto q = *p; q != *p + 4; ++q) cout &lt;&lt; *q &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl;&#125;","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"C++ Primer笔记|第二章-变量和基本类型","slug":"C++ Primer/C++primer笔记-第二章-变量和基本类型","date":"2022-02-20T12:25:30.000Z","updated":"2022-06-29T11:37:00.955Z","comments":true,"path":"2022/02/20/C++ Primer/C++primer笔记-第二章-变量和基本类型/","link":"","permalink":"http://icecorn.github.io/2022/02/20/C++%20Primer/C++primer%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"第二章 变量和基本类型变量初始化如果定义变量时未指定初值，则变量被默认初始化（default initialized）。 对于内置类型，定义于任何函数体之外的变量被初始化为0，函数体内部的变量将不被初始化（uninitialized）。 所以类里边的成员变量一定要初始化，不然会有未定义的结果 变量声明和定义的关系声明（declaration）使得名字为程序所知。一个文件如果想使用其他地方定义的名字，则必须先包含对那个名字的声明。(不分配内存) 定义（definition）负责创建与名字相关联的实体。（分配内存，不一定初始化） 如果想声明一个变量而不定义它，就在变量名前添加关键字extern，并且不要显式地初始化变量。 总结：除了用extern修饰变量，其他的声明都是定义。 12extern int i; // declares but does not define iint j; // declares and defines j extern语句如果包含了初始值就不再是声明了，而变成了定义。 变量能且只能被定义一次，但是可以被声明多次。 如果要在多个文件中使用同一个变量，就必须将声明和定义分开。此时变量的定义必须出现且只能出现在一个文件中，其他使用该变量的文件必须对其进行声明，但绝对不能重复定义。 extern用法详解 extern修饰变量的声明： 主要使用的情况是，不同的文件中都需要用到这个变量X（大多数情况是全局变量），而且，extern声明的变量可以在文件中的任何地方声明。 总结：其实就是类似一个引用的手法，在一个项目中只在某一个地方int x = 1;声明加定义（开辟一块内存），这样在其他地方用到这个变量，只需要extern int x；就相当于获得了这个变量的引用，接下来的程序就可以用了。 extern修饰函数声明： 本质的看，变量和函数没有区别，函数名是指向函数二进制块开头处的指针。也就是说extern在这里，也是一样的，如果A文件中有一个函数int fun(),那么想在B文件里用它，就可以extern int fun()就可以用了。 使用extern和包含头文件引用函数有什么区别呢？ 用extern更简洁，想用哪个函数就extern哪个，而不用整体include，另外的还可以加速程序的编译，因为不需要编译不要用到的函数了嘛！ extern还可用于指示C或者C++的调用规范： 比如在C++中调用C的函数，就需要在C++代码中用extern声明要引入的C库函数。这是给链接器看的，告诉链接器在链接的时候用C函数规范来链接。主要原因是C++和C程序编译完成后在目标代码中命名规则不同。 用C语言编写程序的时候，我们经常会遇到这样一种情况：希望在头文件中定义一个全局变量，然后包含到两个不同的c文件中，希望这个全局变量能在两个文件中共用。 举例说明：项目文件夹project下有main.c、common.c和common.h三个文件，其中common.h文件分别#include在main.c和common.c文件中。现在希望声明一个字符型变量key，在main.c和common.c中公用。如下图所示：有人想，既然是想两个文件都用，那就在common.h中声明一个unsigned char key，然后由于包含关系，在main.c和common.c中都是可见的，所以就能共用了。这种想法其实是很多初学者都会想到的，想起来确实有道理，但是实际写出来，我们发现编译的时候编译器提示出错，一般提示大概都类似于：Error: L6200E: Symbol key multiply defined (by common.o and main.o). 也就是说编译器认为我们重复定义了key这个变量。这是因为#include命令就是原封不同的把头文件中的内容搬到#include的位置，所以相当于main.c和common.c中都执行了一次unsigned char key，而C语言中全局变量是项目内（或者叫工程内）可见的，这样就造成了一个项目中两个变量key，编译器就认为是重复定义。正确的解决办法：使用extern关键字来声明变量为外部变量。具体说就是在其中一个c文件中定义一个全局变量key，然后在另一个要使用key这个变量的c文件中使用extern关键字声明一次，说明这个变量为外部变量，是在其他的c文件中定义的全局变量。请注意我这里的用词：定义和声明。例如在main.c文件中定义变量key，在common.c文件中声明key变量为外部变量，这样这两个文件中就能共享这个变量key了。 标识符和名字的作用域标识符： C++的标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。标识符的长度没有限制，但是对大小写字母敏感。C++为标准库保留了一些名字。用户自定义的标识符不能连续出现两个下划线，也不能以下划线紧连大写字母开头。此外，定义在函数体外的标识符不能以下划线开头。 名字的作用域 定义在函数体之外的名字拥有全局作用域（global scope）。声明之后，该名字在整个程序范围内都可使用。 最好在第一次使用变量时再去定义它。这样做更容易找到变量的定义位置，并且也可以赋给它一个比较合理的初始值。 作用域中一旦声明了某个名字，在它所嵌套着的所有作用域中都能访问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字，此时内层作用域中新定义的名字将屏蔽外层作用域的名字。 可以用作用域操作符::来覆盖默认的作用域规则。因为全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，会向全局作用域发出请求获取作用域操作符右侧名字对应的变量。 12345678910111213141516#include &lt;iostream&gt;// Program for illustration purposes only: It is bad style for a function// to use a global variable and also define a local variable with the same nameint reused = 42; // reused has global scopeint main()&#123; int unique = 0; // unique has block scope // output #1: uses global reused; prints 42 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; int reused = 0; // new, local object named reused hides global reused // output #2: uses local reused; prints 0 0 std::cout &lt;&lt; reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; // output #3: explicitly requests the global reused; prints 42 0 std::cout &lt;&lt; ::reused &lt;&lt; &quot; &quot; &lt;&lt; unique &lt;&lt; std::endl; return 0;&#125; 如果函数有可能用到某个全局变量，则不宜再定义一个同名的局部变量。 总结：内部作用域可以用外部的变量，反之不行，内部作用域会覆盖同名外部作用域。可以用：：选择作用域中的变量。 复合类型引用（References）引用为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成&amp;d的形式来定义引用类型，其中d是变量名称。 123int ival = 1024;int &amp;refVal = ival; // refVal refers to (is another name for) ivalint &amp;refVal2; // error: a reference must be initialized 定义引用时，程序把引用和它的初始值绑定（bind）在一起，而不是将初始值拷贝给引用。一旦初始化完成，将无法再令引用重新绑定到另一个对象，因此引用必须初始化。 引用不是对象，它只是为一个已经存在的对象所起的另外一个名字。 声明语句中引用的类型实际上被用于指定它所绑定的对象类型。大部分情况下，引用的类型要和与之绑定的对象严格匹配。 引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起。 指针（Pointer）与引用类似，指针也实现了对其他对象的间接访问。 指针本身就是一个对象，允许对指针赋值和拷贝，而且在生命周期内它可以先后指向不同的对象。 指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。 通过将声明符写成*d的形式来定义指针类型，其中d是变量名称。如果在一条语句中定义了多个指针变量，则每个量前都必须有符号*。 12int *ip1, *ip2; // both ip1 and ip2 are pointers to intdouble dp, *dp2; // dp2 is a pointer to double; dp is a double 指针存放某个对象的地址，要想获取对象的地址，需要使用取地址符&amp;。 12int ival = 42;int *p = &amp;ival; // p holds the address of ival; p is a pointer to ival 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针。 声明语句中指针的类型实际上被用于指定它所指向的对象类型。大部分情况下，指针的类型要和它指向的对象严格匹配。 指针的值（即地址）应属于下列状态之一： 指向一个对象。 指向紧邻对象所占空间的下一个位置。 空指针，即指针没有指向任何对象。 无效指针，即上述情况之外的其他值。 试图拷贝或以其他方式访问无效指针的值都会引发错误。 如果指针指向一个对象，可以使用解引用（dereference）符*来访问该对象。 123int ival = 42;int *p = &amp;ival; // p holds the address of ival; p is a pointer to ivalcout &lt;&lt; *p; // * yields the object to which p points; prints 42 给解引用的结果赋值就是给指针所指向的对象赋值。 解引用操作仅适用于那些确实指向了某个对象的有效指针。 空指针（null pointer）不指向任何对象，在试图使用一个指针前代码可以先检查它是否为空。得到空指针最直接的办法是用字面值nullptr来初始化指针。 旧版本程序通常使用NULL（预处理变量，定义于头文件cstdlib中，值为0）给指针赋值，但在C++11中，最好使用nullptr初始化空指针。 1234int *p1 = nullptr; // equivalent to int *p1 = 0;int *p2 = 0; // directly initializes p2 from the literal constant 0// must #include cstdlibint *p3 = NULL; // equivalent to int *p3 = 0; 建议初始化所有指针。 void*是一种特殊的指针类型，可以存放任意对象的地址，但不能直接操作void*指针所指的对象。 理解复合类型的声明指向指针的指针（Pointers to Pointers）： 123int ival = 1024;int *pi = &amp;ival; // pi points to an intint **ppi = &amp;pi; // ppi points to a pointer to an int 指向指针的引用（References to Pointers）： 12345int i = 42;int *p; // p is a pointer to intint *&amp;r = p; // r is a reference to the pointer pr = &amp;i; // r refers to a pointer; assigning &amp;i to r makes p point to i*r = 0; // dereferencing r yields i, the object to which p points; changes i to 0 面对一条比较复杂的指针或引用的声明语句时，从右向左阅读有助于弄清它的真实含义。 const限定符在变量类型前添加关键字const可以创建值不能被改变的对象。**const变量必须被初始化。** 12const int bufSize = 512; // input buffer sizebufSize = 512; // error: attempt to write to const object 默认情况下，const对象被设定成仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。 如果想在多个文件间共享const对象： 若const对象的值在编译时已经确定，则应该定义在头文件中。其他源文件包含该头文件时，不会产生重复定义错误。 若const对象的值直到运行时才能确定，则应该在头文件中声明，在源文件中定义。此时const变量的声明和定义前都应该添加extern关键字。 1234// file_1.cc defines and initializes a const that is accessible to other filesextern const int bufSize = fcn();// file_1.hextern const int bufSize; // same bufSize as defined in file_1.cc const的引用把引用绑定在const对象上即为对常量的引用（reference to const）。对常量的引用不能被用作修改它所绑定的对象。这里其实就是因为不能用引用来修改原来是const的变量的值，所以不能有非const的引用，我一个本尊都不能修改，能让你一个假身（引用）修改嘛？ 1234const int ci = 1024;const int &amp;r1 = ci; // ok: both reference and underlying object are constr1 = 42; // error: r1 is a reference to constint &amp;r2 = ci; // error: non const reference to a const object 大部分情况下，引用的类型要和与之绑定的对象严格匹配。但是有两个例外： 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。 12345int i = 42;const int &amp;r1 = i; // we can bind a const int&amp; to a plain int objectconst int &amp;r2 = 42; // ok: r1 is a reference to constconst int &amp;r3 = r1 * 2; // ok: r3 is a reference to constint &amp;r4 = r * 2; // error: r4 is a plain, non const reference 允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。 12double dval = 3.14;const int &amp;ri = dval; 指针和const（Pointers and const）指向常量的指针（pointer to const）不能用于修改其所指向的对象。常量对象的地址只能使用指向常量的指针来存放，但是指向常量的指针可以指向一个非常量对象。 123456const double pi = 3.14; // pi is const; its value may not be changeddouble *ptr = &amp;pi; // error: ptr is a plain pointerconst double *cptr = &amp;pi; // ok: cptr may point to a double that is const*cptr = 42; // error: cannot assign to *cptrdouble dval = 3.14; // dval is a double; its value can be changedcptr = &amp;dval; // ok: but can&#x27;t change dval through cptr 定义语句中把*放在const之前用来说明指针本身是一个常量，常量指针（const pointer）必须初始化。 1234int errNumb = 0;int *const curErr = &amp;errNumb; // curErr will always point to errNumbconst double pi = 3.14159;const double *const pip = &amp;pi; // pip is a const pointer to a const object 指针本身是常量并不代表不能通过指针修改其所指向的对象的值，能否这样做完全依赖于其指向对象的类型。 顶层const（Top-Level const）顶层const表示指针本身是个常量，底层const（low-level const）表示指针所指的对象是一个常量。指针类型既可以是顶层const也可以是底层const。 123456int i = 0;int *const p1 = &amp;i; // we can&#x27;t change the value of p1; const is top-levelconst int ci = 42; // we cannot change ci; const is top-levelconst int *p2 = &amp;ci; // we can change p2; const is low-levelconst int *const p3 = p2; // right-most const is top-level, left-most is notconst int &amp;r = ci; // const in reference types is always low-level 当执行拷贝操作时，常量是顶层const还是底层const区别明显： 顶层const没有影响。拷贝操作不会改变被拷贝对象的值，因此拷入和拷出的对象是否是常量无关紧要。 12i = ci; // ok: copying the value of ci; top-level const in ci is ignoredp2 = p3; // ok: pointed-to type matches; top-level const in p3 is ignored 拷入和拷出的对象必须具有相同的底层const资格。或者两个对象的数据类型可以相互转换。一般来说，非常量可以转换成常量，反之则不行。 这种就想，如果能把常量转换成非常量的话，这就代表你这个新的指针可以随便改这个值，那原来的变量又怎么能叫做常量呢？ 12345int *p = p3; // error: p3 has a low-level const but p doesn&#x27;tp2 = p3; // ok: p2 has the same low-level const qualification as p3p2 = &amp;i; // ok: we can convert int* to const int*int &amp;r = ci; // error: can&#x27;t bind an ordinary int&amp; to a const int objectconst int &amp;r2 = i; // ok: can bind const int&amp; to plain int constexpr和常量表达式（constexpr and Constant Expressions）常量表达式（constant expressions）指值不会改变并且在编译过程就能得到计算结果的表达式。 一个对象是否为常量表达式由它的数据类型和初始值共同决定。 1234const int max_files = 20; // max_files is a constant expressionconst int limit = max_files + 1; // limit is a constant expressionint staff_size = 27; // staff_size is not a constant expressionconst int sz = get_size(); // sz is not a constant expression C++11允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。 123constexpr int mf = 20; // 20 is a constant expressionconstexpr int limit = mf + 1; // mf + 1 is a constant expressionconstexpr int sz = size(); // ok only if size is a constexpr function 指针和引用都能定义成constexpr，但是初始值受到严格限制。constexpr指针的初始值必须是0、nullptr或者是存储在某个固定地址中的对象。 函数体内定义的普通变量一般并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反，函数体外定义的变量地址固定不变，可以用来初始化constexpr指针。 在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针本身有效，与指针所指的对象无关。constexpr把它所定义的对象置为了顶层const。 123constexpr int *p = nullptr; // p是指向int的const指针constexpr int i = 0;constexpr const int *cp = &amp;i; // cp是指向const int的const指针 const和constexpr限定的值都是常量。但constexpr对象的值必须在编译期间确定，而const对象的值可以延迟到运行期间确定。 建议使用constexpr修饰表示数组大小的对象，因为数组的大小必须在编译期间确定且不能改变。 处理类型（Dealing with Types）类型别名（Type Aliases）类型别名是某种类型的同义词，传统方法是使用关键字typedef定义类型别名。 12typedef double wages; // wages is a synonym for doubletypedef wages base, *p; // base is a synonym for double, p for double* C++11使用关键字using进行别名声明（alias declaration），作用是把等号左侧的名字规定成等号右侧类型的别名。 1using SI = Sales_item; // SI is a synonym for Sales_item auto类型说明符（The auto Type Specifier）C++11新增auto类型说明符，能让编译器自动分析表达式所属的类型。auto定义的变量必须有初始值。 12// the type of item is deduced from the type of the result of adding val1 and val2auto item = val1 + val2; // item initialized to the result of val1 + val2 编译器推断出来的auto类型有时和初始值的类型并不完全一样。 当引用被用作初始值时，编译器以引用对象的类型作为auto的类型。 12int i = 0, &amp;r = i;auto a = r; // a is an int (r is an alias for i, which has type int) auto一般会忽略顶层const。因为是赋值出来的另一个变量，独立的内存 12345const int ci = i, &amp;cr = ci;auto b = ci; // b is an int (top-level const in ci is dropped)auto c = cr; // c is an int (cr is an alias for ci whose const is top-level)auto d = &amp;i; // d is an int*(&amp; of an int object is int*)auto e = &amp;ci; // e is const int*(&amp; of a const object is low-level const) 如果希望推断出的auto类型是一个顶层const，需要显式指定const auto。 1const auto f = ci; // deduced type of ci is int; f has type const int 设置类型为auto的引用时，原来的初始化规则仍然适用，初始值中的顶层常量属性仍然保留。 123auto &amp;g = ci; // g is a const int&amp; that is bound to ciauto &amp;h = 42; // error: we can&#x27;t bind a plain reference to a literalconst auto &amp;j = 42; // ok: we can bind a const reference to a literal decltype类型指示符（The decltype Type Specifier）C++11新增decltype类型指示符，作用是选择并返回操作数的数据类型，此过程中编译器不实际计算表达式的值。 1decltype(f()) sum = x; // sum has whatever type f returns decltype处理顶层const和引用的方式与auto有些不同，如果decltype使用的表达式是一个变量，则decltype返回该变量的类型（包括顶层const和引用）。 1234const int ci = 0, &amp;cj = ci;decltype(ci) x = 0; // x has type const intdecltype(cj) y = x; // y has type const int&amp; and is bound to xdecltype(cj) z; // error: z is a reference and must be initialized 如果decltype使用的表达式不是一个变量，则decltype返回表达式结果对应的类型。如果表达式的内容是解引用操作，则decltype将得到引用类型。如果decltype使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，则decltype会得到引用类型，因为变量是一种可以作为赋值语句左值的特殊表达式。 decltype((var))的结果永远是引用，而decltype(var)的结果只有当var本身是一个引用时才会是引用。 自定义数据结构（Defining Our Own Data Structures）C++11规定可以为类的数据成员（data member）提供一个类内初始值（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员，没有初始值的成员将被默认初始化。 类内初始值不能使用圆括号。 类定义的最后应该加上分号。 头文件（header file）通常包含那些只能被定义一次的实体，如类、const和constexpr变量。 头文件一旦改变，相关的源文件必须重新编译以获取更新之后的声明。 头文件保护符（header guard）依赖于预处理变量（preprocessor variable）。预处理变量有两种状态：已定义和未定义。#define指令把一个名字设定为预处理变量。#ifdef指令当且仅当变量已定义时为真，#ifndef指令当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到#endif指令为止。 12345678910#ifndef SALES_DATA_H#define SALES_DATA_H#include &lt;string&gt;struct Sales_data&#123; std::string bookNo; unsigned units_sold = 0; double revenue = 0.0;&#125;;#endif 在高级版本的IDE环境中，可以直接使用#pragma once命令来防止头文件的重复包含。 预处理变量无视C++语言中关于作用域的规则。 整个程序中的预处理变量，包括头文件保护符必须唯一。预处理变量的名字一般均为大写。 头文件即使目前还没有被包含在任何其他头文件中，也应该设置保护符。","categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"}]},{"title":"计算机网络--应用层","slug":"计算机网络/计算机网络--应用层","date":"2022-02-16T11:25:30.000Z","updated":"2022-06-29T10:21:15.875Z","comments":true,"path":"2022/02/16/计算机网络/计算机网络--应用层/","link":"","permalink":"http://icecorn.github.io/2022/02/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E5%BA%94%E7%94%A8%E5%B1%82/","excerpt":"","text":"计算机网络–应用层本章主要掌握各种应用层协议的使用方法和实现方法 常见的基于UDP和TCP的应用 1 域名系统DNS我们打开一个网页比如百度通常是使用www.baidu.com而不是它的ip地址加端口号，这就是靠域名服务器进行域名解析实现的。主机发送DNS请求报文（使用UDP）给**域名服务器**，收到响应中的ip地址后可与目的主机进行通信。 全球只用一个域名服务器显然是不现实的，所以域名服务器实际上是一个分布式系统，并且按如下划分了域名空间 权限域名服务器：负责一个区的域名服务器，一般是一个公司内部的，比如可以划分abc.com和y.abc.com 本地域名服务器：又叫做默认域名服务器，一般是离主机最近的服务器 主机向本地域名服务器的查询一般采用递归查询 本地服务器向根服务器的查询一般采用迭代查询，当然也可以用递归查询 递归查询就是自己只发送一次查询报文然后剩下的一层层处理最后拿个结果就好了（小弟派小弟层层转包） 迭代查询是自己发送查询接收响应反复操作最后得到结果（事必躬亲） 2 文件传送协议FTP基于TCP，TFTP基于UDP 2.1 FTP协议FTP使用客户服务器方式，FTP服务器由一个主进程和若干个从属进程组成，这是因为FTP服务器要接收好多个客户的请求，每次和一个客户连接后马上给这个客户分配几个从属进程，快点把主进程空出来给别的客户访问 对于一个主机来说，与服务器一般建立两个TCP连接，一个控制进程，一个数据传送进程，通信中控制进程一直连接着吗，因此FTP控制信息是带外的 TCP只能整体传送文件，这就有了网络文件系统NFS，它可以允许应用程序只读取并修改指定位置的信息，减少了通信量 2.2 TFTP协议基于UDP的超级简单的协议，只支持传输不支持交互 优点： 多个主机同时从服务器下载东西（因为UDP可以一对多嘛，可以理解类似于多播） 开销小，占内存小，这就适合很多不需要太多功能的开源硬件 另外虽然UDP是不可靠传输，但TFTP类似与停止等待协议，这就是靠应用层实现传输控制来保证的 2.3 远程终端协议TELNET用来远程控制桌面的东东，只需要知道怎么用以及它是基于TCP的就ok 3 万维网协议就是我们熟悉的www啦，了解万维网，主要了解一下几个问题： 怎样标志分布在整个互联网上的各种万维网文档？ URL 用什么协议实现万维网的连接？ HTTP 不同风格的文档在不同主机怎么显示？ HTML 怎样查找需要的信息？ 搜索引擎 3.1 统一资源定位符URL相当于互联网上任一文件的指针，一般形式为： &lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt; 协议常见的有http，ftp等，端口和路径可以省略 3.2 超文本传输协议HTTPHTTP是面向事务的应用层协议，基于TCP 特点： 无连接的：意思就是http不用先建立连接再通信，因为是基于TCP的，由TCP来保证可靠传输 无状态的： 意思是同一个客户再来访问结果还是一样，服务器不会记得 面向文本： 意思是http报文中的每一个字段都是一些ASCII码，长度是由用户输入决定的 http首先要与服务器建立TCP连接，这就需要3次握手，由传输层的知识我们知道这样就会导致客户实际收到消息时需要2RTT的时间间隔，而http1.0协议使用非持续传输，意思就是访问这个网页（服务器不同路径）上的任何一个元素都需要重新建立TCP连接，这就会浪费好多个2RTT时间 所以http1.1采用了持续连接，意思就是访问同一个服务器上东西的时候TCP连接不用断开，就用着一个就完事了，省下来很多握手时间，具体方式还分为流水线和非流水线方式，不赘述了 代理服务器，又叫做万维网高速缓存 这玩意就是保存了一个局域网内最近主机的请求和响应信息，当又有主机访问相同的资源的时候就不用再去远端查找了。这就减少了链路的通信量。 HTTP的报文结构 主要就是请求报文和响应报文 3.3 万维网文档超文本标记语言HTML：用于在浏览器上显示数据 可扩展标记语言XML： 用于传输数据 可扩展超文本标记语言XHTML： 更严格的html版本 层叠样式表CSS： 用于定义html文档布局 动态文档 上述都是静态文档，而动态文档只是文档的生成方法不同，静态文档只要放在服务器上就ok了，动态文档允许客户和服务器进行交互，也就是说服务器获取到客户的信息后进行一系列处理之后生成文档 这就需要在服务器中新增加一个应用程序叫做CGI程序，也叫作CGI脚本。 活动文档 它是用来满足更复杂的需求比如动画交互之类的，如果一直让服务器来传送的话太浪费资源，所以活动文档相当于是在服务器上的一个静态文档，类似一个浏览器可执行的小应用程序，现在常用的JS脚本 3.4 万维网的信息检索系统分为两种： 全文检索搜索： 比如谷歌百度这种，本质是使用爬虫在数据库里搜索相关信息 分类目录搜索： 比如门户网站这些，已经给你分配好了的专栏 4 电子邮件主要涉及简单邮件传送协议SMTP，互联网邮件扩充MIME，邮局协议POP3，网际报文存取协议IMAP 要注意的是这些都是基于TCP的 上图基本给出了用户代理，发送方和接收方邮件服务器的作用 由于SMTP有以下缺点： 不能传送可执行文件和其他的二进制对象 只能传送7位的ASCII码，导致其他国家文字不能传输 SMTP服务器会拒绝超出一定长度的邮件 将制表符tab转换为若干个空格 由此提出了互联网扩充协议MIME 具体看书吧，记住有了MIME实现了上述这些功能就行了 两种接收协议的特点： POP3： 优点：简单 缺点：邮件读了后就自动删除了 IMAP： 优点：可以在不同主机上随时处理邮件服务器的邮件，支持阅读部分邮件 缺点：必须上网连接IMAP服务器才能阅读邮件 互联网邮箱： 现在多数都是这些，记住浏览器和互联网上的邮件服务器通信使用的是HTTP协议，而邮件服务器之间通信使用SMTP即可 5 动态主机配置协议DHCPDCHP使用UDP进行传输。就是动态的分配IP地址，子网掩码，默认路由地址，域名服务器地址（就是我们常用的自动配置IP） 一个新的主机第一次连接到一个网络，按照以下步骤： 主机发送广播（目的地址全1）给网络中的DCHP中继代理（一般是一个路由器） 路由器发送单播告诉DCHP服务器 DCHP发送响应给主机A 注意两点： 主机在一个网络中连了一次网，分配的IP就记录在DCHP服务器中了，下次联网还是这个IP地址 给了IP地址后，不是一直可以使用的，有一个租用期，长短有DCHP服务器控制，过半后主机发送续租报文，服务器同意就续上，不同意就不能用这个IP了 6 P2P应用6.1 集中服务器的P2P工作方式在集中式目录服务器中建立一个数据库保存哪个资源都哪些主机有，这是要想下载一个东西就先去集中服务器查找，返回一串主机，在选一个主机进行下载 6.2 全分布式结构P2P共享程序使用洪泛法，在网络内进行有限范围的洪泛查询，具有代表性的就是BT种子了（某播：技术是无罪的==） P2P的本质就是惠人惠己，比如我们要下载一部小电影，实际上在p2p网络中这个小电影是由好多个文件块组成的，有好多主机上边都有这些文件块，可能这个给你一块那个给你一块那么我们就能很快把这个小电影下载完，当然之后我们电脑上有这个文件了（即使一些文件块）也要给别人下载，不能太自私啦。这些和我们互相交互下载文件块的主机叫做对等方。 同时在发送过程中有两个规则： 最稀有优先：意思就是小电影中哪个文件块在现在网上拥有的数目最少就要先下载哪个，不然那些主机都下线最后少了这个文件块导致看不了小电影就很难受QAQ 优先发送对等方选择：前面说我们也要给别人下载，那么怎么确定优先给谁发呢？当然要优先发给给我们发送文件块的对等方了（按速率排序，互惠互利）。一般保持4个最高速的对等方，这些对等方叫已疏通的或无障碍的对等方 还有一个问题就是分布式结构到底怎么确定小电影在哪些主机上有呢？ 洪泛法的效率太低且浪费资源，所以最好还是建立一个分布式数据库，又不能像集中式服务器那样，所以现在有个算法是分布式散列表，具体内容再看吧QAQ 7 应用进程和系统调用我们知道程序员的业务逻辑代码基本都是在应用层，对运输层的控制很少（只能设置最大数据长度MSS等），那么进行网络编程时实际上都是使用API（也可以说套接字）来对接操作系统从而实现网络通信 进行TCP的基本API调用流程如下，细节的话联系操作系统","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--运输层","slug":"计算机网络/计算机网络--运输层","date":"2022-02-14T06:16:07.000Z","updated":"2022-06-29T10:20:45.416Z","comments":true,"path":"2022/02/14/计算机网络/计算机网络--运输层/","link":"","permalink":"http://icecorn.github.io/2022/02/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E8%BF%90%E8%BE%93%E5%B1%82/","excerpt":"","text":"计算机网络–运输层1. 运输层基本概念运输层向应用层提供通信服务，在运输层中，通信的真正端点不是主机而是主机中的进程 网络层为主机之间提供逻辑通信，运输层为应用进程提供端到端的逻辑通信 运输层连个主要协议： 用户数据报协议UDP（不用连接） 传输控制协议TCP（面向连接） 运输层支持复用和分用，方法是使用协议端口号（端口） 这里的端口号是指软件端口，分为两大类： 服务器端使用的端口号 1.熟知端口号（系统端口号）： 0~1023 比如FTP是21 2.登记算口号： 1024~49151 其他应用使用的 客户端使用的端口号 数值49152~65535 在客户进程运行时才动态选择，又叫短暂端口号 ，在不同主机可以随意分配 2 用户数据报协议UDPUDP在IP数据报服务上增加了复用分用功能和差错检测功能 主要特点： 是无连接的 尽最大努力交付： 即不保证可靠交付 是面向报文的： 意思是UDP接收到应用层报文不做任何操作仅仅加上UDP首部就构成了UDP报文，这就要求应用层控制报文大小（太大会导致IP报文需要分片，太小导致传输效率太低） 没有拥塞控制 支持1对1,1对多，多对1，多对多的交互通信 首部开销小： 只有8字节 UDP 首部格式 首部共8字节，四个字段，分别是源端口 目的端口 长度（UDP报文总长度，最小为8只有首部） 检验和 每个字段2字节 伪首部只在计算检验和时被用于计算，检验方法类似IP数据报首部校验方法，区别是UDP的校验是把首部和数据部分一起都检验 3 传输控制协议TCPTCP具有可靠传输，流量控制，拥塞控制等等功能 主要特点： 面向连接：通信前必须建立TCP连接 点对点：每一条TCP连接只能有两个端点，即只能1对1传输 提供可靠交付： 无差错，不丢失，不重复，按序到达 全双工通信：TCP连接两端设有发送缓存和接收缓存 面向字节流：对TCP来说应用程序发送的数据仅仅看成一连串无结构的字节流，TCP不理解这些玩意代表啥意思，只是必须把这些字节流按照顺序完整的传达到终点，它的任务就完成了。解析的活就交给终端处理就好 这里有一个UDP与TCP的差别就是，UDP发送的报文长度是应用进程给出的，而TCP是根据对方的窗口值和网络拥塞之类的自己判断（如果应用数据太长就分几段，太短就攒几个一起发） TCP连接的端点叫套接字socket，将端口号拼接到IP地址就是套接字 比如 192.3.4.5:80 TCP把连接作为最基本的抽象，每条TCP连接唯一的被通信两端的套接字确定 TCP连接::={socket1,socket2}={(IP1:port1),(IP2,port2)} 4 TCP报文段首部格式TCP首部前20字节是固定的，后边可根据需要增加4n字节 源端口和目的端口：各占2字节，目的是实现分用 序号：4字节，TCP是面向字节流的，所以该字段是指本报文段所发送的第一个字节的序号 确认号：4字节，是期望收到对方下一个报文段的第一个数据字节序号 数据偏移：4位，和IP数据报中的首部长度类似，表示的是TCP首部的实际长度（最大二进制15,4字节为单位，所以TCP首部最大也是60字节） 保留：目前没用，置0 紧急URG：1位，置1时代表高优先级优先发送 确认ACK：1位，置1时才有效，TCP连接建立后所有报文ACK都为1 推送PSH：1位，表示接收端收到就上交给应用层（不用少量信息攒一波），很少用 复位RST：1位，TCP连接出现严重差错，该字段置1重建连接 同步SYN：1位，建立连接时用来同步序号，置1表示这是一个连接请求或连接接受报文 终止FIN：1位，用来释放一个连接，置1表示发送方数据发送完毕，请求释放运输连接 窗口：2字节，是指发送本报文段的一方的接收窗口 检验和：2字节，检验首部和数据两部分，和UDP一样计算时也加伪首部 紧急指针：2字节，仅在URG置1时有意义，指出紧急数据在的末尾在此报文段中的位置 选项：长度可变，最多40字节 5 可靠传输的原理和实现TCP是面向连接且可靠的传输协议，理想的传输协议需要具备以下两点： 传输信道不产生差错 不管发送方以多快的速度发送分组，接收端总能正确接收并处理 5.1 停止等待协议停止等待是最简单的可靠传输，A发生完一个分组就停止发送等待对方的确认 超时重传：当发送方发送的分组出现差错没有送达接收方，就会启动超时重传机制，A每发送一个分组立刻设置一个超时计时器。这里有三点需要注意： A发送一个分组后，必须暂时保留该分组副本，收到确认后才删除 分组和确认分组都要进行编号，对于停止等待来说 0和1两个编号循环使用就行 超时重传时间应该设置的比数据传输的平均往返时间长一些 确认丢失时B忽略第二次收到的重复分组并发送确认给A 确认迟到B同样忽略第二次收到的重复分组，A忽略重复确认 这样我们就在不可靠的传输网络上实现了可靠通信，这种可靠传输协议叫做自动重传请求ARQ 5.2 流水线传输停止等待协议的优点是简单，但缺点是信道利用率太低，所以出现了流水线传输。流水线传输需要用到连续ARQ协议，回退N帧（gobackN）协议，滑动窗口协议等等 连续ARQ协议： 发送方根据接收方的窗口参数和自身的发送缓存决定窗口大小，窗口内的分组都是可以发送的，每收到一个确认窗口就向前移动一个分组 累计确认：接收方不用每收到一个分组就发送一条确认，而是攒几个发送一个确认（按序到达的最后一个分组编号）即可。 累计确认的优点是容易实现，减少了通信量，即使确认丢失也不用重传。 累计确认的缺点是不能向发送方反应已经正确收到的所有分组信息 比如发送了前5个分组，接收方收到了1 2 4 5，那么接收方直接发送收到了2，这样发送方就必须重新发送3 4 5，哪怕4 5 已经收到了，这就叫做回退N帧协议（Go-back-N） 5.3 滑动窗口协议滑动窗口协议其实就是以字节为单位的连续ARQ协议，但是研究的时候通常也可以以分组为单位研究 这里要注意以下几点： A根据B可接收的窗口大小和A的发送缓存大小（取较小值）来确定A的发送窗口，当然有时还可以根据拥塞状况适当减小。 发送窗口中已发送数据在没收到确认之前不能删除 接收方一定要支持累计确认功能，减小传输开销 TCP是全双工通信，通信双方都有发送窗口和接收窗口 5.4 超时重传时间的选择重传时间的选择是TCP中最复杂的问题，TCP采用一种自适应的算法线算出报文段的往返时间RTT，再计算一个加权平均往返时间RTTS。 不想写了，用到的话看书吧QAQ 5.5 选择确认SACK若接收方收到的分组无差错，只是没按序号，或者只有中间的几个分组丢失了，能不能告诉发送方只发送这几个分组？ 没错，这玩意就是解决这个问题的，要在TCP建立连接时在扩展首部里加上“允许SACK”选项 具体内容不写了，QAQ 6 TCP流量控制6.1 利用滑动窗口实现流量控制流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收 TCP是面向字节流的，seq代表发送字节的序号，ACK是确认位，ack是确认编号，rwnd是接收端允许发送端发送的数据窗口大小 图中最后rwnd置0，说明此时A不能再发送字节了，要是之后B发送重置rwnd时确认丢失，就会产生死锁，解决方案就是TCP的每条连接都有一个持续计时器，在发送端收到rwnd置0消息时开启，超时后发送端发送一个1字节的零窗口探测报文段，这样接收端就知道响应报文丢失了。 6.2 TCP的传输效率对于UDP来说，什么时候发送报文是应用程序决定的，UDP只需要原封不动的转发就行。但是对于TCP，应用进程把数据传送到TCP的发送缓存后就不管了，所以TCP是什么时候发送报文就是一个很重要的问题，有下面几种机制来发送： TCP维持一个最大报文段长度MSS变量，只要缓存中数据达到MSS字节就发送 发送方的应用进程指明要求发送报文段，即TCP支持推送操作 用一个计时器规定时间，到点发送 Nagle算法：发送方先发送第一个数据字节，将后续应用程序输入的字节保存在发送缓存，收到接收方的确认后，将攒了一波的数据发送出去（当然不能超过MSS），同时继续保存发送缓存。在收到接收方确认，再发送数据报。另外，当发送缓存中数据已经到达窗口大小的一半或已达到报文段的最大长度时，就立即发送一个报文段。 糊涂窗口综合症： 这个玩意是指TCP接收方的缓存已经满了，并且接受方的应用程序比较懒，一次处理一个字节，那么接收缓存每次仅仅空出一个字节还每次都发送确认（并把rwnd设置为1，导致发送方每次有效传输只有1字节），发送1字节还要加上TCP首部20字节，IP首部20字节，这样效率实在太低 解决方案可以让接收方等一会，等接收缓存空出来一个最大报文段或者等到接收缓存有一半以上空地方 总结： 发送效率主要就是要减少40字节的首部的占比，所以记住发送方别发送太短的报文，接收方也别没事就发信号让发送方发报文就完事了。 6.3 吞吐量吞吐量是指一个传输周期内传输的字节速率，注意单位是bit/s，经常会有和发送窗口相关的计算题 一个TCP连接下面使用256Kb/s的链路，其端到端时延为128ms。经测试，发现吞吐量只有120kb/s，则发送窗口大约是 A．3614字节B．7228字节C．57826字节D．120k比特 本题目主要考查的是“TCP流量控制”。为了提高报文段的传输效率，TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位为字节。发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。发送端利用发送窗口调节向网络注入分组的速率不仅是为了使接收端来得及接收，而且还是为了对网络进行拥塞控制。在每一个运输连接上报文段是断续发送的，这样就有了两种速率。一种是链路层的数据率，另一种是从运输层看到的数据注入速率。题目中给出端到端时延为128ms，则在一个传输周期里，从发送第一个报文段到收到所有确认时间为：W/R+2T，其中w为发送窗口的大小，R为链路速率，T为端到端时延。因此吞吐量TP=W/(W/R+2T)，将题目中的具体数据代入，即可求得W=7228字节。 7 TCP的拥塞控制7.1 拥塞控制概念拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不会过载 拥塞控制和流量控制的区别是：拥塞控制涉及到是整条通信线路上所有的资源（主机，路由器，链路等等），所以需要控制调整的措施也比较复杂。而流量控制是端到端的交流，就是接收端告诉发送端你慢点，我吃不消了QAQ 拥塞控制主要分为两种方法： 开环控制：在设计网络时将会导致拥塞的因素都考虑到，运行时就基本不能改了 闭环控制：基于反馈环路，几种措施 ​ 1.监测网络拥塞发生在何处 ​ 2.把拥塞信息传达到可以采取行动的地方 ​ 3.调整网络系统的运行解决问题 7.2 TCP的拥塞控制方法TCP进行拥塞控制的算法有四种：慢开始 拥塞避免 快重传 快恢复 首先，发送当要维持一个拥塞窗口cnwd变量，发送方让自己的发送窗口等于拥塞窗口，cnwd的单位是发送方的最大报文段SMSS，一般初始设置为1。 慢开始：意思就是初始cnwd设置为1，然后以指数方式增长 拥塞避免：当cnwd超过预设门限值ssthresh时，改为线性增大，尽量避免拥塞发生 快重传： 为了避免发送方一检测到超时就进行慢开始（有时候超时不意味着拥塞），快重传就是说发送方收到连续3次确认（因为中间一个数据报丢了，后边的收到了累计确认），这时发送方直接重传丢失数据报 快恢复： 3ACK后不进行慢开始，而是直接把cnwd置为一半 这就是所谓的加法增大，乘法减小 另外发送窗口大小还取决于接收方的通知窗口，所以发送窗口取值=MIN[rnwd,cnwd] 主动队列管理AQM 在通信链路中的路由器中，路由器缓存队列一般都是先进先出，而一旦发生拥塞后来的分组就会被路由器丢弃，那么发送方就会进行慢开始，而由于TCP的复用特性（路由器接到的都是IP数据报，同一个IP地址可能包装了不同的端口号），这就会导致一时间整个网络很多的TCP连接都慢开始了，这种现象叫全局同步，严重影响了传送效率 而AQM就是解决这个问题的，AQM其中一种方法叫随机早期检测RED，其实就是给路由器的缓存设置一个门限值，不让它到满了的时候再丢弃，用一个随机算法在它超过门限时就随机丢弃，这就保证了不是所有TCP都会同时慢开始了。 8.TCP的运输连接管理TCP连接三个阶段：连接建立，数据传送，连接释放 TCP连接建立采用客户服务器方式 8.1 连接建立就是著名的三次握手啦 SYN报文不允许携带数据，但是消耗一个序号 ACK报文携带数据的话消耗序号，不携带的话不消耗序号 为什么最后A一定要在发送一次确认给B呢？ 这是因为假设A发送请求滞留在路由器里导致超时了，这是A以为报文丢了就重发了一个请求与B建立了连接通信后又断开连接。然后这是A的第一个请求报文到达了B，B就会发送确认给A，此时A知道已经连接完了不搭理B，但B还会傻傻的等着A给他发消息，这就浪费了很多资源。 8.2 连接释放四次挥手 FIN不携带数据，但是消耗序号 ACK不携带数据不消耗序号，携带消耗 MSL叫做最长报文段寿命，为什么time-wait状态后要有2MSL等待时间呢？ 1.因为B再发送完FIN-ACK确认报文后还在等着A发送确认，而A的最后一个确认报文可能会丢失，丢失了B收不到确认就会发送重传，此时如果没有2MSL时间A直接结束了连接，B就会一直发确认，资源浪费 2.就是上边提到的A重复发送连接请求，第一个请求延迟到达了的情况，有了2MSL就能使本连接持续时间内产生的所有报文段都从网络中消失 保活计时器：有时候建立连接后客户端突然挂掉，这是服务器就会一直等着，所以要有这个保活计时器，服务器没收到一次数据就重置保活计时器，时间大约2小时，2小时没有新的数据，服务器就发送一个探测报文段，每75s发送一次，连续10次无反应服务器就关闭连接 8.3 TCP状态机","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--网络层","slug":"计算机网络/计算机网络--网络层","date":"2022-02-13T08:53:09.000Z","updated":"2022-06-29T10:20:16.253Z","comments":true,"path":"2022/02/13/计算机网络/计算机网络--网络层/","link":"","permalink":"http://icecorn.github.io/2022/02/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%BD%91%E7%BB%9C%E5%B1%82/","excerpt":"","text":"计算机网络–网络层1 网络层的两种服务形式一种是虚电路服务，另一种是数据报服务，虚电路面向连接的通信方式，在分组交换中建立一条虚电路来预留通信双方所需的一切网络资源，这样在网络层实现可靠传输。数据报服务是采用分组传输方式，网络层向上只提供简单的，无连接的，尽最大努力的不可靠传输。 本质是是否要在网络层实现可靠传输的问题，由于现在的终端相比于过去的电话设备具有更强的处理能力，所以现在数据报服务成为主流，将可靠传输的实现上移到传输层和用户主机由TCP处理。 对比 虚电路 数据报 思路 可靠通信由网络层保证 可靠通信由用户主机保证 连接建立 必须有 不需要 终点地址 仅在建立连接时使用，每个分组使用短的虚电路号 每个分组都有终点的完整地址 分组转发 同一条虚电路分组由同一路由器转发 每个分组独立选择路由器转发 结点故障 所有通过故障结点的虚电路均不能工作 出故障结点可能会丢失分组，但可以选择其他路由器发送分组 分组的顺序 总是按发送顺序到达终点 到达终点不一定按先后顺序 端到端差错处理及流量控制 可以由网络负责也可以由用户主机负责 由用户主机负责 2 网际协议IPIP协议是很重要的协议，它也是一族协议 除了IP协议外还有与之配套的 地址解析协议 ARP 网际控制报文协议 ICMP 网际组管理协议 IGMP 要把世界上数以万计的网络连接起来是非常复杂的，并且没有一种网络能够满足所有用户的需求。所以，在网络层使用IP协议构成一个虚拟互连网络，也就是说对于ip协议的网络层，下边的数据链路层和物理层是透明的。 2.1 分类的IP地址IP地址就是给互联网上每一台主机或路由器分配一个全世界范围内唯一的32位的标识符，这里只研究IPv4。 IP地址的编码方式经历了三个阶段： 分类的IP地址 划分子网 构成超网 本节研究分类的IP地址，就是将IP地址划分为若干个固定类，每一类地址由两个固定长度字段组成，第一个字段是网络号，第二个阻断是主机号，全网唯一 分为以下几类： 其中A B C类都是单播地址（1对1） A B C类地址网络号分别为1,2,3字节，且网络号前边类别位分别为0,10,110 D类地址是多播地址，类别位1110 E类地址目前不使用 采用点分十进制来记录IP，如128.0.0.1 常见的三类IP地址 对于A B C类IP地址来说，都有几个不能指派的网络号和主机号 对A类地址，网络号全0不能指派，用来表示“此网络”，全1也不能指派，用来表示“环回测试”；主机号全0表示“本主机”，全1表示“所有主机” 对B类和C类地址，因为网络号有类别码10和110故不存在全0全1，但去除掉类别码后的网络号也不能设置为全0，表示的意义和A类一样；主机号也不能全0全1 IP地址特点： 由网络号+主机号组成，分配时只分配网络号，主机号由单位自行分配。另一个好处是路由器转发时可以根据网络号转发分组，减少路由表存储空间 实际上IP地址标志一台主机和一条链路的接口，这意味着路由器两端连接两个网络就必然拥有两个IP地址，而连接两个网络的主机叫做多归属主机 一个网络通常是指网络号相同的网络，所以用转发器和网桥连接起来的局域网通常认为是一个网络 IP地址中，所有分配到网络号的网络都是平等的 2.2 IP地址和硬件地址IP地址是逻辑地址，封装在IP数据报首部 硬件地址是物理地址，存放在适配器ROM中，封装在MAC帧首部 这里只要记住通信时网络层，数据链路层同一层级的传输都是透明的，即不需要考虑封装帧，解析帧之类的。可以理解为网络层直接传送IP数据报，数据链路层只传送MAC帧。 那么有一个问题是路由器转发IP数据报需要包装成MAC帧格式在数据链路层传输，怎么才能知道要添加的MAC地址是多少呢？换句话说怎样通过目的IP得到目的MAC地址？这就需要使用ARP地址解析协议了。 2.3 地址解析协议ARP主要作用就是根据目的IP地址找出目的MAC地址，实现方法是在每一个主机都设有一个ARP高速缓存，里边保存本局域网上各主机和路由器的IP地址到MAC地址映射表。主机A要向B发送IP数据报时，先去高速缓存查找B的映射，如果有直接就找到了，没有的话就要运行ARP根据以下步骤找到B的MAC地址。 ARP进程在本局域网上广播一个ARP请求分组，主要内容是“我的IP地址是xxx。MAC地址是xxx，我想知道IP地址是XXX的主机的硬件地址” 本局域网上所有主机的ARP进程都收到消息 主机B发现A要找的人是自己，，向A发送一个响应分组（注意这里是单播） 内容是“我的IP地址是XXX，我的MAC地址是XXX”，同时把A的映射记录在自己的高速缓存中（这一步是为了以后B向A发消息方便），非B的其他主机当然对A发送的请求分组不理睬 A收到B的响应，将B的映射记录在高速缓存中 总结就是一个喊话（广播）找人的过程，且找人必须要先自报家门让别人可以响应，喊道谁的名字谁就答应（单播），并且互相都把对方的映射记录了下来，这就方便了之后再进行通信，否则每次都要广播喊话再响应浪费资源。 另外，ARP高速缓存每一份映射都要设置生存时间（如10~20分钟），这是因为适配器可能会故障，比如B的适配器坏了，MAC地址失效了，A用失效的MAC地址也找不到B，留着没用还浪费资源，所以定期删除重新广播建立联系，确保不会有“死掉”的映射浪费资源 这里有一个最重要的点就是ARP协议是运行在同一个局域网上的，如果如下图H1要向不在同一个局域网的H4发送消息，那么首先ARP协议会找到路由器R1的MAC地址，A将MAC帧封装的IP数据报发给R1，接下来交给R1来找下一跳的路由器R2，再次运次ARP协议找到和R1同属一个网络的路由器R2的MAC地址，如此反复进行ARP解析。 那么有一个问题是既然最后在链路上传送的帧最终都是要用MAC地址送出，为什么还要用抽象的IP地址而不直接用MAC地址呢？ 这是因为全世界有各种不同的网络和设备，就有不同的硬件地址，要使这些异构网络通信就必须进行复杂的硬件地址转接工作，而使用IP地址将这些差异屏蔽掉，给用户就带来了极大的方便，对于用户来说只要关注IP地址就好了，反正ARP是自动运行的，对于用户是透明的。 2.4 IP数据报格式这里介绍IPv4，在TCP/IP中，各种数据报格式常常以32位（4字节）为单位来描述。 IP数据报由首部+数据部分组成，首部前一部分固定长度20字节，后边还有一些可选字段（一般不用，用了必须是4字节的倍数） 版本 占4位，是指IPv4或IPv6 首部长度 4位，这里必须要注意的是首部长度表示数的单位是32位（4字节，意思是首部长度是数字1实际上代表4字节），最小必须要20字节（也就是十进制5，二进制0101），最大为60字节（因为只占4位，二进制最大1111，相当于十进制15） 区分服务 8位，一般不用这个字段 总长度 16位，单位为字节。最大长度是2的16次幂-1 = 65535字节，实际一般不会这么长。这个总长度指的是首部+数据部分。这是因为总程度不能大于数据链路层的最大传送单元MTU，一般MTU = 1500，超过就要进行分片处理。分片后总长度指的是每一片的首部+数据部分 另外，大部分路由器必须能够接受长度不超过576的IP数据报，至于支不支持1500的根据路由器而定 标识 16位，这个字段是每产生一个数据报，计数器+1，将这个数写入标识符。主要作用是分片后的每一片都是这个标识，接受端根据这个标识把每一片拼在一起 标志 3位 只有前两位有意义，最低位MF（1代表后边还有分片，0标识没了）；中间位DF（1代表不允许分片，0才允许分片） 片偏移 13位 分片后每一片在原数据中的位置，意思是代表这片是从原数据何处开始的。片偏移以8个字节为偏移单位，每个分片长度一定是8的整数倍，具体结合问题去看 生存时间 8位 TTL 现在一般代表跳数，最大值为255，意味着跳了255次路由器就会把它扔掉 协议 8位 指出数据报携带的数据使用哪种协议，上交给谁。常见的有TCP UDP ICMP IGMP IP等等 首部校验和 16位 只检验首部，不包括数据部分 。这是因为每经过一个路由器可能分片信息之类的会发生变化，需要校验。不用复杂的CRC算法，使用16位反码相加的方法，具体参考书本 源地址 32位 目的地址 32位 首部可变部分：这里可以添加很多字段支持排错，安全等但是一般不用，只要记住如果使用必须要填充字节变成4的倍数 2.5 IP层分组转发流程在IP层进行分组转发，主要是根据路由器中的转发表来进行转发，本节不介绍路由器中的转发表是怎么生成和更新的，放在后边处理。 这里要注意的是每个路由器连接几个子网，并且每个子网都有若干台主机，都记录路由转发表的话数据量过多，所以路由器转发是根据网段（网络号）来转发的，并且从源地址到目的地址不是一蹴而就的（不能从开始就知道整条路径），而是进行若干个下一跳达到终点。 每条路由最主要的两个信息（目的网络地址，下一跳地址） 特定路由： 目的网络地址可以设置一个特定的路由器，直接转发到该路由器即可 默认路由： 是指路由表中没有指定跳到哪个路由器时直接转发给默认路由器进行处理（路由表中记为0.0.0.0） 分组转发算法： 从数据报首部提取目的主机的IP地址D，得出网络地址N 若N是与此路由器直连的某个地址，则直接交付 ，不需要经过别的路由器（当然这里必须使用ARP协议解析出目的主机MAC地址，封装后传输，但是研究网络层时看成透明的即可）；否则进行间接交付 ，执行3 若路由表中有目的地址为D的特定路由，则跳到特定路由 若路由表中有到网络N的路由，进行下一跳即可 若都没有，而路由表中有一个默认路由，则跳到默认路由，都没有执行6 报告分组转发出错 3 划分子网和构成超网3.1 划分子网本质是拥有许多物理网络的单位，将所属的物理网络划分为若干个子网，但是对外表现仍然是一个网络。 IP地址 = 网络号 + 子网号 + 主机号 外部路由器还是按网络号145.13.0.0找到R1，R1对内分为145.13.3.0,145.13.7.-，145.13.21.0三个子网进行转发 划分子网知识把IP地址主机号这部分再划分一下 子网掩码：由连续的1和连续的0构成的32位数据 因为IP首部没有标识子网信息的位置，所以使用子网掩码来解决，每一个路由器的路由表中都要配置一项子网掩码。使用时将目的IP地址和子网掩码按位与运算得到子网的网络号，再进行传输。 要注意的是即使没有划分子网，单使用A B C类划分地址也要有默认的子网掩码 路由器在交换路由表时，要把自己所连接的子网和对应的子网掩码同时发送交换 划分子网的目的是增加灵活性，看需求分配主机数不同的子网掩码 划分子网后路由表必须有三项内容： 目的网络地址，子网掩码，下一跳地址 分组转发比不划分子网的情况多了用子网掩码按位与操作 3.2 构成超网（无分类编址CIDR）为了应对B类地址即将用完，互联网路由表项目急速增长，IPv4地址空间将要耗尽等问题，提出了无分类域间路由选择CIDR 取消了分类地址和划分子网，采用网络前缀和主机号两级编址方式 IP地址 = 网络前缀+主机号 记为形如10.0.0.0/10 或者 00001010 00*（ *后边是主机号） 代表前10位是网络前缀，后22位是主机号 CIDR的好处主要有两个： 增加了IP地址的数量 形成地址聚合，从而减少路由表中的条目 最长前缀匹配： 使用CIDR，路由表的每个项目由网络前缀和下一跳地址来组成，而由于地址聚合的性质，同一个目的IP地址在路由表中匹配不同的CIDR可能都符合，这时就要选择匹配成功中的最长前缀的下一跳地址来转发（因为短的包含长的，换句换说长的CIDR是短的精细再分配后的） 二叉线索查找： 由于采用最长前缀匹配，那么最长采用的方法就是遍历路由表来找到最长前缀匹配，但过于浪费时间和资源，所以诞生了二叉线索查找的方法更快的找出目的前缀，具体算法参考教材 4 网际控制报文协议ICMPICMP协议是IP协议族中的，不是高层协议，因为ICMP的报文是装在IP数据报中的，作为数据部分。 类型字段代表协议类型，代码字段细分类型中的具体情况，校验和保证ICMP报文（即IP数据报数据部分）正确，还记得IP报文首部校验和只计算IP首部不计算IP数据部分吧 4.1 ICMP报文种类种类有两种： ICMP差错报告报文 ICMP询问报文 ICMP差错报告报文主要有四种： 终点不可达 时间超过：还记得IP首部生存时间字段吧，TTL为0时丢弃该IP数据报并向源点发送此条ICMP报文 参数问题：收到的数据报首部有字段值不正确发送 改变路由（重定向）：主要是默认路由器找到更优秀的线路时发送 ICMP差错报文格式如下，将要发送差错的IP数据报的首部和紧跟着的8字节（这里是端口号，为上层TCP UDP服务的）拼上ICMP前8字节（差错类型）组成ICMP差错报文发送 不该发送ICMP差错报文情况： 对ICMP差错报文，不再发送ICMP差错报文 对第一个分片数据报的后续分片不发送 对多播的数据报不发送 对特殊地址127.0.0.0/0.0.0.0（环回测试）不发送 ICMP询问报文： 回送请求和回答：测试目的站状态 时间戳请求和回答：用于时钟同步和时间测量 4.2 ICMP应用举例分组网间探测PING，测试主机间连通性，PING使用了ICMP询问报文中的回送请求和回答。注意PING应用是应用层直接使用网络层ICMP协议的一个典型例子，没有通过运输层的TCP或UDP traceroute应用，用来跟踪一个分组从源点到终点的路径 原理是源主机向终点发送一串IP数据报，数据报中封装的是无法交付的UDP用户数据报。第一个数据报的TTL设为1，第二个设为2等等。这样第一个数据报到达路径上第一个路由器R1，TTL变成0，于是R1将第一个数据报丢弃同时向源站发送ICMP时间超过报文。同理我们得到第二个路由器R2发回来的ICMP时间超时报文等等。当有一个数据报成功到达终点时，又因为UDP用户数据报无法被接受，于是终点会向源点发送ICMP终点不可达报文，这样就得到了源点到终点的整条路径。 5 互联网路由选择协议5.1 基本概念路由选择协议就是讨论路由表中的路由是怎样得出的 理想的路由算法： 算法必须是正确的和完整的 算法在计算上应简单 算法应能适应通信量和网络拓扑变化（自适应性，更新路由表） 稳定性（一段时间内端到端基本保持一条路径） 公平性（照顾到所有用户） 能够找出最佳的路径 从能否适应通信量和网络拓扑变化来划分为两大类： 静态路由选择策略（非自适应） 动态路由选择策略 互联网采用的都是动态的，分布式的路由选择协议 可以将整个互联网划分成若干个自治系统AS，比如一个大ISP，在这个基础上分为两大类： 内部网关协议IGP： 研究的是在一个AS中用的什么路由选择协议，主要有RIP和OSPF协议。这种路由选择也叫域内路由选择 外部网关协议EPG： 研究的是不同AS间主机通信的路由选择，主要用BGP-4协议。这种路由选择也叫域间路由选择 每个AS内自主决定用什么IGP，而在每个AS的边界都要有一个或者几个路由器不仅运行IGP还要运行EPG实现系统外通信 5.2 内部网关协议RIPRIP是一种基于距离向量的路由选择协议，优点是简单 可以把使用RIP协议的所有路由器想象成一张图，那么距离就是图中顶点到顶点的距离，并且RIP实际上最求的就是最短距离参考，实际上路由表中维护的就是图中每个顶点到其他顶点的最短路径 RIP将直连的两个路由器距离向量记为1（当然也可以记作0），同时RIP允许一条路径上最多包含15个路由器，因此距离16相当于不可达，这代表RIP只适用于小型互联网 不管是RIP还是OSPF都是动态分布式协议，我们要注意三个问题，和那些路由器交换信息？ 交换什么信息？ 什么时候交换信息？ RIP协议特点： 只和相邻路由器交换信息 交换全部的信息，即整个路由表 按固定时间间隔交换（30s）或者网络拓扑发生变化 距离向量算法：用相邻路由发来的信息更新自己的路由表，做个例题很容易理解 RIP报文格式： 主要掌握RIP协议使用UDP用户数据报进行传送 RIP有一个特点是好消息传播的快，坏消息传播的慢 这个主要是指R1连接的网1故障了，却收到R2之前记录的信息，从而在R1R2之间反复横跳，直到都变成16不可达，具体查看教材 5.3 内部网关协议OSPFOSPF（开放最短路径优先，因为使用了dijkstra算法）是使用分布式的链路状态协议 特点： 向AS中所有路由器发送信息，采用洪泛法 发送的信息是与本路由器相邻的所有路由器的链路状态以及代价（带宽，时延之类的） 只有链路状态发生变化时，才发送信息 通过这种方式最终所有路由器都能建立一个链路状态数据库，实际上就是全网的拓扑结构图，在全网是一致的。这样每个路由器根据这个数据库生成自己的路由表 OSPF可以支持很多的路由器接入，为了方便管理将AS划分成一些小的区域，每个区域内路由器数目最好小于200个 OSPF直接用IP数据报传送 其他优点： 建立路径时允许计算代价而不是单单看最短路径 负载平衡（几条相同代价的线路平均分配通信量） OSPF有五种分组类型： 问候分组，数据库描述分组，链路请求分组，链路状态更新，链路状态确认 OSPF规定每隔10s相邻站点发送问候分组确定有没有站点挂掉，超过40s没有回应，则用剩下4种分组进行更新操作，更新时采用可靠的洪泛法 5.4 外部网关协议BGP解决不同AS之间的路由选择问题 BGP采用路径向量路由选择协议，每个AS至少选择一个BGP发言人，一般是边界路由器，但也可以不是 需要知道的是BGP发言人之间通过建立TCP连接来交换信息，在主干网上发出生命，例如BGP1：“到达N1可以经过AS1” 6 IPv6相比IPv4主要变化： 更大的地址空间：128位 首部固定为40字节 扩展的地址层次结构：空间大，可划分层次多 灵活的首部格式：IPv6精简了首部字段，并且在数据部分支持各种扩展首部 改进的选项：允许在数据部分增加控制信息 允许协议继续扩充 支持即插即用（自动配置）：IPv6不需要DHCP 支持资源预分配 首部改为8字节对齐，IPv4是4字节对齐 版本： 4位，指明IPv6 通信量类： 8位，为了区分不同的IPv6数据报的类别或优先级 流标号： 20位，主要视为流媒体进行资源预分配 有效载荷长度： 16位，指明数据报除了基本首部的字节数，最大值65535字节 下一个首部： 8位，可选字段，标识下一个扩展首部的类型 跳数限制： 8位，就是TTL改个名 源地址： 128位 目的地址： 128位 数据报途中经过的路由器都不处理扩展首部，大大提高了路由器处理效率 IPv6数据报的目的地址可以是三种类型： 单播 同ipv4 多播 同ipv4，ipv6认为广播时特殊的多播 任播 终点是一组计算机，但只交付其中的一个，通常是最近的 IPv6使用冒号十六进制记法 68E6:8C33:FFFF:FFFF:0:DF34:2376:FFFF 中间的0可以压缩： FF05::B3 还可以结合点分十进制法表示之前的ipv4地址： ::128.0.0.1 CIDR也可以使用： 12AB:0:0:CD30::/60 IPv4向IPv6过渡 两种方法，双协议栈 隧道技术 双协议栈：将一部分的主机/路由器同时支持两种协议，不支持的网络通过转换首部来实现通信，当然不可避免会丢失一些字段 隧道技术：原理是在经过ipv4网络时，将ipv6数据报文整个封装进ipv4数据报里，出了ipv4网络再去掉。 ICMPv6是IPv6支持的控制协议，比ipv4的ICMP更加复杂，并且ICMPv6将ARP和IGMP等协议都合并到一起了 7 IP多播多播就是一对多进行传播，需要支持多播的路由器实现。多播的标识符就是IP地址中的D类地址，用一个D类地址标识一个多播组，是尽最大努力交付的（即不保证多播组中每个主机都收到消息），使用的是IGMP协议，故不产生ICMP差错报文 分为硬件多播和互联网多播 需要使用IGMP协议（使用IP数据报传送报文，即IGMP报文构成IP数据报的数据部分）和多播路由选择协议，具体查看教材 8 虚拟专用网VPN实际上一个部门内不是所有的主机都要接入互联网，给这些主机分配全球唯一IP是一种浪费，这时只给这些主机分配本地地址就可以 所以规定了一些专用地址（可重用地址），这些地址只能作为本地地址不能作为全球地址 由这些专用地址组成的网络叫做专用网，假定一个部门在两地拥有两个专用A和B，AB通信的话就要使用公用的互联网作为专用网间的通信载体，这种专用网叫做虚拟专用网VPN 9 网络地址转换NAT如果专用网内的主机已经分配了本地IP地址，但是又想和互联网连接，这时就要用到网络地址转换NAT了 方法是将专用网连接到互联网的路由器装上NAT插件，这样的路由器叫NAT路由器，它必须有至少一个全球IP地址 主机A发送数据报时，NAT路由器将数据报中的本地IP地址转换成全球IP地址用于通信，接收到目的服务器响应后将收到数据报中的全球IP地址转换成主机A的本地IP地址 同一时刻有几个全球IP地址就可以有几个专用网主机与外界通信 也可以加上端口号，这样就可以实现不同端口访问不同的外界服务器。这时一个全球IP地址就可以分配不同的端口给不同专用网内主机使用了。这样的NAT较做网络地址与端口号转换NAPT 10 多协议标记交换MPLS一种新的面向连接的协议，看书吧QAQ 特点： 支持面向连接的服务质量 支持流量工程，平衡网络负载 有效地支持虚拟专用网VPN","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--数据链路层","slug":"计算机网络/计算机网络--数据链路层","date":"2022-02-11T09:25:10.000Z","updated":"2022-06-29T10:19:25.655Z","comments":true,"path":"2022/02/11/计算机网络/计算机网络--数据链路层/","link":"","permalink":"http://icecorn.github.io/2022/02/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/","excerpt":"","text":"计算机网络–数据链路层数据链路层主要研究的是同一个局域网中，数据分组怎样从一台主机传送到另一台主机，不经过路由器的转发。局域网虽然是网络但不放在网络层来研究，因为网络层主要是研究多个网络之间的互连。 数据链路层使用的信道有两种类型： 点对点信道 广播信道 1 点对点信道的数据链路层1.1 数据链路和帧链路： 链路是从一个节点到相邻节点的一段物理线路（有线或无线），而中间没有其他的交换节点。（物理链路） 数据链路： 传送数据时，还需要必要的通信协议来控制数据的传输，吧实现这些协议的硬件和软件加到链路上就构成了数据链路。（逻辑链路） 帧： 数据链路层的协议数据单元 PDU 主机A将IP数据报封装成帧→A发送帧给B→B去掉帧头帧尾取出IP数据报 另外，对于数据链路层，不需要考虑物理层，即物理层是透明的。 1.2 三个基本问题对于数据链路层有不同种协议，但都要实现三个基本的问题。分别是封装成帧，透明传输，差错检测。 封装成帧 将IP数据报加上帧头和帧尾构成帧，首部和尾部的重要作用是帧定界。 为了提高传输效率，帧的数据部分应尽可能大于首部和尾部。 帧的数据部分长度上限——最大传送单元MTU 帧定界使用特殊的帧定符： 帧开始符SOH（start of head） 十六进制编码01（二进制00000001） 帧结束符EOT（end of transmission） 十六进制编码04（二进制00000100） 透明传输 主要目的是防止传输的文件中含有和控制字符SOH或EOT相同的二进制bit导致接收方解析帧错误。 解决方案是在传输数据中出现的SOH或EOT前面加上一个转义字符ESC（十六进制编码1B，二进制00011011）。如果转义字符也出现在数据当中，那么就在ESC前再加一个ESC，接收端解析时会自动去掉前边一个，这种方法叫做字节填充或字符填充。 差错检验 通信链路会因干扰导致比特差错，即0变成1之类。为了保证传输可靠性，我们使用循环冗余检验CRC。 具体的CRC方法参考课本例题，需要知道的是CRC差错检验仅仅保证无比特差错，但这并不代表实现了可靠传输。因为还有另一类传输差错比如帧丢失，帧重复和帧失序等，由于成本原因这类问题不放在数据链路层解决，而由传输层的TCP协议来解决。即不要求数据链路层向上提供可靠的传输服务。这样可以提高通信效率。 2 点对点ppp协议ppp协议用于用户和ISP进行通信时使用的数据链路协议 2.1 ppp协议要求 简单： 意味着不可靠，只需要进行CRC校验 封装成帧： 使用帧定界符 透明性： 字节填充ESC 多种网络层协议： 要在同一条物理链路上支持多种网络层协议（如IP和IPX），连接的局域网或路由器同理 多种类型链路： 电的，光的，交换的或非交换的链路。以太网PPPOE 差错检测： CRC 检测连接状态： 及时检测链路故障的功能 最大传送单元： MTU，如果超过最大长度，ppp就将帧丢弃 网络层地址协商： 提供一种机制使通信的两个网络层实体能够知道彼此的网络层地址，IP地址 数据压缩协商： 提供一种方法来协商使用数据压缩算法 PPP协议只支持全双工链路 2.2 ppp帧格式 字段意义 首尾各一个字节标志字段F（flag，0x7E，01111110），表示帧开始和结束，连续两帧间只需要一个。连续两个标志字段代表空帧，丢弃。 首部地址字段A规定为FF，控制字段C规定为03，不能改。 首部协议字段2字节，为0x0021时表示IP数据报，0xC021表示ppp链路控制协议LCP数据，0x8021表示网络层的控制数据。 尾部FCS是CRC的帧检验序列、 信息部分最大1500字节 字节填充 和上文中字节填充一样，ppp选用转义字符为0x7D(01111101) 信息字段出现 0x7E 变成 0x7D 0x5E 信息字段出现 0x7D变成 0x7D 0x5D 信息字段出现ASCII码的控制字符（即数值小于0x20的字符）如0x23变成 0x7D 0x23 零比特填充 另一种实现透明传输的方法，适用于同步传输（一连串的比特连续发送） 具体方法是发现有5个连续的1，立刻填入一个0，因此可以保证信息字段不会出现连续的6个1（因为7E的二进制01111110），接收端发现连续的5个1时把后边的0去掉即可实现透明传输 2.3 ppp协议的工作状态简单的说就是用户点击拨号上网，此时调制解调器发出载波信号被路由器监听到，建立了一条物理连接。然后用户电脑向ISP发送链路控制协议LCP分组（封装成多个ppp帧），配置了一些参数建立LCP连接。之后进行网络层配置，网络控制协议给用户电脑分配一个临时的IP地址，实现通信。通信结束后，NCP释放网络层连接，收回IP地址，LCP释放数据链路层连接，最后释放物理层连接。 几个状态： 链路静止： 这是用户电脑和ISP路由器间无物理连接 链路建立： 拨号后，建立物理连接后进入该状态，目的建立LCP连接 鉴别： 建立LCP连接后进入该状态，发送鉴别协议分组等待鉴别 网络层协议： ppp协议两端的网络层协商所使用的网络层配置 链路打开： 此时可以正常通信 链路终止：出现故障或鉴定错误等问题时跳变的状态 3 广播信道的数据链路层3.1 局域网的数据链路层局域网优点： 具有广播功能，局域网内主机共享各种硬件软件资源 便于系统的扩展和逐渐演变，设备位置灵活调整改变 提高系统的可靠性，可用性，生存性 按网络拓扑分类： 星型网，环型网，总线网 为保证众多用户共享媒体资源，采用两种技术方法 静态划分信道： 频分，时分，波分，码分复用等等，代价高，不适合局域网使用 动态媒体接入控制：随机接入（重点），受控接入 两种以太网标准： DIX Ethernet V2标准和IEEE 802.3标准，802.3比较繁琐，所以目前主要使用的还是V2版本 适配器的作用： 适配器，即是网络接口卡（NIC 网卡），其与局域网通信是通过双绞线或无线连接等传输媒体（串行传输），与计算机通信则是通过主板上的I/O总线（并行传输）。 所以网卡中须有缓存的存储芯片来协调接受或发送网络通信内容传达给CPU进行处理。且我们说的MAC地址就在适配器的ROM之中。 3.2 CSMA/CD协议以太网采用随机接入，而一条总线网络同一时间只能传送一条信息，这就会导致会有信息的碰撞，CSMA/CD协议就是为了解决这个问题诞生的。 协议要点： 多点接入： 说明是总线型网络，多台主机接入 载波监听： 检测信道，总线上每个站时刻不停的检测信道 碰撞检测： 边发送边监听，发送时判断有没有其他站也在发送信息，发生碰撞立刻停止发送 CSMA/CD协议中的每个站不可能同时发送和接收，故只能半双工通信 把总线上单程端到端的传播时延记为T，每个站发出一个帧后最长需要经过2T时间可以知道是否发生了碰撞，故2T叫做争用期（碰撞窗口）。对于10Mbit/s的以太网，争用期时间为51.2微秒，征用期内可发送512bit，即64字节。也可以说争用期是512bit时间，用bit作为争用期的单位。 发生碰撞后以太网使用截断二进制指数退避选择重传的时机，从离散集合【0,1，…,2的k次幂-1】随机取出一个数r，等待r倍的争用期再进行重传。重传16次仍不成功，丢弃该帧，向上级反映。 重点：一种特殊情况是某个站发出了一个很短的帧，在发送完毕前没有检测到碰撞，而实际上该帧发生了碰撞并被丢弃，但发送站不知道碰撞从而不会进行重发。 为了避免这种状况，以太网规定一个最短帧长64字节，即512bit（争用期时间），不满64字节的帧要补充到64字节，所以如果收到小于64字节的帧即为错误帧，舍弃。 强化碰撞：发送站发现碰撞，立刻停止发送，并且发送32bit或48bit的人为干扰信号，此举是为了让所有的站都知道现在发生了碰撞。 帧间最小间隔： 以太网规定最小间隔为96bit时间。 3.3 以太网信道利用率因为会发生碰撞，所以以太网信道利用率不会是100%，T是bit端到端单程的时间，T1是帧的发送时间 a = T/T1 a越小信道利用率越高，故可采用的办法有两个，限制以太网连线的长度，适当增大以太网帧的长度 信道的利用率S = T/T+T1 = 1/1+a 3.4 以太网MAC层MAC地址又叫硬件地址或物理地址，是在适配器ROM中存在的具有唯一性的标识。MAC地址格式为6字节（48bit）由IEEE分配的全球唯一标识。 主机通信时，适配器使用过滤功能，主要有三种情况 单播帧（一对一）： 收到帧的MAC地址与自己的相同 广播帧（一对全体）： 发送给本局域网多有站点的帧（全1地址） 多播帧（一对多）： 发送给局域网上一部分站点，需要多播协议设置，有的适配器不支持 MAC帧的格式： 只介绍V2的帧格式： 很简单前边两个字段是目的地址和源地址，类型字段用来标志数据使用的是什么协议，0x0800代表IP数据报。数据是46~1500，46是因为最小长度64-首尾18=46。尾部FCS用于CRC校验。 另外，帧的前边有8字节的前同步码，是因为MAC帧是异步传输，需要与适配器进行时钟同步，最后一个字节是帧定界符，最后的11告诉适配器接下来的就是有用的MAC帧消息了。还有个问题是，MAC帧没有长度字段怎么确定数据部分是从哪到哪呢？ 这是因为以太网采用了曼彻斯特编码，具有自同步功能，当接受完全部的帧信息后，从后往前数4个字节就可以得到IP数据报的结束位置了，这也是MAC帧不需要结尾帧定界的原因。 3.5 以太网的扩展 物理层 物理层的以太网使用多个集线器，连接成很大范围内的以太网 好处： 可以使远端计算机互相连接 扩大了以太网范围，因为集线器最大距离只有100m 坏处： 1.碰撞域也增大了，大的以太网上同一时间也只能传送一个帧 不同速率的适配器不能连接在一起 数据链路层 网桥：可以对收到的MAC帧进行转发和过滤，根据网桥中的地址表选择转发和丢弃 交换机：实质上是一个多接口的网桥，可以使多对主机同时通信，其内部的地址表不用像网桥一样配置而是通过自学习算法自主建立的。最大的优点是每个用户可以使用独自的带宽 交换机的自学习功能： A向B发送帧，把自己的MAC地址和接口1写入地址表，然后去地址表查有没有B的地址，有就转发，没有就向除了自己的接口1之外的其他接口广播这个帧，这是B发现和自己的MAC地址一样就接受了，C D扔掉。 中心思想就是谁发帧谁登记，这样慢慢的所有主机都记录在地址表上了 另外两个交互接空闲接口多的时候广播时容易发生兜圈子现象，这是就要使用生成树协议STP从逻辑上切断某些链路 总结： 集线器工作在物理层，用它连接后的网络依然还是一个网，需要使用CSMA/CD协议，且集线器只是转发电信号而已。网桥有一定的转发过滤功能，只有两个接口，网桥两边的网络可以理解为分开的网络，是全双工的不会发生碰撞。交换机是加强版的网桥，有很多接口，全双工不会发生碰撞，并且有强大的自学习算法不需要人工配置地址表。换句话说集线器连接的网络整个都是冲突域，网桥是端口两端分别为冲突域，而交换机每个端口是一个冲突域。 3.6 虚拟局域网利用交换机实现的一种逻辑上的局域网 支持虚拟局域网的以太网帧扩展：最大长度从1518字节增加到1522字节 3.7 使用以太网进行宽带接入因为以太网帧格式中没有标识用户名字段的位置，所以采用pppoe（ppp over ethernet）的方法连接互联网。现在的光纤入户宽带接入都是采用这种方式。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"计算机网络--物理层","slug":"计算机网络/计算机网络--物理层","date":"2022-02-10T06:35:54.000Z","updated":"2022-06-29T09:48:26.452Z","comments":true,"path":"2022/02/10/计算机网络/计算机网络--物理层/","link":"","permalink":"http://icecorn.github.io/2022/02/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C--%E7%89%A9%E7%90%86%E5%B1%82/","excerpt":"","text":"计算机网络–物理层1. 物理层的基本概念物理层的主要任务是尽可能的屏蔽掉不同传输媒体和通信手段的差异，使物理层之上的数据链路层使用起来是透明的。物理层的协议又叫做规程。 物理层的主要任务描述为确定与传输媒体的接口有关的一些特性： 机械特性： 指明接口所用的接线器的形状，尺寸，引脚数目和排列，固定等。平时常见的各种规格的接插件都有严格的标准化规定。 电气特性： 指明在接口电缆的各条线上出现的电压的范围。 功能特性： 指明某条线上出现的某一电平的电压的意义。 过程特性： 指明对于不同功能的各种可能事件的的出现顺序。 物理层协议：点对点，多点连接，广播连接 传输媒体： 导引型传输媒体：架空明线，双绞线，同轴电缆，光缆 非导引型传输媒体： 各种波段的无线信道，微波，卫星通信 2. 数据通信的基础知识2.1 通信系统三部分： 源系统： 源点： 产生要传输数据的设备 如计算机产生数字比特流，又叫源站，信源 发送器： 比特流要经过发送器编码才能传输，典型发送器就是调制器，计算机使用内置的调制解调器 目的系统： 接收器：接受传输系统发出的信号，并转换为终端设备可处理的信号，典型接收器就是解调器，将模拟信号解调还原发送端产生的数字比特流。 终点： 从接收器获取数字比特流，显示在输出设备上，如屏幕 传输系统： 可以使简单的传输线，也可以是复杂的网络系统 消息： 话音，文字，图像，视频 数据： 运送消息的实体 信号： 是数据的电气或者电磁表现 分为模拟信号（连续信号）和数字信号（离散信号）两种 2.2 信道的概念及极限容量信道一般表示向某一个方向传送信息的媒体，一条通信电路包括一条发送信道和一条接收信道。 通信方式 信道 举例 单工通信 一条 无线广播 半双工通信 一条（正向或反向） 对讲机 全双工通信 两条（正反各一条） 手机 文字图像等信源输出的信号属于基带信号，传输不便，故需要进行调制。 调制方法： 基带调制： 将数字信号转换为另一种数字信号，变换后仍为基带信号，故称编码。 载波调制： 将基带信号频率调到较高的频段，转换为模拟信号，能更好的在模拟信道中传输，调制后的信号成为带通信号（仅在一段频率范围内能够通过信道），故也称为带通调制。 常见编码方式： 曼彻斯特编码是看周期中心的跳变是正还是负（上下），差分曼彻斯特编码是看位开始边界是否有跳变。曼彻斯特编码有自同步能力，不归零则没有。 要注意的是以上每种编码的0/1都是人为规定的，所以是可以互换的。 基本带通调制： 另外还有QAM16为代表的正交振幅调制，利用编码让每一个码元携带更多比特的信息量。 奈氏准则： 在任何信道中，码元传输的速率是有上限的，传输速率超过上限，就会出现码间串扰，影响接收端的识别。 信噪比： 信号的平均功率和噪声的平均功率之比。记作S/N，度量单位为分贝db 信噪比（db） = 10 log10（S/N）（db） 香农公式： 信道的极限信息传输速率C C = W * log2（1+S/N）(bit/s) 其中W为信道带宽（单位HZ），S为信道内信号的平均功率，N为信道内高斯噪声功率。 香农公式表明信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。 2.3 信道复用技术 频分复用 FDM： 所有用户在同一时间内占用不同的带宽资源（频带宽度HZ）。即频带分片 时分复用 TDM： 所有用户在不同时间占用同样的频带宽度。即时间分片 统计时分复用 STDM： 一种改进的时分复用，明显提高信道的利用率，又叫异步时分复用。 波分复用 WDM： 光的频分复用。分光器 码分复用 CDM： 码分多址CDMA，抗干扰能力强，广泛应用与民用的移动通信中，特别是无线局域网。 在CDMA中，每一个比特时间再划分为m个短的时间间隔，称为码片，m通常为64或128，实际就是发送64个比特来表示一个逻辑比特0或1，虽然降低了发送效率，但是完成了加密更安全。 一个站要发送比特1，则发送自己的m bit码片序列，发送0则发送码片序列的二进制补码。CDMA系统给每一个站分配的码片序列不仅必须各不相同而且必须互相正交。这样可以保证每一个码片都与其他站的码片的內积为0。另外码片自身的內积为1，自身与自身补码的內积为-1（-1代表二进制0）。 现假定一个站X要接受站S发送的数据，则X需要知道S的码片序列，在同一时刻会有很多不同的站发来数据，而此时X使用S的码片序列与接收到的比特流进行內积操作，这样X收到其他非S站的数据內积均是0，只有收到S的比特流內积可以得出1或者-1，即可获得S站发出的逻辑比特流。 2.4 宽带接入技术 ADSL 技术： 非对称数字用户线ADSL技术是用数字技术对现有的模拟电话用户线进行改造。ADSL将0~4khz的低端频谱保留给传统电话使用，4khz以上的高频谱分为上行带宽和下行带宽。 光纤同轴混合网： 即HFC网，是一种基于有线电视网的居民宽带。 FTTx技术：及光纤入户，光纤入楼。使用分光器使几十户人家共用一根光纤干线。 使用光线路终端OLT把收到的下行数据发往无源的1：N光分路器，然后用广播方式向所有用户端的光网络单元ONU发送。ONU在用户家中即是光纤入户，从ONU到个人电脑一般用以太网连接，使用5类线作为传输媒体。 3. 常见问题3.1 传输媒体是物理层吗？传输媒体和物理层的主要区别是什么？不是，传输媒体在物理层下面。由于物理层是体系结构第一层，因此有时称传输媒体为0层。在传输媒体中传输的是信号，但传输媒体并不知道所传输的信号是什么意思，即不知道传输的信号什么时候代表1，什么时候代表0。但物理层由于规定了电气特性，所以能够识别比特流。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"Markdown常用语法","slug":"Markdown基础语法","date":"2022-02-09T11:37:26.000Z","updated":"2022-06-29T11:19:33.075Z","comments":true,"path":"2022/02/09/Markdown基础语法/","link":"","permalink":"http://icecorn.github.io/2022/02/09/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdown语法1.Markdown 的基础语法本文介绍markdown的基本语法，很容易掌握，一看就会。 1.1标题 这是最为常用的格式，在平时常用的的文本编辑器中大多是这样实现的：输入文本、选中文本、设置标题格式。而在 Markdown 中，你只需要在文本前面加上 # 即可，同理、你还可以增加二级标题、三级标题、四级标题、五级标题和六级标题，总共六级，只需要增加 # 即可，标题字号相应降低。Markdown 支持 6 种级别的标题，对应 HTML 标签 h1 ~ h6。l例如： 123456# h1## h2### h3#### h4##### h5###### h6 注意： ```123456789101112131415161718 和标题之间建议保留一个字符的空格，这是最标准的 Markdown 写法。以上标记效果如下： ![ ](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/h1.png)- 除此之外，Markdown 还支持另外一种形式的标题展示形式，其类似于 Setext 标记语言的表现形式，使用下划线进行文本大小的控制```bash这是一级标题===这是二级标题--- 以上标记效果如下： 这种处理方式在 Github 的一些开源工程上面比较常见，显而易见的缺点是：文字大小控制级别有限。 1.2段落及区块引用 需要记住的是，Markdown 其实就是一种易于编写的普通文本，只不过加入了部分渲染文本的标签而已。其最终依然会转换为 HTML 标签，因此使用 Markdown 分段非常简单，将你要分段的部分前后至少保留一个空行即可。 而另外一个比较常见的需求就是，我们可能希望对某段文字进行强调处理。Markdown 提供了一个特殊符号 &gt; 用于段首进行强调，被强调的文字部分将会高亮显示。例如： 1|&gt; 如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。 其显示结果如下： 如果你不相信努力和时光，那么时光第一个就会辜负你。不要去否定你的过去，也不要用你的过去牵扯你的未来。不是因为有希望才去努力，而是努力了，才能看到希望。 注意： 聪明的你可能已经发现了，上面显示的引用效果和文章开头引用百度百科的效果是一样的。没错，本站所有文章均采用 Markdown 语法写作，而且大家在评论时也可以采用 Markdown 语法进行评论。这也是为什么第二篇文章写 Markdown 的原因之一了。至于我渲染出来的结果为什么跟你不一样，这是因为我们采用了不同的 CSS 进行调节，这一内容会在后面的教程进行讲解。 引用完后，一定记得空出一行再写其他东西，不然，你接下来写作的内容也都在引用内容里。 &gt;与你要引用的文字之间一定有一个空格，不然会被认为是普通的文本。&gt;前面不能有文字，必须单独一行才能引用。 1.3目录 Markdown引入目录非常简单，只需要在你想加入目录的地方输入[TOC]就可以了。 1.4首行缩进方法 在用中文写文章时，我们通常习惯段首缩进两个字，但是使用 Markdown 编辑时我们手打空格缩进是不起作用的，因此我们需要通过使用 HTML 中的空格实体来帮助我们实现缩进效果。 为了让本文不那么难以理解，这一部分我只打算讲一个，也是我比较推荐的一个，&amp;emsp;。一个汉字占两个空格大小，所以使用四个空格就可以达到首行缩进两个汉字的效果。而一个 &amp;emsp; 代表两个空格，所以用两个 &amp;emsp; 就代表两个汉字、四个空格了。 1.5分割线 分割线可以由 * 、 - 、 _（星号，减号，底线）这 3 个符号的至少 3 个符号表示，注意至少要 3 个，且不需要连续，有空格也可以。例如： 12345***---___* * ***** 其显示结果如下： 1.6粗体和斜体 Markdown 的粗体和斜体也非常简单，用**或者__包含一段文本就是粗体的语法，用*或者_包含一段文本就是斜体的语法。例如： 1234*始于颜值、陷于才华、忠于人品*_始于颜值、陷于才华、忠于人品_**始于颜值、陷于才华、忠于人品**__始于颜值、陷于才华、忠于人品__ 其显示结果如下： 始于颜值、陷于才华、忠于人品始于颜值、陷于才华、忠于人品始于颜值、陷于才华、忠于人品始于颜值、陷于才华、忠于人品 1.7删除线 用 ~~ 包含一段文本就是删除线了。例如： 1~~请删除我~~ 其显示结果如下：请删除我 1.8列表 Markdown 支持有序列表和无序列表两种形式：无序列表使用*或+或- 标识；有序列表使用数字加 . 标识。例如： 1234567891011121314151617181920212223* 黄瓜* 玉米* 茄子+ 黄瓜+ 玉米+ 茄子- 黄瓜- 玉米- 茄子1. 黄瓜2. 玉米3. 茄子4. 黄瓜5. 玉米6. 茄子7. 黄瓜8. 玉米9. 茄子 其显示结果如下： 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 黄瓜 玉米 茄子 注意： 有序表不用 1. 2. 3. 这样排下去，可以直接 1. 1. 1. 这样，如果以 3. 开头，如 3. 2. 1. 这样，那么结果是 3. 4. 5.。即以什么数字开头，结果就以什么数字开头，后面的数字可以随便写。如果中间要再插入一项，就不用修改整个列表的序号了。 如果需要写多级列表，这可以用缩进的办法实现，例如： 1234567891. 动物 1. 哺乳动物 2. 爬行动物 3. 鸟类 4. 其他2. 植物 5. 被子植物 6. 裸子植物 7. 其他 其显示结果如下： 动物 哺乳动物 爬行动物 鸟类 其他 植物 被子植物 裸子植物 其他 1.9代办清单 To-do List 你可以在 Markdown 中编写代办清单，相关代码如下： 12345- [x] 已完成项目1 - [x] 已完成事项 - [ ] 代办事项- [ ] 代办项目2- [ ] 代办项目3 其显示结果如下： 已完成项目1 已完成事项 代办事项 代办项目2 代办项目3 1.10插入链接 Markdown 针对链接的处理比较简单，可以使用下面的语法进行标记： 1[点击跳转至百度](http://www.baidu.com) 其显示结果如下：点击跳转至百度 2.Markdown 的高级语法 通过上一节的讲解，我们现在已经可以进行简单的纯文字写作了。你可能想问，Markdown 只能处理纯文本吗，那如果我想插入表格，图片，公式等等该怎么办。不要急，Markdown 虽然语法简单，但是功能很强大的，上面的这些需求完全可以满足。 2.1插入图片2.1.1基本用法1![当链接内容不存在时显示的内容](https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya2.jpg) 其显示结果如下： 当链接内容不存在时显示的内容 2.1.2加入图名和居中对齐 Markdown 图片默认左对齐，如果需要居中对齐，就需要采用 HTML 的语法了（注：博主采用了样式表，使图片默认居中，显示图名）。语法如下： 1&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot;&gt;&lt;/br&gt;小雅&lt;/div&gt; 小雅 2.1.3控制图片大小1&lt;img src = &quot;https://cdn.jsdelivr.net/gh/xiaoshidi-hub/PicGO/picture/xiaoya.jpg&quot; width = 50%/&gt; 其显示结果如下： 2.1.4其他 主要采用的是HTML标记语言和CSS样式表来控制图片格式的。本系列教程不涉及这些，如果你有需要，可以点击HTML图片|菜鸟教程和CSS图片|菜鸟教程 进行学习。 2.1.5图床图床请参考我的Github+Hexo博客搭建小白教程 里面详细的介绍了七牛云图床的使用方法 2.2表格 表格是 Markdown 语法中比较复杂的一个，也是我们平常常用的样式之一，但也不是无迹可寻。 2.2.1基本用法 使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 为了美观，可以使用空格对齐不同行的单元格，并在左右两侧都使用 | 来标记单元格边界。 在表头下方的分隔线标记中加入:，即可标记下方单元格内容的对齐方式。 :— 代表左对齐:–: 代表居中对齐—: 代表右对齐 例如： 12345| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 其显示结果如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 例如： 12345dog | bird | cat----|------|----foo | foo | foobar | bar | barbaz | baz | baz 其显示结果如下： dog bird cat foo foo foo bar bar bar baz baz baz 注意： | 、 - 、: 之间的多余空格会被忽略，不影响布局。 默认标题栏居中对齐，内容居左对齐。 -: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。 内容和 | 之间的多余空格会被忽略，每行第一个|和最后一个|可以省略，-的数量至少有一个。 2.2.2加入表头 Markdown 默认语法里面没有关于表头的，但如果我们需要有表头，那该怎么办呢。通过图片章节的学习，我想你应该知道解决办法了。对，没错，就是 HTML + CSS。点击 HTML 表格 | 菜鸟教程 进行学习。 2.3插入代码块 Markdown 在 IT 圈子里面比较流行的一个重要原因是，它能够轻松漂亮地插入代码，其实我在前面已经多次向大家展示了代码块的最终效果。代码块的语法特别简单，只要把你想要展示的代码片段用 包裹就可以了。行内代码用一个 包裹，如 var y=x^3+2 如果要插入一整段代码，就需要至少三个` 进行包裹，如： 123456789101112#!/usr/bin/python# -*- coding: UTF-8 -*-num=[];i=2for i in range(2,100): j=2 for j in range(2,i): if(i%j==0): break else: num.append(i)print(num) 上面的例子就是输出100以内的素数的Python代码。 注意： 在代码前面，三个反引号后面填写你插入代码的类型，如 Markdown、Python，这样就可以高亮你的代码块了。 很多人不知道怎么输入反引号。在英文模式下，找到键盘最左侧 esc 键下面的第一个键点击即可。 2.4数学公式 Markdown 可以插入 LaTex 数学公式，这一点我非常的喜欢，因为我是先学习了 LaTex，然后再接触到 Markdown 的，Markdown 几乎支持 LaTex 的所有数学公式语法。至于 LaTex 是什么，我会在后面的文章进行介绍，现在你只要知道 Markdown 适合记一些笔记，写一些文字，但它并不适合写论文，而 LaTex 就是为排版而生的。 下面引用百度百科的介绍： LaTeX（LATEX，音译 “拉泰赫”）是一种基于 ΤΕΧ 的排版系统，由美国计算机学家莱斯利・兰伯特（Leslie Lamport）在 20 世纪 80 年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由 TeX 所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 从百度百科的介绍中我们可以知道，LaTex 非常适合生成复杂的数学公式，理工科的同学看到这点是不是很激动啊。在 Word 里面输入公式，我们一般会用到 Mathtype 这个插件，但每次都需要点很多次才能输入我们想要的公式，这严重影响到了我们的思绪。而 LaTex 只需要记住少量的代码，就可以非常流畅且快速的书写数学公式了。我曾在知乎上面看到过这样的介绍，「1700 页数学笔记火了！全程敲代码，速度飞快易搜索，硬核小哥教你上手 LaTeX+Vim」，虽然有 Vim 这样的编辑器之神（此处多说几句，自从用上Vim后，对其他编辑器的操作方式再也没正眼瞧过，看我文章的应该没有Emacs党吧）加持，但依然从侧面说明了 LaTex 在书写数学公式方面的强大和易用。 由于数学公式语法较多，后面我会在 LaTex 系列专门写一篇文章进行介绍，这里就展示几个例子。 行内公式：将公式插入到本行内，用一个美元符号包裹公式。 独行公式：将公式插入到新的一行内，并且居中，用两个美元符号包裹公式。 123456%欧拉公式$$e^&#123;i\\pi&#125;+1=0$$%薛定谔方程$$i \\hbar \\frac&#123;\\partial&#125;&#123;\\partial t&#125; \\Psi(\\boldsymbol&#123;r&#125;, t)=-\\frac&#123;\\hbar^&#123;2&#125;&#125;&#123;2 m&#125; \\nabla^&#123;2&#125; \\Psi(\\boldsymbol&#123;r&#125;, t)+V(\\boldsymbol&#123;r&#125;, t) \\Psi(\\boldsymbol&#123;r&#125;, t)$$ 2.5特殊符号处理 Markdown 使用反斜杠 \\ 插入语法中用到的特殊符号。在 Markdown 中，主要有以下几种特殊符号需要处理： 1234567891011121.\\ 反斜线2.` 反引号3.* 星号4._ 底线5.&#123;&#125; 花括号6.[] 方括号7.括弧8.# 井字号9.+ 加号10.- 减号11.. 英文句点12.! 惊叹号 1.\\ 反斜线2.` 反引号3.* 星号4._ 底线5.{} 花括号6.[] 方括号7.括弧8.# 井字号9.+ 加号10.- 减号11.. 英文句点12.! 惊叹号 3.Markdown 软件推荐 对于初学者，我推荐你使用Typora，Typora 的优点太多了：简洁美观、实时预览、扩展语法、跨平台、免费。","categories":[{"name":"工具","slug":"工具","permalink":"http://icecorn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://icecorn.github.io/tags/Markdown/"}]}],"categories":[{"name":"ReadingNotes","slug":"ReadingNotes","permalink":"http://icecorn.github.io/categories/ReadingNotes/"},{"name":"C++","slug":"ReadingNotes/C","permalink":"http://icecorn.github.io/categories/ReadingNotes/C/"},{"name":"计算机基础","slug":"计算机基础","permalink":"http://icecorn.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","permalink":"http://icecorn.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"C++ Primer","slug":"C-Primer","permalink":"http://icecorn.github.io/tags/C-Primer/"},{"name":"计算机网络","slug":"计算机网络","permalink":"http://icecorn.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"Markdown","slug":"Markdown","permalink":"http://icecorn.github.io/tags/Markdown/"}]}